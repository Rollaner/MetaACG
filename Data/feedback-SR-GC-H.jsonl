{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONTIGUOUS_COLOR_LABELS. Encoding: solution is a list of 9 positive integers [c1,...,c9] where ci is the color of vertex i. Valid labels are contiguous {1,...,k}.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_FIX_PERTURB_FN:Missing implementation '$Perturb' breaks heuristic pipeline. Provide a concrete def perturb_solution(solution, intensity, rng) returning a valid, normalized neighbor; avoid placeholders.\nE_OBJ_ORIENTATION:Local solvers terminate at higher cost than initial sample (3.0\u21924.0). Acceptance\/selection logic treats minimization incorrectly. Enforce strictly 'lower-is-better' when updating best and when applying acceptance criteria.\nE_ASSERT_EVAL:Using provided evaluate_solution, the given sample solution is feasible and has lower cost than your three reported finals. Your runs regress; fix best-tracking and acceptance checks.\nE_API_CONTRACT:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) returns (new_best, new_best_score, final_state, final_score) with minimization-consistent updates. Validate that score comparisons use '<' not '>'.\nE_SA_ACCEPT:Simulated annealing acceptance likely inverted. For cost delta=curr_cost - new_cost, accept if delta>0 or exp(delta\/T)>rand(). Do not accept strictly worse moves at low T; ensure T schedule actually cools.\nE_TS_MOVES:Tabu search likely missing aspiration for strictly better solutions and uses too-short tenure, enabling cycling to worse 4-color states. Add aspiration: if candidate_cost < best_cost, override tabu. Increase tenure or diversify when repetition detected.\nE_ILS_STRUCTURE:ILS appears to perturb away from a feasible lower-cost configuration and fails to apply descent properly. Ensure loop: local_search -> perturb -> local_search, with best-so-far guarding; reject perturb outcome if it fails to improve after a bounded descent unless diversification criteria met.\nE_NEIGH_LIM:Single-vertex recolor with 20% chance of k+1 grows palette and harms minimization once feasible. Gate color expansion only when conflicts>0; when conflict-free, forbid k+1 and add k-1 pressure via repair.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood too weak for escaping 3\u21944 plateaus on dense subgraphs. Add: (a) color-swap of two labels, (b) Kempe-chain interchanges, (c) conflict-driven recolor prioritizing highest-conflict vertex, (d) 2-color path recoloring.\nR_STR_INADEQUATE:Color labels unrestricted permit drift to larger k. Add phase-based representation: fix a target k and search within {1..k}, using repair operators; periodically decrement k when conflict-free.\nE_CONTIGUITY_COST:Contiguity penalty PEN_GAP=1e5 dwarfs edge penalty 1e4; a single gap is more expensive than multiple conflicts, skewing search to maintain contiguity over fixing conflicts. Reduce PEN_GAP to <= PEN_EDGE or enforce contiguity by normalization only.\nNB_NORMALIZE_DUP:Neighbor already normalizes; combined with heavy PEN_GAP this double-encourages contiguity and can hide beneficial exploratory moves. If you always normalize, lower or remove PEN_GAP entirely.\nE_MOVE_BIAS:Random vertex recolor is uniform over vertices; conflicts cluster on specific vertices. Bias selection toward vertices with largest conflict degree; sample colors by least-conflicting choice with noise (softmax over conflict counts).\nE_RESTART_POLICY:No evidence of strategic restarts. Add multi-start with k-target schedule: start from feasible state, lock k, perform descent; if stuck with zero-conflicts at k, attempt k-1 via merge-and-repair perturbations.\nE_HEURISTIC_SAFE_GUARDS:Add invariant checks each iteration: assert len(sol)==9, labels>=1, contiguity after normalization, and recompute k decreases only when conflict-free.\nE_TEMPERATURE_SCHED:SA schedule unspecified; risk of premature freezing or excessive wandering. Use geometric cooling T_{t+1}=alpha*T_t with alpha in [0.90,0.99], epoch length >= c*n moves, reheats on stagnation.\nE_TABU_TENURE:Set tenure proportional to n and palette size, e.g., tenure\u2248[7, 15] moves, plus frequency-based penalties to discourage overused assignments.\nE_PERTURB_SPECIFIC:Implement: (1) merge two random colors then greedy-repair; (2) recolor a random Kempe chain; (3) large-kick: recolor top-b conflict vertices to alternative labels with least conflicts, then descent.\nE_EVAL_SPEED:Current evaluation O(|E|) per move; recompute delta conflicts instead of full scan by tracking incident edges of changed vertex for O(deg).\nE_K_LOCKSTEP:When conflict-free, lock k and forbid k+1 in neighbors; when conflicts>0, allow k+1 with low probability only if stuck for S iterations (measured by no improvement).\nE_STOP_CRIT:Stop conditions missing\/weak. Use: stop after I_max iterations without improvement at fixed k; then either apply strong perturbation or adjust k.\nE_PARAM_SENS:Random new color probability fixed at 0.2 is arbitrary. Make adaptive: p_new = min(0.2, max(0, stagnation\/I_window)).\nE_REPRODUCIBILITY:Set RNG via injected rng object; avoid global random to ensure deterministic runs for debugging and fair comparisons.\nE_SCORING_SANITY:Always compare to current best via evaluate_solution; if a move increases k while conflict-free, reject unless explicit diversification step is in progress with acceptance logged.\nE_CODE_RUNNABLE:Provide complete, runnable Perturb and Heuristic code; ensure no file\/network\/OS calls as per constraints.\nS_CONCRETE_FIXES:\n- Replace PEN_GAP=1e5 with 0 (since normalize enforces contiguity) or <=1e4.\n- Modify generate_neighbour: if conflicts==0, colors=list(range(1,k+1)); else colors=range(1,k+1)+[k+1] only after stagnation.\n- Add Kempe-chain move: pick u, v with different colors; BFS over subgraph induced by {color(u), color(v)}; swap colors in connected component containing u if it decreases conflicts or keeps conflicts same with lower k potential.\n- Implement SA acceptance with correct sign and cooling; keep separate incumbent best.\n- In TS, add aspiration and increase tenure; maintain a tabu list on (vertex,color) assignments.\n- In ILS, implement strong 'merge-two-colors-then-repair' perturbation when conflict-free; if repair succeeds, keep reduced k; else revert.\nVALIDATION_PLAN:\n- Evaluate all reported solutions with evaluate_solution to ensure any new change never accepts a strictly worse cost as 'best'.\n- Add unit tests: (a) sample solution returns finite low cost with zero penalties, (b) neighbor always returns valid length-9 positive labels, (c) normalize produces contiguous labels, (d) perturb never breaks representation.\nPERF_TARGET:Achieve monotone non-increasing incumbent cost over iterations at fixed k; verify no regressions from a feasible baseline in SA\/ILS\/TS runs.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_CONTIGUOUS_COLOR_LABELS. Encoding: solution is a list of 9 positive integers [c1,...,c9] where ci is the color of vertex i. Valid labels are contiguous {1,...,k}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Objective = k + penalties for edge conflicts and non-contiguous labels.\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Base objective (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity check: labels must be exactly {1,...,k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood: single-vertex recolor to an existing or new color (at most +1 new color), then relabel to contiguous.\n    # Returns: (new_solution, movement_type)\n    def normalize_labels(sol):\n        # Relabel colors to 1..k by order of first appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"INVALID_INPUT\")\n\n    curr = list(solution)\n    n = 9\n    # choose a vertex to recolor\n    i = random.randrange(n)\n    k = 0\n    for x in curr:\n        if x > k:\n            k = x\n    # candidate colors: existing 1..k plus optionally k+1 with small probability\n    colors = list(range(1, k+1))\n    # 20% chance to allow a new color to escape local minima\n    if random.random() < 0.2:\n        colors.append(k+1)\n    new_color = random.choice(colors)\n    # ensure change\n    tries = 0\n    while new_color == curr[i] and tries < 5:\n        new_color = random.choice(colors)\n        tries += 1\n    curr[i] = new_color\n    curr = normalize_labels(curr)\n    return (curr, \"RECOLOR_ONE\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: perform multiple random recolors and occasional color-merge, then normalize labels.\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    s = list(solution)\n    n = 9\n    # Determine current k\n    k = 0\n    for x in s:\n        if x > k:\n            k = x\n\n    steps = 4  # number of random recolors\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # pick from existing colors only to avoid uncontrolled growth\n        if k < 1:\n            colors = [1]\n        else:\n            colors = list(range(1, k+1))\n        s[idx] = random.choice(colors)\n\n    # With 50% chance, merge two colors if k >= 2\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k+1), 2)\n        # map all b to a\n        s = [a if c == b else c for c in s]\n\n    s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[2,3,1,3,2,1,3,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i, with contiguous labels {1,...,k}.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\n\"FEEDBACK\",\"E_RUN_FAIL_LOCAL_SOLVER: Heuristic signatures and calls do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Your SA\/ILS\/TS definitions include extra positional parameters and call generate_neighbour() in the signature, causing invocation failures and 'too many values to unpack' at runtime. Replace with: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Within Heuristic, call ns, mv = generate_neighbour(sol) and always use ns as the candidate.\"\n\n\"FEEDBACK\",\"E_GEN_NEIGH_CALL: You are passing generate_neighbour() (executed) rather than the function handle generate_neighbour. Remove parentheses in the Heuristic signature and usage. Inside the loop, call it as generate_neighbour(sol) and handle its (solution, movement_type) tuple.\"\n\n\"FEEDBACK\",\"E_RET_UNPACK: Your Heuristic likely expects generate_neighbour to return a single object. Current neighbor returns (new_solution, movement_type). Ensure you unpack exactly two and ignore movement_type if unused. Example: cand, mv = generate_neighbour(cur).\"\n\n\"FEEDBACK\",\"E_PARAM_PACKING: The framework provides other_params for SA temperature, ILS iterations, TS tenure, etc. Do not add extra positional arguments in the Heuristic signature. Parse from other_params with defaults and validate types.\"\n\n\"FEEDBACK\",\"E_NO_PERTURB: Perturbation function is missing ($Perturb placeholder). Provide a concrete perturb_solution to satisfy the contract and enable ILS. Avoid NOOP perturbations. Use multi-vertex recolor or multi-Kempe perturbation.\"\n\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: recolor_move may introduce k+1 even when feasible solutions exist, inflating k and objective. Limit palette expansion strictly to infeasible states where no color in 1..k fits the chosen vertex; otherwise disallow k+1.\"\n\n\"FEEDBACK\",\"NB_STALL_RISK: swap_two_colors and kempe_chain_move can return NOOP for k<2 or empty choices; also, swap may not change conflicts in feasible plateaus, causing stagnation. Add a retry loop with bounded attempts and fallback to recolor of a high-degree or high-conflict vertex to guarantee a change.\"\n\n\"FEEDBACK\",\"NB_COMPONENT_SCOPE: kempe_chain_move builds components using a BFS that pushes neighbors irrespective of edge colors prior to checking allowed set on dequeue. This can traverse irrelevant nodes. Filter enqueue by color-in-allowed at edge traversal time to reduce unnecessary exploration.\"\n\n\"FEEDBACK\",\"EVAL_SCALE_IMBALANCE: PEN_EDGE=1e4 dwarfs k, making any conflicting solution far worse than any feasible one (good), but also turns neighbor acceptance in SA effectively binary, undermining gradient information. For SA\/ILS acceptance, consider adaptive penalty or staged objective (first minimize conflicts, then k) to improve search guidance.\"\n\n\"FEEDBACK\",\"LABEL_CONTIGUITY_ENFORCEMENT: Evaluation does not explicitly penalize non-contiguous labels; only max color is counted as k. You rely on normalize_labels in neighbors, but heuristics can still accumulate gaps. Normalize inside the main loop after accepting any candidate to maintain {1..k}.\"\n\n\"FEEDBACK\",\"INIT_VALIDATION: Add pre-run validation: type\/length checks and sanitize currentSolution to integers >=1 and normalization. Early exit with HARD_PEN if invalid inputs detected to avoid hidden crashes.\"\n\n\"FEEDBACK\",\"TABU_DEF_WEAK: No Tabu mechanism specified. If implementing TS, tabu list should track recent vertex-color assignments or color swaps, not full solutions, to keep memory small and moves effective. Tenure should be dynamic (e.g., degree-based or reactive).\"\n\n\"FEEDBACK\",\"SA_TEMP_POLICY: Temperature parameters were hard-coded into the function signature. Move to other_params and implement geometric cooling with reheating on stagnation. Clamp temperature to avoid underflow and ensure acceptance probability uses delta\/objective scale.\"\n\n\"FEEDBACK\",\"ILS_ACCEPT_CRITERION: ILS not defined; when implemented, accept strictly better solutions and occasionally accept equal-score diversifications only if structural change (e.g., different color class sizes) occurs. Use perturb_solution strength escalation on repeated stagnation.\"\n\n\"FEEDBACK\",\"STOPPING_CRITERIA: Absent. Add max_iters, max_no_improve, and time budget via other_params to prevent infinite loops and to standardize benchmarking.\"\n\n\"FEEDBACK\",\"CODE_SNIPPET_SA_FIXED: \ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import math, random\n    def normalize(sol):\n        m={},1\n        out=[]\n        for c in sol:\n            if c not in m:\n                m[c]=m[1]; m[1]+=1\n            out.append(m[c])\n        return out\n    cur = normalize(list(currentSolution))\n    cur_score = evaluate_solution(cur)\n    if best is None or cur_score < best_score:\n        best, best_score = list(cur), float(cur_score)\n    T = float(other_params.get('T', 1.0))\n    T_min = float(other_params.get('T_min', 1e-3))\n    alpha = float(other_params.get('alpha', 0.95))\n    max_iters = int(other_params.get('max_iters', 10000))\n    no_imp = 0\n    for it in range(max_iters):\n        cand, mv = generate_neighbour(cur)\n        cand = normalize(cand)\n        cand_score = evaluate_solution(cand)\n        delta = cand_score - cur_score\n        if delta <= 0 or random.random() < math.exp(-delta\/max(T,1e-12)):\n            cur, cur_score = cand, cand_score\n            if cand_score < best_score:\n                best, best_score = list(cand), float(cand_score)\n                no_imp = 0\n            else:\n                no_imp += 1\n        else:\n            no_imp += 1\n        if T > T_min:\n            T *= alpha\n        if no_imp >= 500 and perturb_solution is not None:\n            cur = normalize(perturb_solution(cur))\n            cur_score = evaluate_solution(cur)\n            no_imp = 0\n    return best, best_score\n\"\n\n\"FEEDBACK\",\"CODE_SNIPPET_ILS_FIXED:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import random\n    def normalize(sol):\n        m={},1\n        out=[]\n        for c in sol:\n            if c not in m:\n                m[c]=m[1]; m[1]+=1\n            out.append(m[c])\n        return out\n    def local_search(sol, budget):\n        cur = list(sol)\n        cur_score = evaluate_solution(cur)\n        for _ in range(budget):\n            cand,_ = generate_neighbour(cur)\n            cand = normalize(cand)\n            s = evaluate_solution(cand)\n            if s < cur_score:\n                cur, cur_score = cand, s\n        return cur, cur_score\n    cur = normalize(list(currentSolution))\n    cur, cur_score = local_search(cur, int(other_params.get('ls_budget', 200)))\n    if best is None or cur_score < best_score:\n        best, best_score = list(cur), float(cur_score)\n    max_its = int(other_params.get('max_iters', 200))\n    no_imp = 0\n    for _ in range(max_its):\n        if perturb_solution is None:\n            break\n        pert = normalize(perturb_solution(cur))\n        pert, pert_score = local_search(pert, int(other_params.get('ls_budget', 200)))\n        if pert_score < best_score:\n            best, best_score = list(pert), float(pert_score)\n            cur, cur_score = pert, pert_score\n            no_imp = 0\n        else:\n            no_imp += 1\n        if no_imp >= int(other_params.get('escalate_every', 10)):\n            other_params['pert_strength'] = int(other_params.get('pert_strength', 2))+1\n            no_imp = 0\n    return best, best_score\n\"\n\n\"FEEDBACK\",\"CODE_SNIPPET_TS_FIXED:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import random, collections\n    def normalize(sol):\n        m={},1\n        out=[]\n        for c in sol:\n            if c not in m:\n                m[c]=m[1]; m[1]+=1\n            out.append(m[c])\n        return out\n    tenure = int(other_params.get('tabu_tenure', 7))\n    iters = int(other_params.get('max_iters', 5000))\n    cur = normalize(list(currentSolution))\n    cur_score = evaluate_solution(cur)\n    if best is None or cur_score < best_score:\n        best, best_score = list(cur), float(cur_score)\n    tabu = collections.deque()\n    tabu_set = set()\n    stagn = 0\n    for _ in range(iters):\n        best_cand = None\n        best_cand_score = float('inf')\n        best_move_key = None\n        for _ in range(int(other_params.get('nbh_samples', 25))):\n            cand, mv = generate_neighbour(cur)\n            cand = normalize(cand)\n            key = tuple(cand)\n            if key in tabu_set and best_score is not None and evaluate_solution(cand) >= best_score:\n                continue\n            s = evaluate_solution(cand)\n            if s < best_cand_score:\n                best_cand, best_cand_score, best_move_key = cand, s, key\n        if best_cand is None:\n            stagn += 1\n            if stagn > 50 and perturb_solution is not None:\n                cur = normalize(perturb_solution(cur))\n                cur_score = evaluate_solution(cur)\n                stagn = 0\n            continue\n        cur, cur_score = best_cand, best_cand_score\n        tabu.append(best_move_key); tabu_set.add(best_move_key)\n        if len(tabu) > tenure:\n            old = tabu.popleft(); tabu_set.discard(old)\n        if cur_score < best_score:\n            best, best_score = list(cur), float(cur_score)\n            stagn = 0\n        else:\n            stagn += 1\n    return best, best_score\n\"\n\n\"FEEDBACK\",\"CODE_SNIPPET_PERTURB:\ndef perturb_solution(sol):\n    import random\n    s = list(sol)\n    # multi-vertex conflict-driven recolor + Kempe swap\n    idx = list(range(len(s)))\n    random.shuffle(idx)\n    take = max(2, min(len(s)\/\/3, int(3)))\n    idx = idx[:take]\n    # Randomly remap selected colors to existing palette\n    palette = sorted(set(s))\n    for i in idx:\n        s[i] = random.choice(palette)\n    # Single Kempe-chain over random vertex\/colors\n    # (Assumes access to edges in enclosing scope; otherwise inline edges list)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    u = random.randrange(len(s))\n    a = s[u]\n    other = [c for c in palette if c != a]\n    if other:\n        b = random.choice(other)\n        allowed = {a,b}\n        from collections import deque\n        vis=[False]*len(s)\n        dq=deque([u]); vis[u]=True\n        comp=[]\n        while dq:\n            x=dq.popleft()\n            if s[x] in allowed:\n                comp.append(x)\n                for (p,q) in edges:\n                    y = q-1 if p-1==x else p-1 if q-1==x else None\n                    if y is None: continue\n                    if not vis[y] and s[y] in allowed:\n                        vis[y]=True; dq.append(y)\n        for id in comp:\n            s[id] = b if s[id]==a else a\n    # normalize contiguous labels\n    m={},1; out=[]\n    for c in s:\n        if c not in m:\n            m[c]=m[1]; m[1]+=1\n        out.append(m[c])\n    return out\n\"\n\n\"FEEDBACK\",\"ACCEPTANCE_POLICY: For SA, explicitly clamp exp(-delta\/T) to avoid math range errors; for TS, implement aspiration (allow tabu move if it improves global best). For ILS, enforce that perturbation strength escalates on repeated stagnation, then resets upon improvement.\"\n\n\"FEEDBACK\",\"MOVE_SELECTION_POLICY: In infeasible states, prioritize recolor of vertex with highest conflict degree and choose color minimizing local conflicts using neighbor colors. In feasible states, forbid introducing k+1 in neighbors and focus on Kempe-chain swaps to reduce color classes and enable k reduction by post-processing.\"\n\n\"FEEDBACK\",\"K_REDUCTION_STRATEGY: After reaching a feasible solution with k colors, attempt greedy color elimination: pick smallest color class, try recoloring its vertices one-by-one into remaining k-1 colors (best-fit), if all succeed, relabel to k-1. Repeat until failure. Integrate as a periodic post-processing step inside the heuristic loop.\"\n\n\"FEEDBACK\",\"PERF_HINT_SMALL_N: For n=9 the full neighborhood enumeration is feasible. Replace random sampling in TS\/ILS with full move scanning to avoid stochastic miss of improving moves; this reduces iterations and accelerates convergence.\"\n\n\"FEEDBACK\",\"REPRODUCIBILITY: Seed randomness via other_params.get('seed') for deterministic benchmarking; avoid global random state side-effects inside neighbor by parameterizing RNG or setting local Random(seed).\"\n\n\"FEEDBACK\",\"ASSERT_EVAL_CORRECTNESS: Verified that the provided evaluation function correctly scores feasible colorings strictly by k and heavily penalizes any edge conflicts. Ensure all heuristics treat lower scores as better and do not invert comparison operators.\"","Componentes":{"REPRESENTATION":"List[int] of length 9: solution[i-1] = color of vertex i, with contiguous labels {1,...,k}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**4\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Base objective (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_type)\n    # Neighborhood includes: conflict-driven recolor, color-swap, and Kempe-chain swap.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        # 0-indexed\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Allow k+1 only if conflicts>0 and with small probability\n        if total > 0 and random.random() < 0.05:\n            palette.append(k+1)\n        # Choose color minimizing local conflicts\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c == a else a if c == b else c for c in s]\n        s = normalize_labels(s)\n        return s, \"SWAP_TWO_COLORS\"\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        # Prefer a conflicting vertex if exists\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        # pick a different color b\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return s, \"NOOP\"\n        b = random.choice(choices)\n        # Build subgraph induced by colors {a,b} and find component containing u\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] in allowed:\n                comp.append(x)\n                for (p,q) in edges:\n                    y = q-1 if p-1 == x else p-1 if q-1 == x else None\n                    if y is None:\n                        continue\n                    if not visited[y] and s[y] in allowed:\n                        visited[y] = True\n                        dq.append(y)\n        # Swap colors a<->b within comp\n        for idx in comp:\n            s[idx] = b if s[idx] == a else a\n        s = normalize_labels(s)\n        return s, \"KEMPE_CHAIN_SWAP\"\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"INVALID_INPUT\")\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return (solution, \"INVALID_INPUT\")\n    except Exception:\n        return (solution, \"INVALID_INPUT\")\n\n    # Decide move type based on conflicts\n    _, tot = conflicts_by_vertex(solution)\n    r = random.random()\n    if tot == 0:\n        # When feasible, avoid increasing palette; prefer neutral diversification\n        if r < 0.6:\n            return swap_two_colors(solution)\n        elif r < 0.9:\n            return kempe_chain_move(solution)\n        else:\n            return recolor_move(solution)\n    else:\n        # When infeasible, prioritize conflict resolution\n        if r < 0.65:\n            return recolor_move(solution)\n        elif r < 0.85:\n            return kempe_chain_move(solution)\n        else:\n            return swap_two_colors(solution)\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: (a) if feasible, attempt merge-two-colors then greedy repair; (b) else, multi-kick recolors of top-conflict vertices; normalize at end.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def greedy_repair(sol, max_iters=60):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            # pick a vertex involved in conflict\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in current palette 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return solution\n    except Exception:\n        return solution\n\n    s = normalize_labels(list(solution))\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt to reduce palette via merging two colors, then repair\n        a, b = random.sample(range(1, k+1), 2)\n        # Merge b into a\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=100)\n        return s\n\n    # Otherwise, perform multi-kick recolors focusing on high-conflict vertices\n    steps = 5\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        # choose a color that minimizes local conflicts within current k (do not add new color here)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=60)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9 where solution[i-1] is the color (positive int) assigned to vertex i; labels normalized to contiguous {1,...,k}.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-review-fix-sa-ils-tabu-neigh-eval\"\n\"FEEDBACK\":\"\\\nE_LOCAL_SOLVER_SIG:Target wrapper expects Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/Tabu use def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor). Remove parentheses when passing functions; match the target signature.\\\nE_LOCAL_SOLVER_RET:Wrapper likely unpacks 2 values. Ensure heuristic returns exactly (best_solution, best_score). Avoid extra return values\/logs unless the wrapper explicitly expects them.\\\nE_LOCAL_SOLVER_ARG:Do not pass scalar params positionally if wrapper supplies other_params. Parse TEMP,MIN_TEMP,cooling_factor from other_params to maintain compatibility.\\\nE_SA_NAME:All heuristics must be exposed under the unified name Heuristic to satisfy the runner. Wrap algorithm-specific implementations accordingly.\\\nE_PERTURB_MISSING:Perturbation Function placeholder '$Perturb' is undefined. Implement perturb_solution(solution, rng, intensity) returning a valid neighbor; avoid filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION.\\\nE_NEIGH_RET_CONTRACT:generate_neighbour returns (new_solution, move_type). Heuristics must only use the first element for scoring; ignore\/mask move_type unless your wrapper handles extra outputs.\\\nE_NEIGH_NOOP:On invalid input path, generate_neighbour may return (original_solution,'INVALID_INPUT'), causing no move. Replace with guaranteed-change fallback (e.g., recolor_move) and never return identical solution.\\\nE_NEIGH_K_INFLATION:recolor_move can introduce k+1 too eagerly in infeasible states. Before adding a new color, first try best feasible color within 1..k and attempt conflict-directed repair; introduce k+1 only if no zero-conflict color exists for any conflicting vertex.\\\nE_NEIGH_BIAS:Current vertex selection uses max conflicts; adds stochasticity but risks cycling. Add tabu list on vertices\/colors or break ties by highest degree among max-conflict set to diversify.\\\nE_NEIGH_INCOMPLETE:Missing color-class elimination operator. Add 'DROP_COLOR' move: pick the smallest color class, try to recolor its vertices greedily\/with Kempe chains; if success, normalize to reduce k.\\\nE_NEIGH_NORMALIZE:Normalization occurs in both neighbor and evaluation; redundant cost. Keep normalization in evaluation only; in neighbor, ensure labels remain compact but avoid double-normalization per step to reduce overhead.\\\nE_EVAL_PEN:Edge penalty 1e5 vs base k may cause numerical stiffness yet is acceptable. Ensure arithmetic uses integers where possible to avoid float imprecision; return int(k + PEN_EDGE*conflicts).\\\nE_EVAL_COST:Recomputing edges each call is constant but avoid rebuilding lists\/closures in hot paths. Hoist edges, neighbor lists, and PENs to module scope for speed.\\\nE_EVAL_VALIDATION:Type casting int(x) silently floors floats; reject non-integers explicitly to prevent hidden states.\\\nE_SA_ACCEPT:Define Metropolis acceptance with delta=score_new-score_cur; accept if delta<0 or exp(-delta\/T)>U. Ensure T strictly decreases and stop at MIN_TEMP.\\\nE_SA_PARAMS:Cooling_factor too aggressive often freezes search. Start T high enough to accept most uphill moves; use geometric cooling in [0.90,0.99]. Calibrate via average delta.\\\nE_ILS_FRAME:ILS must alternate local_search and perturb_solution with increasing intensity on stagnation; reset intensity on improvement. Ensure best is updated only on strictly lower score.\\\nE_TABU_CORE:Tabu list should be on move attributes (vertex,color) or color swap (a,b) with tenure ~ [5,10]. Include aspiration: allow tabu move if it yields a new global best.\\\nE_STOPPING:Define consistent stopping conditions across heuristics: max_evals, max_no_improve, wall-clock budget (if available).\\\nE_RNG:Seed control via other_params['seed'] to enable reproducibility; pass a rng object to all components.\\\nE_LOGGING:If extra outputs are expected, channel them through a dedicated log object in other_params to avoid breaking return contract.\\\nE_KNOWN_CHECK:Use evaluate_solution on candidate outputs to assert feasibility (zero conflicts) before claiming improvement; reject worsening moves that introduce conflicts unless temperature\/strategy allows.\\\nNB_CODE_FAIL_LOCAL_OPT:Operators limited to recolor\/swap\/kempe. Add strategic 'color merge' attempt followed by local repair to drive k reductions.\\\nR_STR_INADEQUATE:Label contiguity enforced each step may hamper diversification. Permit temporary non-contiguous labels in neighbor, normalize only when evaluating or when k changes.\\\nE_CODE_PERF:conflicts_by_vertex recomputes totals every call. Maintain incremental edge-conflict counters when applying single-vertex recolors to reduce from O(|E|) to O(deg(v)).\\\nTEST_MIN_FEAS:Sample Solution evaluates with zero conflicts; evaluation returns base objective equal to number of used labels, confirming evaluator consistency on a known-feasible assignment.\\\nASSERT_PIPELINE:Create a minimal end-to-end test: run Heuristic with the sample solution, verify it returns a feasible solution and a not-worse score, and that no exceptions occur.\\\nACTION_SA_FIX:Implement Heuristic wrapper that dispatches to SA with proper signature and returns (best_solution,best_score). Remove parentheses on function parameters and consume only the first element of generate_neighbour's return.\\\nACTION_ILS_FIX:Define perturb_solution and integrate with local_search(generate_neighbour,evaluate_solution). Normalize labels before evaluation; enforce return contract.\\\nACTION_TABU_FIX:Represent moves as (vertex,old_color,new_color) or (color_a,color_b) for swap; track tabu tenure and aspiration. Ensure neighbor generation never yields identical solution.\\\n\"","Componentes":{"REPRESENTATION":"List[int] of length 9 where solution[i-1] is the color (positive int) assigned to vertex i; labels normalized to contiguous {1,...,k}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and normalization to contiguous labels\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Normalize labels to enforce contiguity {1..k}\n    mapping = {}\n    nxt = 1\n    sn = []\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sn.append(mapping[c])\n\n    # Base objective (k)\n    k = 0\n    for x in sn:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sn[u-1] == sn[v-1]:\n            conflicts += 1\n\n    fitness = float(k) + PEN_EDGE * float(conflicts)\n    return float(fitness)\n","NB_CODE":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns: (new_solution_list, movement_type_str)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Choose color minimizing local conflicts; allow k+1 only if infeasible and no feasible color exists\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if total > 0 and (not best_colors or best_val > 0):\n            # Consider introducing k+1 only if all current colors cause conflicts\n            # and we are in an infeasible state\n            new_col = k + 1\n            best_colors.append(new_col)\n        # pick one different color for sure\n        if best_colors:\n            # Avoid no-op\n            choices = [c for c in best_colors if c != s[i]]\n            if not choices:\n                # fallback: force a different color within 1..max(k,2)\n                choices = list(range(1, max(2, k+1)))\n                choices = [c for c in choices if c != s[i]]\n            s[i] = random.choice(choices)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            # fallback to recolor\n            return recolor_move(s)\n        # retry to ensure change\n        for _ in range(5):\n            a, b = random.sample(range(1, k+1), 2)\n            if a == b:\n                continue\n            t = [b if c == a else a if c == b else c for c in s]\n            if t != s:\n                s = normalize_labels(t)\n                return s, \"SWAP_TWO_COLORS\"\n        # fallback\n        return recolor_move(s)\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return recolor_move(s)\n        b = random.choice(choices)\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] not in allowed:\n                continue\n            comp.append(x)\n            # enqueue neighbors having allowed colors only\n            for (p,q) in edges:\n                if p-1 == x:\n                    y = q-1\n                elif q-1 == x:\n                    y = p-1\n                else:\n                    continue\n                if not visited[y] and s[y] in allowed:\n                    visited[y] = True\n                    dq.append(y)\n        t = list(s)\n        for idx in comp:\n            t[idx] = b if t[idx] == a else a\n        t = normalize_labels(t)\n        if t != s:\n            return t, \"KEMPE_CHAIN_SWAP\"\n        # fallback\n        return recolor_move(s)\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (list(solution), \"INVALID_INPUT\")\n    try:\n        s0 = [int(x) for x in solution]\n        if any(x < 1 for x in s0):\n            return (s0, \"INVALID_INPUT\")\n    except Exception:\n        return (list(solution), \"INVALID_INPUT\")\n\n    s0 = normalize_labels(s0)\n    # Decide move type based on conflicts with guaranteed change\n    _, tot = conflicts_by_vertex(s0)\n    r = random.random()\n    if tot == 0:\n        if r < 0.55:\n            return kempe_chain_move(s0)\n        elif r < 0.85:\n            return swap_two_colors(s0)\n        else:\n            return recolor_move(s0)\n    else:\n        if r < 0.7:\n            return recolor_move(s0)\n        elif r < 0.9:\n            return kempe_chain_move(s0)\n        else:\n            return swap_two_colors(s0)\n","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation with color merge when feasible and conflict-driven repair\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def greedy_repair(sol, max_iters=100):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        return normalize_labels(s)\n\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return list(solution)\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return list(solution)\n    except Exception:\n        return list(solution)\n\n    s = normalize_labels(s)\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt merge of two colors followed by greedy repair\n        a, b = random.sample(range(1, k+1), 2)\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=150)\n        return s\n\n    # Otherwise, multi-kick recolors of high-conflict vertices\n    steps = 6\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=120)\n    return s\n","SAMPLE_SOL":"[1, 2, 3, 1, 2, 3, 2, 1, 3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE (solution = [x1,...,x9], 1-indexed students)","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERROR:generate_neighbour returns 3 values; local solvers unpack 2 -> adjust to return (new_sol, move_meta) only or update solvers to handle 3-tuple consistently.\nHEURISTIC_SIG_MISMATCH:Provided SA\/ILS\/Tabu signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE -> standardize to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nPERTURB_FN_MISSING:$Perturb placeholder is unresolved -> implement perturb_solution with explicit interface and pass into Heuristic via other_params or argument.\nNB_RET_CONTRACT:Neighbor currently returns labels ('NB_Recolor','One-Vertex') but solvers do not use them -> either remove extra labels or modify solvers to consume them; avoid silent arity bugs.\nNB_REBUILD_ADJ:Adjacency recomputed on every neighbor generation -> precompute adj once and close over or pass via other_params to cut overhead.\nNB_TARGET_SELECTION:Random conflict vertex selection dilutes progress -> select vertex with max conflict-degree or max DSATUR score to intensify improvement.\nNB_MOVE_SET_WEAK:Only one-vertex recolor -> add Kempe-chain swaps and explicit color-merge attempts (try removing a color and recoloring affected vertices) to escape plateaus and reduce color count.\nNB_COLOR_EXPANSION:Adding new color with fixed p=0.2 may bloat palette -> condition expansion on stuck iterations or annealing temperature; otherwise prioritize reuse.\nREP_NORMALIZATION:Lack of canonicalization inflates search space -> remap colors to 1..k in increasing order after each move to maintain compact representation and stabilize evaluation.\nEVAL_CONFLICT_PENALTY:Tie-breaking solely via conflicts*1e5 may be coarse for metaheuristics with float temps -> keep heavy penalty but also include minor secondary term (e.g., edge-cut delta) if needed; ensure no overflow in cumulative runs.\nEVAL_INCREMENTAL:Full recomputation per neighbor is O(|E|) -> implement delta evaluation using only edges incident to moved vertex for O(deg(v)) updates.\nSA_PARAM_PASSING:Temp controls shown as separate args; unify through other_params dict {T, T_min, alpha, iters_per_T} to comply with general signature.\nTABU_ATTR_DEFICIT:No tabu attributes defined -> use (vertex_id, old_color->new_color) as move attributes; set tenure ~ [7,15]; aspiration if move improves best_score.\nILS_FRAME:Lack of explicit local-improvement and perturbation length -> define descent (first\/best improvement) and perturb strength proportional to k or |E|; use accept-if-better or SA-acceptance for diversification.\nRANDOM_SEED:No seed control -> expose seed in other_params for reproducibility during evaluation.\nSTAGNATION_CRIT:No restart\/stop criteria -> add max_no_improve, time\/iter caps; on stagnation, apply stronger perturbation (e.g., multi-vertex Kempe chain).\nINPUT_VALIDATION:generate_neighbour returns original solution on invalid input -> ensure defensive deep copy and guarantee a change; otherwise solvers may loop without progress.\nEVAL_ASSERT:Evaluator correctness cross-validated against a known optimum using the provided function; consistency confirmed without disclosing the optimum value.\nLOCAL_SOLVER_IO:Solvers expect and may produce extra outputs -> document exact return type contract (solution,best_score,stats) and conform across SA\/ILS\/Tabu to avoid unpacking errors.\nPOST_MOVE_CHECK:After neighbor\/perturb, enforce color-compaction and revalidate domain (positive ints) to prevent evaluator LARGE penalty.\nSUGGESTED_PERTURB:Implement randomized Kempe-chain on a high-degree\/conflict vertex; optionally attempt color deletion then greedy repair to force exploration.\nDATA_CACHING:Cache degree, DSATUR scores, and neighbor colors; update incrementally after each move to reduce per-iteration overhead.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE (solution = [x1,...,x9], 1-indexed students)","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 100000","NB_CODE":"import random, copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"NB_Recolor\", \"One-Vertex\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, \"NB_Recolor\", \"One-Vertex\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = solution[:]\n\n    # Identify conflicting vertices (if any)\n    conflicts = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    # Choose target vertex: prefer conflicts, else random\n    if conflicts:\n        i = random.choice(list(conflicts))\n    else:\n        i = random.randint(1, 9)\n\n    # Candidate colors: reuse existing palette and optionally one new color with small prob\n    palette = set(new_sol)\n    max_color = max(palette)\n    candidates = list(palette)\n    if random.random() < 0.2:\n        candidates.append(max_color + 1)\n\n    # Exclude neighbor colors for a greedy-feasible move if possible\n    neighbor_colors = {new_sol[j-1] for j in adj[i]}\n    feasible = [c for c in candidates if c not in neighbor_colors]\n    if feasible:\n        chosen = random.choice(feasible)\n    else:\n        # Fall back: pick any candidate (may create or shift conflicts)\n        chosen = random.choice(candidates)\n\n    new_sol[i-1] = chosen\n    return (new_sol, \"NB_Recolor\", \"One-Vertex\")","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = solution[:]\n\n    # Apply k random recolors (k in [2,4])\n    k = random.randint(2, 4)\n    for _ in range(k):\n        i = random.randint(1, 9)\n        palette = set(new_sol)\n        max_color = max(palette)\n        candidates = list(palette)\n        # With moderate probability, allow introducing a new color\n        if random.random() < 0.4:\n            candidates.append(max_color + 1)\n        neighbor_colors = {new_sol[j-1] for j in adj[i]}\n        feasible = [c for c in candidates if c not in neighbor_colors]\n        if feasible:\n            chosen = random.choice(feasible)\n        else:\n            chosen = random.choice(candidates)\n        new_sol[i-1] = chosen\n\n    # Optional normalization: relabel colors to 1..m to avoid label drift\n    relabel = {}\n    next_label = 1\n    for idx in range(9):\n        c = new_sol[idx]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n        new_sol[idx] = relabel[c]\n\n    return new_sol","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_MISSING_COMPONENT:Perturbation function is undefined ('$Perturb'). Define 'perturb_solution(solution, other_params)' with safe, filesystem\/network-free operators (e.g., multi-vertex Kempe-chain swaps, color-class merge\/split, random-recolor bursts). \nE_API_CONTRACT_VIOLATION:Target heuristic signature declared but no 'Heuristic(...)' provided. Implement 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' and ensure it returns (new_solution,new_score,new_best,new_best_score,meta). \nE_CODE_KEYS_SEC:Verify no function accesses filesystem, OS, or network anywhere (MAIN_CRITICAL_INSTRUCTION). Remove any placeholders that could be expanded into such calls. \nE_NEIGH_TIEBREAK:DSATUR target selection compares 'val > (best_set,-1)' but only updates 'best_set=val[0]'. Tie-breaking on the second component is never used; selection becomes unstable. Fix by keeping full best tuple and comparing tuples consistently, or compute a scalar priority. \nE_NEIGH_REDUNDANT_ADJ:Adjacency is rebuilt on every call (O(|E|)). Hoist 'edges' and 'adj' to a precomputed constant or closure to cut neighbor-generation overhead. \nNB_CODE_FAIL_LOCAL_OPT:Move set lacks explicit k-reduction when conflicts=0. Introduce color-elimination moves: pick a color class, attempt to recolor its vertices using existing palette via greedy\/ILP micro-solver; if successful, drop the color. \nNB_SCOPE_LIMITED:Kempe swap limited to pair {a,b} around one seed vertex; chains may be too small. Add multi-seed expansion or alternating BFS from multiple conflicted vertices; include color-pair selection biased toward high-interference pairs. \nNB_NO_IMPROVEMENT_HANDLING:On no conflicts, random recolor may worsen cost without structured acceptance. Gate neutral\/worsening moves via annealing probability or tabu aspiration; otherwise skip destructive moves. \nE_EVAL_TIEBIAS:max_label tie-breaker depends on arbitrary labels if not compacted prior to evaluation. Either compact inside 'evaluate_solution' or replace tie-breaker with label-invariant term (e.g., lexicographically sorted color-class size vector). \nE_CODE_PERF:Evaluation O(|E|) is fine, but extra 'set(solution)' and 'max(solution)' are separate passes. Cache 'num_groups' alongside compaction and compute max during a single traversal to reduce constant factors. \nINIT_MISSING:No constructive initializer. Add DSATUR\/greedy saturation to produce a feasible low-k starting point and to set an initial upper bound for label restriction. \nR_STR_CONSTRAINING:Unbounded positive labels degrade search. Maintain an active upper bound k and restrict palette to {1..k}; periodically attempt k\u2192k-1 reduction phases. \nSEARCH_STAGNATION:All solvers return the initial solution unchanged, indicating exploration failure. For SA: increase initial temperature, geometric cooling 0.95\u20130.99, allow sideways moves. For TS: tabu tenure ~7\u201315 with aspiration and short-term\/long-term memory. For ILS: nontrivial perturbation strength (e.g., 2\u20134 Kempe swaps) and acceptance criterion beyond strict improvement. \nCONFLICT_DIRECTED:When conflicts>0, prioritize conflicted vertices and use min-conflict recolor with frequency-based penalties to escape local minima. \nDIVERSIFICATION:Add random restarts and adaptive noise when no-improve for T iterations; reweight colors by conflict frequency (reactive search). \nSEED_CONTROL:Add 'seed' in 'other_params' and seed 'random' for reproducibility in local experiments. \nSTOP_CRITERIA:Define iteration\/time budget and no-improvement cutoff; log best-so-far and move stats for diagnostics. \nXCHECK_CORRECTNESS:Exhaustive evaluation confirms the provided sample solution is feasible and aligns with the minimal achievable objective for this instance; no discrepancy detected. Do not disclose the objective value in logs to prevent leakage. \nTESTS_MINIMAL:Add unit tests: (1) invalid shapes\/types \u2192 LARGE, (2) conflict injection increases score by \u22651e6, (3) color-compaction invariance, (4) neighbor always returns valid representation and non-increasing k when conflicts=0 under k-reduction mode. \nIMPLEMENTABLE_IMPROVEMENTS: \n- NB_ADD:('ColorElim','GreedyRecolorClass'): select smallest color class; try recoloring each vertex by min-conflicts; if success, compact. \n- NB_ADD:('PairSwap','VertexSwap'): swap colors of two non-adjacent vertices to unlock recolorability. \n- NB_FIX:Use tuple 'best_key=(len(neigh_colors), local_conflicts)' and compare 'if val>best_key: best_key=val; target=i'. \n- EVAL_FIX:Compact inside 'evaluate_solution' before measuring 'num_groups' and remove 'max_label' tie-breaker or replace with canonical ordering of classes. \n- PERF_FIX:Precompute 'adj' once; pass it via closure or 'other_params'. \nLOGGING_MIN:Track (k, conflicts, move_type, acceptance) per iteration to detect regressions.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Number of used groups (colors)\n    num_groups = len(set(solution))\n\n    # Heavy penalty for conflicts; lower is better\n    # Add tiny tie-breaker to slightly prefer lower max color label after compaction\n    max_label = max(solution)\n    return num_groups + conflicts * 1_000_000 + max_label * 1e-9\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    # DSATUR-like target selection: maximize number of distinct neighbor colors (prioritize conflicted)\n    candidates = list(conflicts) if conflicts else list(range(1, 10))\n    best_set = -1\n    target = random.choice(candidates)\n    for i in candidates:\n        neigh_colors = {new_sol[j-1] for j in adj[i]}\n        val = (len(neigh_colors), sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1]))\n        if val > (best_set, -1):\n            best_set = val[0]\n            target = i\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Try improved move-set:\n    # 1) Attempt greedy recolor avoiding neighbor colors using existing palette only\n    neighbor_colors = {new_sol[j-1] for j in adj[target]}\n    feasible = [c for c in palette if c not in neighbor_colors]\n    move_type = (\"NB_Recolor\", \"One-Vertex\")\n\n    if feasible:\n        new_color = random.choice(feasible)\n        if new_color != new_sol[target-1]:\n            new_sol[target-1] = new_color\n            new_sol = compact_colors(new_sol)\n            return (new_sol, move_type)\n\n    # 2) Kempe chain swap between current color a and random color b from palette\n    a = new_sol[target-1]\n    b_choices = [c for c in palette if c != a]\n    if b_choices:\n        b = random.choice(b_choices)\n        # Build Kempe chain containing target with colors {a,b}\n        stack = [target]\n        visited = set([target])\n        chain = set([target])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        # Swap colors a<->b on chain\n        for v in chain:\n            c = new_sol[v-1]\n            new_sol[v-1] = a if c == b else (b if c == a else c)\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n\n    # 3) As last resort, allow introducing a new color (rare)\n    if random.random() < 0.1:\n        new_sol[target-1] = max_color + 1\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_Recolor\", \"NewColor\"))\n\n    # No change possible (should be rare)\n    return (solution[:], (\"NB_NoOp\", \"Stall\"))\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Strategy: perform r randomized moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        target = random.randint(1, 9)\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        move_roll = random.random()\n        if feasible and move_roll < 0.5:\n            # Greedy recolor to feasible color\n            new_color = random.choice(feasible)\n            new_sol[target-1] = new_color\n        elif len(palette) >= 2 and move_roll < 0.9:\n            # Kempe chain swap between two random colors\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = set([target])\n                chain = set([target])\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to remove a color via recolor\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recolor target to the smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        # Compact after each micro-perturb to stabilize labels\n        new_sol = compact_colors(new_sol)\n\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_ERROR:Missing Perturbation Function ($Perturb placeholder). Define def perturb_solution(solution, intensity, rng) to avoid runtime failures in SA\/ILS; \nE_API_SIG_MISMATCH:TARGET_HEURISTIC_GENERAL_SIGNATURE requires perturb_solution but none provided. Add callable with zero filesystem\/network\/OS usage per MAIN_CRITICAL_INSTRUCTION; \nE_DETERMINISM:No RNG seeding or rng object threading. Pass a rng parameter and avoid global random to enable reproducibility and controlled noise; \nE_EVAL_SCALE:Conflict penalty fixed at 1e6 can destabilize SA acceptance. Prefer lexicographic objective (conflicts first, then groups) or dynamic penalty scaled by degree max to keep gradients informative; \nE_EVAL_COST:Full recomputation each call is O(m) with m=17. For local search, compute delta cost for single-vertex recolors using adjacency precompute to reduce to O(deg(v)); \nNB_CODE_FAIL_LOCAL_OPT:min_conflict_recolor uses a fixed palette and ignores creation of promising temporary colors when trapped. Add selective new-color trials with immediate compaction to escape plateaus; \nNB_STALL:Returns (NB_NoOp, Stall) with unchanged solution, causing search stagnation. Enforce nontrivial move generation or retry policy up to K attempts before returning; \nNB_TIEBREAK_WEAK:DSATUR key=(sat_deg, local_conf) but local_conf counted on current color only; prefer key=(sat_deg, deg, local_conf) to prioritize high-degree conflicted vertices; \nNB_KEMPE_SCOPE:Kempe chain builds maximal (a,b) component but no acceptance check. Compute delta-conflicts and reject non-improving swaps when conflicts>0, or use simulated annealing acceptance; \nNB_CLASS_ELIMINATION:Greedy recolor of smallest class uses static palette order, risking early infeasible choice. Order target colors by least conflicts\/least saturation increase and backtrack if a step fails; \nNB_DELTA_CACHE:Repeated neighbor evaluations recompute neighbor colors via Python sets each time. Maintain per-vertex color counts (array[int]) to update in O(1) on tentative recolors; \nR_STR_INADEQUATE:Unbounded positive labels expand palette unnecessarily. Constrain to [1..k_max] and enforce compaction after every move; \nALG_ILS_WEAK:Without a real perturbation, ILS will cycle. Implement perturbation as L steps of randomized Kempe swaps or vertex recolors on highest-saturation vertices; \nALG_SA_TEMPERATURE:No temp schedule integration evident with heavy penalties. Use geometric cooling with reheats and accept uphill moves only when conflicts strictly drop or with prob tuned to local delta; \nALG_TABU_CONFIG:No tabu attributes attached to moves. Track tabu on (vertex,color) assignments with aspiration by best-so-far to prevent immediate reversals; \nE_ASSERT_CORRECTNESS:Evaluation and neighbor validity checked via internal exhaustive verification over k\u2208{1..4}; sample solution is feasible and consistent with objective scale; \nE_CODE_PERF:Adjacency built every neighbor call. Precompute adj, degree, and edge list once and pass via other_params to reduce overhead; \nTEST_COVERAGE:No unit tests for edge cases (invalid lengths, zero\/neg colors). Add tests asserting LARGE return and neighbor returns NB_Invalid; \nSUGG_PERTURB:def perturb_solution(sol,intensity,rng): apply intensity randomized Kempe swaps or recolor top-saturation vertices, then compact; \nSUGG_MOVE_SET:Add color-merge attempts: pick two colors a,b, try recolor a into b via greedy with backtracking; \nSUGG_ACCEPTANCE:Use two-level objective (conflicts, groups). In conflict-free region, only accept moves that do not increase groups; \nSUGG_RESTARTS:Add capped plateau moves with diversification restarts when no improvement in T iterations; \nSUGG_LOGGING:Record move types, deltas, and palette size to diagnose stalls and tune parameters\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Compact labels to ensure label-invariant evaluation\n    relabel = {}\n    next_label = 1\n    compacted = solution[:]\n    for i in range(len(compacted)):\n        c = compacted[i]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n        compacted[i] = relabel[c]\n\n    # Number of used groups (colors)\n    num_groups = len(relabel)\n\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 1_000_000","NB_CODE":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts_vertices = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Helper: attempt recolor of a single vertex to minimize conflicts using existing palette\n    def min_conflict_recolor(sol, v):\n        current = sol[v-1]\n        neigh_colors = {sol[j-1] for j in adj[v]}\n        best_c = current\n        best_conf = math.inf\n        for c in palette:\n            if c == current:\n                # evaluate keeping color too\n                pass\n            # compute local conflicts at v\n            local_conf = 0\n            for u in adj[v]:\n                if (c == sol[u-1]) and u != v:\n                    local_conf += 1\n            if local_conf < best_conf:\n                best_conf = local_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_c != current:\n            sol[v-1] = best_c\n        return sol\n\n    # If there are conflicts, prioritize conflicted vertices\n    if conflicts_vertices:\n        # DSATUR-like selection with correct tie handling\n        target = None\n        best_key = (-1, -1)\n        for i in conflicts_vertices:\n            neigh_colors = {new_sol[j-1] for j in adj[i]}\n            local_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            key = (len(neigh_colors), local_conf)\n            if key > best_key:\n                best_key = key\n                target = i\n        # Try min-conflict recolor within existing palette first\n        trial = new_sol[:]\n        trial = min_conflict_recolor(trial, target)\n        if trial != new_sol:\n            return (compact_colors(trial), (\"NB_Recolor\", \"Min-Conflict\"))\n        # Kempe chain swap between two colors a and b to break conflicts\n        a = new_sol[target-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # bias b towards most frequent neighbor color\n            neighbor_colors = [new_sol[j-1] for j in adj[target]]\n            freq = {}\n            for c in neighbor_colors:\n                freq[c] = freq.get(c, 0) + 1\n            b_choices.sort(key=lambda c: freq.get(c, 0), reverse=True)\n            b = b_choices[0]\n            stack = [target]\n            visited = {target}\n            chain = {target}\n            while stack:\n                u = stack.pop()\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (a, b):\n                        visited.add(v)\n                        stack.append(v)\n                        chain.add(v)\n            swapped = new_sol[:]\n            for v in chain:\n                c = swapped[v-1]\n                swapped[v-1] = a if c == b else (b if c == a else c)\n            return (compact_colors(swapped), (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n        # As a last resort, introduce a new color with small probability\n        if random.random() < 0.1:\n            trial = new_sol[:]\n            trial[target-1] = max_color + 1\n            return (compact_colors(trial), (\"NB_Recolor\", \"NewColor\"))\n        return (new_sol[:], (\"NB_NoOp\", \"Stall\"))\n\n    # No conflicts: attempt explicit color elimination\n    # Select the smallest color class\n    color_to_vertices = {}\n    for i, c in enumerate(new_sol, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    smallest_color = min(color_to_vertices.keys(), key=lambda c: len(color_to_vertices[c]))\n\n    # Try to recolor all vertices of this class into existing palette without introducing a new color\n    target_vertices = color_to_vertices[smallest_color][:]\n    trial = new_sol[:]\n    success = True\n    # order by decreasing degree to be safer\n    target_vertices.sort(key=lambda v: len(adj[v]), reverse=True)\n    for v in target_vertices:\n        current = trial[v-1]\n        neigh_colors = {trial[j-1] for j in adj[v]}\n        feasible = [c for c in palette if c != current and c not in neigh_colors]\n        if not feasible:\n            success = False\n            break\n        # choose the color minimizing new potential conflicts (here zero by feasibility)\n        trial[v-1] = feasible[0]\n    if success:\n        return (compact_colors(trial), (\"ColorElim\", \"GreedyRecolorClass\"))\n\n    # If elimination failed, attempt a Kempe swap focused on freeing the smallest color\n    anchor = random.choice(target_vertices)\n    a = new_sol[anchor-1]\n    other_colors = [c for c in palette if c != a]\n    if other_colors:\n        # choose b maximizing adjacency interference with a\n        def interference(b):\n            count = 0\n            for u in color_to_vertices.get(a, []):\n                for w in adj[u]:\n                    if new_sol[w-1] == b:\n                        count += 1\n            return count\n        b = max(other_colors, key=interference)\n        stack = [anchor]\n        visited = {anchor}\n        chain = {anchor}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        swapped = new_sol[:]\n        for v in chain:\n            c = swapped[v-1]\n            swapped[v-1] = a if c == b else (b if c == a else c)\n        return (compact_colors(swapped), (\"NB_KempeSwap\", \"ClassFocused\"))\n\n    # Fallback: swap colors of two non-adjacent vertices to diversify\n    v1 = random.randint(1, 9)\n    non_adj = [i for i in range(1, 10) if i != v1 and i not in adj[v1]]\n    if non_adj:\n        v2 = random.choice(non_adj)\n        trial = new_sol[:]\n        trial[v1-1], trial[v2-1] = trial[v2-1], trial[v1-1]\n        return (compact_colors(trial), (\"PairSwap\", \"VertexSwap\"))\n\n    return (new_sol[:], (\"NB_NoOp\", \"Stall\"))","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Perform r randomized macro-moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        target = random.randint(1, 9)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        move_roll = random.random()\n        if move_roll < 0.45:\n            # Greedy feasible recolor if possible\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                new_sol[target-1] = random.choice(feasible)\n        elif move_roll < 0.9 and len(palette) >= 2:\n            # Kempe chain swap between two random colors containing target\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = {target}\n                chain = {target}\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to collapse colors\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recoloring to smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        new_sol = compact_colors(new_sol)\n\n    return new_sol","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS_LEN9. solution := [c1,...,c9], ci \u2208 {1,2,...}. Interpreted as color assignment for vertices 1..9. Fitness minimizes K = max(ci) with penalties for edge conflicts.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_RUNTIME_TYPE_HINTS:Type List cannot be instantiated error indicates code (or runner) is calling typing.List(). Replace all typing generics with built-ins and remove typing imports. Use def evaluate_solution(solution: list) -> int and def generate_neighbour(solution: list) -> tuple. Ensure no List() or Tuple() are called anywhere.\n\nE_API_COMPAT_SIG:Heuristic function missing. Provide def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): and ensure it returns (new_current,new_best,new_best_score,meta) where best_score strictly decreases for improvements (minimization). Avoid any filesystem\/network\/os calls per constraints.\n\nE_PERTURB_MISSING:Perturbation function not provided. Add a deterministic, parameterized perturbation: e.g., Kempe-chain swap seeded by (vertex,color) with bounded radius r, or k-vertex color-swap on vertices currently using max color. Keep it stateless and pure.\n\nE_INIT_MISSING:Lack of constructive initializer undermines convergence. Add DSATUR or greedy-by-degree initialization to produce a low-K, conflict-free seed; fall back to repair if conflicts arise.\n\nE_EVAL_PENALTY_SCALE:Penalty 1e6 blocks exploration for annealing\/ILS. Replace with adaptive penalty \u03bb that scales with current K and graph size: return K + \u03bb*conflicts with \u03bb in [100,1000], or dynamic \u03bb = c*max(1,iter\/\u03c4). Maintain hard infeasible cap only for invalid inputs.\n\nE_EVAL_VALIDATION:Using Python, verified evaluation rejects invalid shapes\/domains and distinguishes feasible vs. infeasible; sample solution evaluates to a small K. No changes required to edge indexing. Keep n and E constants encapsulated to avoid drift.\n\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to single-vertex recolor; plateaus likely. Add: (a) color-swap between two vertices (2-opt analogue), (b) Kempe-chain recolor, (c) swap two color classes, (d) targeted recolor of vertices on max color to reduce K.\n\nNB_CODE_K_INCREASE:Allowing palette_max+1 in neighbour expands K even when feasible, degrading objective. Restrict neighbor to non-increasing K when conflicts==0; only permit K increase inside perturbation or after max no-improve iters.\n\nNB_CODE_VERTEX_SELECTION:Uniform selection over conflicts is weak. Replace with argmax over conflict-degree or saturation degree; break ties by higher graph degree to prioritize impactful moves.\n\nNB_CODE_CANONICALIZATION:Relabeling colors each move breaks Tabu\/annealing state tracking and induces cycling. Remove per-move remap; instead maintain a stable label scheme, and perform optional normalization only when recording a new best.\n\nNB_CODE_FEASIBILITY_BIAS:When conflicts>0, feasible color set excludes neighbors but may still dead-end. Add limited-length tabu on (vertex,color), and aspiration by improvement on conflicts; or use soft-conflict acceptance with temperature to escape.\n\nR_REPRESENTATION:List of ints OK but lacks capped palette. Maintain an upper bound K_max in state and enforce 1..K_max to align with objective; decrement K_max greedily when a color class becomes empty.\n\nSCHED_ANNEALING:No cooling schedule provided. Use T0 set so that ~80% of +\u0394 moves are accepted, geometric cooling T<-\u03b1T with \u03b1 in [0.90,0.99], reheating on stagnation with bounded cycles.\n\nILS_PERTURB_DEPTH:Not specified. Use adaptive perturbation depth proportional to stagnation length, capped by min(4, K) for this graph size.\n\nTABU_TENURE:Undefined for Tabu_Search. Set tenure ~ [5,10] moves; use tabu on (vertex,color) and on class swaps; aspiration if move improves best_score.\n\nE_CODE_RANDOMNESS:random seeded nowhere; results non-reproducible. Add optional seed in other_params and seed RNGs on entry.\n\nE_COMPAT_RETURN_TYPES:generate_neighbour must always return (solution, NB_Type, Movement_Type). Ensure solution is list[int] and NB_Type\/Movement_Type are short strings; avoid None.\n\nE_PERF_MOVE_EVAL:Re-evaluate full solution each step is O(|E|). Cache conflicts and K; update incrementally when a single vertex changes to O(deg(v)).\n\nE_STOP_CRITERIA:Not specified. Define max iterations, no-improve budget, and time cap. For small graphs, 1e4\u20131e5 iterations suffice with incremental evaluation.\n\nTEST_ASSERTIONS:Add unit tests: (a) infeasible random -> penalty > 1e6-1000; (b) move from feasible never increases K unless allowed by perturbation; (c) neighbor diversity measured via Hamming distance distribution.\n\nKNOWN_BEST_EVAL_CHECK:Using Python, validated that evaluate_solution ranks candidate solutions consistently with the objective and penalization; neighbor preserves feasibility when starting feasible. Do not expose any best-known value in logs.\n\nCONCRETE_FIX_SNIPPET_EVAL:def evaluate_solution(solution: list) -> int:  # replace typing; logic unchanged. Avoid importing typing.\nCONCRETE_FIX_SNIPPET_NB:def generate_neighbour(solution: list) -> tuple:  # replace typing; remove remap; forbid K increase if conflicts==0; add vertex selection by saturation degree.\n\nCONCRETE_ADD_PERTURB:def perturb_solution(solution: list, strength: int, rng) -> list:  # implement Kempe-chain swap with up to strength vertices; ensure purity and bounded K.\n\nCONCRETE_ADD_HEURISTIC:def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):  # implement SA\/ILS loop with incremental eval, proper acceptance, and return tuple as specified.\n\nLOGGING_MINIMAL:Limit extras to NB_Type, Movement_Type, \u0394cost, conflicts, K, and acceptance reason to satisfy local solver expectations without noise.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORS_LEN9. solution := [c1,...,c9], ci \u2208 {1,2,...}. Interpreted as color assignment for vertices 1..9. Fitness minimizes K = max(ci) with penalties for edge conflicts.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type\/size\/domain\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000*conflicts + K\n    return K\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # fallback random feasible-ish solution basis\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Identify conflicting vertices\n    conflicts = [False]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts[u-1] = True\n            conflicts[v-1] = True\n    candidate_indices = [i for i in range(n) if conflicts[i]]\n    if not candidate_indices:\n        # No conflicts: perform color-lowering or random recolor to explore\n        idx = random.randrange(n)\n    else:\n        idx = random.choice(candidate_indices)\n    # Determine forbidden colors from neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(sol[u-1])\n    current_color = sol[idx]\n    K = max(sol)\n    # Try colors from 1..max(K,3) excluding neighbor colors and current\n    palette_max = max(K, 3)\n    feasible = [c for c in range(1, palette_max+1) if c != current_color and c not in neighbor_colors]\n    if not feasible:\n        # If no feasible within current palette, allow one higher color as escape\n        feasible = [c for c in range(1, palette_max+2) if c != current_color and c not in neighbor_colors]\n    new_color = random.choice(feasible)\n    new_sol = list(sol)\n    new_sol[idx] = new_color\n    # Optional post-process: if max color unused, normalize down by relabeling\n    used = sorted(set(new_sol))\n    remap = {c:i+1 for i, c in enumerate(used)}\n    new_sol = [remap[c] for c in new_sol]\n    return new_sol, \"Recolor\", \"Single-Vertex\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex recolor with bias toward conflicts; includes occasional 2-color Kempe swap\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Compute conflicts per vertex\n    conflict_count = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    # Decide perturbation mode\n    if random.random() < 0.5:\n        # Mode A: recolor top-m conflicted vertices\n        m = random.randint(2, 4)\n        order = sorted(range(n), key=lambda i: conflict_count[i], reverse=True)\n        targets = [i for i in order if conflict_count[i] > 0][:m]\n        if not targets:\n            targets = random.sample(range(n), k=min(m, n))\n        K = max(sol)\n        palette_max = max(K, 3)\n        for idx in targets:\n            neighbor_colors = set()\n            for (u, v) in E:\n                if u-1 == idx:\n                    neighbor_colors.add(sol[v-1])\n                elif v-1 == idx:\n                    neighbor_colors.add(sol[u-1])\n            current_color = sol[idx]\n            choices = [c for c in range(1, palette_max+1) if c != current_color and c not in neighbor_colors]\n            if not choices:\n                choices = [c for c in range(1, palette_max+2) if c != current_color and c not in neighbor_colors]\n            sol[idx] = random.choice(choices)\n    else:\n        # Mode B: 2-color Kempe chain swap on randomly chosen pair of colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            used = list(range(1, max(3, max(sol)+1)))\n        c1, c2 = random.sample(used, 2)\n        # Build subgraph indices with colors {c1,c2}\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if nodes:\n            # Pick random seed and BFS within {c1,c2}\n            seed = random.choice(nodes)\n            in_sub = set(nodes)\n            comp = set([seed])\n            frontier = [seed]\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            while frontier:\n                i = frontier.pop()\n                for j in adj[i]:\n                    if j in in_sub and j not in comp:\n                        comp.add(j)\n                        frontier.append(j)\n            # Swap colors on component\n            for i in comp:\n                sol[i] = c1 if sol[i] == c2 else (c2 if sol[i] == c1 else sol[i])\n    # Normalize color labels to 1..|used|\n    used = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(used)}\n    sol = [remap[c] for c in sol]\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] of length 9; solution[i] is color (1-based) for vertex i+1","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0.1\"\n\"FEEDBACK\",\"FIX_SIG_SA:Heuristic signature mismatch. Use def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass functions without calling them (no parentheses).\nFIX_CALLING_CONVENTION:Local solver passes function objects; remove generate_neighbour() and evaluate_solution() from parameter lists and internal calls; call generate_neighbour(solution) at runtime.\nFIX_NB_RET_ARITY:generate_neighbour returns 3 values; local solver expects <=2. Return either (neighbour_solution, meta) or just neighbour_solution. If extra info is needed, pack as a single meta dict.\nFIX_PERTURB_MISSING:Perturbation function is undefined. Implement def perturb_solution(solution,other_params): return diversified_solution with bounded changes; avoid any filesystem\/network\/OS access.\nSA_LOCAL_ERROR:Error 'too many values to unpack (expected 2)' indicates unpacking mismatch from neighbour. Standardize to out=(sol,meta) and ensure solver unpacks at most 2 items.\nILS_TS_LOCAL_ERROR:Same unpacking error propagates across ILS\/Tabu due to shared neighbour interface. Fix neighbour arity first; retest all.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is weak. Add Kempe-chain exchanges and color-swap (swap two colors on an induced subgraph) to escape plateaus and reduce K faster.\nNB_SELECTION_BIAS:Greedy pick by (conflicts,degree,saturation) is brittle. Use DSATUR-style priority with probabilistic tie-breaking (e.g., softmax over conflict counts) to improve exploration.\nNB_K_POLICY:Currently forbids K+1 moves even when conflicted; allow temporary K+1 under SA acceptance to escape local minima; restrict with cap K+1 only and revert via focused repair.\nNB_EMPTY_CANDIDATES:When candidates empty you sample any alt in 1..K; this can be a no-op or worsen conflicts. Prefer: (a) try second-best vertex, (b) invoke Kempe-chain, (c) allow K+1 with small probability under temperature control.\nE_PENALTY_SCALE:Penalty \u03bb=500 may dwarf K and freeze SA at early stages. Use adaptive \u03bb: start small, increase if conflicts persist; or lexicographic evaluation (primary conflicts, secondary K) via tuple or scaled composite with dynamic \u03bb.\nE_TIME_SAFEGUARD:Ensure evaluate_solution never throws; keep fast O(|E|) evaluation and optionally maintain incremental delta evaluation for single-vertex recolors to cut cost per move.\nSA_ACCEPTANCE:Define clear acceptance: p=exp(-(\u0394cost)\/T); reject NaNs; clamp \u0394cost to avoid overflow. Cooling: geometric T\u2190\u03b1T with \u03b1\u2208[0.90,0.99]; add reheats on long stagnation.\nTS_MEMORY:Tabu should store (vertex,color) pairs with tenure \u2248 [7,15]; aspiration if move improves best_score; diversify when cycling detected.\nILS_PERTURB:Implement k-shake that randomly recolors k vertices among those incident to conflicts or with max color; set k adaptive to stagnation.\nK_REDUCTION_STRATEGY:When conflict-free, actively attempt palette shrink by freezing colors {1..K-1} and reassigning K-colored vertices via feasible recolors or Kempe-swaps; iterate until failure then resume search.\nSEED_CONTROL:Add RNG seed in other_params to ensure reproducibility across runs; pass through to all components.\nUNIT_TESTS_MINIMAL:Add tests: (a) evaluate_solution(valid_coloring)==K without conflicts; (b) neighbour returns list[int] length 9; (c) perturb keeps colors \u22651; (d) SA\/ILS\/TS run without exceptions and improve or keep score.\nAPI_CONSISTENCY:Ensure all components accept and return plain Python types; no side effects; no I\/O calls to satisfy 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\nPERF_LIMITS:Set iteration\/time budgets in other_params (e.g., max_iter, max_no_improve) and guard loops to avoid infinite runs.\nEXTRA_OUTPUT_HANDLING:If extra move metadata is required by local solver, return as a single dict in the second tuple element to avoid further unpacking errors.\nVALIDATION_FASTPATH:Precompute adjacency lists and use cached neighbor color counts to speed delta evaluation during move generation.\nCORRECTNESS_ASSERTION:Independent verification confirms existence of a conflict-free assignment with minimal palette; use it as an internal regression case to validate evaluate_solution and move operators without exposing its details.)\"","Componentes":{"REPRESENTATION":"list[int] of length 9; solution[i] is color (1-based) for vertex i+1","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute score\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Adaptive penalty within reasonable scale for annealing\n    penalty_lambda = 500\n    return K + penalty_lambda * conflicts\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Prepare working copy\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency and degree\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    degree = [len(adj[i]) for i in range(n)]\n    # Conflict counts and saturation degrees\n    conflict_count = [0] * n\n    neighbor_color_sets = []\n    for i in range(n):\n        ncols = set(sol[j] for j in adj[i])\n        neighbor_color_sets.append(ncols)\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    K = max(sol)\n    # Select target vertex\n    if any(c > 0 for c in conflict_count):\n        # prioritize by conflicts, then degree, then saturation size\n        order = sorted(range(n), key=lambda i: (conflict_count[i], degree[i], len(neighbor_color_sets[i])), reverse=True)\n        idx = order[0]\n    else:\n        # No conflicts: try reduce K by modifying a vertex using color K, else random\n        max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n        if max_color_vertices:\n            idx = random.choice(max_color_vertices)\n        else:\n            idx = random.randrange(n)\n    # Feasible colors: avoid neighbors' colors and current color\n    forbidden = neighbor_color_sets[idx]\n    current_color = sol[idx]\n    # When conflict-free, disallow increasing K in neighbor move\n    palette_max = K\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color and c not in forbidden]\n    if not candidates:\n        # If no strictly feasible color, allow a random change within 1..K to diversify (may introduce conflicts)\n        alt = [c for c in range(1, palette_max + 1) if c != current_color]\n        if alt:\n            new_color = random.choice(alt)\n        else:\n            new_color = current_color\n    else:\n        new_color = random.choice(candidates)\n    new_sol = list(sol)\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", (\"Conflict-Driven\" if conflict_count[idx] > 0 else \"K-Reduction-Biased\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (Kempe chain swap or multi-vertex recolor targeting max color)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol)\n    mode = random.random()\n    if mode < 0.5 and K >= 2:\n        # Kempe-chain swap between two random used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        # BFS within subgraph induced by colors {c1, c2}\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = [seed]\n        while q:\n            i = q.pop()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        # Swap colors on component\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Multi-vertex recolor focusing on vertices with max color K\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = random.sample(range(n), k=min(3, n))\n        m = min(len(targets), max(2, len(targets)\/\/2))\n        chosen = random.sample(targets, m)\n        for idx in chosen:\n            neighbor_colors = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, K) if c not in neighbor_colors]\n            if not choices:\n                # fallback allow any color <= K (may introduce conflicts)\n                choices = [c for c in range(1, K+1) if c != sol[idx]]\n            if choices:\n                sol[idx] = random.choice(choices)\n        return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:Missing Perturbation Function ('$Perturb'). Provide a concrete, runnable implementation.\nPERTURB_CODE_PATCH:def perturb_solution(solution, intensity=1):\\n    import random\\n    n=len(solution)\\n    sol=list(solution)\\n    for _ in range(max(1,intensity)):\\n        # Kempe-chain style swap between two colors to escape plateaus\\n        i=random.randrange(n)\\n        c1=sol[i]\\n        # choose another color present in solution or introduce 1 if only one color\\n        palette=list(set(sol))\\n        if len(palette)==1:\\n            c2=1 if c1!=1 else 2\\n        else:\\n            c2=random.choice([c for c in palette if c!=c1])\\n        # swap c1<->c2 on a random connected component induced by {c1,c2}\\n        # build adjacency once for n=9 (hard-coded edges for runtime safety)\\n        E=[(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\\n        adj=[[] for _ in range(n)]\\n        for (u,v) in E:\\n            u-=1; v-=1\\n            adj[u].append(v); adj[v].append(u)\\n        # BFS component within colors {c1,c2}\\n        comp=[]; seen=[False]*n; from collections import deque\\n        q=deque([i]); seen[i]=True\\n        while q:\\n            u=q.popleft(); comp.append(u)\\n            for v in adj[u]:\\n                if not seen[v] and sol[v] in (c1,c2):\\n                    seen[v]=True; q.append(v)\\n        for u in comp:\\n            sol[u]=c2 if sol[u]==c1 else c1\\n    return sol\nEVAL_CORRECTNESS_ASSERT:PASS\nSAMPLE_FEASIBILITY_CHECK:PASS\nGLOBAL_OPT_CONSISTENCY_CHECK:PASS\nE_EVAL_METRIC_LEXICOGRAPHY:Penalty_lambda=1000 is arbitrary; small changes can break lexicographic dominance. Use infinite-lex ordering via tuple comparison to avoid tuning.\nE_EVAL_FIX:def evaluate_solution(solution):\\n    E=[(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\\n    if not (isinstance(solution,list) and len(solution)==9 and all(isinstance(c,int) and c>=1 for c in solution)):\\n        return 10**9\\n    conflicts=sum(1 for (u,v) in E if solution[u-1]==solution[v-1])\\n    K=max(solution)\\n    # tuple -> map to scalar for compatibility (conflicts dominate, then K)\\n    return conflicts*10**9 + K\nNB_CODE_FAIL_LOCAL_OPT:Neighbour never attempts K reduction when conflicts==0; only lateral recolors. This prevents convergence to minimal K with proof of minimality.\nNB_CODE_IMPROVE_K_REDUCTION:Add targeted K-tightening move: pick vertex with max color K and try recolor to [1..K-1] via greedy\/kempe; if success and no vertices use K, decrease K.\nNB_CODE_PATCH:def generate_neighbour(solution):\\n    import random\\n    n=9\\n    E=[(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\\n    sol=list(solution) if isinstance(solution,list) and len(solution)==n else [random.randint(1,3) for _ in range(n)]\\n    adj=[[] for _ in range(n)]\\n    for (u,v) in E:\\n        u-=1; v-=1; adj[u].append(v); adj[v].append(u)\\n    K=max(sol)\\n    # try K-reduction first when conflict-free\\n    conflicts=sum(1 for (u,v) in E if sol[u-1]==sol[v-1])\\n    if conflicts==0:\\n        ks=[i for i,c in enumerate(sol) if c==K]\\n        random.shuffle(ks)\\n        for idx in ks:\\n            forbid={sol[j] for j in adj[idx]}\\n            candidates=[c for c in range(1,K) if c not in forbid]\\n            if candidates:\\n                new_sol=sol[:]; new_sol[idx]=random.choice(candidates)\\n                if max(new_sol)<K:\\n                    return new_sol,{\\\"move\\\":\\\"K-reduce\\\",\\\"idx\\\":idx}\\n                return new_sol,{\\\"move\\\":\\\"recolor\\\",\\\"idx\\\":idx}\\n    # conflict-directed recolor\\n    conflict=[0]*n\\n    for (u,v) in E:\\n        u-=1; v-=1\\n        if sol[u]==sol[v]: conflict[u]+=1; conflict[v]+=1\\n    order=sorted(range(n), key=lambda i:(conflict[i],len(set(sol[j] for j in adj[i])),len(adj[i])), reverse=True)\\n    for idx in order[:3]:\\n        forbid={sol[j] for j in adj[idx]}\\n        cur=sol[idx]\\n        palette_max=K  # avoid K expansion; handle via perturbation\/outer loop\\n        candidates=[c for c in range(1,palette_max+1) if c!=cur and c not in forbid]\\n        if candidates:\\n            new_sol=sol[:]; new_sol[idx]=random.choice(candidates)\\n            return new_sol,{\\\"move\\\":\\\"recolor\\\",\\\"idx\\\":idx}\\n    # fallback: random color flip within [1..max(K,2)]\\n    idx=random.randrange(n)\\n    alt=[c for c in range(1,max(K,2)+1) if c!=sol[idx]]\\n    if alt:\\n        new_sol=sol[:]; new_sol[idx]=random.choice(alt)\\n        return new_sol,{\\\"move\\\":\\\"fallback\\\",\\\"idx\\\":idx}\\n    return sol,{\\\"move\\\":\\\"noop\\\"}\nALG_DRIFT_RISK:Allowing K+1 in neighbour induces objective drift; conflicts have huge weight, but expansion undermines minimization goal. Restrict K expansion to perturbation or to failed K-target phases only.\nR_STR_INADEQUATE:Representation uses arbitrary numeric colors; lacks explicit K target. Add K_target parameter in other_params to enforce phase-based search (feasible at fixed K).\nPHASED_K_STRATEGY:Implement descending K loop: find feasible with K=K0; if success, set K0=K0-1 and forbid colors>K0 via neighbour; restart with perturbations.\nSA_COOLING_WEAK:No evidence of conflict-first acceptance; mixing K into score inflates acceptance jumps. Use two-stage acceptance: first minimize conflicts, then K with zero-conflict constraint.\nTABU_ATTR_WEAK:Tabu on solution vectors is ineffective; use attribute-based tabu on (vertex,color) assignments and tenure adaptive to conflicts.\nILS_WEAK_DIVERSIFICATION:Perturbation absent; local minima traps guaranteed. Use kempe-chain swaps, color-class shuffles, and random subset recolor with bounded radius.\nMOVE_SET_LIMITED:Single-vertex recolor lacks long-range corrections. Add moves: (a) swap two color classes, (b) recolor small clique, (c) path-relinking between elite solutions.\nINITIALIZATION_NON_TARGETED:Random init in [1..3] arbitrary. Seed via DSATUR constructive coloring to reduce conflicts from start.\nDSATUR_INIT_PATCH:def dsatur_init():\\n    E=[(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\\n    n=9; adj=[[] for _ in range(n)]\\n    for (u,v) in E:\\n        u-=1; v-=1; adj[u].append(v); adj[v].append(u)\\n    colors=[0]*n; sat=[0]*n; deg=[len(adj[i]) for i in range(n)]\\n    used=[set() for _ in range(n)]\\n    for _ in range(n):\\n        i=max(range(n), key=lambda k:(sat[k],deg[k],k))\\n        c=1\\n        while c in used[i]: c+=1\\n        colors[i]=c\\n        for j in adj[i]:\\n            if colors[j]: continue\\n            used[j].add(c); sat[j]=len(used[j])\\n    return colors\nHEURISTIC_SIGNATURE_COMPLIANCE:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) enforces K_target and returns improved best if and only if score strictly decreases.\nHEURISTIC_PATCH:def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    import random\\n    K_target=other_params.get('K_target', max(currentSolution))\\n    max_iters=other_params.get('max_iters', 2000)\\n    iters_no_improve=0\\n    sol=list(currentSolution)\\n    best_local=sol[:]; score_local=evaluate_solution(sol)\\n    for it in range(max_iters):\\n        cand,_=generate_neighbour(sol)\\n        # enforce K_target by remapping any color>K_target down randomly\\n        if max(cand)>K_target:\\n            # remap exceeding colors into [1..K_target]\\n            cand=[min(c,K_target) for c in cand]\\n        s=evaluate_solution(cand)\\n        if s<score_local or (s==score_local and random.random()<0.1):\\n            sol=cand; score_local=s\\n            if s<best_score:\\n                best=cand[:]; best_score=s; iters_no_improve=0\\n            else:\\n                iters_no_improve+=1\\n        else:\\n            iters_no_improve+=1\\n        if iters_no_improve>200:\\n            sol=perturb_solution(best if random.random()<0.5 else sol, intensity=2)\\n            iters_no_improve=0\\n    return best,best_score\nMETRICS_AND_LOGGING:Add counters for conflicts, K, acceptance rate, and K-reduction successes to diagnose stagnation.\nVALIDATION_TESTS:Add unit tests: (a) evaluate_solution monotonicity: any added conflict increases score; (b) neighbour never increases K when conflicts==0; (c) perturb preserves feasibility w.r.t. conflicts with small probability to allow escape.\nRUNTIME_BOUNDING:Set strict iteration\/time caps and deterministic seed option for reproducibility during evaluation.\nPY_ASSERTIONS:All provided code avoids filesystem\/network\/os commands per MAIN_CRITICAL_INSTRUCTION.\n\"","Componentes":{"REPRESENTATION":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts and K\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Lexicographic-like composite: conflicts dominate, then K\n    penalty_lambda = 1000\n    score = conflicts * penalty_lambda + K\n    return int(score)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, meta_dict)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute neighbor color sets and conflict counts\n    neighbor_colors = [set(sol[j] for j in adj[i]) for i in range(n)]\n    conflict_count = [0] * n\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        if sol[u0] == sol[v0]:\n            conflict_count[u0] += 1\n            conflict_count[v0] += 1\n    K = max(sol) if sol else 1\n    # DSATUR-like priority with conflict emphasis\n    saturation = [len(neighbor_colors[i]) for i in range(n)]\n    degree = [len(adj[i]) for i in range(n)]\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_count[i] > 0, conflict_count[i], saturation[i], degree[i]), reverse=True)\n    # Try up to 3 candidate vertices to avoid no-move cases\n    chosen_idx = None\n    new_color = None\n    move_type = \"recolor\"\n    for idx in order[:3]:\n        forbid = neighbor_colors[idx]\n        cur = sol[idx]\n        # Allow K+1 with small probability when conflicts exist\n        allow_expand = (any(c > 0 for c in conflict_count) and random.random() < 0.1)\n        palette_max = K + (1 if allow_expand else 0)\n        candidates = [c for c in range(1, palette_max + 1) if c != cur and c not in forbid]\n        if candidates:\n            chosen_idx = idx\n            new_color = random.choice(candidates)\n            break\n    if chosen_idx is None:\n        # Fallback: random vertex recolor within 1..max(K,2)\n        idx = random.randrange(n)\n        palette_max = max(K, 2)\n        alt = [c for c in range(1, palette_max + 1) if c != sol[idx]]\n        if alt:\n            chosen_idx = idx\n            new_color = random.choice(alt)\n        else:\n            return sol, {\"move\": \"noop\"}\n    new_sol = list(sol)\n    new_sol[chosen_idx] = new_color\n    meta = {\"move\": move_type, \"idx\": chosen_idx, \"from\": sol[chosen_idx], \"to\": new_color}\n    return new_sol, meta\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Kempe-chain swap or multi-vertex recolor focusing on max color\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol) if sol else 1\n    if random.random() < 0.5 and K >= 2:\n        # Kempe-chain swap between two used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        # pick seed among vertices with color c1 or c2\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = deque([seed])\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Recolor a subset of vertices with max color K or incident to conflicts\n        conflict = [0] * n\n        for (u, v) in E:\n            u0, v0 = u - 1, v - 1\n            if sol[u0] == sol[v0]:\n                conflict[u0] += 1\n                conflict[v0] += 1\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = [i for i, cc in enumerate(conflict) if cc > 0]\n        if not targets:\n            targets = list(range(n))\n        k = max(2, min(4, len(targets)))\n        chosen = random.sample(targets, min(k, len(targets)))\n        for idx in chosen:\n            neigh_cols = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, max(2, K) + 1) if c != sol[idx] and c not in neigh_cols]\n            if not choices:\n                # Allow temporary K+1 to diversify\n                choices = [c for c in range(1, K + 2) if c != sol[idx]]\n            sol[idx] = random.choice(choices)\n        return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED_COLORS.c[i-1] is color of vertex i. Domain: positive integers starting at 1.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic functions do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) exactly and route your SA\/ILS\/TS logic through it.\nE_NEIGHBOR_UNPACK:Heuristics expect 1 neighbor value but generate_neighbour returns a 3-tuple (sol, NB_Type, Move). Update heuristics to accept and ignore metadata or wrap generate_neighbour to return only sol.\nE_CALLING_STYLE:Error message shows passing generate_neighbour() and evaluate_solution() as called results. Pass function references, not invoked results. Use generate_neighbour and evaluate_solution.\nE_PERTURB_UNDEFINED:Perturbation Function is missing ($Perturb placeholder). Provide a callable perturb_solution that returns a valid solution and metadata tuple to match neighbor output conventions.\nE_VALUE_DIRECTION:Framework expects lower scores better (HEURISTICS_VALUE_BEST_AS_LESSER_COST). Ensure acceptance and comparison logic use smaller-is-better semantics; remove any negation used for maximization.\nE_EVAL_EDGE_CASES:evaluate_solution only returns max(color) for feasible; no compacting. Color holes inflate objective. Add normalize_colors(solution) to relabel to [1..k] after every move to prevent artificial k inflation.\nE_MOVE_LIMITATION:SingleVertexRecolor is weak; lacks recolor chains and color-class moves. Add Kempe-chain swaps, color merge-split, and recolor-by-conflict-degree to escape plateaus and reduce k.\nE_INIT_WEAK:No constructive seed; random starts increase search time. Add DSATUR or greedy-by-degree initializer to produce low-k feasible seeds quickly.\nE_SEARCH_PARAM:Cooling\/acceptance unspecified. For SA, set TEMP_0 to median delta over 500 samples \/ ln(0.8); MIN_TEMP small (e.g., 1e-3); cooling geometric 0.95\u20130.99. For TS, tabu tenure ~ 7\u201310 with aspiration by best_k. For ILS, perturb strength 2\u20133 non-adjacent vertices.\nE_CONSTRAINT_RESPECT:generate_neighbour may set color to maxc+1 too often, inflating k. Prioritize moves that reduce or keep k: enumerate feasible in [1..maxc]; if none, attempt Kempe-chain before introducing maxc+1.\nE_ACCEPTANCE_PENALTY:Penalty=1e9 is fine, but acceptance rules must treat any penalized neighbor as strictly worse; never accept unless no feasible exists and algorithm explicitly repairs next.\nE_STATE_VALIDATION:Add fast validators. Cache adjacency and neighbor colors; incremental conflict checks to avoid O(|E|) re-evaluation each step.\nR_SPECIFIC_FIX_1:Refactor Heuristic signature and unpacking:\n- Expect neighbor triple: neigh, _, _ = generate_neighbour(cur)\n- best_score = min(best_score, evaluate_solution(neigh)) with feasibility guard.\nR_SPECIFIC_FIX_2:Implement normalize_colors:\ndef normalize_colors(sol):\n    remap = {}\n    nxt=1\n    out=[]\n    for c in sol:\n        if c not in remap:\n            remap[c]=nxt; nxt+=1\n        out.append(remap[c])\n    return out\nCall after every accepted move.\nR_SPECIFIC_FIX_3:Add DSATUR initializer to produce a feasible seed with low k; use as currentSolution and best.\nR_SPECIFIC_FIX_4:Add Kempe-chain neighbor:\n- pick vertex v, conflicting color a\/b\n- BFS on subgraph induced by colors {a,b}, swap colors in connected component containing v.\nR_SPECIFIC_FIX_5:Define perturb_solution:\n- apply 2\u20133 Kempe-chain swaps and one color compaction (try to eliminate highest color class).\nReturn (sol, 'Perturb', 'KempeChain+Compact').\nR_SPECIFIC_FIX_6:Stop criterion: no k improvement for T iterations; whenever k decreases, restart temperature and clear tabu to intensify near new frontier.\nE_LOCAL_SOLVER_LOGIC:Your SA\/ILS\/TS all failing with \u201ctoo many values to unpack (expected 2)\u201d confirms wrong neighbor unpacking and\/or wrong function signature. Correct before any performance tuning.\nE_SAMPLE_EVAL:Sample solution evaluates to 3 and is feasible under evaluate_solution. Use it to unit-test normalization and neighbor legality.\nTEST_PLAN:\n- Unit test generate_neighbour returns legal coloring and triple; assert evaluate_solution(neigh) < PENALTY.\n- Unit test perturb_solution legality and effect size distribution.\n- Regression: run 50 trials; assert fraction of feasible states > 0.99 and monotone non-increasing best_score with more iterations.\nCODE_PATCH_GUIDE:\n- Wrapper for neighbor to maintain backward compatibility:\ndef nb_wrap(sol): r = generate_neighbour(sol); return r[0]\n- Temporary fix if legacy heuristics only handle neighbor: use nb_wrap until full refactor is done.\nPERF_IMPROVE:\n- Maintain per-vertex conflict counts and color-class availability bitsets; recolor in O(deg(v)) instead of re-scanning E; update incrementally on acceptance.\nVALIDATION_WITH_KNOWN:Chromatic computation via exact backtracking confirms feasibility checks are correct; evaluator returns expected values for feasible\/penalized cases. Do not expose target value; use it internally for assertions only.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_1BASED_COLORS.c[i-1] is color of vertex i. Domain: positive integers starting at 1.","EVAL_CODE":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    return max(solution)","NB_CODE":"import random\nfrom copy import deepcopy\n\n# Returns: (neighbor_solution, NB_Type, Movement_Type)\n# NB_Type: \"Local\"; Movement_Type: \"SingleVertexRecolor\"\n\ndef generate_neighbour(solution):\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    cur = deepcopy(solution)\n    i = random.randrange(n)\n    used = set(cur[j] for j in adj[i])\n    maxc = max(cur)\n    # Try smallest feasible color to encourage k reduction\n    feasible = [c for c in range(1, maxc) if c not in used]\n    if feasible:\n        cur[i] = random.choice(feasible)\n    else:\n        # If current color conflicts or no lower color available, either keep or try new safe color\n        if cur[i] in used:\n            # Ensure proper coloring by assigning a new color (maxc+1) not used by neighbors\n            cur[i] = maxc + 1\n        else:\n            # Non-improving but legal random recolor among 1..maxc excluding neighbor colors\n            fallback = [c for c in range(1, maxc+1) if c not in used]\n            if fallback:\n                cur[i] = random.choice(fallback)\n            else:\n                cur[i] = maxc + 1\n    return (cur, \"Local\", \"SingleVertexRecolor\")","PERTURB_CODE":"import random\nfrom copy import deepcopy\n\ndef perturb_solution(solution):\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    cur = deepcopy(solution)\n    maxc = max(cur)\n    # Number of vertices to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        used = set(cur[j] for j in adj[i])\n        # With small probability, allow expanding palette to escape plateaus\n        if random.random() < 0.2:\n            candidates = [c for c in range(1, maxc+2) if c not in used]\n        else:\n            candidates = [c for c in range(1, maxc) if c not in used]\n            if not candidates:\n                candidates = [c for c in range(1, maxc+1) if c not in used]\n            if not candidates:\n                candidates = [maxc+1]\n        cur[i] = random.choice(candidates)\n        maxc = max(maxc, cur[i])\n    return cur","SAMPLE_SOL":"[3,2,1,2,3,1,2,2,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:True\nH_SIG_MISMATCH:Your metaheuristics have incorrect signatures. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Return exactly (best,best_score) to satisfy the framework unpacking logic.\nH_RETVAL_COUNT:Framework error 'too many values to unpack' indicates your heuristic returns >2 values. Restrict returns to a 2-tuple (best,best_score).\nPERTURB_MISSING:$Perturb placeholder is undefined. Implement a perturbation operator (e.g., random color-merge attempt + multi-vertex recolor) and pass it to the heuristic per the target signature.\nNB_API_CONTRACT:generate_neighbour type hint claims -> ('NB_Type','Movement_Type') but actually returns List[int]. Fix to -> List[int] to prevent caller-side destructuring errors and silent misuse.\nNB_REPAIR_INCOMPLETE:repair() does a single pass and recolors only u on each conflicting edge. Conflicts introduced later remain unresolved. Replace with a loop until no conflicts, recoloring the vertex with higher degree or larger color to minimize k-increase.\nNB_COLOR_BLOAT:Single-vertex recolor allows introducing max(new_sol)+1, increasing k unnecessarily. Restrict candidates to colors <= current max, and only allow introducing a new color when no feasible color \u2264 max exists and only under a diversification flag.\nNB_KEMPE_NOOP:kempe_chain_swap BFS includes a pointless condition if any(True for _ in [0]) that always evaluates True, adding overhead and obscuring logic. Remove it; simply enqueue when sol[y] in {a,b}.\nNB_KEMPE_TARGETING:Lack of targeting: Kempe swaps are applied without checking if they reduce k or conflicts. Add acceptance filters: apply swap only if it does not increase evaluate_solution() and preferably reduces max color or conflict count (in infeasible intermediate moves).\nNB_NORMALIZE_OVERUSE:normalize_colors is called repeatedly in neighbour generation and repair, causing color relabel churn that disrupts energy continuity for SA\/TS. Avoid normalization inside operators; keep labels stable during search and normalize only inside evaluate_solution.\nNB_GREEDY_REPAIR_HEURISTIC:Recoloring with the first free color may trap the search in poor basins. Use least-constraining-color (min-conflict count on neighbors) or DSATUR order for repair steps.\nEVAL_PENALTY_SCALE:PENALTY=1e9 dwarfs all k differences, making SA temperature tuning ineffective if temporary infeasible states are considered. If you ever allow infeasible intermediate states, use a composite score: score = conflicts*P + k with P ~ 1000, or enforce feasibility strictly and keep current penalty unused.\nEVAL_NORM_SCOPE:normalize_colors inside evaluation is correct, but note it makes color IDs meaningless for heuristics. Ensure operators do not rely on specific color IDs persisting across evaluations.\nINIT_QUALITY:The fallback greedy initializer is random and may start with bloated k. Replace with DSATUR-based greedy to obtain stronger starting solutions without extra cost.\nSAMPLE_SOLUTION_CHECK:The provided sample solution is feasible under the given E and n per the evaluation function; however, there is no validation against a certified optimum. Add an exact checker (ILP\/CP-SAT or exhaustive\/DSATUR bound) offline to benchmark heuristic outputs without exposing the value in logs.\nCODE_PERF:generate_neighbour does deepcopies multiple times and normalizes twice per call. Reduce to a single copy and avoid redundant normalization to cut overhead by ~2x.\nSTAGNATION_CONTROL:Missing perturbation schedule and acceptance criteria tuning. Add adaptive temperature or tabu tenure and periodic perturbation intensity ramp-up to escape plateaus.\nREPRO_SEED:No seeded RNG control in operators. Accept a seed in other_params to allow reproducibility for local solver evaluation.\nCORRECTIVE_CODE_SNIPPETS:\n- Heuristic adapter:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import random\n    cur = currentSolution[:]\n    cur_score = evaluate_solution(cur)\n    best = best if best is not None else cur[:]\n    best_score = min(best_score if best_score is not None else cur_score, cur_score)\n    max_iters = other_params.get('max_iters', 10000)\n    for _ in range(max_iters):\n        nb = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        if nb_score < cur_score:\n            cur, cur_score = nb, nb_score\n            if cur_score < best_score:\n                best, best_score = cur[:], cur_score\n        else:\n            # simple SA-like acceptance\n            T = other_params.get('T', 0.1)\n            if random.random() < other_params.get('accept_prob', 0.0):\n                cur, cur_score = nb, nb_score\n        if other_params.get('perturb_every', 500) and (_+1) % other_params['perturb_every'] == 0:\n            cur = perturb_solution(cur)\n            cur_score = evaluate_solution(cur)\n    return best, best_score\n- Robust repair loop:\ndef repair_feasible(sol, adj):\n    n = len(sol)\n    changed = True\n    while changed:\n        changed = False\n        for u in range(n):\n            for v in adj[u]:\n                if v <= u: \n                    continue\n                if sol[u] == sol[v]:\n                    # recolor vertex with higher degree (tie-break on higher color)\n                    pick = u if len(adj[u]) >= len(adj[v]) and (len(adj[u]) > len(adj[v]) or sol[u] >= sol[v]) else v\n                    used = {sol[w] for w in adj[pick]}\n                    c = 1\n                    while c in used and c <= max(sol):\n                        c += 1\n                    if c > max(sol):\n                        # last resort: introduce new color only if unavoidable\n                        c = max(sol) + 1\n                    if sol[pick] != c:\n                        sol[pick] = c\n                        changed = True\n    return sol\n- Kempe cleanup:\ndef kempe_chain_swap(sol, adj, v_idx, a, b):\n    from collections import deque\n    n = len(sol)\n    q = deque([v_idx])\n    seen = {v_idx}\n    while q:\n        x = q.popleft()\n        for y in adj[x]:\n            if sol[y] in (a,b) and y not in seen:\n                seen.add(y); q.append(y)\n    for x in seen:\n        sol[x] = b if sol[x] == a else (a if sol[x] == b else sol[x])\n    return sol\n- Neighbour recolor without k inflation:\ndef recolor_vertex(sol, adj, i):\n    used = {sol[j] for j in adj[i]}\n    cap = max(sol)\n    feasible = [c for c in range(1, cap+1) if c not in used]\n    if feasible:\n        # pick least constraining color\n        def lc_cost(c): \n            return sum(1 for j in adj[i] if c not in {sol[k] for k in adj[j] if k != i})\n        return [*sol[:i], min(feasible, key=lc_cost), *sol[i+1:]]\n    # unavoidable: allow a new color\n    return [*sol[:i], cap+1, *sol[i+1:]]\nVERIFICATION_ACTION:Used the provided evaluation function to validate the sample solution\u2019s feasibility locally and confirm the tooling can compute objective values consistently. Do not expose or rely on best-known values in outputs.\nNEXT_STEPS:\n- Align all heuristic signatures and returns to the target API.\n- Implement perturb_solution and pass via other_params.\n- Replace repair and Kempe implementations with the above corrected versions.\n- Remove redundant normalization and deepcopies to reduce overhead.\n- Add an exact checker offline to validate final solutions during development without emitting best-known values in logs.\"","Componentes":{"REPRESENTATION":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","EVAL_CODE":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","NB_CODE":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a legal neighbouring solution (list[int])\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Create a quick feasible fallback by greedy coloring\n        order = list(range(n))\n        random.shuffle(order)\n        cur = [1]*n\n        for i in order:\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n    maxc = max(cur)\n\n    def kempe_chain_swap(sol, v_idx, color_a, color_b):\n        # BFS on subgraph induced by colors {a,b}, swap in connected component containing v_idx\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    if any(True for _ in [0]):\n                        seen.add(y)\n                        q.append(y)\n        # Swap colors in component\n        for x in seen:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    move_type = random.random()\n    new_sol = deepcopy(cur)\n\n    if move_type < 0.5:\n        # Single-vertex feasible recolor with smallest available color\n        i = random.randrange(n)\n        used = {new_sol[j] for j in adj[i]}\n        candidates = [c for c in range(1, max(new_sol)) if c not in used]\n        if not candidates:\n            candidates = [c for c in range(1, max(new_sol)+1) if c not in used]\n        if candidates:\n            new_sol[i] = random.choice(candidates)\n        else:\n            # Try Kempe swap to free a color\n            target_color = new_sol[i]\n            alt = random.choice([c for c in range(1, max(new_sol)+1) if c != target_color] or [target_color])\n            new_sol = kempe_chain_swap(new_sol, i, target_color, alt)\n    else:\n        # Kempe-chain swap between two colors touching a random vertex\n        v = random.randrange(n)\n        neigh_colors = list({new_sol[u] for u in adj[v]})\n        if len(neigh_colors) >= 1:\n            a = new_sol[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n        else:\n            # Fallback to single recolor if isolated (unlikely here)\n            used = {new_sol[j] for j in adj[v]}\n            candidates = [c for c in range(1, max(new_sol)) if c not in used] or [c for c in range(1, max(new_sol)+1) if c not in used] or [max(new_sol)]\n            new_sol[v] = random.choice(candidates)\n\n    # Ensure feasibility by repairing if needed\n    def repair(sol):\n        sol = normalize_colors(sol)\n        for (u, v) in E:\n            u -= 1; v -= 1\n            if sol[u] == sol[v]:\n                # Recolor u greedily\n                used = {sol[w] for w in adj[u]}\n                c = 1\n                while c in used:\n                    c += 1\n                sol[u] = c\n        return normalize_colors(sol)\n\n    new_sol = repair(new_sol)\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","PERTURB_CODE":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: a few Kempe-chain swaps and attempt to reduce highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Greedy fallback\n        cur = [1]*n\n        for i in range(n):\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n\n    def kempe_component(sol, v_idx, color_a, color_b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, color_a, color_b):\n        for x in comp:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    # Apply 2-3 Kempe-chain swaps\n    t = random.randint(2, 3)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class by greedy recolor\n    cur = normalize_colors(cur)\n    maxc = max(cur)\n    highest = [i for i, c in enumerate(cur) if c == maxc]\n    random.shuffle(highest)\n    for i in highest:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, maxc) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n    cur = normalize_colors(cur)\n\n    # Final quick repair to ensure feasibility\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if cur[u] == cur[v]:\n            used = {cur[w] for w in adj[u]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[u] = c\n    return normalize_colors(cur)\n","SAMPLE_SOL":"[3,2,1,2,3,1,2,2,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_SIG_HEURISTIC:Local solver crashes due to signature\/return mismatch. Implement a single entry point Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure it RETURNS EXACTLY (best_solution,best_score). Do NOT pass generate_neighbour() with parentheses; pass the function reference and unpack its (neigh, move) internally.\n\nFIX_PERTURB_MISSING:Perturbation function is undefined ($Perturb). Provide a deterministic, side-effect-free perturb_solution(current,best,other_params) that returns a valid solution and does not access filesystem\/network\/OS.\n\nNB_API_CONTRACT:generate_neighbour returns (solution,move_description). Heuristic must use only the solution for evaluation and handle the extra move string as optional logging; do not attempt to unpack more than two values from the heuristic return.\n\nH_LOCAL_SOLVER_ERRORS_FIRST:Simulated_Annealing\/Iterated_Local_Search\/Taboo_Search signatures and parameter order do not match TARGET_HEURISTIC_GENERAL_SIGNATURE and appear to be called incorrectly (function invoked instead of passed). Standardize to the target signature and normalize acceptance\/loop control via other_params.\n\nE_EVAL_ASSERT:Evaluation correctness verified against an exact solver; evaluate_solution is consistent on feasibility and objective. Maintain this as the authoritative scoring function.\n\nE_EVAL_WEAK_LANDSCAPE:Penalty 1e9 flattens all infeasible states and impedes guidance. Add a secondary graded term for conflicts (e.g., conflicts_count*W) and keep k as the primary objective, or restrict neighbours to produce only feasible solutions to avoid flat regions.\n\nE_EVAL_NORMALIZE_NOTE:Color normalization changes labels but preserves k. Ensure heuristics never rely on raw labels; always compare by evaluate_solution output.\n\nNB_CODE_FAIL_LOCAL_OPT:repair_feasible may introduce new colors, inflating k and masking regressions. Enforce a hard cap cap<=current_k during repair; if no feasible color <= cap exists, backtrack the move or try Kempe-chain\/color-swap before allowing a new color.\n\nNB_MOVESET_INCOMPLETE:Neighbourhood lacks direct k-reduction moves. Add:\n- COLOR_MERGE: attempt to recolor all vertices of the highest label into existing colors via DSATUR order under a hard cap.\n- PAIRWISE_COLOR_SWAP: interchange two color classes to unlock merges.\n- TARGETED_KEMPE: pick (a,b) that reduces usage of the highest color and apply only if max color does not increase.\n- VERTEX_SWAP: exchange colors of two vertices to break symmetry without increasing k.\n\nNB_DSATUR_INIT_SCATTERED:DSATUR initializer is embedded in neighbour; lift it into an explicit initializer to seed the search with a low-k solution and reduce warm-up time.\n\nH_ACCEPTANCE_POLICY:Current small acceptance filter in kempe step is ad hoc. For SA\/ILS\/TS, accept strictly improving k; allow lateral moves only if k unchanged; reject any move that increases k unless in a controlled diversification phase with a hard cap and step budget.\n\nH_TABU_SCOPE:If using Tabu, tabu attributes should include (vertex,color) and (color merge attempts) with aspiration when k decreases. Current design lacks memory; add a bounded tabu list to avoid cycles.\n\nH_RESTART_STRATEGY:Define perturb_solution to perform color-class shuffling, partial uncoloring + greedy recolor under fixed cap, or random Kempe cascades, keeping feasibility and not increasing k.\n\nE_CODE_PERF:Repeated max(sol) and set constructions in tight loops. Cache current_k and per-vertex neighbor color sets; update incrementally to reduce overhead.\n\nTEST_VALIDATION:Add unit checks:\n- evaluate_solution([1,2,3,1,2,3,2,1,3]) returns finite and equals its max label.\n- generate_neighbour returns a length-9 list of ints >=1 and a str move; evaluating neighbour never raises or returns non-integer.\n\nRETURN_CONSISTENCY:Heuristic must not emit extra outputs beyond the mandated (best_solution,best_score). Route any move logs to other_params['log'] to satisfy 'extra outputs expected' without breaking unpacking.\n\nOBJ_CONVENTION:Minimization confirmed. Ensure any metaheuristic using temperature or aspiration compares by evaluate_solution and never negates the score.\n\nSA_PARAM_SANITY:Use cooling schedule that guarantees termination: T*=alpha in (0.8,0.99), MIN_TEMP>0, and a fixed iterations-per-T. Expose these via other_params and remove hardcoded constants.\n\nROBUSTNESS_ON_BAD_INPUT:If currentSolution is invalid, initialize via DSATUR and proceed; never propagate invalid states into the loop.\n\nREPRODUCIBILITY:Add optional rng seed in other_params; do not access external entropy sources.\n\nNO_SIDE_EFFECTS:Ensure all components avoid filesystem\/network\/OS per MAIN_CRITICAL_INSTRUCTION. All state must be in-memory only.\"","Componentes":{"REPRESENTATION":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","EVAL_CODE":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","NB_CODE":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_description)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # pick vertex with max saturation, tie-break on degree\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_chain_swap(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        for x in seen:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        # Loop until all conflicts resolved. Introduce new color only if unavoidable.\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        # recolor vertex with higher degree; tiebreak on larger color id\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    def recolor_vertex(sol, i):\n        used = {sol[j] for j in adj[i]}\n        cap = max(sol)\n        feasible = [c for c in range(1, cap+1) if c not in used]\n        if feasible:\n            # least-constraining color heuristic\n            def lc_cost(c):\n                cost = 0\n                for j in adj[i]:\n                    nbr_used = {sol[k] for k in adj[j] if k != i}\n                    if c in nbr_used:\n                        cost += 1\n                return cost\n            best_c = min(feasible, key=lc_cost)\n            sol[i] = best_c\n            return sol, \"recolor\"\n        # unavoidable: allow a new color\n        sol[i] = cap + 1\n        return sol, \"recolor_new\"\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    move_r = random.random()\n    if move_r < 0.5:\n        # Single-vertex recolor attempt\n        i = random.randrange(n)\n        new_sol = cur[:]\n        new_sol, mtype = recolor_vertex(new_sol, i)\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n    else:\n        # Kempe-chain swap around a random vertex and a neighbor color\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        new_sol = cur[:]\n        mtype = \"kempe_noop\"\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            if a != b:\n                before_cap = max(new_sol)\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n                # small acceptance filter: avoid k inflation\n                if max(new_sol) > before_cap:\n                    # revert with small probability to maintain diversity\n                    if random.random() < 0.2:\n                        pass\n                    else:\n                        new_sol = cur[:]\n                else:\n                    mtype = \"kempe\"\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n","PERTURB_CODE":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple Kempe-chain swaps and targeted reduction of highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    # Apply several Kempe swaps\n    t = random.randint(2, 4)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class\n    cap = max(cur)\n    top_vertices = [i for i, c in enumerate(cur) if c == cap]\n    random.shuffle(top_vertices)\n    for i in top_vertices:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, cap) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n\n    cur = repair_feasible(cur)\n    return cur\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nE_RUNTIME_TYPING_LIST:Error 'Type List cannot be instantiated; use list() instead' indicates runtime attempted to call typing.List(). Remove 'from typing import List' from all executable components or alias as 'from typing import List as TList' and never call it. Use built-in 'list' exclusively.\nE_SIG_HEURISTIC_MISSING:Heuristic function not provided. Implement 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' returning (new_solution,new_best,new_best_score,aux) to match framework.\nNB_SIG_MISMATCH:generate_neighbour annotated as 2-tuple but returns 3-tuple (solution,op_type,move_type). Align signature and downstream expectations or return a dict with explicit keys.\nPERTURB_MISSING:No perturbation provided ('$Perturb'). Implement a safe operator (e.g., Kempe-chain perturbation, multi-node recolor, or color-class shuffle) to enable escaping local minima.\nEVAL_DOUBLE_PENALTY_NON_INT:non_pos penalizes non-int again, causing double-count (1.1e7 per non-int). If intentional, document; otherwise split: penalize non-int only once and non-positive-only separately.\nEVAL_OBJECTIVE_TIE:When infeasible, fitness += k_used blends feasibility and objective, potentially distorting search gradients. Prefer lexicographic scoring: (violations, k_used) or weight violations >> k_used without adding overlap.\nEVAL_PERF:O(|E|) per call; acceptable but costly in metaheuristics. Implement delta evaluation to update only affected edges on recolor (O(deg(v))).\nEVAL_VALIDATION:Sample solution parses and evaluates; confirm feasibility via evaluate_solution without exposing optimality. Keep this check in unit tests.\nNB_EXPANDS_COLORS:Allowing max+1 on every move inflates color space and slows convergence. Restrict to 1..current_k during intensification; only permit +1 in diversify\/perturb phases.\nNB_WEAK_LOCAL_OPT:Pure random recolor is low-quality. Add conflict-directed moves: pick conflicted node; recolor to the least-conflicting color; include 1-swap (color exchange), Kempe chain, and node-move between color classes.\nNB_NORMALIZE_COLORS:Gaps in color labels inflate k_used. After each move, relabel colors to a compact 1..k to stabilize objective and tabu attributes.\nTABU_ATTR_UNDEFINED:For Tabu Search, define tabu attributes as (node,color) or (edge,color-pair) with aspiration if fitness improves; maintain short-term memory on introduced colors to prevent drift.\nSA_SCHEDULE_UNSPECIFIED:For Simulated Annealing, define cooling (e.g., geometric), initial temperature from initial uphill acceptance, and reheating policy for stagnation.\nILS_LOCAL_SEARCH_INCOMPLETE:Define an inner local-improvement loop using best-improving or first-improving recolors; apply perturb_solution only after no-improving moves.\nRANDOMNESS_CONTROL:Inject RNG via other_params (seeded random.Random) and pass it to generate_neighbour\/perturb_solution to ensure reproducibility and fair solver comparisons.\nCONSTRAINT_REPAIR:Add a fast repair heuristic post-move (greedy recolor conflicted nodes) before evaluating to reduce wasted evaluations on obviously bad neighbors.\nUNIT_TESTS_MIN:set of tests: length !=9; non-int entries; non-positive entries; infeasible recolor creating conflict; normalization preserves feasibility.\nKNOWN_BEST_CHECK:Internally verified objective on exact search to validate evaluation consistency; do not expose best value\/solution in solver logs to prevent overfitting.\nSUGGESTED_PERTURB:Implement kempe_chain_perturb(solution,rng,depth=2..3) to swap colors along alternating-color connected components; optionally combine with random color-class merge\/split.\nSUGGESTED_DELTA_API:Expose evaluate_delta(solution, idx, old_color, new_color) returning (delta_fitness, delta_violations, delta_k) to support fast move selection in TS\/SA\/ILS.\nDATA_STRUCTURES:Maintain adjacency lists and for each node a per-color conflict count array to evaluate recolors in O(1) amortized.\nLOGGING_MINIMAL:Record only fitness, violations, k_used, colors_count, and move type; avoid printing solutions to comply with evaluation format and prevent leaking optimal info.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_INT_POS_LEN9","EVAL_CODE":"import math, random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Robust evaluation: lower is better. Feasibility strongly enforced.\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len({x for x in solution if isinstance(x, int) and x >= 1})\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-node recoloring; may introduce a new color up to max+1\n    if not isinstance(solution, (list, tuple)):\n        return (list(solution), \"invalid-input\", \"noop\") if hasattr(solution, \"__iter__\") else ([1]*9, \"invalid-input\", \"noop\")\n    n = len(solution)\n    if n != 9:\n        # pad\/trim to maintain function robustness\n        sol = list(solution)[:9] + [1] * max(0, 9 - len(solution))\n    else:\n        sol = list(solution)\n\n    # Determine current color spectrum\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    max_c = max(colors) if colors else 1\n\n    idx = random.randrange(0, 9)\n    current_color = colors[idx]\n    # Candidate new colors: 1..max_c+1 excluding current_color\n    candidate_colors = [c for c in range(1, max_c + 2) if c != current_color]\n    if not candidate_colors:\n        candidate_colors = [1 if current_color != 1 else 2]\n    new_color = random.choice(candidate_colors)\n    colors[idx] = new_color\n\n    return (colors, \"single-flip\", \"recolor\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + optional color swap\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*9\n    else:\n        base = list(solution)[:9] + [1]*max(0, 9-len(solution))\n\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    max_c = max(colors) if colors else 1\n\n    # Randomly recolor k nodes\n    k = random.randint(2, 4)\n    indices = random.sample(range(9), k)\n    for idx in indices:\n        cand = [c for c in range(1, max_c + 2) if c != colors[idx]]\n        colors[idx] = random.choice(cand) if cand else (1 if colors[idx] != 1 else 2)\n\n    # Optional swap two colors to escape symmetry basins\n    if max_c >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, max_c + 1), 2)\n        for i in range(9):\n            if colors[i] == a:\n                colors[i] = b\n            elif colors[i] == b:\n                colors[i] = a\n\n    return colors\n","SAMPLE_SOL":"[1,1,1,2,3,2,4,3,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Define SA\/ILS\/TS as def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function references not calls.;E_CALL_ERROR:Do not write generate_neighbour() or evaluate_solution() in parameter lists. Passing invoked results triggers 'too many values to unpack'. Use generate_neighbour and evaluate_solution.;E_NB_RET_MISMATCH:generate_neighbour returns (neighbor, movement_type) but solvers likely expect a single neighbor. Either change generate_neighbour to return only neighbor or update solvers to handle the 2-tuple consistently.;E_PERTURB_MISSING:Perturbation Function undefined ($Perturb). Provide perturb_solution(currentSolution, intensity, rng) that performs multi-node moves (e.g., Kempe-chain swap, random recolor of a subset) and returns a valid neighbor.;E_LOCAL_SOLVER_IO:Tabu\/SA\/ILS error messages show unpacking at call sites. Audit all tuple unpacking. Enforce a single consistent return contract across moves and solvers.;NB_CODE_FAIL_LOCAL_OPT:Single-node recolor is too myopic. Add moves: (1) Kempe-chain swap between two colors; (2) vertex-color swap; (3) color-class merge with repair; (4) pair-swap of two vertices\u2019 colors when non-adjacent.;R_INIT_ABSENT:No construction heuristic. Add DSATUR or smallest-last ordering initializer to produce low-k feasible seeds before local search.;E_EVAL_SCALE:Penalty 1e5 per violation dwarfs color-count differences and can freeze SA acceptance. Calibrate SA temperature to this scale or reduce violation penalty and add degree-weighted conflict cost to preserve gradient.;SA_SCHED_WEAK:Cooling unspecified. Set T0 via acceptance of ~50% of \u0394=1e5 moves, e.g., T0=1e5\/ln(2); geometric cooling T_{t+1}=alpha*T_t with alpha in [0.90,0.99]; reheats on stagnation.;TS_CONF_UNSPEC:Define tabu attributes on (vertex,color) assignments; tabu tenure \u2248 [5,10]; aspiration when move improves best_score.;ILS_PERTURB:Use controlled perturb intensity (e.g., 2\u20134 Kempe swaps) between local descents; increase intensity on repeated stagnation.;E_CODE_PERF:_normalize_colors called twice per neighbor generation. Inline normalization to a single pass to cut overhead by ~2x.;E_DIVERSIFICATION:Add-new-color probability (0.15) increases k prematurely. Gate new color introduction to stagnation or when all candidate recolors increase violations.;R_STR_INADEQUATE:Unbounded integer palette hinders k control. Maintain explicit palette size k and map colors to 1..k; attempt k-reduction via color-class elimination followed by repair.;EVAL_CORRECTNESS:Evaluation returns exact color count for feasible solutions and strong penalties for violations; verified via Python on multiple cases; ensure solvers treat lower as better and compare strictly on fitness.;ASSERT_TESTS:Add unit tests: (1) feasible sample -> small fitness equal to color count; (2) equal-color on edge -> fitness increases by 1e5; (3) wrong length -> 1e9+penalty.;MOVE_ACCEPT_RULES:For infeasible states, prefer non-increasing violations first, then k; break ties via degree-weighted conflict decrease.;STOP_CRITERIA:Specify iteration\/time budgets and no-improvement thresholds per phase to avoid premature termination.;LOGGING_MIN:Record (iter,best,violations,k,move_type,temperature\/tabu_size) to diagnose stagnation and parameter misfit.;REPRO_SEED:Set RNG seed handling in other_params to ensure reproducible runs and comparable evaluations.;K_FIX_LOCAL:Confirm neighbor generator always returns length-9 int>=1; clamp\/repair any anomalies before evaluation to avoid structural penalties.;K_COMPAT_INTERFACE:All components must avoid filesystem\/network\/OS access and be pure functions to satisfy MAIN_CRITICAL_INSTRUCTION.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_INT_POS_LEN9","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        # heavy penalty, but preserve gradient with magnitude proportional to size error\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    # Penalize structural\/type issues strongly\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    # Penalize violations very strongly\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        # Feasible: objective is the number of colors\n        fitness = k_used\n    else:\n        # Infeasible: add small pressure to reduce colors while repairing\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random, math\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to a compact 1..k to stabilize k_used\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Single-node recolor favoring diversification within current palette; robust to malformed inputs\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n    idx = random.randrange(0, n)\n    current_color = colors[idx]\n\n    # Candidate colors within current palette; allow +1 with small probability to diversify\n    allow_new = (random.random() < 0.15)\n    max_try = max_c + (1 if allow_new else 0)\n    candidates = [c for c in range(1, max_try + 1) if c != current_color]\n    if not candidates:\n        candidates = [1 if current_color != 1 else 2]\n    new_color = random.choice(candidates)\n\n    neighbor = colors[:]\n    neighbor[idx] = new_color\n    neighbor = _normalize_colors(neighbor)\n\n    return (neighbor, \"single-recolor\")\n","PERTURB_CODE":"import random, math\n\n\ndef _normalize_colors(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Stronger shake using multi-recolor and optional color swap (Kempe-style light)\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n\n    # Randomly recolor k nodes\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        # Allow introduction of at most one new color during perturbation\n        allow_new = (random.random() < 0.5)\n        max_try = max_c + (1 if allow_new else 0)\n        cand = [c for c in range(1, max_try + 1) if c != colors[idx]]\n        if cand:\n            colors[idx] = random.choice(cand)\n    colors = _normalize_colors(colors)\n\n    # Optional swap two existing colors to escape symmetry basins\n    max_c = max(colors) if colors else 1\n    if max_c >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, max_c + 1), 2)\n        for i in range(n):\n            if colors[i] == a:\n                colors[i] = b\n            elif colors[i] == b:\n                colors[i] = a\n        colors = _normalize_colors(colors)\n\n    return colors\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"L_RUN_ERR_SIG:Heuristic signature mismatch. Must be def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do NOT invoke callables in signature; pass references.\nL_RUN_ERR_CALLABLES:Your SA\/ILS\/TS use generate_neighbour() and evaluate_solution() in the signature\/calls. Remove parentheses and pass the functions to match the general driver.\nL_RUN_ERR_UNPACK:generate_neighbour returns (neighbor_solution, movement_type). Your solver expects a single object and raises 'too many values to unpack (expected 2)'. Fix by unpacking both and using only the first for evaluation; log the second optionally.\nL_RUN_ERR_PERTURB_UNDEF:Perturbation Function is '$Perturb' (undefined). Provide a concrete def perturb_solution(solution, intensity, rng) -> solution. Ensure it returns a valid length-9 positive-int list and preserves normalization.\nL_RUN_ERR_INTERFACE:Simulated_Annealing\/Iterated_Local_Search\/Taboo_Search signatures not aligned with TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor to a single dispatcher compliant with the required signature and route method-specific params via other_params dict.\nE_EVAL_ASSERTION:Evaluator validated against internal feasibility check; sample solution yields feasible objective. Maintain lower-is-better semantics; do not negate scores.\nE_EVAL_L2:Penalty composition mixes feasibility and k_used (adds k_used to infeasible scores). This can misorder moves near feasibility. Replace with lexicographic scoring: (violations, k_used, non_int, non_pos) or fitness = violations*B + k_used with B >> 9 to strictly prioritize feasibility.\nE_EVAL_FASTCHECK:Current violation loop scans all edges each eval. Cache adjacency and maintain delta-evaluation in the heuristic to cut per-move cost from O(|E|) to O(deg(v)) on recolors.\nNB_CODE_FAIL_LOCAL_OPT:recolor_min_conflict selects a random vertex. Bias selection to conflicting vertices only; iterate until no local improvement to accelerate feasibility.\nNB_KEMPE_SCOPE:Kempe-chain swap picks (a,b) uniformly. Guide selection using conflict counts per color pair; prioritize pairs involved in conflicts to increase effective reductions.\nNB_SWAP_NONEDGE:vertex_color_swap may inflate color count after normalization. Constrain swaps to preserve current k or accept only if conflicts do not increase.\nNB_NORMALIZE:You normalize in neighbor moves. Ensure identical normalization in perturb_solution and at heuristic entry\/after acceptance to stabilize k tracking.\nINIT_CONSTRUCTION:No dedicated initializer. Add DSATUR or greedy largest-degree-first to produce a low-k, near-feasible start; pass as currentSolution.\nACCEPT_CRITERIA_SA:For SA, incorrect parameter unpacking and missing temp schedule. Use: T0, T_min, alpha in other_params; accept if dE<=0 or exp(-dE\/T)>u. Decrease T by T*=alpha per iteration.\nTS_TABU_KEY:Tabu list should key (vertex,old_color,new_color) or (vertex,color) with tenure ~ n; include aspiration if move improves best_score regardless of tabu.\nILS_PERTURB:Define perturbation intensity proportional to conflicts or small fraction of n; after perturb, run a focused local search (e.g., do-while improving recolors\/Kempe).\nBEST_SCORE_DIR:Ensure best_score is the minimum observed fitness. Remove any negation used for maximization conventions.\nMOVE_BUDGET:Define clear stopping rules: max_iters, max_evals, or no_improve_limit in other_params. Log movement_type frequencies and improvements for diagnostics.\nTEST_FIXTURES:Add unit tests: (1) neighbour returns tuple and valid normalized solution, (2) evaluate_solution correctness on crafted infeasible cases, (3) perturb preserves domain and length.\nKNOWN_BEST_CHECK:Internal brute-force confirmed evaluator consistency against an optimal reference on this instance. Use this only for automated assertions; do not leak target value into solver output.\nPARAM_SUGGEST:SA defaults: T0 set near median positive dE over 100 random conflict-reducing recolors; alpha in [0.90,0.99]; T_min small (e.g., 1e-3 of T0). TS tenure ~7\u201310; ILS perturb size 2\u20133 vertices.\nLOG_EXTRA:Record (iter,best,cur,violations,k,move_type) every N steps. This matches expectation that local solver emits extra outputs for evaluation.\nCODE_SAFETY:Ensure no filesystem\/network\/OS calls in any component; keep all randomness via a passed-in rng to allow reproducibility.\nREPR_IMPROVE:Index-list is fine. To reduce symmetry, enforce canonical color relabeling after each move (you already normalize); keep it consistent across all components.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_INT_POS_LEN9","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Mixed neighborhood: single-node recolor (conflict-minimizing), Kempe-chain swap, non-edge vertex color swap\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Coerce to valid length-9 positive-int list\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u,v in edges:\n            if sol[u] == sol[v]:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        # With small probability, allow a new color\n        if random.random() < 0.1:\n            candidates.append(kmax+1)\n        best = None\n        best_conf = None\n        # Evaluate local conflicts at i only for speed\n        neigh = adj[i]\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out), \"single-recolor\"\n\n    def kempe_swap(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return recolor_min_conflict(sol)\n        a,b = random.sample(range(1, kmax+1), 2)\n        # pick a start vertex with color a or b\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return recolor_min_conflict(sol)\n        s = random.choice(cand)\n        target_colors = {a,b}\n        visited = [False]*n\n        comp = []\n        dq = deque([s])\n        visited[s] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and sol[v] in target_colors:\n                    visited[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out), \"kempe-swap\"\n\n    def vertex_color_swap(sol):\n        # swap colors of two non-adjacent vertices\n        non_edges = []\n        is_adj = [[False]*n for _ in range(n)]\n        for u,v in edges:\n            is_adj[u][v] = True\n            is_adj[v][u] = True\n        for i in range(n):\n            for j in range(i+1, n):\n                if not is_adj[i][j]:\n                    non_edges.append((i,j))\n        if not non_edges:\n            return recolor_min_conflict(sol)\n        i,j = random.choice(non_edges)\n        out = sol[:]\n        out[i], out[j] = out[j], out[i]\n        return normalize(out), \"vertex-swap\"\n\n    colors = normalize(colors)\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb, mtype = recolor_min_conflict(colors)\n    elif move_pick < 0.8:\n        nb, mtype = kempe_swap(colors)\n    else:\n        nb, mtype = vertex_color_swap(colors)\n\n    # Final safety: enforce ints >=1 and length n\n    nb = [int(c) if isinstance(c,int) and c>=1 else 1 for c in nb[:n]]\n    return (nb, mtype)\n","PERTURB_CODE":"import random, math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple conflict-minimizing recolors + Kempe swaps; returns a valid solution list\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def recolor_min_conflict_once(sol, allow_new_prob=0.2):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        if random.random() < allow_new_prob:\n            candidates.append(kmax+1)\n        neigh = adj[i]\n        best = None\n        best_conf = None\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out)\n\n    def kempe_swap_once(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return sol[:]\n        a,b = random.sample(range(1, kmax+1), 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return sol[:]\n        s = random.choice(cand)\n        target = {a,b}\n        seen = [False]*n\n        dq = deque([s])\n        seen[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in target:\n                    seen[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out)\n\n    colors = normalize(colors)\n\n    # Multi-node recolors\n    r = random.randint(2, 4)\n    for _ in range(r):\n        colors = recolor_min_conflict_once(colors, allow_new_prob=0.3)\n\n    # One or two Kempe swaps\n    s = 1 + (1 if random.random() < 0.5 else 0)\n    for _ in range(s):\n        colors = kempe_swap_once(colors)\n\n    # Final safety\n    colors = [int(c) if isinstance(c,int) and c>=1 else 1 for c in colors[:n]]\n    return colors\n","SAMPLE_SOL":"[4,4,2,1,2,1,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS: a comma-separated string of 9 positive integers [c1,...,c9] representing colors for nodes 1..9.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nHEUR_SIG_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/Tabu use def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor). Unify to TARGET_HEURISTIC_GENERAL_SIGNATURE and pass temperature\/params via other_params.\nHEUR_PARAM_PASSING:Remove function-call parentheses in parameters of heuristic signature. Pass function objects, not results. Use generate_neighbour not generate_neighbour().\nNB_RETURN_ARITY:Framework attempts to unpack 2 values; your generate_neighbour returns 3 (new_solution, NB_Type, Movement_Type). Standardize to 2 outputs (new_solution, meta) or update all unpack sites to accept 3. Do not mix arities across solvers.\nPERTURB_ABSENT:Perturbation Function is $Perturb placeholder. Implement perturb_solution(solution, other_params) with deterministic signature. Without perturbation, ILS\/TS cannot recover from local minima.\nEVAL_API_CONTRACT:Evaluation returns large penalties for malformed\/violations and small values for feasible. Ensure all heuristics minimize the score; never negate it. Remove any maximization logic.\nEVAL_ASSERT:Cross-checked evaluation with exact feasibility\/backtracking; no contradictions detected. Use as-is.\nINIT_BIAS:Neighbour init path forces maxc=4 for malformed input, biasing search. Replace with degree-based greedy coloring initializer with k seeded from other_params to improve convergence and reduce evaluation penalties.\nNB_CODE_FAIL_LOCAL_OPT:Operator too simple and uninformed (uniform single-vertex recolor). Add conflict-driven selection and informed recolor sets to accelerate feasibility improvements.\nNB_MISSING_SHRINK:Palette occasionally grows (palette_max=maxc or maxc+1), but lacks explicit palette-shrinking moves. Add targeted moves: remove highest color by recoloring its vertices (DSATUR-order) and reject if infeasible.\nNB_ADV_MOVES:Add Kempe-chain interchange and color-swap moves to escape plateaus and reduce k without increasing conflicts.\nMOVE_FOCUS:Current idx selection uniform over all vertices. Prioritize conflicted vertices or highest degree, highest saturation, or vertices in the max-color class to reduce score faster.\nTEMPERATURE_FLOW:For SA within unified Heuristic(), read and update temp from other_params dict; apply geometric cooling per iteration. Avoid hard-coded globals.\nTABU_CONFIG:Define tabu on (vertex,color) assignments with short-term tenure and aspiration when a better score is found. Current failure indicates no usable tabu container due to signature mismatch.\nILS_STRUCTURE:Define clear loop: local_search -> perturb_solution -> local_search with acceptance on improved or equal solutions. Pass iteration budgets via other_params.\nRANDOM_SEED_CONTROL:For reproducibility and fair evaluation, take optional seed from other_params; do not call random.seed() globally inside evaluation.\nREP_VALIDATE:Representation expects 9 positive ints. Add fast pre-check before neighborhood to avoid repeated heavy penalties.\nE_CODE_PERF:Max clique O(2^n) in evaluate_solution is acceptable for n=9 but expensive inside hot loops. Cache omega and adjacency once per run and share via other_params to cut overhead.\nACCEPTANCE_POLICY:Ensure all heuristics compare by evaluate_solution strictly; do not rely on k alone, as evaluation adds penalties for improvability.\nTERMINATION:Unify stopping criteria (max_iters, no_improve_iters, time_budget) within other_params; current solvers likely diverge or terminate inconsistently.\nCONCRETE_FIX_HEURISTIC_SIG:Refactor all solvers to:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    # run loop; call generate_neighbour(curr) -> (new_sol, meta); score=evaluate_solution(new_sol); maintain best; use other_params.\nCONCRETE_FIX_NB_ARITY:Change generate_neighbour to return exactly (encoded_solution, {'type':'Local','move':'Recolor'}) or adjust caller to accept three values consistently.\nCONCRETE_PERTURB:Implement perturb_solution that performs color-swap on two randomly chosen colors and 2\u20134 Kempe-chain flips; ensure it returns a valid encoding; no filesystem\/network\/OS calls.\nCONCRETE_LOCAL_SEARCH:Add descent step that greedily recolors vertices in conflicts until no violations, then invoke shrink-highest-color attempt before accepting.\nSCORING_SANITY_TESTS:Before running metaheuristics, auto-test evaluate_solution on: malformed input, wrong length, zero\/negative colors, conflicting feasible-looking coloring, and a feasible baseline to assert expected penalty tiers.\nRESULTS_PIPELINE:Record (iter,best_score,curr_score,move_type,palette_size) to diagnose stagnation; avoid printing extraneous text from inside evaluate_solution.\nR_STR_INADEQUATE:CSV string parsing is permissive but fragile; if allowed, carry solutions as lists internally and encode only at IO boundaries to reduce parse overhead and errors.\nNB_DIVERSIFICATION:Occasional palette growth should be conditional on stagnation counters rather than random 10%; otherwise it degrades solution quality without purpose.\nSA_MOVE_ACCEPT:For uphill acceptance, compute delta = new_score - curr_score; accept if delta <= 0 or with prob exp(-delta\/temp). Ensure temp > 0 and decays each iteration.\nCACHE_ADJ:Precompute adjacency and degree order in other_params, reuse across neighbor and perturbation to reduce per-move overhead.\nCOMPLIANCE_NOTE:All provided\/updated functions must avoid filesystem\/network\/OS usage per MAIN_CRITICAL_INSTRUCTION.\"","Componentes":{"REPRESENTATION":"CSV9_INT_COLORS: a comma-separated string of 9 positive integers [c1,...,c9] representing colors for nodes 1..9.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + float(abs(len(colors)-n))\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact clique number (lower bound)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision check: is graph k-colorable for smaller k?\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k):\n        col = {i: 0 for i in range(1, n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1, k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1, n+1) if col[u] == 0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    # penalties\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_encoded, NB_Type, Movement_Type)\n    n = 9\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n:\n        # initialize a random coloring if malformed\n        maxc = 4\n        colors = [random.randint(1, maxc) for _ in range(n)]\n    else:\n        # ensure domain\n        colors = [x if isinstance(x, int) and x >= 1 else 1 for x in colors]\n\n    maxc = max(4, max(colors))\n\n    idx = random.randrange(n)\n    old = colors[idx]\n    # propose a recolor, try to keep palette size, occasionally allow growth\n    palette_max = maxc + (1 if random.random() < 0.1 else 0)\n    new_color = old\n    for _ in range(10):\n        cand = random.randint(1, palette_max)\n        if cand != old:\n            new_color = cand\n            break\n    colors[idx] = new_color\n\n    return (encode(colors), \"Local\", \"Recolor\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger move: reassign multiple nodes and optionally shrink palette\n    n = 9\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n:\n        colors = [random.randint(1, 4) for _ in range(n)]\n    else:\n        colors = [x if isinstance(x, int) and x >= 1 else 1 for x in colors]\n\n    maxc = max(4, max(colors))\n    # choose m positions to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    # optionally move towards fewer colors by limiting palette\n    if random.random() < 0.5 and maxc > 2:\n        palette_max = maxc - 1\n    else:\n        palette_max = maxc\n    for i in idxs:\n        colors[i] = random.randint(1, palette_max)\n    return encode(colors)\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"L_ERR_PERTURB_MISSING:$Perturb placeholder is undefined. Provide a concrete perturbation implementation returning (new_solution_encoded, meta_str) to enable ILS\/SA escapes.\"\n\n\"FEEDBACK\",\"L_ERR_HEURISTIC_ABSENT:Heuristic(...) required by TARGET_HEURISTIC_GENERAL_SIGNATURE is missing. Implement the orchestrator to manage temperature\/iterations, acceptance, and restart logic.\"\n\n\"FEEDBACK\",\"E_COST_EXPONENTIAL:evaluate_solution calls max_clique_size (O(2^n n^2)) and repeatedly backtracks k_colorable per evaluation. This is prohibitively expensive inside tight local search loops. Cache omega once per instance and memoize k_colorable(k); or remove k_colorable from the evaluator and move decision checks to a separate verifier.\"\n\n\"FEEDBACK\",\"E_SIDE_EFFECT_SCORING:Evaluator performs decision search (backtracking) that changes runtime nondeterministically with k_hat. This biases acceptance decisions by computational cost rather than solution quality. Restrict evaluate_solution to static metrics only.\"\n\n\"FEEDBACK\",\"E_SIGNAL_WEAK:Feasible solutions with the same k receive identical scores with no secondary tie-breaks. This flattens the landscape and stalls improvements. Add deterministic tie-breakers (e.g., minimize number of vertices using max color, then total color sum, then DSATUR saturation slack) to guide the search.\"\n\n\"FEEDBACK\",\"E_PARSE_FRAGILE:No upper bound validation for color domain; malformed but large integers are accepted, harming normalization. Enforce 1 <= c_i <= n and reject gaps via canonical relabeling.\"\n\n\"FEEDBACK\",\"REP_SYMMETRY_HIGH:Color labels are arbitrary; symmetric solutions inflate the search space and weaken Tabu memory. Canonicalize colors by order-of-first-appearance after each move to reduce symmetry.\"\n\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Local\/Swap globally relabels two colors without reducing k or conflicts in most cases. Replace with targeted elimination: attempt to recolor vertices of the max color into lower colors using Kempe chains + greedy, then drop the max color.\"\n\n\"FEEDBACK\",\"NB_PALETTE_BLOAT:Conflict recolor may increase palette (k+1 with probability 0.1), directly harming the objective. Disallow palette growth in neighbours; only permit increases within perturbation, and couple with immediate normalization.\"\n\n\"FEEDBACK\",\"NB_KEMPE_SCOPE_LIMITED:Kempe move selects random pair (cu,c2) around a random vertex, often yielding neutral swaps. Bias selection toward (k, c2) and vertices currently colored k; prefer chains that reduce max-color component size.\"\n\n\"FEEDBACK\",\"NB_CONSTRAINT_AWARENESS:Recolor picks smallest feasible color ignoring future conflicts. Use least-constraining-color heuristic (minimizes new conflicts with uncolored neighbours) and degree\/saturation-aware vertex choice.\"\n\n\"FEEDBACK\",\"TABU_GRANULARITY:Without color canonicalization, tabu on labels is ineffective. Tabu should track affected vertex sets or canonicalized color classes; otherwise cycling occurs after swaps.\"\n\n\"FEEDBACK\",\"SA_MOVE_ACCEPT:No temperature\/acceptance coupling shown. Ensure SA acceptance uses exp(-(delta)\/T) with deterministic cooling; for plateau navigation, include reheating or record-to-record travel.\"\n\n\"FEEDBACK\",\"ILS_PERTURB_INADEQUATE:No defined perturbation strength control. Implement depth-controlled multi-move perturbation (e.g., sequence: 1x Kempe (k, c), 1x targeted recolor, 1x greedy repair) scaled by stagnation.\"\n\n\"FEEDBACK\",\"VALIDATION_EVAL_CONSISTENCY:All provided outputs are scored identically by evaluate_solution; the evaluator currently cannot discriminate among multiple distinct feasible outputs. Strengthen tie-breakers to produce a strict ordering.\"\n\n\"FEEDBACK\",\"R_INIT_DSATUR_ONLY:Single greedy initializer risks consistent basin entry. Add diversity: random tie-breaking, multiple DSATUR seeds, and Welsh-Powell permutations; pick best after quick repair.\"\n\n\"FEEDBACK\",\"E_CODE_PERF:Python-level loops in clique check and backtracking dominate runtime. Precompute adjacency bitsets (int masks) to speed clique checks and use bit-operations for induced subgraph enumeration.\"\n\n\"FEEDBACK\",\"E_CACHE_POLICY_MISSING:omega and k_colorable(k) are invariant per instance but recomputed per call. Introduce module-level memoization keyed by instance hash and k to cut evaluation time.\"\n\n\"FEEDBACK\",\"ACCEPT_CRITERION_SCOPE:Evaluator penalizes potential improvability uniformly (fixed 100). Replace binary penalty with structured penalties: penalty = alpha*(count of vertices at max color) + beta*(sum conflicts), removing backtracking calls.\"\n\n\"FEEDBACK\",\"FIX_SPECIFIC:Implement color-elimination local search step:\n- Select color k.\n- For each vertex u with color k in descending degree order, try recolor to c in {1..k-1} using BFS-limited Kempe interchanges; fallback to greedy LCV.\n- If all recolored, decrement k and canonicalize.\"\n\n\"FEEDBACK\",\"FIX_PERTURB_SPECIFIC:Define perturb_solution as:\n- With prob p: perform s Kempe interchanges involving color k and random c<k.\n- Else: execute a random 2-color component flip on a large conflicting component, then repair greedily.\nEnsure it returns (encoded_solution, 'Perturb\/...').\"\n\n\"FEEDBACK\",\"UNIT_TESTS_REQUIRED:Add tests: (1) evaluator rejects invalid lengths and values, (2) canonicalization invariance, (3) neighbour never increases k except in perturbation, (4) elimination succeeds on synthetic near-feasible cases.\"\n\n\"FEEDBACK\",\"RISK_OF_STAGNATION:Given flat scoring, SA\/TS will plateau. Introduce strategic oscillation: alternate minimize conflicts at fixed k and minimize number of k-colored vertices, with periodic forced elimination attempts.\"\n\n\"FEEDBACK\",\"TOOL_ASSERTION:Using the provided evaluate_solution, every listed sample\/result evaluates as feasible with identical scores. The feedback above addresses the evaluator\u2019s inability to provide finer-grained guidance and the neighbour\u2019s weak k-reduction pressure.\"","Componentes":{"REPRESENTATION":"CSV9_INT_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality. Lower is better.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact clique number (lower bound)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision check: is graph k-colorable for smaller k?\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k):\n        col = {i: 0 for i in range(1, n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1, k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1, n+1) if col[u] == 0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    # penalties\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution_encoded, meta_str)\n    meta_str examples: 'Local\/Recolor', 'Local\/Swap', 'Local\/Kempe'\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        # DSATUR-like greedy\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n\n    # Helper: list conflicts and max-color vertices\n    conflicts = []\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts.append((u,v))\n    max_color_vertices = [i for i in range(1,n+1) if colors[i-1] == k]\n\n    move_type = None\n\n    r = random.random()\n    new = colors[:]\n\n    if conflicts and r < 0.5:\n        # Conflict-driven recolor\n        u,v = random.choice(conflicts)\n        u = random.choice([u,v])\n        used = set(new[w-1] for w in adj[u])\n        # Prefer smallest feasible color; if none, pick random other color\n        c = 1\n        chosen = None\n        while c <= k:\n            if c not in used:\n                chosen = c\n                break\n            c += 1\n        if chosen is None:\n            # allow temporary new color with small prob; else random different\n            palette_max = k + (1 if random.random() < 0.1 else 0)\n            cand = list(range(1, palette_max+1))\n            cand = [x for x in cand if x != new[u-1]]\n            chosen = random.choice(cand)\n        new[u-1] = chosen\n        move_type = 'Local\/Recolor'\n    elif max_color_vertices and r < 0.8:\n        # Color swap between max color and a random other color to promote shrinking\n        c1 = k\n        other_colors = [c for c in range(1, k) if c != c1]\n        if other_colors:\n            c2 = random.choice(other_colors)\n            for i in range(n):\n                if new[i] == c1:\n                    new[i] = c2\n                elif new[i] == c2:\n                    new[i] = c1\n            move_type = 'Local\/Swap'\n        else:\n            # fallback recolor a max-color vertex to best feasible\n            u = random.choice(max_color_vertices)\n            used = set(new[w-1] for w in adj[u])\n            feasible = [c for c in range(1, k) if c not in used]\n            if feasible:\n                new[u-1] = random.choice(feasible)\n            else:\n                new[u-1] = random.randint(1, k)\n            move_type = 'Local\/Recolor'\n    else:\n        # Kempe-chain style flip between two colors on a random vertex\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(k,2)+1) if c != cu]\n        c2 = random.choice(alt_colors)\n        # BFS on subgraph induced by colors {cu, c2}\n        from collections import deque\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n        move_type = 'Local\/Kempe'\n\n    # Normalize colors to keep them as positive ints and compact if desired (optional)\n    # Ensure at least 1..max present; leave gaps as-is to avoid invalidating acceptance logic\n    return (encode(new), move_type or 'Local\/Recolor')\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: multi-vertex recolor + color-class swap + 1-2 Kempe flips\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n    new = colors[:]\n\n    # 1) Randomly reassign m vertices, biasing towards max color class to encourage shrink\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        u = i+1\n        used = set(new[v-1] for v in adj[u])\n        palette = list(range(1, max(2, k) + 1))\n        # Prefer colors not used by neighbors\n        feasible = [c for c in palette if c not in used]\n        if feasible:\n            new[i] = random.choice(feasible)\n        else:\n            # fallback: random different color\n            cand = [c for c in palette if c != new[i]]\n            new[i] = random.choice(cand) if cand else new[i]\n\n    # 2) Swap two random color classes\n    if k >= 2:\n        c1, c2 = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if new[i] == c1:\n                new[i] = c2\n            elif new[i] == c2:\n                new[i] = c1\n\n    # 3) Do 1-2 Kempe-chain flips between random color pairs\n    from collections import deque\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(2, max(new))) if c != cu]\n        if not alt_colors:\n            continue\n        c2 = random.choice(alt_colors)\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n\n    return encode(new)\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-crit\"\n\"FEEDBACK\",\"E_EVAL_CRASH:Type List cannot be instantiated; remove typing imports and all typing-based runtime constructs. Use built-in list\/tuple only in executable code.\nE_MISSING_COMPONENT:Perturbation function undefined ($Perturb). Provide a concrete def perturb_solution(...) to enable ILS\/SA escapes.\nE_API_CONTRACT:Neighbour function name misspelled in header ('Neigbour'). Standardize to generate_neighbour across all callers to prevent import\/dispatch failures.\nE_SIGNATURE_MISMATCH:Return type annotation ->('NB_Type','Movement_Type') is nonstandard. Replace with Tuple[str,str] or omit annotations to avoid parser confusion.\nE_SAMPLE_SOL_EVAL_FAIL:Local solver failed before evaluation due to typing error. Fix evaluator imports first; confirm evaluate_solution executes on CSV and list inputs.\nE_CANON_ORDER:Canonicalize in both evaluator and neighbourhood must be identical. Extract a single shared canonicalize to avoid divergence-induced tie-break drift.\nR_REPR_DOMAIN:Mixed input acceptance (CSV string or list) complicates callers. Standardize internal representation as list[int]; parse\/encode only at I\/O boundaries.\nE_PALETTE_INFLATION:Post-move canonicalization can increase palette; current repair remaps arbitrarily and may inject conflicts. Constrain moves so max(new) <= k by construction; eliminate repair path.\nNB_CODE_FAIL_LOCAL_OPT:LCV uses repeated set constructions per neighbor (O(deg^2)). Precompute neighbor-color counts; reuse buffers to reduce allocations.\nNB_KEMPE_VALIDITY:Kempe acceptance uses only count of max-color vertices; may accept non-improving or conflict-introducing flips under conflicts=0. Add feasibility-preserving check and score-based acceptance.\nNB_SCOPE:Kempe pool selection includes k+0 typo and ambiguous pool when k=1. Guard edge cases; ensure non-empty pool without relying on ad-hoc fallbacks.\nINIT_STRATEGY:greedy_init is DSATUR-like but lacks true saturation update ordering. Implement proper DSATUR with a priority queue; reduce initial palette and conflicts.\nE_TIE_BREAKERS:Sum-of-colors after canonicalization as 0.001-weight can distort moves. Prefer lexicographic tie-break: (k, count_k, color-class histogram) to reduce noise.\nE_RANDOMNESS:Unseeded random in neighbourhood hampers reproducibility. Accept a rng in other_params or use a passed Random instance to ensure repeatable runs.\nE_HEURISTIC_CONTRACT:TARGET_HEURISTIC_GENERAL_SIGNATURE requires compatible generate_neighbour\/evaluate\/perturb wiring. Verify Heuristic(...) passes through the exact functions without wrapping that reintroduces typing objects.\nE_BOUND_CHECK:Evaluator accepts values up to 9 by spec; neighbourhood never attempts color 0 but repair\/mapping code can. Add assertions; remove any path that sets 0.\nE_VALIDATION:No regression tests. Add unit tests for: invalid length, out-of-range color, conflict count correctness, canonicalization idempotence, and palette non-increase invariant.\nR_SEARCH_ESCAPES:Perturbation should implement multi-vertex Kempe cascades or graph partition shuffle; single-vertex noise is insufficient against plateaus.\nILS_PARAM:SA\/TS failed due to earlier errors. After fixes, add schedule: T0 auto-scaled from initial delta costs; length L proportional to |E|; tabu tenure \u2248 [7, 10] with aspiration on better scores.\nE_EVAL_SPEED:evaluate_solution recomputes k,cnt_k,ssum each call; cheap but frequent. For inner loops, maintain incremental deltas in the heuristic to cut eval calls.\nVERIFICATION:Brute-force\/backtracking validated feasibility bound for this instance using evaluate_solution; evaluator is consistent with the objective ordering.\nACTION_FIX_ORDER:1) Remove typing imports\/annotations from all executable code. 2) Implement perturb_solution. 3) Enforce no-palette-growth invariant in moves. 4) Replace LCV\/sets with precomputed color-availability caches. 5) Add reproducible RNG handling. 6) Add regression tests and re-run SA\/ILS\/TS to confirm convergence.\"","Componentes":{"REPRESENTATION":"CSV9_INT_COLORS","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Static evaluator. Lower is better.\n    Score structure prioritization:\n    1) conflicts_count (primary feasibility) -> weight 1_000_000\n    2) k (max color) -> weight 1_000\n    3) tie-breakers for feasible solutions:\n       - number of vertices using max color -> weight 10\n       - total sum of colors (after canonicalization) -> weight 0.001\n    Representation: CSV of 9 positive integers within [1..9]. Colors are canonicalized\n    by order-of-first-appearance before scoring to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        \"\"\"Relabel colors to 1..m by order of first appearance.\"\"\"\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + float(abs(len(cols) - n))\n    # domain checks: integers within [1..n]\n    for x in cols:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1 or x > n:\n            return 7_000_000.0\n\n    cols = canonicalize(cols)\n\n    # compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    k_hat = max(cols) if cols else 0\n    cnt_k = sum(1 for x in cols if x == k_hat) if k_hat > 0 else 0\n    ssum = sum(cols)\n\n    if conflicts > 0:\n        score = conflicts * 1_000_000.0 + k_hat * 1_000.0 + float(ssum) * 0.001\n    else:\n        score = k_hat * 1_000.0 + cnt_k * 10.0 + float(ssum) * 0.001\n\n    return float(score)\n","NB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (encoded_solution, meta_str)\n    Neighbourhood is constraint-aware and does NOT increase palette size.\n    Moves:\n    - Targeted recolor of a vertex (prefer max-color vertices) using least-constraining color.\n    - Kempe chain flip biased toward (k, c<k) pairs to reduce max-color usage.\n    - If conflicts exist, prioritize resolving them with LCV recolor.\n    All outputs are canonicalized to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def greedy_init() -> List[int]:\n        # DSATUR-like greedy with deterministic ties by degree then index\n        colors = [0] * n\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        uncolored = set(range(1, n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x], -x))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return canonicalize(colors)\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = greedy_init()\n    else:\n        cols = canonicalize([max(1, int(x)) for x in cols])\n\n    k = max(cols)\n\n    def conflict_edges(colors: List[int]) -> List[Tuple[int, int]]:\n        res = []\n        for (u, v) in edges:\n            if colors[u-1] == colors[v-1]:\n                res.append((u, v))\n        return res\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        # least-constraining color among feasible 1..palette_max\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        # score by how many neighbors would forbid that color for their neighbors (approx: neighbor degree with that color)\n        best_c = None\n        best_score = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if colors[v-1] == 0:\n                    continue\n                # if v had c, it would conflict; approximate constraint via degree\n                if c not in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (impact, -c)\n            if best_c is None or key > best_score:\n                best_c = c\n                best_score = key\n        return best_c if best_c is not None else feas[0]\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    new = cols[:]\n    confs = conflict_edges(new)\n    meta = 'Local\/Recolor'\n\n    r = random.random()\n    if confs:\n        # Resolve a conflict by recoloring one endpoint with LCV, no palette growth\n        u, v = random.choice(confs)\n        pick = u if random.random() < 0.5 else v\n        c = lcv_color(pick, new, k)\n        new[pick-1] = c\n        meta = 'Local\/Recolor-ConflictLCV'\n    else:\n        # Target max-color pressure moves\n        max_vertices = [i for i in range(1, n+1) if new[i-1] == k]\n        if max_vertices and r < 0.7:\n            u = random.choice(max_vertices)\n            # try direct feasible recolor to <k using LCV\n            used = set(new[v-1] for v in adj[u])\n            feas = [c for c in range(1, k) if c not in used]\n            if feas:\n                # choose LCV among feas\n                best = None\n                best_key = None\n                for c in feas:\n                    impact = 0\n                    for w in adj[u]:\n                        if c in set(new[z-1] for z in adj[w]):\n                            impact += 1\n                    key = (-(impact), -c)\n                    if best is None or key > best_key:\n                        best = c\n                        best_key = key\n                new[u-1] = best\n                meta = 'Local\/Recolor-MaxDrop'\n            else:\n                # attempt Kempe with a lower color that may free u\n                c2 = random.choice([c for c in range(1, k)])\n                flipped = kempe_flip(new, u, c2)\n                # if flip reduces number of max-color vertices or keeps same but reduces adjacency conflicts, accept\n                before = sum(1 for x in new if x == k)\n                after = sum(1 for x in flipped if x == k)\n                if after <= before:\n                    new = flipped\n                    meta = 'Local\/Kempe(k,c)'\n                else:\n                    # fallback: Kempe around random vertex with pair (k, c2)\n                    w = random.randrange(1, n+1)\n                    c2 = random.choice([c for c in range(1, max(k, 2)) if c != new[w-1]])\n                    new = kempe_flip(new, w, c2)\n                    meta = 'Local\/Kempe-Fallback'\n        else:\n            # General Kempe flip biased to involve k when possible\n            if k >= 2 and random.random() < 0.8:\n                u = random.choice(range(1, n+1))\n                cu = new[u-1]\n                pool = [c for c in range(1, k + 0) if c != cu] if cu != k else [c for c in range(1, k) if c != cu]\n                pool = pool if pool else [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n                new = kempe_flip(new, u, c2)\n                meta = 'Local\/Kempe-Biased'\n            else:\n                # small recolor anywhere using LCV\n                u = random.randrange(1, n+1)\n                new[u-1] = lcv_color(u, new, k)\n                meta = 'Local\/Recolor-LCV'\n\n    new = canonicalize(new)\n    # Do not increase palette\n    if max(new) > k:\n        # repair by remapping any color >k down to closest in [1..k]\n        mapping = {}\n        nxt = 1\n        for c in sorted(set(new)):\n            if nxt > k:\n                mapping[c] = k\n            else:\n                mapping[c] = nxt\n                nxt += 1\n        new = [mapping[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), meta)\n","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong diversification without increasing palette size.\n    Sequence (depth randomized):\n    - Perform s in {2..4} Kempe flips involving color k and random c<k when possible.\n    - Randomly recolor m in {1..3} vertices with LCV within palette 1..k.\n    Returns (encoded_solution, meta_str)\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            # keep color if no feasible alternative\n            return colors[u-1]\n        # pick least constraining (approx.)\n        best = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if c in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (-impact, -c)\n            if best is None or key > best_key:\n                best = c\n                best_key = key\n        return best\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # simple fallback: 1..n cyclic\n        cols = [((i % 3) + 1) for i in range(n)]\n    cols = canonicalize(cols)\n    k = max(cols)\n\n    new = cols[:]\n\n    # s Kempe flips involving k when possible\n    s = random.randint(2, 4)\n    for _ in range(s):\n        u = random.randrange(1, n + 1)\n        cu = new[u-1]\n        if k >= 2 and (cu == k or random.random() < 0.7):\n            pool = [c for c in range(1, k) if c != cu]\n            if pool:\n                c2 = random.choice(pool)\n            else:\n                # fallback to any other color\n                pool = [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n        else:\n            pool = [c for c in range(1, max(k, 2)) if c != cu]\n            c2 = random.choice(pool)\n        new = kempe_flip(new, u, c2)\n\n    # m random LCV recolors within 1..k\n    m = random.randint(1, 3)\n    idxs = random.sample(range(1, n + 1), m)\n    for u in idxs:\n        new[u-1] = lcv_color(u, new, k)\n\n    new = canonicalize(new)\n    if max(new) > k:\n        # enforce palette cap\n        uniq = sorted(set(new))\n        relabel = {c: i + 1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), 'Perturb\/KempeLCV')\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_FAIL:Error 'Any cannot be instantiated' indicates the runtime attempts to construct typing.Any. Remove 'from typing import Any' everywhere and avoid Any in annotations. Use only concrete types (e.g., List[int]).; E_EVAL_IMPORT_REDUNDANCY:'import math' and 'Any' unused. Remove to reduce parse surface and avoid Any instantiation by frameworks.; E_TYPEHINT_RUNTIME:Neighbour return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' may be evaluated by some runners as a tuple to be constructed. Replace with '-> tuple' or remove the annotation to prevent runtime evaluation issues.; E_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). This breaks SA\/ILS\/TS pipelines. Implement a pure-function perturbation consistent with constraints, e.g., randomly reassign k vertices among most-conflicted.; E_GEN_SIGNATURE_MISMATCH:Provide Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure no filesystem\/network\/OS calls and the function is runnable end-to-end.; E_EVAL_CORRECTNESS_ASSERT:Evaluation returns consistent scalar on feasible and infeasible inputs. Verified on a feasible optimal and random infeasible solutions; no inconsistencies found.; E_EVAL_OBJECTIVE_TIEBREAK:The current scalar blends feasibility and objective with fixed weights. Violations (1000 each) dominate, but still allow objective to influence infeasible states. For stricter guidance, use lexicographic handling: prioritize zero violations first, then minimize max color. Implement via scaled penalties (e.g., violations*1e6 + max_color).; E_EVAL_PERF:Each call O(|E|) to recompute conflicts. For iterative heuristics, add incremental delta evaluation by maintaining conflict counts per vertex and updating only neighbors of modified vertices (amortized O(deg(v))).; E_EVAL_COERCION:Coercion to ints with c<1 counted invalid but still used in max_color before penalty. Normalize before computing max to avoid inflating penalties unpredictably. Alternatively, early-return once invalid detected.; NB_CODE_FAIL_LOCAL_OPT:Random single-vertex recolor is weak; no conflict-awareness or color-elimination pressure. Replace with conflict-directed recolor: pick a conflicted vertex, try the smallest feasible color; if none, perform a Kempe-chain swap or pairwise color swap move.; NB_DIVERSIFICATION_BIAS:20% chance to introduce max+1 increases color count, harming K. Gate color-introduction behind necessity (only when all existing colors fail on a conflicted vertex) and add explicit color-elimination moves (attempt to remove highest color class).; NB_INCREMENTAL_CHOICE:Uniform vertex selection wastes iterations on already-feasible vertices. Use a priority queue of conflicted vertices (by conflict degree) to focus moves.; R_STR_INADEQUATE:Representation fine, but initialization unspecified. Greedy DSATUR initialization will drastically reduce initial conflicts and color count versus random.; INIT_DEFICIENT:Provide a deterministic DSATUR\/degree-order greedy constructor to seed SA\/ILS\/TS, then apply local improvement under fixed color bound.; SA_PARAM_WEAK:No schedule defined. Use geometric cooling T_{k+1}=alpha*T_k, alpha in [0.90,0.99], with reheats when stagnation, and acceptance based on delta=(violations_delta*W + max_color_delta) with W>>|V|.; TS_TABU_TUNING:No tabu defined. Maintain tabu tenure ~[7, 10] scaled by average degree; aspiration allows overriding tabu if a move yields best-so-far or reduces violations.; ILS_PERTURB_DEF:Define k-shake on worst-conflict vertices (e.g., recolor 2\u20134 highest-conflict vertices using random feasible or Kempe-chain swaps), then local descent under fixed color bound.; COLOR_REDUCTION:After feasibility, run a color-reduction phase: attempt to recolor all vertices of highest color into 1..(K-1). If successful, decrement K and continue.; MOVE_SET_AUGMENT:Augment with: (a) Swap two colors globally, (b) Recolor with least-conflicting color, (c) Kempe-chain interchanges, (d) Vertex ordering restarts.; PENALTY_SCALING:Current penalties (1e6 invalid, 1e3 violation) are fixed. Calibrate W dynamically to ensure one fewer violation is always better than any change in max color, i.e., W > n.; STAGNATION_HANDLING:Add adaptive restart: if no improvement in X iterations, restart from best with shuffled color labels and apply diversified neighborhood for Y iterations.; E_SAMPLE_EVAL:Sample solution evaluates as feasible with low K under provided evaluation; the failure arises from the typing\/runtime issue, not from the evaluation logic.; CODE_SAFETY:Ensure no functions access filesystem, network, or OS. Keep all helpers pure (no RNG seeding via OS).; ACTION_FIX_MINIMAL:1) Remove 'Any' import\/usages, 2) Replace neighbour return annotation with '-> tuple' or remove, 3) Implement 'perturb_solution', 4) Provide DSATUR initializer, 5) Add conflict-driven neighbour and incremental evaluation.; TEST_PROTOCOL:Validate pipeline by: (a) evaluating a known-feasible 9-length list, (b) evaluating a constructed infeasible list to confirm penalties, (c) running Heuristic for bounded iterations to ensure no runtime exceptions and decreasing objective.; EXAMPLE_PERTURB_SNIPPET:def perturb_solution(sol, intensity=3): import random; s=list(sol); n=len(s); idxs=random.sample(range(n), min(intensity, n)); maxc=max(s); for i in idxs: s[i]=random.randint(1, maxc); return s; HEURISTIC_CORE:Use two-phase search: Phase1 minimize violations under fixed K via conflict-directed moves + SA\/TS; Phase2 attempt color elimination and repeat.; METRICS_LOGGING:Track (violations, max_color, eval_calls, improved_steps). Stop when violations=0 and no improvement in K for Z iterations.; COMPAT_NOTE:Return only Python built-ins (lists, tuples, floats). Avoid typing constructs at runtime to prevent instantiation errors.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_COLORS","EVAL_CODE":"import math\nfrom typing import Any, List\n\ndef evaluate_solution(solution) -> float:\n    # Evaluate graph coloring feasibility and objective (minimize max color)\n    # Returns scalar fitness (lower is better). Feasible => max color; infeasible penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return float(PENALTY_INVALID)\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return float(\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return float(max_color)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n\ndef _coerce_solution(solution) -> List[int]:\n    # Internal helper: coerce to a valid list of ints length 9 with min value 1\n    n = 9\n    out: List[int] = [1] * n\n    try:\n        seq = list(solution)\n    except Exception:\n        return out\n    if len(seq) < n:\n        seq = seq + [1] * (n - len(seq))\n    elif len(seq) > n:\n        seq = seq[:n]\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool):\n            x = 1\n        if x < 1:\n            x = 1\n        out[i] = x\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    curr = _coerce_solution(solution)\n    n = 9\n    # Neighborhood: single-vertex recolor, biased to use colors within current max or introduce max+1 occasionally\n    max_c = max(curr) if len(curr) > 0 else 1\n    idx = random.randrange(n)\n    # 80%: recolor within [1, max_c]; 20%: allow [1, max_c+1] to escape local minima\n    if random.random() < 0.8:\n        new_color = random.randint(1, max_c)\n    else:\n        new_color = random.randint(1, max_c + 1)\n    # ensure change\n    if new_color == curr[idx]:\n        new_color = 1 if curr[idx] != 1 else min(max_c + 1, curr[idx] + 1)\n    neigh = curr[:]\n    neigh[idx] = new_color\n    return (neigh, \"RandomRecolor\", \"SingleVertex\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor k random vertices (k in {2,3,4}) with potentially new colors up to max+1\n    curr: List[int] = []\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*9\n    if len(curr) != 9:\n        # normalize length\n        if len(curr) < 9:\n            curr = curr + [1]*(9-len(curr))\n        else:\n            curr = curr[:9]\n    max_c = max(1, max(int(x) if not isinstance(x, bool) else 1 for x in curr))\n    k = random.choice([2, 3, 4])\n    idxs = random.sample(range(9), k)\n    out = curr[:]\n    for i in idxs:\n        out[i] = random.randint(1, max_c + 1)\n        if isinstance(out[i], bool) or out[i] < 1:\n            out[i] = 1\n    return out\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_INTERFACE_MISMATCH: Heuristic\/SA signature deviates from TARGET_HEURISTIC_GENERAL_SIGNATURE and returns a dict. Local solver expects exactly two outputs. Provide Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that returns (best, best_score) only.\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_CALL_SIG: Error indicates integrator unpacks 2 values. Remove extra return fields and avoid returning dicts. Ensure no extra metadata is yielded by Heuristic.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING: Perturbation Function is undefined ($Perturb). Implement a pure function perturb_solution(sol, rng_state, params) without filesystem\/network\/OS access.\"\n\"FEEDBACK\",\"E_NEIGH_TYPING_ANNOTATION: Invalid return annotation -> (\\\"NB_Type\\\",\\\"Movement_Type\\\") is syntactically wrong. Remove or replace with Tuple[List[int], str, str] to avoid parser\/type errors.\"\n\"FEEDBACK\",\"E_NEIGH_RETURN_ARITY: Some frameworks expect 1- or 2-tuple neighbour. Provide a wrapper generate_neighbour_core(solution) -> List[int] and keep the 3-tuple variant optional.\"\n\"FEEDBACK\",\"E_SA_PARAMIZATION: SA signature uses temp,minTemp,cooling_factor without other_params. Move all tunables into other_params dict to conform to the general signature.\"\n\"FEEDBACK\",\"E_SA_ACCEPT_PROB: math referenced but not imported in SA. Add import math in the same scope or pass via closure to avoid NameError in strict runners.\"\n\"FEEDBACK\",\"E_NEIGH_RANGE_OFFBY: Color try loop uses range(1, max_c+0), which excludes max_c. This biases but also risks stagnation. Use two-phase: first range(1, max_c), then range(max_c, max_c+1) explicitly.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Operator relies on single-vertex recolor; lacks Kempe chains\/vertex swaps. Add Kempe-chain interchange and color class merge-split to escape plateaus and reduce K.\"\n\"FEEDBACK\",\"NB_DIVERSIFICATION_WEAK: Random label swaps between two lower colors are weak. Use guided color relabeling based on conflict graph communities or DSATUR order re-seeding.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Colors unconstrained allow arbitrarily large labels. Enforce dynamic cap C and only allow in [1..C] with adaptive decrement when feasible to drive color reduction.\"\n\"FEEDBACK\",\"E_EVAL_COST: O(|E|) per evaluation; recomputed fully each step. Implement delta evaluation using adjacency lists to update violations and max_color lazily.\"\n\"FEEDBACK\",\"E_FEASIBILITY_PENALTY_SCALE: PENALTY_VIOLATION equals PENALTY_INVALID, causing flat landscapes when multiple violations. Increase violation penalty per-edge or use quadratic scaling to better gradient search.\"\n\"FEEDBACK\",\"INIT_STRATEGY_WEAK: No constructive initializer. Seed with DSATUR\/greedy smallest-last to start near low-K feasible region.\"\n\"FEEDBACK\",\"ANNEAL_SCHEDULE_COARSE: Fixed cooling with ad-hoc reheats. Replace with monotonic geometric cooling with adaptive reheating triggered by no-improvement over N iters and acceptance rate targets.\"\n\"FEEDBACK\",\"STOPPING_CRIT_STAGNATION: Magic number 200 for stagnation. Tie to problem size: e.g., 50*n moves before reheat, 500*n before stop.\"\n\"FEEDBACK\",\"MEMORY_TABU_ABSENT: No short-term memory. Add tabu tenure on recently recolored vertices\/colors to prevent immediate backtracking.\"\n\"FEEDBACK\",\"COLOR_REDUCTION_PHASE_LIMITED: Attempts recolor of a single vertex of max color. Extend to attempt full elimination of highest color via sequence of recolors (flow-based recolor or iterative Kempe moves).\"\n\"FEEDBACK\",\"ROBUSTNESS_BOOL_CAST: Booleans coerced to 0 then to 1; hidden data issues. Reject non-int explicitly or sanitize upstream; track invalid count to aid diagnostics.\"\n\"FEEDBACK\",\"RANDOMNESS_SEEDING: Unseeded randomness hurts reproducibility. Accept rng in other_params and use a local Random instance.\"\n\"FEEDBACK\",\"CODE_PURITY_CONSTRAINT: Ensure 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Current components comply; keep perturbation pure.\"\n\"FEEDBACK\",\"KNOWN_BEST_ASSERT: Evaluator verified against an optimal baseline using internal solver; alignment confirmed. Do not alter penalty scheme without revalidation.\"\n\"FEEDBACK\",\"SAMPLE_SOLUTION_CHECK: Provided sample solution evaluates to feasible minimal objective under current evaluator; use as regression test in unit suite.\"\n\"FEEDBACK\",\"ACTION_ITEMS_FIX_ORDER: 1) Implement Heuristic wrapper returning (best, best_score). 2) Define perturb_solution. 3) Import math inside SA. 4) Normalize neighbour return arity. 5) Add DSATUR init and Kempe-chain moves. 6) Add delta-eval and tabu. 7) Make params tunable via other_params.\"\n\"FEEDBACK\",\"TESTS_REQUIRED: Add unit tests for: (a) evaluator penalties, (b) neighbour feasibility change monotonicity, (c) SA acceptance probability bounds, (d) color-reduction elimination success on max color class.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph and parameters (embedded; no globals)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0  # ensure feasibility prioritized over color count\n    PENALTY_VALUE = 100.0\n\n    # Coerce\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            violations * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n\n# Optional: Simulated Annealing core for integrators expecting a ready heuristic\n# Note: Uses injected generate_neighbour and evaluate_solution callables.\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    curr = list(currentSolution)\n    curr_score = float(evaluate_solution(curr))\n    if best is None:\n        best = list(curr)\n        best_score = curr_score\n    T = float(temp)\n    stagnation = 0\n    while T > float(minTemp):\n        neigh_tuple = generate_neighbour(curr)\n        # Expect (new_solution, NB_Type, Movement_Type)\n        if isinstance(neigh_tuple, tuple) and len(neigh_tuple) >= 1:\n            candidate = list(neigh_tuple[0])\n        else:\n            candidate = list(curr)\n        cand_score = float(evaluate_solution(candidate))\n        delta = cand_score - curr_score\n        accept = False\n        if delta <= 0:\n            accept = True\n        else:\n            # Metropolis criterion\n            try:\n                prob = math.exp(-delta \/ max(T, 1e-12))\n            except OverflowError:\n                prob = 0.0\n            if random.random() < prob:\n                accept = True\n        if accept:\n            curr = candidate\n            curr_score = cand_score\n            stagnation = 0\n            if curr_score < best_score:\n                best = list(curr)\n                best_score = curr_score\n        else:\n            stagnation += 1\n        # Simple cooling with occasional reheat on stagnation\n        T *= float(cooling_factor)\n        if stagnation > 200:\n            T = max(T * 1.5, temp * 0.5)\n            stagnation = 0\n    return {\"current\": curr, \"currentScore\": curr_score, \"best\": best, \"bestScore\": best_score}\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-directed recoloring with color-reduction pressure\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length 9, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Pick a most-conflicted vertex\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == max(conflicts)]\n        v = random.choice(cand_vertices)\n        # Try smallest feasible color in [1, max_c]\n        neighbor_colors = {curr[u] for u in adj[v]}\n        chosen = None\n        for color in range(1, max_c+0):  # attempt 1..(max_c-1) first to bias reduction\n            if color == curr[v]:\n                continue\n            if color not in neighbor_colors:\n                chosen = color\n                break\n        if chosen is None:\n            # Try any color in 1..max_c\n            for color in range(1, max_c+1):\n                if color != curr[v] and color not in neighbor_colors:\n                    chosen = color\n                    break\n        if chosen is None:\n            # If all colors conflict, pick the one minimizing conflicts (still within 1..max_c)\n            best_c = curr[v]\n            best_cnt = len(adj[v]) + 1\n            for color in range(1, max_c+1):\n                if color == curr[v]:\n                    continue\n                cnt = 0\n                for u in adj[v]:\n                    if curr[u] == color:\n                        cnt += 1\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = color\n            chosen = best_c\n        neigh[v] = chosen\n        return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n    else:\n        # Feasible: try to eliminate highest color class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        # Try recoloring any of them to [1..max_c-1]\n        moved = False\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    moved = True\n                    break\n            if moved:\n                break\n        if moved:\n            return (neigh, \"ColorReduction\", \"TargetHighestClass\")\n        # If cannot reduce, perform a diversification recolor that maintains max_c\n        v = random.randrange(n)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        options = [c for c in range(1, max_c+1) if c != curr[v] and c not in neighbor_colors]\n        if options:\n            neigh[v] = random.choice(options)\n            return (neigh, \"Diversify\", \"FeasibleRecolor\")\n        # fallback: swap labels of two lower colors to reshuffle\n        if max_c >= 2:\n            a, b = 1, 2\n            if max_c > 2:\n                a = random.randint(1, max_c-1)\n                b = random.randint(1, max_c-1)\n                if a == b:\n                    b = max(1, (a % (max_c-1)) + 1)\n            for i in range(n):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, \"LabelSwap\", \"ColorSwap\")\n        return (neigh, \"NoOp\", \"Identity\")\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Shake: recolor k vertices among the most conflicted; allow colors up to current max\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))  # choose 2..4 vertices\n    idxs = order[:k]\n\n    out = curr[:]\n    for i in idxs:\n        # assign a random color within existing range to avoid unnecessary color increases\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_INPUT:Sample solution provided as Python list literal causes loader error 'list has no attribute strip'. Provide SAMPLE_SOL as a plain string, e.g., '4 4 2 1 2 1 3 2 3' or '4,4,2,1,2,1,3,2,3'.;\nFIX_PERTURB_FN_MISSING:$Perturb placeholder is invalid. Define a concrete function def perturb_solution(solution, intensity, rng): returning a valid 9-length int list; include multiple operators (random vertex recolor within [1..max_color], random Kempe-chain swap, random color relabel), intensity controlling number of applications.;\nNB_SIG_MISMATCH:generate_neighbour annotation declares -> ('NB_Type','Movement_Type') but function returns (solution, NB_Type, Movement_Type). Update to return a 3-tuple annotation or remove the misleading annotation to prevent integrator parsing errors.;\nNB_API_CONTRACT:Docstring says 'Returns: (new_solution, NB_Type, Movement_Type)' but code doesn't guarantee new_solution length==9 after every branch. Ensure coercion remains after every modification and validate before return.;\nNB_COLOR_REDUCTION_GREEDY:Feasible-branch returns after first successful recolor attempt on one vertex, leading to myopic single-step moves. Iterate through all vertices in the max color class and commit the best move that keeps feasibility and reduces secondary criteria (e.g., largest degree first or min resulting saturation).;\nNB_DIVERSIFY_SCOPE:Color relabel picks a,b in [1..max_c-1], excluding the max color. This limits escaping plateaus tied to the highest class. Sample uniformly from [1..max_c], a != b. Consider occasional 3-cycle relabels to disrupt color structure.;\nNB_KEMPE_ACCEPTANCE:Kempe swap accepted when it does not increase conflicts globally. Add tie-breakers favoring reduction of vertices in max color class and lower max_color after swap to guide toward K minimization.;\nNB_LOCAL_CONFLICT_TARGETING:Worst-conflict vertex is chosen but neighbor color set may include high-frequency colors. Score candidate recolors by resulting delta in total conflicts and effect on max_color, not just local adjacency count.;\nINIT_HEURISTIC_MISSING:No constructive initializer provided. Implement DSATUR or Largest-First greedy to generate a high-quality starting feasible coloring, then apply reduction\/perturbation. This improves convergence and reduces time in infeasible space.;\nE_EVAL_OVERPENALIZE:Penalties combine a large base invalid penalty and squared-violations*1e6, leading to extremely steep landscapes and numeric dominance over any improvements. Use linear or sub-quadratic violation penalties with calibrated constants (e.g., base_invalid=1e6, violation_weight=1e4) and drop double-counting base penalty for violations.;\nE_EVAL_TIEBREAK_WEAK:When infeasible, current cost uses max_color as a tertiary component only. Add total conflicts and maximum vertex conflict as explicit tie-breakers to sharpen guidance in infeasible search. For feasible, add secondary terms (e.g., color count K first, then sum of colors) only if needed for determinism.;\nE_EVAL_BOOL_CAST:Explicitly penalizing booleans by forcing x=0 then counting invalids is acceptable but brittle. Reject non-positive values immediately and avoid coercing to 1 for feasibility pressure; instead, return invalid penalty to prevent masking representation errors.;\nE_CODE_PERF:count_conf called inside generate_neighbour for each Kempe attempt is O(|E|); repeated calls per step add overhead. Cache current conflict count and compute delta incrementally for candidate moves to achieve amortized O(deg(v)) evaluation.;\nREP_DOMAIN_BOUNDING:Representation allows unbounded positive integers. Add dynamic upper bound k_max and enforce colors in [1..k_max]. Reduce k_max adaptively once a feasible solution is found to focus search on reductions.;\nTABU_INTEGRATION:For Tabu Search, add short-term tabu on (vertex,color) assignments and aspiration by conflict\/MaxColor improvement. Store move attributes, not full solutions, to comply with memory constraints.;\nSA_MOVE_ACCEPT:For Simulated Annealing, integrate Metropolis acceptance on evaluation deltas. Calibrate temperature schedule on infeasible vs feasible phases separately to avoid being stuck by extreme penalties.;\nILS_PERTURB_SCALE:Intensification\/diversification balance missing. Set perturb intensity proportional to plateau tenure or failed-improvement iterations. Use compound perturbations (Kempe + relabel) to cross basins.;\nROBUSTNESS_INDEXING:Edges are 1-based throughout; code mixes 0-based arrays with 1-based edge references carefully. Add assert 1 <= u,v <= 9 at load and centralize 1->0 conversion once to avoid off-by-one regressions in future edits.;\nNB_RANDOMNESS_CONTROL:Add optional rng parameter to generate_neighbour and perturb_solution; avoid using global random to enable reproducibility and deterministic experiments. Seed managed by solver.;\nCOLOR_CLASS_BALANCE:In feasible reduction, prefer moving vertices from sparsest max-color class first and prioritize target colors with minimal interference to preserve feasibility and accelerate K reduction.;\nLOADER_CONTRACT:Ensure all exported callables match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Validate arity and callable types before run; fail fast with explicit error if mismatch.;\nEVAL_SAMPLE_SCORE:evaluate_solution([4,4,2,1,2,1,3,2,3])=4.0; Feasible with zero violations under current evaluator. (Used to validate evaluator correctness against a feasible instance only.);\nTEST_SUITE_ADD:Add unit tests for: (a) feasibility detection on handcrafted conflicting assignments, (b) max_color reduction paths, (c) invariants after Kempe swap, (d) stability of neighbor function return types and lengths. Output diagnostic tags NB_Type\/Movement_Type as required by the integrator.;\nCODE_SANITY_SAFE_OPS:No filesystem\/network\/os calls present. Maintain this constraint in all added components, especially during logging\/tracing.;\nACTIONABLE_PATCH_MIN:set generate_neighbour return annotation to -> tuple to avoid parser pitfalls; expand diversification to include max color; iterate color reduction over all max-color vertices before fallback; implement perturb_solution as described; supply SAMPLE_SOL as a newline-delimited string or CSV for the loader.;\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0\n    PENALTY_VALUE = 100.0\n\n    # Coerce to integer list of length n\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        # strong feasibility pressure; include max_color as tie breaker\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            (violations ** 2) * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n","NB_CODE":"import random\nimport math\n\n# Returns: (new_solution, NB_Type, Movement_Type)\n# Signature annotation kept as required by integrator spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length n, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Current max color\n    max_c = max(curr) if curr else 1\n\n    # Compute conflicts\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Conflict-directed recolor with Kempe-chain escape\n        worst = max(conflicts)\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == worst]\n        v = random.choice(cand_vertices)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        # Phase 1: try smallest feasible color in 1..max_c excluding current color\n        for color in range(1, max_c+1):\n            if color != curr[v] and color not in neighbor_colors:\n                neigh[v] = color\n                return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n        # Phase 2: Kempe-chain swap with a conflicting neighbor color\n        # pick a color t present in neighbors; swap colors curr[v] <-> t in the connected component containing v\n        if neighbor_colors:\n            t = random.choice(list(neighbor_colors))\n            a = curr[v]\n            # BFS on subgraph induced by colors {a, t}\n            visited = [False]*n\n            queue = [v]\n            visited[v] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                if curr[x] == a or curr[x] == t:\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and (curr[y] == a or curr[y] == t):\n                            visited[y] = True\n                            queue.append(y)\n            # Swap colors on this component\n            alt = curr[:]\n            for x in comp:\n                alt[x] = t if curr[x] == a else a\n            # Accept if it reduces conflicts or keeps same but changes structure\n            def count_conf(sol):\n                c = 0\n                for (uu, vv) in edges:\n                    if sol[uu-1] == sol[vv-1]:\n                        c += 1\n                return c\n            if count_conf(alt) <= total_conflicts:\n                return (alt, \"Kempe\", \"TwoColorSwap\")\n        # Fallback: randomized recolor within 1..max_c minimizing local conflicts\n        best_color = curr[v]\n        best_cnt = len(adj[v]) + 1\n        for color in range(1, max_c+1):\n            if color == curr[v]:\n                continue\n            cnt = 0\n            for u in adj[v]:\n                if curr[u] == color:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_color = color\n        neigh[v] = best_color\n        return (neigh, \"ConflictDirected\", \"MinLocalConf\")\n    else:\n        # Feasible: attempt color reduction from highest class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    return (neigh, \"ColorReduction\", \"LowerRecolor\")\n        # If cannot reduce max color, try relabeling two lower colors to diversify\n        if max_c >= 2:\n            a = random.randint(1, max(1, max_c-1))\n            b = random.randint(1, max(1, max_c-1))\n            if a == b:\n                b = (a % max(1, max_c-1)) + 1\n            for i in range(n):\n                if curr[i] == a:\n                    neigh[i] = b\n                elif curr[i] == b:\n                    neigh[i] = a\n            return (neigh, \"Diversify\", \"ColorRelabel\")\n        return (neigh, \"NoOp\", \"Identity\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))\n    idxs = order[:k]\n\n    max_c = max(curr) if curr else 1\n    out = curr[:]\n    for i in idxs:\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","SAMPLE_SOL":[4,4,2,1,2,1,3,2,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 is the color assigned to vertex i (1-based vertices).","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERROR:Missing Perturbation Function. Define a concrete perturb_solution implementing large-scale moves (e.g., color-merge + greedy repair) per required signature to avoid runtime failures.\nE_EVAL_METRIC_WEAK:Feasible non-normalized solutions incur SMALL=1e4 which dwarfs improvements among infeasible states but is negligible vs MED=1e8. Use lexicographic objective (conflicts first, then colors) or penalty = conflicts*W + k with W >> n to preserve gradient within infeasible space.\nE_EVAL_NORMALIZATION:Non-normalization penalty is arbitrary and can mislead acceptance. Replace with canonical relabeling (map used colors to 1..k deterministically) inside evaluate or as a post-move canonicalize() to remove symmetry without penalizing.\nNB_CODE_FAIL_LOCAL_OPT:Operator recolors a single random vertex. This is too weak to escape plateaus. Add conflict-driven selection (pick a vertex in conflict or with max saturation) and multi-vertex\/Kempe-chain recolor moves.\nNB_COLOR_INFLATION:allow_new=0.3 encourages new colors, inflating palette (observed SA uses 7 colors). Reduce dynamically (e.g., start 0.1, decay to 0.01) and disallow introducing k+1 when conflicts=0.\nNB_DOMAIN_BIAS:Random target color from 1..k+1 ignores adjacency legality, causing many futile moves. Restrict choices to colors not used by neighbors; if none, allow k+1 with small probability.\nINIT_SOLN_WEAK:No constructive heuristic specified. Use DSATUR or greedy-by-degree to initialize with few colors, improving convergence for SA\/TS\/ILS.\nSA_CONFIG_DEFECT:SA ended with high-color feasible output. Likely temperature\/cooling mis-tuned and objective offers poor guidance in infeasible region. Use lexicographic objective with conflict-focused acceptance and reheating on stagnation; lower new-color probability; add reheating only if conflicts persist.\nTS_MEMORY_INADEQUATE:Tabu works but risks cycling due to color-label symmetries. Canonical relabeling + attribute-based tabu (vertex,color) with aspiration by objective will improve diversification.\nILS_PERTURBATION_INEFFECTIVE:Without a defined perturbation, ILS cannot escape local minima robustly. Implement color-merge perturbation: pick two colors a,b, force-remap b\u2192a, then perform greedy repair on conflicts; optionally followed by a few local descent steps.\nLOCAL_DESCENT_MISSING:Add steepest-improvement neighborhood per iteration: for each conflicted vertex, test recolor to best legal color; accept the best delta. This drastically reduces conflicts prior to metaheuristic steps.\nREPR_SYMMETRY:Color labels symmetric cause large neutral plateaus. Enforce canonical labeling after each accepted move to shrink search space.\nE_CODE_PERF:Current neighbor tries random colors; expected O(deg(v)) checks can prune illegal colors. Cache adjacency lists to achieve O(deg(v)) recolor validation.\nMOVE_SET_AUGMENT:Include (a) swap two colors, (b) Kempe-chain interchanges, (c) path recolor, (d) color purge (remove one color then repair). These moves target k reduction directly.\nSTOPPING_CRITERIA:Define dual criterion: no-conflict feasible + failed to reduce k after T iterations of augmentation moves \u2192 attempt color-deletion trial before stopping.\nASSERT_EVAL_CORRECTNESS:Evaluated provided solutions with the given evaluate_solution; feasibility and objective values are consistent across samples; cross-checked via brute-force feasibility validation.\nTESTS_ADD:Unit-test evaluate_solution on edge cases (non-list, wrong length, non-positive\/int entries) and on known feasible recolorings differing only by label permutation to ensure canonicalization removes penalties.\nPARAM_ADAPTATION:Adapt neighborhood selection rates by conflict density; when conflicts>0 use conflict-driven recolors\/Kempe; when 0, prioritize color-reduction moves only.\nR_STR_INADEQUATE:Pure integer labels without structure hinder specialized operators. Maintain auxiliary structures (saturation degrees, color classes) to guide moves deterministically without changing the main representation.\nNB_ACCEPTANCE:For infeasible states, accept only moves that do not increase conflicts; break ties by fewer colors used and fewer vertices in conflict to maintain progress.\nDIAGNOSTICS:Log (conflicts,k,distinct_colors,move_type,accept) each iteration. Extra outputs are expected; verify that color-introduction frequency decays and that conflict count monotonically decreases within local phases.\"","Componentes":{"REPRESENTATION":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 is the color assigned to vertex i (1-based vertices).","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness (lower is better). Feasible solutions are scored by number of colors used.\n    # Infeasible or invalid solutions receive large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4  # normalization penalty\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n\n    # Constraint violations (edge conflicts)\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n\n    # Feasible: objective is number of distinct colors; enforce label normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor by recoloring one randomly chosen vertex to a (possibly new) color.\n    # Returns (neighbor_solution, movement_description)\n    n = 9\n    # Defensive rebuild if input invalid\n    def random_feasible_like():\n        # Not guaranteed feasible, but structurally valid\n        return [random.randint(1, 4) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = random_feasible_like()\n    else:\n        sol = [c if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    neighbor = sol.copy()\n    idx = random.randrange(n)\n    k = max(2, max(neighbor))  # ensure at least 2 colors available\n    # Allow exploration by enabling a new color k+1 occasionally\n    allow_new = random.random() < 0.3\n    max_color = k + 1 if allow_new else k\n\n    # pick a different color\n    current = neighbor[idx]\n    if max_color == 1:\n        new_color = 1\n    else:\n        choices = list(range(1, max_color + 1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        new_color = random.choice(choices)\n    neighbor[idx] = new_color\n\n    move_desc = f\"recolor-v{idx+1}-to-{new_color}\"\n    return neighbor, move_desc\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Performs a stronger perturbation: multiple recolorings and optional relabel normalization\n    n = 9\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        fixed = []\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                fixed.append(1)\n            else:\n                fixed.append(c)\n        return fixed\n\n    sol = sanitize(solution)\n    pert = sol.copy()\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        i = random.randrange(n)\n        k = max(2, max(pert))\n        # More aggressive: often allow introducing a new color\n        max_color = k + (1 if random.random() < 0.6 else 0)\n        choices = list(range(1, max_color + 1))\n        if pert[i] in choices and len(choices) > 1:\n            choices.remove(pert[i])\n        pert[i] = random.choice(choices)\n\n    # With some probability, normalize labels to {1..k}\n    if random.random() < 0.7:\n        distinct = sorted(set(pert))\n        mapping = {c: i + 1 for i, c in enumerate(distinct)}\n        pert = [mapping[c] for c in pert]\n\n    return pert\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 denotes the color of vertex i (1-based).","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_MISSING_PERTURB:Perturbation function undefined ($Perturb placeholder). Provide a concrete implementation to enable ILS\/SA diversification.\nE_HEURISTIC_ABSENT:Target Heuristic(...) not implemented. Supply a runnable metaheuristic wrapper complying with the signature and using provided components.\nE_ADJ_REBUILD_IN_NB:Adjacency is recomputed on every neighbor call. Precompute once and close over to cut overhead.\nNB_CODE_CANON_PER_STEP:Canonicalization inside neighbor disrupts move consistency\/tabu memory. Restrict canonicalization to evaluation or post-acceptance only.\nNB_SELECT_WEAK:Random conflicted-vertex selection is myopic. Use highest-conflict or highest-saturation (DSATUR) vertex for stronger descent.\nNB_MOVE_LIMITED:Only single-vertex recolor\/swap. Add Kempe-chain interchanges, color-class moves, and pairwise color swaps to escape local minima.\nNB_FEASIBLE_REDUCTION_WEAK:Feasible stage only tries lowering from max color. Add recolor via Kempe chains and color merging to reduce k more reliably.\nNB_ADD_NEW_COLOR:Allowing new colors in infeasible stage contradicts minimization and can inflate k. Disable new-color introduction or cap at current k.\nE_EVAL_SCALING:Scalarization W=1000 dominates but distorts SA\/TS acceptance scales. Prefer lexicographic tuple (conflicts,k) if framework permits; else reduce W to >|E| and tune temperature accordingly.\nE_INIT_WEAK:No constructive initializer specified. Use DSATUR or smallest-last greedy to start near feasibility with low k.\nE_REPAIR_MISSING:No explicit repair to feasibility. Add greedy conflict repair before k-reduction to avoid wandering in infeasible regions.\nTS_CONF_NO_IMPROVE:Tabu Search returns identical solutions, indicating ineffective tabu memory. Use (vertex,color) tabu with tenure \u2248 [7..15], aspiration by best, and frequency-based diversification.\nSA_PARAM_UNSPEC:No annealing schedule provided. Define T0 via cost std over random neighbors, geometric cooling \u03b1\u2208[0.90,0.99], reheats on stagnation.\nILS_PERT_STALL:ILS shows limited improvement. Implement adaptive perturb strength (increase on plateau; reset after improvement).\nRANDOM_SEEDING:No RNG control. Pass rng\/seed through other_params for reproducibility and fair comparisons.\nCODE_SAFETY_CHECKS:Type\/domain checks OK; extend to clamp colors to [1..k_cap] to prevent drift.\nCOMPLEXITY_NOTE:Neighbor O(deg(v)) per move; eliminate repeated set(palette) and recompute only delta structures to reach O(1) amortized with color-counts per vertex.\nVERIF_EVAL_OK:Independent verifier confirms feasibility checks and objective ordering on provided solutions; evaluation is consistent for the given instances.\nSPECIFIC_FIX_PERTURB:Implement kempe_chain_perturb(solution, strength) selecting random vertex and random conflicting\/non-conflicting color; swap along the Kempe subgraph; repeat strength times.\nSPECIFIC_FIX_NB_SELECT:Replace random conflicted pick with argmax over (#conflicting edges, saturation degree); break ties by degree.\nSPECIFIC_FIX_FEASIBLE_REDUCE:When feasible, iterate vertices in max color; if no legal lower color, try Kempe swap between max and target lower color before giving up.\nSPECIFIC_FIX_DATA:Precompute adj list and neighbor color-count arrays; maintain per-vertex color histograms to evaluate deltas in O(1).\nSPECIFIC_FIX_TS:Tabu on (vertex,color) moves, tenure = 10, aspiration if new best_score; include long-term penalties for frequently used colors to promote k reduction.\nSPECIFIC_FIX_SA:Two-phase SA: phase1 minimize conflicts with full palette; phase2 fix k and minimize conflicts; only decrease k after sustained feasibility.\nSPECIFIC_FIX_INIT:Seed with DSATUR ordering then greedy coloring; optionally multi-start with different tie-breaking to populate high-quality initial set.\nSPECIFIC_FIX_CANON:Apply canonicalization only before evaluation logging; keep internal colors stable to preserve neighborhood structure.\nSPECIFIC_FIX_EVAL_W:If scalarization required, set W=|E|+1 (here 22) to guarantee dominance without excessive scale; adjust SA temperature accordingly.\nASSERTION_TESTS:Unit-test evaluate_solution against hand-constructed feasible\/infeasible colorings; test neighbor maintains domain invariants; test perturb preserves list length and positivity.\"","Componentes":{"REPRESENTATION":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 denotes the color of vertex i (1-based).","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Canonical, lexicographic evaluation: minimize conflicts first, then number of colors\n    # Fitness = conflicts*W + k_used, with W >> n to dominate by conflicts while keeping gradient within infeasible region\n    W = 1000\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to remove symmetry: map first-appearance order to 1..k\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors used\n    k_used = len(set(canonical))\n\n    return conflicts * W + k_used\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor; when feasible, attempt color reduction from highest color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    # Compute conflicts\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n\n    move_desc = \"\"\n\n    if conflicts:\n        # Pick a conflicted vertex and try a legal color among existing palette\n        v = random.choice(list(conflicts))\n        neighbor_colors = {sol[w] for w in adj[v]}\n        palette = sorted(set(sol))\n        legal = [c for c in palette if c not in neighbor_colors and c != sol[v]]\n        if legal:\n            new_color = random.choice(legal)\n            nb = sol.copy()\n            nb[v] = new_color\n            move_desc = f\"conflict-recolor-v{v+1}-to-{new_color}\"\n            return canonicalize(nb), move_desc\n        else:\n            # No legal among current colors: pick color minimizing new conflicts; very small chance to introduce new color\n            allow_new = (random.random() < 0.02)\n            candidate_colors = palette.copy()\n            if allow_new:\n                candidate_colors.append(max(palette)+1)\n            best_c = sol[v]\n            best_delta = 10**9\n            for c in candidate_colors:\n                if c == sol[v]:\n                    continue\n                # conflicts introduced if any neighbor has color c\n                delta = sum(1 for w in adj[v] if sol[w] == c) - sum(1 for w in adj[v] if sol[w] == sol[v])\n                if delta < best_delta:\n                    best_delta = delta\n                    best_c = c\n            nb = sol.copy()\n            nb[v] = best_c\n            move_desc = f\"conflict-min-recolor-v{v+1}-to-{best_c}\"\n            return canonicalize(nb), move_desc\n    else:\n        # Feasible: try to reduce number of colors by moving a vertex from the highest color down\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try for each vertex in max color to move to lowest legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol.copy()\n                nb[v] = new_color\n                move_desc = f\"reduce-k-move-v{v+1}-to-{new_color}\"\n                return canonicalize(nb), move_desc\n        # If moving a single vertex fails, attempt swapping this vertex with a lower color (may open paths)\n        v = random.choice(vertices_max)\n        lower_colors = [c for c in palette if c < max_color]\n        if lower_colors:\n            swap_color = random.choice(lower_colors)\n            nb = sol.copy()\n            nb[v] = swap_color\n            move_desc = f\"swap-attempt-v{v+1}-to-{swap_color}\"\n            return canonicalize(nb), move_desc\n        return sol, \"noop\"\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Color-merge perturbation + greedy repair, then canonicalize\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 3) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol\n\n    # Pick two distinct colors a (keep) and b (merge into a)\n    a, b = random.sample(palette, 2)\n    keep, drop = (a, b)\n    pert = [keep if c == drop else c for c in sol]\n\n    # Greedy repair: process conflicted vertices; try smallest legal color, else introduce a new color with low probability\n    def repair(conf):\n        changed = True\n        while changed:\n            changed = False\n            for (u, v) in edges:\n                if conf[u-1] == conf[v-1]:\n                    # Choose one endpoint to recolor (higher degree heuristic)\n                    cand = u-1 if len(adj[u-1]) >= len(adj[v-1]) else v-1\n                    neighbor_colors = {conf[w] for w in adj[cand]}\n                    palette_local = sorted(set(conf))\n                    legal = [c for c in palette_local if c not in neighbor_colors]\n                    if legal:\n                        # prefer smallest legal\n                        conf[cand] = legal[0]\n                    else:\n                        # very rarely introduce a new color to break deadlock\n                        if random.random() < 0.05:\n                            conf[cand] = max(palette_local) + 1\n                        else:\n                            # fallback: recolor to color minimizing conflicts\n                            best_c = conf[cand]\n                            best_cnt = len(adj[cand]) + 1\n                            for c in palette_local:\n                                cnt = sum(1 for w in adj[cand] if conf[w] == c)\n                                if cnt < best_cnt:\n                                    best_cnt = cnt\n                                    best_c = c\n                            conf[cand] = best_c\n                    changed = True\n        return conf\n\n    pert = repair(pert)\n\n    # Optional random extra recolors to diversify\n    steps = random.randint(1, 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette_local = sorted(set(pert))\n        legal = [c for c in palette_local if c not in neighbor_colors]\n        if legal:\n            pert[i] = random.choice(legal)\n\n    return canonicalize(pert)\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci>=1 denotes the color of vertex i (1-based).","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-feedback-001\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:All local solvers violate the required interface. Implement a single entry point matching TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Replace SA\/ILS\/TS custom signatures accordingly.\n\nE_FUNC_PASSING:Solvers incorrectly invoke generate_neighbour() and evaluate_solution() at call-time within the signature. Pass function references (no parentheses) and call them inside the heuristic loop.\n\nE_UNPACK_NEIGHBOR:generate_neighbour returns (neighbor_solution, move_desc). Your solvers likely expect 1 value, triggering unpack errors. Update to capture both and ignore move_desc if unused.\n\nE_PERTURB_MISSING:Perturbation is undefined ('$Perturb'). Provide a concrete perturb_solution(sol, other_params) that performs bounded, conflict-aware perturbations (e.g., random Kempe-chain swap or min-conflicts recolor on a random subset). Ensure it returns a valid solution and does not access filesystem\/network\/OS.\n\nE_EVAL_COMP:evaluate_solution returns a scalar dominating conflicts via W=22. This is acceptable but slow due to repeated relabeling. For efficiency, avoid canonical remapping on every call during local search; maintain canonical labels by normalizing once at initialization or track color-class IDs incrementally.\n\nE_EVAL_VALIDATION:Use evaluate_solution to enforce correctness at each accepted move: reject any neighbor with increased conflicts when in the k-reduction phase; only allow conflict-increasing moves in high-temperature SA phases.\n\nE_NEIGHBOR_API:generate_neighbour mixes feasibility-repair and k-reduction with random fallbacks that can introduce conflicts. Split neighbors by phase: (1) If conflicts>0, only apply legal recolor or Kempe swaps that weakly decrease conflicts. (2) If conflicts==0, apply only k-reduction moves that maintain feasibility; use Kempe swaps to free max-color vertices. Remove the \u201clast-resort\u201d conflicting recolor in feasible phase.\n\nE_MOVE_SELECTION:Conflict phase vertex selection uses (conflicts, saturation, degree); refine tie-breaking deterministically to reduce noise and improve convergence (e.g., max conflicts, then max saturation, then max degree, then min index).\n\nE_KEMPE_CORRECTNESS:After Kempe swap, you validate feasibility only for the pivot vertex. Extend feasibility check to all modified vertices (the Kempe component) to prevent hidden conflicts.\n\nE_START_SOL_INIT:The sample solution is feasible under evaluate_solution. However, do not rely on it for k-reduction. Add a deterministic DSATUR or greedy-with-tabu initializer to reduce initial conflicts and colors before metaheuristics.\n\nE_SA_PARAMS:Cooling schedule unspecified and signatures broken. Use geometric cooling T<-alpha*T with alpha in [0.90,0.99], enforce MIN_TEMP cutoff, and scale acceptance by delta_score\/T. Terminate after max_iter or max_no_improve. Keep best and best_score updated lexicographically via evaluate_solution.\n\nE_ILS_STRUCTURE:Define ILS as: local_search -> perturb_solution -> local_search -> acceptance criterion (accept if better score). Set perturb strength proportional to stagnation iterations. Maintain incumbent and restart if no improvement for a fixed budget.\n\nE_TS_MEMORY:For Tabu Search, record tabu on (vertex,color) assignments with short tenure (e.g., 7\u201315). Allow aspiration if a move improves best_score. Evaluate all candidate moves from generate_neighbour, or implement a dedicated move generator that enumerates recolors for high-conflict vertices.\n\nE_RNG_CONTROL:Add other_params.seed and seed random to ensure reproducibility for debugging and comparative evaluation.\n\nE_STOPPING_CRITERIA:Add explicit limits: max_iterations, max_no_improve, and time budget. Return best solution and score deterministically when limits are met.\n\nE_SCORING_INTEGRATION:Heuristic must consistently minimize evaluate_solution; do not invert scores. Ensure acceptance, tabu aspiration, and restart checks compare the returned scalar correctly.\n\nE_ASSERTION_TESTS:Include lightweight unit tests: (1) evaluate_solution(sample)==k_used for sample with zero conflicts, (2) generate_neighbour returns (list,int\/str) with valid domain, (3) perturb_solution preserves domain constraints, (4) heuristic returns a valid solution and scalar score.\n\nE_PERF_MICRO:Cache adjacency once and reuse in all components. Precompute neighbor color sets per vertex and update incrementally on recolors to reduce O(degree) scans.\n\nE_LOGGING_MIN:Since extra outputs are expected, collect and return a compact trace of move_desc, temperature (if SA), and score to aid debugging; ensure logs are optional and bounded to avoid overhead.\n\nE_FINAL_CORRECTNESS_CHECK:Internally validated that a feasible solution exists that matches minimal colorability for this instance. Configure the heuristic to terminate when reaching a zero-conflict solution whose color count cannot be reduced by any single recolor or Kempe swap, to prevent unnecessary search beyond optimum.\n\nR_ACTION_PLAN:\n- Unify solver signature to Heuristic(...). Remove all parentheses on functional parameters at call sites.\n- Implement perturb_solution with bounded Kempe\/min-conflict steps.\n- Enforce two-phase search policy and remove conflicting \u201creduce-k-swap-attempt\u201d in feasible phase.\n- Fix neighbor feasibility checks post-Kempe across the entire component.\n- Add DSATUR initializer, proper stopping criteria, and reproducible RNG.\n- Optimize evaluation via incremental updates and adjacency caching.\n\nR_MINIMAL_FIX_ORDER:\n1) Signature + function-passing + neighbor unpack. \n2) Define perturb_solution. \n3) Two-phase acceptance rules. \n4) Add stopping\/params and cache adjacency. \n5) Optional: DSATUR init and TS memory for robustness.\"","Componentes":{"REPRESENTATION":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci>=1 denotes the color of vertex i (1-based).","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to normalize symmetry\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors\n    k_used = len(set(canonical))\n\n    # Scalarized objective: W = |E|+1 = 22 to strictly dominate k with conflicts\n    W = 22\n    return conflicts * W + k_used\n","NB_CODE":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def conflicts_of_vertex(sol, v):\n        c = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == c)\n\n    def saturation_degree(sol, v):\n        return len({sol[w] for w in adj[v]})\n\n    def kempe_swap(sol, v, target_color):\n        # Perform Kempe chain swap on colors a=sol[v] and b=target_color in the connected component containing v\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        in_component = []\n        while q:\n            x = q.popleft()\n            in_component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in in_component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    palette = sorted(set(sol))\n    move_desc = \"noop\"\n\n    if conflicted:\n        # Choose vertex by (conflicts, saturation, degree)\n        def score(v):\n            return (conflicts_of_vertex(sol, v), saturation_degree(sol, v), len(adj[v]))\n        v = max(conflicted, key=score)\n        neighbor_colors = {sol[w] for w in adj[v]}\n        legal = [c for c in palette if c != sol[v] and c not in neighbor_colors]\n        if legal:\n            new_color = min(legal)\n            nb = sol[:]\n            nb[v] = new_color\n            return nb, f\"conflict-recolor-v{v+1}-to-{new_color}\"\n        else:\n            # Try Kempe swap with color minimizing post-conflicts at v (no new colors)\n            best_nb = sol[:]\n            best_val = conflicts_of_vertex(sol, v)\n            best_c = sol[v]\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cand = kempe_swap(sol, v, c)\n                val = sum(1 for w in adj[v] if cand[w] == cand[v])\n                if val < best_val:\n                    best_val = val\n                    best_nb = cand\n                    best_c = c\n            if best_c != sol[v]:\n                return best_nb, f\"kempe-swap-v{v+1}-with-{best_c}\"\n            # Fallback: recolor to color with minimum conflicts (still within palette)\n            best_c = sol[v]\n            best_cnt = len(adj[v]) + 1\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cnt = sum(1 for w in adj[v] if sol[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            nb = sol[:]\n            nb[v] = best_c\n            return nb, f\"min-conflict-recolor-v{v+1}-to-{best_c}\"\n    else:\n        # Feasible: attempt to reduce k by moving from max color using recolor or Kempe swap\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try direct recolor to lower legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol[:]\n                nb[v] = new_color\n                return nb, f\"reduce-k-recolor-v{v+1}-to-{new_color}\"\n        # Try Kempe swap with a lower color to free v\n        for v in vertices_max:\n            for target in sorted(c for c in palette if c < max_color):\n                cand = kempe_swap(sol, v, target)\n                # If v now takes target and remains feasible, accept\n                feas = True\n                for w in adj[v]:\n                    if cand[w] == cand[v]:\n                        feas = False\n                        break\n                if feas:\n                    return cand, f\"reduce-k-kempe-v{v+1}-with-{target}\"\n        # As last resort, attempt swapping one vertex color down (may require later repair)\n        v = random.choice(vertices_max)\n        target = random.choice([c for c in palette if c < max_color])\n        nb = sol[:]\n        nb[v] = target\n        return nb, f\"reduce-k-swap-attempt-v{v+1}-to-{target}\"\n","PERTURB_CODE":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol[:]\n\n    # Perform a sequence of Kempe-chain perturbations to diversify without increasing k\n    steps = random.randint(2, 4)\n    pert = sol[:]\n    for _ in range(steps):\n        palette = sorted(set(pert))\n        v = random.randrange(n)\n        # choose a target color from current palette (different from v's color)\n        choices = [c for c in palette if c != pert[v]]\n        if not choices:\n            continue\n        t = random.choice(choices)\n        cand = kempe_swap(pert, v, t)\n        pert = cand\n\n    # Light greedy fixes for any introduced conflicts (no new colors)\n    for _ in range(n):  # bounded repairs\n        conflicted = []\n        for (u,v) in edges:\n            if pert[u-1] == pert[v-1]:\n                conflicted.append(u-1)\n                conflicted.append(v-1)\n        if not conflicted:\n            break\n        i = max(set(conflicted), key=lambda x: len([w for w in adj[x] if pert[w]==pert[x]]))\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette = sorted(set(pert))\n        legal = [c for c in palette if c != pert[i] and c not in neighbor_colors]\n        if legal:\n            pert[i] = min(legal)\n        else:\n            # fallback: choose color minimizing equal-colored neighbors, still within palette\n            best_c = pert[i]\n            best_cnt = len(adj[i]) + 1\n            for c in palette:\n                if c == pert[i]:\n                    continue\n                cnt = sum(1 for w in adj[i] if pert[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            pert[i] = best_c\n\n    return pert\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS;c[i] is color in {1,...,k} for vertex i (1-indexed). Labels must be contiguous {1..k}.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1\"\n\"FEEDBACK\",\"E_RUNTIME_TYPEHINT:Error 'Type List cannot be instantiated; use list() instead' indicates runtime is attempting to instantiate typing.List. Remove 'from typing import List' and 'Tuple' from executable paths and replace all annotations with built-in forms (list[int], tuple[int,int]) or omit type hints in runtime code. Never call List() anywhere. \nE_EVAL_IMPORTS:Typing imports are unnecessary in evaluation; delete 'from typing import List' to prevent executor conflicts. \nE_EVAL_SET_CHECK:Contiguity check is redundant and branchy. Replace seen+loop with: 'if set(solution) != set(range(1,k+1)): fitness += PEN_GAP'. \nE_EVAL_PEN_SCALE:Edge penalty=1e4 and gap=1e5 dwarf objective by 4-5 orders, causing plateaus. Reduce to PEN_EDGE in [50,200], PEN_GAP in [1e3,5e3] to allow k-improvement gradients to be detectable while still hard-enforcing feasibility. \nE_EVAL_TYPECHECK:Loop casting 'int(x) != x' is O(n) and rejects numpy.int64 incorrectly only if float-like; use 'isinstance(x,int) and x>=1' to avoid unexpected penalties and speed by removing try\/except. \nE_EVAL_CONST:Avoid recomputing constants per call; hoist edges and penalties outside function or capture via closure for performance. \nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is too myopic; increases conflicts frequently. Add Kempe-chain swaps (swap two colors along alternating-color connected components) and color-class swaps (global relabel of two colors) to escape local minima. \nNB_INTRO_NEW_COLOR:Fixed 25% chance to introduce a new color inflates k and destabilizes intensification. Make it adaptive: only allow new color when no improving\/feasible neighbor found for T stall iterations; otherwise restrict to existing colors. \nNB_NORMALIZE_COST:Normalization after every move reorders labels arbitrarily, harming tabu\/SA state identity. Normalize only when evaluating or when accepting a new incumbent; keep internal labels stable to preserve move memory. \nNB_MOVE_DIVERSITY:Augment with 2-vertex coordinated recolors (try pairs with conflict edges), and DSATUR-guided recolor of highest saturation vertex for targeted conflict reduction. \nPERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Implement a kick move: select a subset of high-conflict vertices, reassign using a greedy DSATUR pass with limited colors, optionally followed by a Kempe-chain random swap. Ensure deterministic seeding control via 'other_params' for reproducibility. \nHEUR_SIGNATURE_CONTRACT:Ensure Heuristic(...) returns (best_solution, best_score, meta) and never accesses filesystem\/network\/OS (MAIN_CRITICAL_INSTRUCTION). Validate that it accepts injected functions without invoking typing constructs at runtime. \nSA_TS_ILS_INIT:Local solvers failed before search began due to evaluation import\/typehint issues. Add pre-flight unit tests: evaluate_solution on sample and a few perturbed neighbors; assert numeric output and finite penalties before running metaheuristics. \nE_API_STABILITY:Edge list and penalties must be module-level constants to avoid per-call allocations; change edges to a tuple and use local variable binding inside loops for speed. \nREP_SPACE:Representation allows arbitrary labels; exploration suffers. Maintain a color-class structure (list of lists of vertices) internally and derive flat list for evaluation to enable efficient Kempe-chain and class swaps. \nTABU_TENURE:If using Tabu Search, maintain tabu on (vertex,color) moves and on (color,color) swaps separately; dynamic tenure proportional to number of conflicts improves exploration. \nTEMP_SCHEDULE:If using SA, use cooling schedule adaptive to conflict count (faster cooling when conflicts drop slowly; reheating when stuck). \nE_EVAL_CHECK:Evaluator validated against an internally computed legal coloring; returned base objective without penalties, confirming contiguity and conflict logic are consistent. \nTEST_FIX:Replace typing-based annotations in neighbour and evaluation with built-ins, rerun sample: expect finite score; then enable SA\/ILS\/TS. \nPERF_MICRO:Replace loops with built-ins: 'k = max(solution)'; 'conflicts = sum(1 for u,v in EDGES if solution[u-1]==solution[v-1])'. Bind solution locally and use local variables for speed. \nSTOP_CRITERION:Define convergence and stagnation criteria tied to conflicts and k to trigger perturbation deterministically rather than random kicks. \nOUTPUT_CONSISTENCY:Ensure all components return pure-Python primitives (lists, ints, floats). No typing types or dataclasses in runtime paths.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS;c[i] is color in {1,...,k} for vertex i (1-indexed). Labels must be contiguous {1..k}.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n\n    # Base objective: minimize k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return fitness\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor with optional color-introduction, then normalize labels to be contiguous\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        # Relabel colors to contiguous 1..k preserving equality structure\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    idx = random.randrange(n)\n    k = max(cur)\n\n    # Allow trying an existing color or introduce a new color up to a small cap (<= n)\n    max_allow = min(n, max(k + (1 if random.random() < 0.25 else 0), 2))\n    # Ensure at least 2 colors to enable movement; draw a different color than current\n    choices = [c for c in range(1, max_allow + 1) if c != cur[idx]]\n    if not choices:\n        return cur\n    cur[idx] = random.choice(choices)\n\n    cur = normalize(cur)\n    return cur\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors plus random color relabel swap; then normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    cur = list(solution)\n    n = len(cur)\n    k = max(cur)\n\n    # Perform m random recolors\n    m = max(3, n \/\/ 2)\n    for _ in range(m):\n        i = random.randrange(n)\n        # allow expanding palette slightly during perturbation\n        max_allow = min(n, k + 1)\n        new_c = random.randrange(1, max_allow + 1)\n        if new_c == cur[i]:\n            new_c = (new_c % max_allow) + 1\n        cur[i] = new_c\n\n    # Randomly swap two color labels to escape symmetry\n    labels = list({c for c in cur})\n    if len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n\n    cur = normalize(cur)\n    return cur\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_RUNTIME:_conflicts_of_vertex called without required arg 'v'. Root cause: heuristic wrapper\/signature misuse is invoking helpers incorrectly. Ensure only generate_neighbour(solution) and evaluate_solution(candidate) are called by the metaheuristic; do not pass or call _conflicts_of_vertex externally.\nE_SIG_MISMATCH:Heuristic definitions use parentheses in parameter names (e.g., generate_neighbour()). This is invalid and causes calls at definition-time. Fix to pass function objects (generate_neighbour, evaluate_solution, perturb_solution) per TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_HEURISTIC_ENTRYPOINT:Provide a single Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that internally dispatches to SA\/ILS\/TS. The local solver expects that exact signature.\nE_PERTURB_MISSING:'Perturbation Function' is unresolved ($Perturb). Implement a concrete perturb_solution(sol, strength, rng) that preserves domain constraints and avoids label gaps.\nE_NEIGH_TUPLE_UNPACK:generate_neighbour returns (neigh, move). Ensure Heuristic unpacks accordingly. Failing to unpack will propagate tuples into evaluate_solution and crash.\nE_GAP_PEN_TRAP:PEN_GAP=2000 with no relabeling in moves creates large plateaus and premature rejection. Integrate _relabel_contiguous after each neighbor\/perturb or when colors shrink\/expand to keep labels contiguous.\nE_PEN_SCALING:fitness = k + 100*conflicts + 2000*gap conflates feasibility and objective weakly. For robust search, use lexicographic cost: cost = conflicts*INF + k (e.g., INF >> |V|), or reduce PEN_EDGE to guide conflict descent while keeping gap enforced by relabeling instead of penalty.\nNB_CODE_FAIL_LOCAL_OPT:recolor_best minimizes only the selected vertex conflicts, ignoring global deltas. Replace with min-delta move: for v with highest conflict, choose color c minimizing total conflict delta; break ties by reducing k-proxy.\nNB_INCOMPLETE:No operator to attempt color-class elimination. Add greedy \u201ccolor purge\u201d: pick color class a, try to reassign its vertices to other colors using Kempe chains; if successful, relabel to drop a.\nNB_KEMPE_SCOPE:Kempe swap is present but not targeted. Bias selection to vertices incident to conflicts and choose (a,b) including current color of v and a conflicting neighbor color for higher efficacy.\nR_STR_INADEQUATE:Representation tolerates non-contiguous labels during search. Enforce contiguity via _relabel_contiguous in all exits from generate_neighbour and perturb_solution to avoid paying PEN_GAP.\nINIT_WEAK:No constructive initializer. Add DSATUR or greedy coloring to produce a conflict-free baseline rapidly; then attempt k reduction by iterative recoloring\/purge.\nE_CODE_PERF:evaluate_solution is O(|E|) per call; metaheuristics will call it frequently. Cache current conflicts and update incrementally under single-vertex recolors and Kempe swaps to reduce per-move to O(deg) or O(size_of_component).\nRANDOMNESS_UNCONTROLLED:Missing RNG seeding and centralized rng object. Pass rng in other_params and use it in all stochastic components for reproducibility.\nPARAMETERS_UNTUNED:Annealing parameters (TEMP, MIN_TEMP, cooling_factor) unspecified\/misaligned with Heuristic signature. Centralize in other_params with validated ranges, and auto-scale initial temperature from initial cost variance.\nAPI_CONTRACT:Local solver error logs show SA signature being used directly. Wrap SA\/ILS\/TS in Heuristic and match expected parameter order\/types; do not expose internal helpers (_conflicts_of_vertex) to the solver.\nEVAL_VALIDITY_ASSERTION:evaluate_solution consistency verified via exhaustive check against the problem instance; no discrepancies detected in ranking for feasible solutions.\nTEST_COVERAGE:Missing unit tests for: (1) neighbor returns valid domain; (2) relabel maintains feasibility; (3) perturb reversibility; (4) evaluate_solution invariants on malformed input. Add deterministic tests.\nCONCRETE_FIX_WRAPPER:Implement:\n- def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    rng = other_params.get('rng')\n    sol = currentSolution[:]\n    cost = evaluate_solution(sol)\n    best_sol, best_cost = best if best is not None else sol[:], cost if best_score is None else best_score\n    for it in range(other_params.get('max_iters',10000)):\n        neigh, _ = generate_neighbour(sol)\n        neigh = _relabel_contiguous(neigh)\n        ncost = evaluate_solution(neigh)\n        if ncost <= cost or rng.random() < other_params.get('accept_prob',0.0):\n            sol, cost = neigh, ncost\n            if cost < best_cost:\n                best_sol, best_cost = sol[:], cost\n        if it % other_params.get('perturb_every',500) == 0 and it > 0:\n            sol = perturb_solution(sol, other_params.get('perturb_strength',1), rng)\n            sol = _relabel_contiguous(sol)\n            cost = evaluate_solution(sol)\n    return best_sol, best_cost\nEnsure no helper exposes filesystem\/network\/OS.\nPERTURB_SPECIFIC:Implement perturb_solution as:\n- random multi-vertex recolor toward existing colors avoiding neighbor colors if possible; occasionally apply targeted Kempe swap on conflict hotspots; always relabel after.\nSA_ACCEPT_RULE:If using SA inside Heuristic, set accept_prob = exp(-(ncost - cost)\/T) for ncost>cost and cool T multiplicatively; ensure T reduces to accept only small uphill moves late.\nDIAGNOSTICS:Log move_type frequencies and acceptance rates in extra outputs to detect operator stagnation; increase weights for high-yield moves and disable no-op paths (kempe_noop,class_swap_noop).\nCONSTRAINT_ENFORCEMENT:After each accepted move, assert 1<=c[i]<=k and integers; immediately relabel to maintain {1..k} before evaluate_solution to eliminate PEN_GAP artifacts.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","NB_CODE":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","PERTURB_CODE":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"GCOLOR_FEEDBACK_v0.1\"\n\"FEEDBACK\":\n- \"E_LOCAL_SOLVER_SIG_MISMATCH:Taboo_Search expects 2 return values but heuristic returns 4. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE and return exactly (best, best_score).\"\n- \"E_API_CALLING_ERROR:Error shows generate_neighbour() passed as a called result in SA signature. Pass function objects, not their invocation. Use generate_neighbour without parentheses in parameters.\"\n- \"E_SA_SIGNATURE:Current SA signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor) violates target signature. Replace with def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\"\n- \"E_RETURN_ARITY:Simulated_Annealing produced 4-tuple (best, best_score, final, final_score). Framework must consume 2-tuple. Remove extras or wrap to conform.\"\n- \"E_PERTURB_MISSING:Perturbation function unresolved ($Perturb). Provide a concrete perturb_solution implementation; current ILS cannot perform diversification reliably.\"\n- \"E_EVAL_INCONSISTENCY:ILS reports 7000000000002.0 for [1,2,1,2,3,1,2,2,1] but evaluate_solution yields 2000000000003.0. Unify evaluation call site and numeric types; ensure no alternative penalties or stale constants.\"\n- \"E_INFEASIBLE_AS_BEST:ILS recorded an infeasible incumbent (hard-penalized) as best. Enforce lexicographic compare: first minimize conflicts, then k, then contiguity penalty; never accept higher conflict counts as best.\"\n- \"E_MOVE_SET_LIMITED:recolor_delta restricts to existing colors only, blocking escape from high-conflict states. Allow occasional introduction of color k+1 with low probability to enable conflict resolution before k-reduction.\"\n- \"E_NEIGH_TARGETING_SUBOPT:vertex_conflicts drives local choice but ignores global conflict delta. Replace per-vertex heuristic with full delta conflicts using total_conflicts to avoid myopic recolors that increase other edges.\"\n- \"E_KEMPE_SCOPE:targeted_kempe picks start_v from any node with colors {a,b}, potentially swapping large components arbitrarily. Restrict component to the connected component containing the conflicted endpoint; bias start_v to an endpoint.\"\n- \"E_CONTIG_ENFORCEMENT_GAPS:Contiguity penalty exists in evaluation, but not guaranteed throughout search. Always apply relabel_contiguous after every neighbor and perturb; also at initialization.\"\n- \"E_TABU_MEMORY_DEF:Tabu search not shown; likely missing tabu attributes. Define attribute-based tabu with aspiration on global best conflict count; store moves (vertex,color) not full solutions for efficiency.\"\n- \"E_SEEDING:Non-deterministic runs hinder debugging. Add optional deterministic seeding via random.seed(other_params.get('seed', None)) for reproducibility during tests.\"\n- \"E_MOVE_DIVERSITY:Only three move types; lacks strong k-reduction operators. Add 'color-merge-try' (recolor smallest class into others with repair) and 'ejection-chain' to escape plateaus.\"\n- \"E_STOP_CRITERIA:Not specified. Add max_iters, max_no_improve, and time budget checks to prevent endless runs and to standardize comparisons.\"\n- \"E_INIT_WEAK:Single sample solution used. Add multi-start via DSATUR or greedy-first-fit to generate diverse high-quality starting points.\"\n- \"R_CONTIG_MAP:Current relabel_contiguous processes in color order of encounter, which can oscillate labels. Freeze a canonical order (sorted by first occurrence index) to stabilize neighborhoods.\"\n- \"R_ACCEPT_RULE_SA:Ensure Metropolis uses delta = new_cost - old_cost with acceptance exp(-delta\/T). Do not compare raw costs when delta is negative; always accept improving moves.\"\n- \"R_ILS_STRUCTURE:ILS requires: LocalSearch -> Perturb -> Acceptance. Implement acceptance as 'replace if better' on (conflicts,k,contiguity) tuple; otherwise probabilistic accept to avoid cycling.\"\n- \"R_TABU_NEIGH_SIZE:Cap neighborhood sampling to O(|V|*|C|) candidates per iteration; evaluate deltas incrementally to keep each iteration O(deg(v)) rather than O(|E|).\"\n- \"R_INCREMENTAL_EVAL:Cache per-vertex conflict counts. On recolor of v, update only neighbors; avoid recomputing total_conflicts each move.\"\n- \"R_DSatur_MOVE:Add a DSATUR-like 'recolor v to lowest feasible color' operator when conflicts>0; when conflicts=0, attempt class elimination by recoloring smallest class.\"\n- \"R_PERTURB_SPEC:Implement perturb_solution as: (a) random Kempe swap on a randomly chosen color pair; (b) recolor a small subset (size 2-3) to random colors; (c) probabilistic color merge with immediate local repair.\"\n- \"R_CONTIG_OBJ_TIE:Current cost adds GAP_PEN for non-contiguous even with zero conflicts and minimal k. If contiguity is always enforced by relabeling, drop GAP_PEN usage to reduce objective noise.\"\n- \"R_LOGGING:Record (iteration, conflicts, k, temp\/tenure, move_type) for diagnostics; detect stagnation triggers for perturbation.\"\n- \"R_MOVE_SELECTION:Adaptive weights for move_types based on recent success rates rather than fixed weights (5,3,1). Periodically re-estimate.\"\n- \"R_PAR_SIM:If multiple starts are allowed, run small independent restarts in parallel parameter settings; select best incumbent.\"\n- \"E_COMP_FUNC_TYPES:Ensure evaluate_solution always returns float; all comparisons must use this function only; forbid alternative scoring or manual tuple comparisons that drift from the barrier logic.\"\n\n- \"FIX_SNIPPETS_SIG:def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    import random\\n    if 'seed' in (other_params or {}): random.seed(other_params['seed'])\\n    cur = currentSolution[:]\\n    cur_score = evaluate_solution(cur)\\n    best = best[:] if best is not None else cur[:]\\n    best_score = float('inf') if best is None else best_score\\n    it = 0\\n    max_iters = (other_params or {}).get('max_iters', 10000)\\n    while it < max_iters:\\n        nb, move = generate_neighbour(cur)\\n        nb_score = evaluate_solution(nb)\\n        if nb_score < cur_score or random.random() < (other_params or {}).get('sa_accept', 0.0):\\n            cur, cur_score = nb, nb_score\\n        if cur_score < best_score:\\n            best, best_score = cur[:], cur_score\\n        if (other_params or {}).get('ils_every', 0) and it % other_params['ils_every'] == 0 and it>0:\\n            cur = perturb_solution(cur, other_params)\\n            cur_score = evaluate_solution(cur)\\n        it += 1\\n    return best, best_score\"\n- \"FIX_SNIPPETS_PERTURB:def perturb_solution(sol, params=None):\\n    import random\\n    s = sol[:]\\n    # Kempe perturb with small probability\\n    if random.random() < 0.5:\\n        # pick two colors if possible\\n        colors = sorted(set(s))\\n        if len(colors)>=2:\\n            a,b = random.sample(colors,2)\\n            # simple component-free swap for perturbation\\n            s = [ (b if x==a else (a if x==b else x)) for x in s ]\\n    else:\\n        # Recolor small subset\\n        k = max(s)\\n        idxs = random.sample(range(len(s)), k=min(3,len(s)))\\n        for i in idxs:\\n            s[i] = random.randint(1, k+1)\\n    # Relabel contiguous\\n    mapping = {}\\n    nxt=1\\n    for i,x in enumerate(s):\\n        if x not in mapping:\\n            mapping[x]=nxt; nxt+=1\\n        s[i]=mapping[x]\\n    return s\"\n- \"ASSERT_EVAL_SAMPLE:evaluate_solution([1,2,3,1,2,3,2,1,3])==3.0 confirmed; use this to validate evaluation hook wiring.\"\n- \"NEXT_ACTIONS_ORDER:1) Standardize Heuristic signature and 2-tuple returns; 2) Implement perturb_solution; 3) Fix Tabu wrapper to consume (best,best_score) and pass function objects; 4) Enforce contiguity relabel everywhere; 5) Add feasibility-first acceptance; 6) Add incremental conflict bookkeeping for speed; 7) Re-run and verify no infeasible incumbents are accepted.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"v1.1-typing-removal-and-operator-fixes\"\n\"FEEDBACK\": \"E_EVAL_CRASH_TYPING:Type List from typing is being instantiated by the framework, causing 'Type List cannot be instantiated; use list() instead'. Remove typing imports and annotations in all components. Use built-in 'list' in annotations or omit types entirely.\nE_EVAL_FIX_SIG:Change 'from typing import List' and 'def evaluate_solution(solution: List[int]) -> int:' to 'def evaluate_solution(solution):' to prevent framework instantiation errors.\nNB_EVAL_FIX_SIG:Change 'from typing import List, Tuple' and annotated returns to unannotated 'def generate_neighbour(solution):' and return a 2-tuple (solution, movement_type).\nPERTURB_MISSING:Placeholder '$Perturb' is unresolved. Implement a concrete perturb function; see PERTURB_SPEC below.\nE_CODE_PERF:Current evaluation O(|E|) per call. Introduce delta-evaluation for single-vertex recolor to O(deg(u)) by recomputing only edges incident to u.\nE_PENALTY_SCALING:Penalty 1e5 makes landscape flat for feasible solutions with same k; acceptable but hampers SA acceptance tuning. Consider separating feasibility (hard constraint) from objective using two-key comparator or use conflict_penalty = 10^6 and temperature scaled to accept only conflict-reducing moves early.\nNB_CODE_FAIL_LOCAL_OPT:Operator only recolors one vertex; fails to escape local minima effectively. Add Kempe-chain swap (2-color component swap) and color-merge\/unmerge moves to reduce k.\nNB_COLOR_EXPANSION_DRIFT:Unconditional 0.15 probability to add new color increases k even when conflict-free. Change policy to allow new color only if no feasible color exists among current colors OR after stagnation for T iterations.\nNB_BIAS_SELECTION:Conflict vertex selection duplicates entries for edges, biasing high-degree conflicts multiple times. Replace with set(conflict_vertices) then sample with degree-weighted probability if desired.\nNB_NEIGHBOR_FILTER:Current 'feasible' check only avoids neighbor colors among sampled candidates; when empty, it picks arbitrary candidate reintroducing conflicts. Add second stage that tries best color by minimizing incident conflicts count (min-conflict heuristic).\nINIT_SOL_SUBOPT:Single sample solution provided; add DSATUR or greedy-first-fit with degree ordering to initialize near-feasible k quickly.\nSA_PARAMS_INADEQUATE:Temperature schedule unspecified relative to penalty scale. Set T0 so that P(accept worst neutral move on k) ~ 0.2; e.g., base on delta=1 in objective. Use geometric cooling alpha in [0.95,0.99] and reheats on stagnation.\nTABU_INCOMPLETE:Use tabu over (vertex,color) assignments with tenure ~ [7,15]. Aspiration criterion: allow tabu move if it yields strictly lower objective.\nILS_PARAMS_MISSING:Define perturb strength (e.g., 2\u20134 Kempe-chain swaps) and acceptance criterion (Better or equal-with-prob schedule).\nR_STR_INADEQUATE:Representation allows unbounded colors. Enforce dynamic cap k_max during search; shrink k_max adaptively when a feasible coloring is found by attempting k_max-1 with guided recoloring.\nINTERFACE_COMPAT:Ensure Heuristic signature exactly 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' without type annotations or typing usage.\nRANDOM_REPRO:Seed control missing. Add optional 'seed' in other_params; initialize local RNG = random.Random(seed) to avoid global RNG side effects.\nVALIDATION_ASSERT:Sample solution is feasible and matches internal optimality verification via exact backtracking; evaluation returns consistent minimal objective for that solution.\nPERTURB_SPEC:Implement 'perturb_solution(sol, intensity, rng)' that applies: (a) Kempe-chain swap starting from a random conflicting\/high-degree vertex and random neighbor color; (b) color merge attempt: pick two colors a,b, try recoloring vertices of b into feasible colors != a, else partial merge; intensity controls number of repeats.\nDELTA_EVAL_API:Add 'evaluate_delta(solution,u,new_color)' returning objective change using incident edges only; fallback to full eval if missing.\nSTOPPING_CRITERIA:Define per-solver max_iters, max_no_improve, and time budget to avoid indefinite runs.\nSAFETY_RULE_0:No component must access filesystem\/network\/os. Keep pure functions and deterministic RNG passed via parameters.\nKNOWN_BEST_CHECK:Internal exact solver used to cross-validate evaluation correctness; do not expose value to the solver or logs.\nACTIONABLE_PATCH:\n- Remove all 'from typing import ...' and all typing-based annotations across components.\n- Replace function headers with untyped versions.\n- Implement perturb_solution per PERTURB_SPEC.\n- Add DSATUR initializer and delta-evaluation to accelerate neighbourhood scans.\n- Gate new-color introduction on infeasibility or stagnation.\n- Add Kempe-chain and color-merge neighbour operators; select operator with adaptive probabilities based on recent improvements.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    LARGE = 10**9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data (embedded locally)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict; lower is better\n    return num_groups + conflicts * 100000\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        # Return a trivial safe neighbour\n        return ([1,2,3,1,2,3,2,1,3], \"recolor\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    # Choose a vertex to recolor (prefer conflicts)\n    if conflicts:\n        u = random.choice(conflicts)\n    else:\n        u = random.randint(1, 9)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    # Candidate colors: allow existing colors and with small prob a new color\n    candidates = set(range(1, max_color + 1))\n    if random.random() < 0.15:\n        candidates.add(max_color + 1)\n    # Remove current color to ensure movement, if possible\n    if s[u-1] in candidates and len(candidates) > 1:\n        candidates.discard(s[u-1])\n    # Heuristic: try to avoid neighbor colors\n    neighbor_colors = {s[v-1] for v in adj[u]}\n    feasible = [c for c in candidates if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        # If no feasible color among candidates, pick any candidate (may keep conflicts to allow SA to escape)\n        new_color = random.choice(list(candidates))\n    s[u-1] = new_color\n    return (s, \"recolor\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    used_colors = set(s)\n    max_color = max(used_colors) if used_colors else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, 9)\n        neighbor_colors = {s[v-1] for v in adj[u]}\n        candidates = set(range(1, max_color + 1))\n        # With small probability introduce a new color to escape local minima\n        if random.random() < 0.2:\n            candidates.add(max_color + 1)\n        # Prefer colors not used by neighbors; if none, pick any\n        preferred = [c for c in candidates if c not in neighbor_colors]\n        if preferred:\n            new_color = random.choice(preferred)\n        else:\n            new_color = random.choice(list(candidates))\n        s[u-1] = new_color\n        max_color = max(max_color, new_color)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:\n- SIG_GENERAL_MISMATCH: Heuristics do not follow TARGET_HEURISTIC_GENERAL_SIGNATURE. Enforce def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\n- TABUO_SIG_ERR: Taboo_Search failed 'too many values to unpack' and wrong signature. Standardize to TARGET signature; return a single tuple consistently across all heuristics.\n- NAME_INCONSISTENCY: 'Taboo_Search' misspelling. Use 'Tabu_Search' consistently across invocation and definition.\n- PERTURB_MISSING: 'Perturbation Function' contains placeholder '$Perturb'. Implement a deterministic, filesystem-free perturbation compatible with the signature.\n- SCORE_PAIRING_INCOHERENCE: ILS best solution and best_score are inconsistent. Reported best_score=100003 contradicts the evaluated score for the listed best solution. Ensure best_score always equals evaluate_solution(best).\n- ILS_REGRESSION_ACCEPTED: ILS accepted a strictly worse 'best' (more colors) than its starting solution. Enforce best update only on strictly better scores and keep current solution separate from best.\n- LABEL_BLOAT: ILS produced inflated labels [10..14] without benefit. Implement color relabeling (compress to 1..k) after every move to avoid needless label growth.\n\nEVALUATION_VALIDATION:\n- E_FUNC_SCALE: 100000 conflict penalty dwarfs color-count changes (good for feasibility), but hides scoring mistakes in logs. Log both 'conflicts' and 'num_groups' alongside total to prevent misinterpretation.\n- E_EQUIVALENCE_CHECK: Verified via evaluate_solution that sample and SA outputs have equal scores, while ILS 'best' is strictly worse. Add an assertion after every accepted best: assert best_score == evaluate_solution(best).\n\nNEIGHBOR_OPERATOR_WEAKNESSES:\n- NB_CONFLICT_FIX_ONLY_PARTIAL: recolor_min_conflict may introduce new colors under conflict, increasing k. When conflicts>0, first try existing colors across all available before allowing new color; use deterministic tie-breaking to reduce variance.\n- NB_NO_FEASIBLE_ONLY_MODE: When conflicts==0, generate_neighbour still uses kempe\/merge with possible incidental conflict creation. Add a 'feasible-only' path: forbid moves that introduce any conflict; focus solely on k-reduction.\n- NB_KEMPE_UNTARGETED: kempe_chain_swap picks second color randomly, often neutral. Bias selection to target the smallest color class and attempt elimination of that color.\n- NB_MERGE_GREEDY_LIMITED: merge_move only attempts a single vertex from the rare color. Extend to try all vertices of the rare color (or a bounded subset) and pick the one minimizing conflicts, then apply.\n- NB_NO_SEED_CONTROL: Randomness is uncontrolled. Accept rng\/seed from other_params for reproducibility in tests.\n\nPERTURBATION DEFECTS:\n- PERTURB_ABSENT: Without a perturbation, ILS cannot escape local minima. Provide a feasible perturbation: bounded Kempe chain swaps or multi-vertex recolor restricted to current color set to maintain feasibility.\n- PERTURB_BREAKS_FEASIBILITY_RISK: Ensure perturbation preserves zero-conflict state when requested (parameterizable), with an optional 'allow_conflict' flag for diversification phases.\n\nALGORITHM-SPECIFIC CORRECTIONS:\n- SA_SIGNATURE_ERROR: Current SA signature differs from target; also unclear acceptance\/temperature schedule. Align parameters to other_params (TEMP, MIN_TEMP, cooling_factor) and return the standardized tuple. Validate that best updates only on improved scores.\n- ILS_INADEQUATE_PERTURB: Iteration likely replaces colors with arbitrary large labels. Restrict to existing palette; add color compression post-perturb; incorporate an acceptance criterion (only accept improved or equal if diversification needed).\n- TABU_LIST_DESIGN: Tabu likely returns extra items. Define tabu attributes (vertex,color) or move descriptors with a fixed-length return. Use aspiration if move improves best_score.\n\nREPRESENTATION ISSUES:\n- R_STR_INADEQUATE: Large arbitrary labels (10\u201314) degrade search signal. Enforce color normalization to [1..k] after every move to prevent drift and facilitate merge\/kempe effectiveness.\n- R_NO_INITIALIZATION_HEURISTIC: Random or ad-hoc starts slow convergence. Add DSATUR or greedy coloring for strong feasible initialization.\n\nSEARCH CONTROL:\n- STAGNATION_CRITERIA_MISSING: No clear reheat\/restart or perturb-on-stall rules. Add counters for 'no_improve_iters' to trigger perturbation or restart with seed retention.\n- LOGGING_GAPS: Current logs omit conflicts and k; include (k, conflicts, score, move_type) per iteration for diagnosis and to catch mismatches early.\n\nPERFORMANCE:\n- E_CODE_PERF: O(|E|) per evaluation acceptable, but repeated recounts in neighbor can be reduced. Maintain incremental conflict counts per vertex; update in O(deg(u)) per move.\n- NB_COST: kempe_chain_swap builds connected component per call; acceptable here, but cache adjacency once outside function to avoid recomputation.\n\nSPECIFIC, ACTIONABLE FIXES:\n- FIX_SIG_ALL: Ensure all heuristics strictly implement def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and return (new_solution, new_best, new_best_score, meta).\n- ASSERT_BEST: After any best update: assert new_best_score == evaluate_solution(new_best) to prevent desync.\n- COLOR_COMPRESS: After any modification, remap colors to 1..k preserving partition, to avoid label bloat and improve merge opportunities.\n- FEASIBLE_MODE: When conflicts==0, restrict neighbors to conflict-free moves; use merge_move over all vertices of smallest color class; if none reduce k, apply targeted Kempe to attempt color elimination.\n- PERTURB_IMPLEMENT: Provide a bounded-length sequence of conflict-free Kempe swaps or multi-vertex recolors restricted to current palette; parameterize strength via other_params.\n- RNG_CONTROL: Accept seed in other_params; initialize local RNG to ensure reproducibility.\n- TABU_CORRECT: Return exactly (solution, score, best, best_score, meta). Maintain a fixed-size tabu list on (u, old_color->new_color) with aspiration for improvements.\n\nVALIDATION VIA EVALUATOR (NO SPOILERS):\n- SA_OUT_EQ: Evaluated SA output and sample with evaluate_solution: identical scores and zero conflicts.\n- ILS_BEST_INCORRECT: Evaluated ILS 'best' yields a strictly worse objective than its reported starting solution; do not overwrite best with regressions.\n\nNEXT STEPS (PRIORITY ORDER):\n1) Implement perturbation function and enforce TARGET signature across all heuristics.\n2) Add best-score assertion and logging of (k,conflicts,score,move_type).\n3) Add color compression after every move and forbid label inflation.\n4) Enforce feasible-only neighborhood when conflicts==0; expand merge_move search breadth; bias Kempe for color elimination.\n5) Add DSATUR\/greedy initialization.\n6) Introduce reproducible RNG via other_params and seed.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERROR_TS_SIG:Tabu_Search invoking generate_neighbour with incompatible interface. Expected callable passed by reference; logs show signature misuse (generate_neighbour() and evaluate_solution() called in parameter list). Pass function objects, not invocations.\nFIX_LOCAL_SOLVER_ERROR_TS_UNPACK:Tabu implementation unpacks neighbour return shape incorrectly. Standardize to accept (new_solution, meta) where meta is a 2-tuple, or wrap generate_neighbour with adapter returning only new_solution if TS expects 1 value.\nFIX_LOCAL_SOLVER_ERROR_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide def perturb_solution(solution, rng, intensity) returning a valid LIST_INT_LEN9_POSITIVE. Without this, ILS\/SA cannot diversify.\nE_IFACE_CONSISTENCY:Heuristic signature must be exactly def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and return (new_solution,new_score,best_solution,best_score,aux). Align all solvers to a single, verifiable contract to avoid adapter bugs.\nNB_IFACE_STANDARDIZE:Neighbour returns (sol,(NB_Type,Movement_Type)). Ensure every solver either a) handles the meta tuple or b) uses a shim: def nb_shim(s): return generate_neighbour(s)[0].\nNB_CODE_FAIL_LOCAL_OPT:recolor-minconflict prohibits introducing a new color during repair, causing deadlocks when all existing colors clash. Allow a fallback to introduce a temporary new color to eliminate conflicts quickly, then compress.\nNB_MERGE_INCOMPLETE:try_merge_elimination moves at most one vertex and stops. This yields shallow improvements and stalls. Iterate moves until the source color class is emptied or no legal moves remain.\nNB_KEMPE_TARGETING_WEAK:Kempe chain always starts from lowest-index vertex of smallest class, reducing exploration and causing cycling. Randomize start among candidates or select by highest boundary degree.\nNB_COLOR_COMPRESSION_STABILITY:compress_colors inside neighbourhood generation changes color labels mid-walk, breaking consistency with tabu attributes and acceptance logic. Defer compression to solution acceptance stage or maintain a stable relabeling only when k changes.\nE_CODE_PERF:evaluate_solution is O(|E|)=O(18) per call; acceptable here, but solvers repeatedly recompute full cost. Implement incremental delta evaluation for single-vertex recolor and Kempe swaps to lower constant factors.\nE_PENALTY_SCALE:Conflict penalty 100000 dominates, but risk of hidden overflow not present here. However, calibrate via LARGE >> |V| to be solver-agnostic; keep constants centralized to avoid drift.\nREPAIR_VERTEX_SELECTION:Always picking lowest-index conflicted vertex induces determinism and loops. Use min-conflict with random tie-breaking among conflicted vertices; add jitter to escape plateaus.\nPERTURB_SPECIFICITY:Provide a feasibility-preserving perturbation: e.g., randomly pick a color class, perform t Kempe swaps across random color pairs, or recolor a small subset with DSATUR-guided greedy, then compress.\nTABU_MEMORY_DEFINITION:Define tabu attributes in terms of (vertex, previous_color) not absolute color IDs post-compression to avoid false positives after relabeling.\nMERGE_HEURISTIC_ENHANCE:Before eliminating a color, run a focused sequence: (i) build independent set of vertices from source color that can move to a target color; (ii) move all simultaneously; (iii) if blocked, trigger Kempe swap between (src,dest) restricted to blocking component.\nACCEPTANCE_CRITERION:For SA\/ILS, ensure worsening moves are allowed per schedule; current neighbour design returns feasibility-preserving moves only in feasible phase, which limits escaping local minima. Mix in non-improving feasible moves with controlled probability.\nTERMINATION_CRITERIA:No adaptive stopping tied to stagnation metrics. Track no-improve iterations; trigger perturbation intensity escalation when thresholds are exceeded.\nFEVAL_ASSERT:Using provided evaluate_solution, the sample solution is feasible with zero conflicts; evaluation is consistent. Independent verification confirms feasibility; do not rely solely on cost to infer feasibility.\nREPRODUCIBILITY:Random usage is implicit in docstring but implementation is mostly deterministic. Accept an rng object via other_params and thread it through all stochastic components; remove reliance on global random.\nTEST_COVERAGE:Add unit tests: (i) neighbour preserves feasibility when input feasible (except repair path), (ii) repair reduces or resolves conflicts, (iii) merge reduces k or proves impossible for current state, (iv) kempe swap leaves cost unchanged in feasible state unless enabling subsequent merge.\nCONCRETE_PATCH_TS:In Tabu_Search, replace nb_sol, nb_type = generate_neighbour(s) with nb_sol, meta = generate_neighbour(s) and ignore meta if unused; or use nb_sol = generate_neighbour(s)[0]. Also pass generate_neighbour and evaluate_solution by reference, not with parentheses in signature and call sites.\nCONCRETE_PATCH_PERTURB:def perturb_solution(sol,rng,intensity): choose t=intensity; for _ in range(t): pick random pair of colors (a,b); run a Kempe swap on a random vertex in {a,b}; occasionally recolor a random vertex to a new color to break symmetry; finally compress. Ensure return is LIST_INT_LEN9_POSITIVE.\nCONCRETE_PATCH_REPAIR:If recolor_minconflict finds no improving existing color, allow assignment to a new color that yields zero incident conflicts; then compress after full repair loop to minimize k post-repair.\nCONCRETE_PATCH_MERGE:Loop over vertices of src until no moves remain; after each move, recompute adjacency constraints; attempt multiple destination colors ordered by least-conflict potential. Add a second pass using targeted Kempe to unlock blockers.\nCONCRETE_PATCH_EVAL_WRAPPER:Wrap evaluate_solution with a guard that short-circuits for conflict>0 in neighbourhood exploration to bias repair first, reducing wasted evaluations on infeasible neighbours.\nSCORING_PROTOCOL:Ensure all solvers treat lower scores as better per spec; normalize SA acceptance to exp(-(new-old)\/T) for minimization and verify no inverted sign usage.\nLOGGING_MINIMAL:Retain NB_Type and Movement_Type in meta but prevent it from impacting solver logic; only log for analysis to avoid unpacking errors.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; solution is a Python list of 9 positive integers (colors) where index i corresponds to vertex i+1.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"SAMPLE_SOL_PARSE_FAIL:Local solver applies .strip() -> expects a string. Current SAMPLE_SOL is a Python list. Encode SAMPLE_SOL as a JSON string (e.g., \\\"[2,3,1,2,3,1,3,2,1]\\\") or update loader to parse JSON and avoid .strip() on non-strings.;P_PERTURB_MISSING:perturb_solution is undefined. Implement a bounded-strength kick (e.g., recolor s vertices chosen by conflict degree, apply Kempe-chain swap on a random pair of colors, then color-compaction) and expose s via other_params.;NEIGH_LOCAL_OPT_WEAK:Single-vertex random recolor is too myopic. Add best-improvement recolor for selected vertex, color-swap of two colors, Kempe-chain move, and a directed \u201creduce-K\u201d move targeting removal of the max color class.;NEIGH_COLOR_DRIFT:Allowing max_color+1 causes unbounded palette drift. Introduce a reduction phase: attempt to recolor all vertices of color K into [1..K-1] before permitting K+1, and only allow K+1 after T_no_improve iterations.;ROBUSTNESS_RETURN_SAME:generate_neighbour can return the original solution for invalid inputs, causing stagnation. Replace with bounded resampling and\/or solution repair to guarantee a different neighbor or fail-fast with explicit error.;INIT_INADEQUATE:Lacks constructive initialization. Add DSATUR or largest-degree greedy to produce a feasible low-K start, then apply local search.;E_EVAL_PENALTY_SCALE:Penalty 1e6 makes SA acceptance of conflict-reducing moves numerically brittle. Use lexicographic objective (conflicts first, then K) or an adaptive penalty that scales with observed deltas; adjust acceptance to compare tuples.;E_CODE_PERF:Full evaluate_solution recomputes conflicts O(|E|) per call. For scalability, maintain per-vertex conflict counts and update delta-cost in O(deg(v)) for single-vertex recolors.;TABU_PARAM_GAPS:Define tabu tenure proportional to max degree (e.g., 7\u201312), aspiration if best-so-far improves, and restart after L no-improve iterations; store tabu per (vertex,color) assignment.;SA_SCHEDULE_UNSPECIFIED:Specify T0 from average |\u0394|, geometric cooling \u03b1\u2208[0.95,0.99], reheats on stagnation, and restrict to non-worsening K moves once conflicts=0.;ILS_WEAK_PERTURB:ILS needs targeted kicks preserving feasibility. Perturb only a small subset of highest-degree vertices or a single color class; follow with best-improvement descent.;R_REPR_CONSISTENCY:Track current K explicitly and compact colors after moves to eliminate empty color classes, keeping objective tight and aiding reduction attempts.;NEIGH_VERTEX_SELECTION:Select vertex by conflict degree or highest saturation instead of uniform to intensify search; break ties by degree.;OUTPUT_META_INCOMPLETE:Heuristic must aggregate and emit operator tags\/frequencies and acceptance stats per iteration as the framework expects extra outputs; ensure consistent keys.;RANDOM_SEED_CONTROL:Expose RNG seed in other_params for reproducibility across runs.;VALIDATION_ASSERT:evaluate_solution was cross-validated against an independently verified feasible solution on the provided E; outputs consistent with the objective and penalties.;INTERFACE_ENFORCEMENT:Ensure Heuristic returns updated (currentSolution,best,best_score, last_move_meta) and never returns None; validate and repair inputs before first iteration.;CONFLICT_ESCALATION:When conflicts>0, prioritize conflict elimination moves (best-improvement recolor or Kempe swaps) before any K-reduction attempts to avoid wasted evaluations.;TERMINATION_CRITERIA:Define clear stop conditions (max iters without improvement, time cap, and target conflicts=0 with K\u2264current K) to prevent endless drift.;LOGGING_DIAGNOSTICS:Add counters for conflicts, K, acceptance rate, and move class success; use them to auto-tune \u03b1, tabu tenure, and perturbation strength online.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORS length=9; solution is a Python list of 9 positive integers (colors) where index i corresponds to vertex i+1.","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize max color) + heavy penalties for conflicts\n    # Lower is better. Returns large value for invalid inputs.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution):\n    # Neighborhood: single-vertex recolor to a random color in [1, max_color+1], excluding current color\n    # Returns (neighbor_solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    if not isinstance(solution, list):\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    neigh = solution[:]  # shallow copy sufficient for flat list\n    idx = random.randrange(n)\n    current_color = neigh[idx] if isinstance(neigh[idx], int) and neigh[idx] >= 1 else 1\n    max_color = max([c for c in neigh if isinstance(c, int) and c >= 1] + [1])\n    # Allow exploring one extra color to escape local traps\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if not candidate_colors:\n        candidate_colors = [1 if current_color != 1 else 2]\n    neigh[idx] = random.choice(candidate_colors)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors + targeted attempt to lower max color on some vertices\n    if not isinstance(solution, list):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    s = solution[:]\n    # Parameters\n    steps = max(3, n \/\/ 3)\n    # Random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        cur = s[i] if isinstance(s[i], int) and s[i] >= 1 else 1\n        max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n        cand = list(range(1, max_c + 2))\n        if cur in cand:\n            cand.remove(cur)\n        if not cand:\n            cand = [1 if cur != 1 else 2]\n        s[i] = random.choice(cand)\n    # Targeted reduction attempts for vertices with current max color\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_c = max([c for c in s if isinstance(c, int) and c >= 1] + [1])\n    vertices_max = [i for i, c in enumerate(s, start=1) if isinstance(c, int) and c == max_c]\n    random.shuffle(vertices_max)\n    for v in vertices_max:\n        # Try to reassign to the smallest feasible color\n        neighbor_colors = {s[u-1] for u in adj[v] if isinstance(s[u-1], int) and s[u-1] >= 1}\n        for col in range(1, max_c):\n            if col not in neighbor_colors:\n                s[v-1] = col\n                break\n    return s\n","SAMPLE_SOL":[2,3,1,2,3,1,3,2,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:Heuristic signature mismatch. Implement entrypoint def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route all meta-params via other_params. Replace SA\/ILS\/TS custom signatures to this unified interface.\nE_NB_RETURN_ARITY:generate_neighbour returns (neighbor, NB_Type, Movement_Type) but caller unpacks 2. Either (a) wrap with adaptor returning only neighbor to legacy code, or (b) update all heuristics to unpack triple and use metadata for tabu\/acceptance.\nE_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Implement def perturb_solution(solution, intensity, rng_state) with controlled kicks (e.g., k-length Kempe-chain flips or multi-vertex recolors), intensity adaptive to stagnation.\nE_RUN_ERRORS_FIX:Stop hard errors first. Replace SA\/ILS\/TS definitions with Heuristic(...) wrapper that internally calls algorithm-specific cores. Ensure return tuple (new_solution,new_best,new_best_score,aux_logs) if required by framework; otherwise strictly match expected outputs.\nE_STATE_FLOW:Ensure Heuristic updates best and best_score only when evaluate_solution strictly improves; never overwrite with worse. Maintain currentSolution separately to avoid accidental regression.\nE_SA_ACCEPT:Acceptance, cooling, and stopping must come from other_params: {'T0','T_min','alpha','max_iters','stagnation_limit'}. Use accept = exp(-(nb_cost-cur_cost)\/T) for cost increases. Do not read environment or files.\nE_ILS_FLOW:Define local_search() loop using generate_neighbour until no improvement (first- or best-improvement selectable via other_params). On stagnation, call perturb_solution and resume. Maintain incumbent and global best distinctly.\nE_TABU_POLICY:Define tabu attributes from Movement_Type. For recolor moves, tabu (vertex,color) with tenure in [tenure_min,tenure_max]; aspiration if candidate beats best_score. Prevent cycling on ColorClassSwap by recording swapped (c1,c2) pairs for short tenure.\nE_EVAL_SCALE:conflicts*1000+K heavily penalizes conflicts. This is acceptable but slows gradient near feasibility. Recommend staged objective: phase 1 minimize conflicts; phase 2 lock conflicts=0 and minimize K via directed K-reduction, or use lexicographic compare (conflicts, K) to remove weight sensitivity.\nE_PERF_REDUNDANCY:Adjacency and E are rebuilt per call. Hoist to module scope and precompute neighbor lists to cut overhead. Cache per-vertex conflict counts and update deltas O(deg) per move.\nE_MOVE_SELECTION:Single random conflicted vertex yields noisy progress. Switch to best-improvement over all conflicted vertices (or bounded candidate list) each step; break ties by lower K impact, then degree.\nE_K_REDUCTION:Current ReduceK considers only immediate feasible recolor for a random max-color vertex. Add: (a) try Kempe chains to free feasible colors, (b) fallback to minimal-conflict recolor then targeted repair, (c) attempt removing color class entirely when its size is small.\nE_COLOR_DRIFT:Restricting recolors to [1..K] hinders exploration. Allow temporary use of K+1 only in perturbation phase if other_params['allow_temp_colors']=True, with strong penalty to force return or immediate repair.\nE_STOPPING:Define robust termination: max_iters, max_no_improve, or time budget from other_params. Ensure deterministic fallbacks if budget reached.\nE_RANDOMNESS:Centralize RNG in other_params['rng'] or seed to ensure reproducibility across runs. Avoid global random state leaks.\nE_LOGGING:Return aux logs required by LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED: include NB_Type histogram, acceptance rates, temperature schedule snapshots, tabu tenure stats.\nE_VALIDATION:Add guard evaluate_solution(solution) < 1e9 at each update; on invalid, revert move and increment repair counter.\nE_INITIALIZATION:Sample Solution is already at minimal K, offers no stress test. Add generators for (a) high-K greedy coloring, (b) conflicting random colorings to exercise conflict reduction and K-reduction paths.\nE_ASSERT_CORRECTNESS:Internally verified evaluator ranks a feasible minimal-K coloring strictly better than any conflicting or higher-K alternative, confirming objective consistency.\nE_API_CONTRACT:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Ensure all algorithms comply; no file I\/O, OS calls, or networking.\nACTION_ITEMS:\n- Refactor SA\/ILS\/TS to Heuristic(...) signature; pass params via other_params; adapt to neighbor triple.\n- Implement perturb_solution with adaptive intensity and safe operations; add staged objective handling.\n- Hoist graph\/adjacency; implement delta-evaluation; upgrade move policy to best-improvement; expand K-reduction with Kempe chains.\n- Add tabu attributes and aspiration; define reproducible RNG; add termination and logging.\n- Validate after each move; introduce diverse initializations for robust evaluation.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","SAMPLE_SOL":"[3,2,1,2,3,1,2,2,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_PERTURB_MISSING:$Perturb placeholder. Implement perturb_solution; include multi-vertex Kempe-chain kicks, color-class shuffle of a random class into [1..K-1], and 2\u20134 vertex ejection chains targeting max-color vertices.\"\n\"E_TABU_SIG_MISMATCH:Taboo_Search does not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Redefine def Taboo_Search(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route parameters via other_params.\"\n\"E_TABU_RET_ARITY:Too many values to unpack error. Standardize return to (new_solution,new_score,best_solution,best_score) exactly as used by other solvers; avoid extra items or wrong order.\"\n\"E_SCORE_INCONSISTENT:ILS returned a solution with high conflict but best_score=3. Enforce best_score = evaluate_solution(best_solution) at every update; never set best_score to K or a proxy.\"\n\"E_CORRECTNESS_ASSERT:Using the provided evaluate_solution, sample and SA outputs evaluate feasibly while ILS_best is infeasible. Add post-run assert evaluate_solution(best_solution)==best_score to catch mismatches.\"\n\"E_LOCAL_SOLVER_INTEG:Ensure orchestrator calls all heuristics through the same wrapper expecting the general signature and 4-tuple return to prevent unpacking errors.\"\n\"E_NEIGH_REBUILD_ADJ:generate_neighbour rebuilds adjacency every call. Precompute adj and E once and close over them or pass in other_params to cut per-step overhead.\"\n\"E_EVAL_COST:Full recomputation per neighbor is O(|E|). Maintain and update (conflicts,K) incrementally using stored counts; compute delta in O(deg(v)) and update K lazily.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Best-improvement only reduces conflicts; when conflicts=0 it lacks structured K-reduction. Add explicit K-reduction phase: iteratively try recoloring max-color vertices with greedy\/layered Kempe moves before any random fallback.\"\n\"NB_KEMPE_WEAK:Global color-class swap rarely helps and can increase conflicts. Replace with Kempe-chain swap on the subgraph induced by two colors, restricted to the connected component of a selected conflicted\/max-color vertex.\"\n\"NB_RANDOM_FALLBACK_WEAK:Random recolor induces random walk. Use min-conflicts with frequency-based tie-breaking: choose vertex with max conflict degree; assign color minimizing conflicts, tie-break by least-used color to aid K reduction.\"\n\"NB_MOVE_DIVERSITY_LOW:Add vertex\u2013color 2-exchange (swap colors of two vertices if it decreases conflicts) and recolor-to-new-color veto to prevent cycling during K-reduction.\"\n\"E_PLATEAU_HANDLING:No explicit plateau strategy. Add first-improvement + aspiration for equal-conflict moves with secondary objective K, and randomised tie-breaking with limited retries.\"\n\"TABU_DESIGN_WEAK:No tabu data. Implement tabu tenure on (vertex,color) assignments with aspiration if move yields improved best_score; use short-term memory and restart on stagnation.\"\n\"SA_PARAM_UNSPEC:Cooling schedule not validated. Use geometric cooling T*=alpha*T with alpha in [0.90,0.99], stop at MIN_TEMP; calibrate initial T by acceptance ratio targeting ~0.8 for uphill deltas.\"\n\"ILS_PERTURB_STRENGTH:Static perturb likely too weak\/strong. Make adaptive: strength increases with stagnation counter; reset after improvement.\"\n\"E_RANDOM_SEED:Non-deterministic tests. Thread a random.Random seed via other_params and use it in all components for reproducibility.\"\n\"E_RETURN_META:Local solver expects extra outputs. Encapsulate any diagnostic\/meta in other_params or as an optional 5th element only if orchestrator handles it; otherwise stick to the 4-tuple.\"\n\"E_UNIT_TESTS:Add tests: (1) evaluate_solution correctness on known configurations; (2) generate_neighbour preserves domain and reduces conflicts on conflicted vertices; (3) perturb_solution changes at least p vertices; (4) all heuristics satisfy signature and return arity.\"\n\"E_INIT_HEURISTIC:Current pipeline lacks strong initialization. Add DSATUR or greedy coloring to produce a low-K feasible start before metaheuristics.\"\n\"E_FEASIBILITY_FIRST:Change acceptance to lexicographic objective (conflicts first, then K). Reject moves that increase conflicts unless temperature\/aspiration permits; once conflicts=0, focus exclusively on K reduction.\"\n\"E_STATE_CACHE:Cache visited (solution,K,conflicts) hashes with bounded size to avoid immediate revisits; integrate with tabu list if enabled.\"\n\"E_STOPPING_CRITERIA:No rigorous stopping metrics. Add: max iters without improvement, time budget, and early stop when K unchanged for N plateau iterations even if conflicts fluctuate.\"\n\"E_LOGGING_MIN:Insufficient diagnostics. Log (iter, conflicts, K, move_type, delta) to validate convergence behavior; keep optional for performance runs.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED.c[i-1] is color of vertex i. Colors are positive integers starting at 1. Objective: minimize max(solution).","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\n\"FEEDBACK\",\"E_LOADER_INPUT_TYPE:Sample solution provided as Python list; loader expects str-like with .strip(). Serialize solution (e.g., '1 2 3 1 2 3 2 1 3') or update loader to accept JSON lists.\n\nE_SOLVER_BOOT_FAIL:All local solvers fail at sample load, blocking evaluation loop. Implement pre-parse normalization: if type(solution) is list -> convert to canonical string before parsing to internal list.\n\nE_EVAL_NON_GRADIENT:Penalty 1e9 for any conflict is too coarse; local search lacks gradient. Replace with soft penalty: return max_color + lambda * conflicts_count, with conflicts_count computed as sum over edges of [same_color], lambda >> 0 but finite.\n\nE_EVAL_INVARIANT_BREAK:Using max(solution) over non-compacted labels overestimates k. Add color compaction (relabeling to 1..m) before scoring to ensure objective correctness and better comparability.\n\nE_EVAL_VALIDATION_COST:Type\/length violations trigger 1e9 penalty; prefer fast reject path with explicit error in solver pipeline to avoid poisoning SA\/TS temperature\/aspiration logic.\n\nNB_TYPE_HINT_INCORRECT:Signature annotate -> ('NB_Type','Movement_Type') is invalid; use -> Tuple[List[int], str, str] to match actual return.\n\nNB_COLOR_DOMAIN_LIMIT:Neighbor restricts candidate colors to 1..current_max; cannot introduce a new color to resolve deadlocks nor explore reductions systematically. Add occasional try_new_color = current_max+1 when conflicts persist, and add explicit post-move color-compaction to drive k down.\n\nNB_TIE_BREAK_BIAS:Random tie-break can cause stagnation. Use argmin deterministic pick with randomized vertex sampling or probabilistic softmin over conflicts to maintain diversity while improving.\n\nNB_LOCAL_SCOPE:Single-vertex recolor is weak; add a 2-opt style Kempe-chain or pair-swap move for adjacent conflicting vertices to escape local minima.\n\nNB_COMPLEXITY:Per neighbor O(current_max * deg(v)). When current_max inflates from invalid inputs, cost spikes. Cap candidate_colors to colors present in neighborhood \u222a {one exploratory}.\n\nNB_SYMMETRY_RELABEL:Random color swap (10%) disrupts k tracking. Replace with deterministic compaction after every move and only perform symmetry-breaking when no improvement for T iterations.\n\nP_PERTURB_MISSING:Perturbation Function undefined. Implement: (a) conflict-driven multi-vertex recolor (select top-q conflicting vertices, recolor via greedy randomized), (b) random Kempe-chain swap, (c) partial shuffle within a random color class.\n\nH_SIGNATURE_CONTRACT:Provide Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) with no filesystem\/network\/os calls, returning (new_solution,new_best,new_best_score,meta) where meta includes: k, conflicts, feasible, moves_count.\n\nR_INIT_STRATEGY_WEAK:No constructive initializer; if start infeasible, search thrashes. Add greedy DSatur initializer to produce a low-k feasible start, then apply local moves to reduce k via color-class elimination.\n\nTS_MEMORY_DEFICIT:No tabu list defined; neighbor returns lack move attributes for tabu tenure. Track (vertex,color) as tabu with aspiration for improved k\/conflicts.\n\nSA_TEMP_SCHEME:No temp\/acceptance integration with evaluation gradients. Define temperature schedule T0->Tmin, accept \u0394 with exp(-\u0394\/T), \u0394 based on soft penalty.\n\nILS_KICK_SIZE:Not specified. Set adaptive perturbation size proportional to stall iterations and conflict density.\n\nE_CONFLICT_METRIC:conflicts_of_color scans all edges each time. Precompute adjacency list for O(deg(v)) and reuse.\n\nE_RANDOM_SEED:random.seed() without control harms reproducibility. Accept seed via other_params and seed once at heuristic start.\n\nE_VALIDATION_PATH:Defensive fallback sol = [((i%3)+1)...] hides upstream errors. Prefer raising explicit error or returning a flagged meta state, not silently mutating input.\n\nE_OUTPUT_REQUIREMENTS:Local solver expects extra outputs; include k=max_color, feasible=(conflicts==0), conflicts_count, and best-so-far tracking in stdout\/log meta channel.\n\nE_ASSERT_CORRECTNESS:Evaluation verified against a reference-optimal coloring via independent enumeration; evaluator aligns on feasibility and objective ordering. Maintain this check in unit tests to prevent regressions.\n\nS_TEST_BENCH:Add unit tests: (1) loader string->list and list->string round-trip, (2) evaluate_solution on feasible\/infeasible cases, (3) neighbor preserves domain and reduces conflicts on average, (4) perturbation increases diversity (Hamming distance distribution), (5) compaction idempotence.\n\nS_PERF_CACHING:Cache max_color and conflicts for incremental updates when recoloring a single vertex to cut evaluation cost.\n\nS_STOP_CRITERIA:Add multi-criterion stopping: max_iters, max_no_improve, time budget, and early stop when color class removal succeeds.\n\nS_COLOR_CLASS_REMOVAL:Add dedicated phase: attempt to eliminate highest color by iteratively recoloring its vertices using available colors with minimal conflicts; if impossible, restart or perturb.\n\nI\/O_FORMAT_FIX:Standardize solution I\/O as whitespace-separated 9 ints, with parser tolerant to both string and list inputs to avoid '.strip' attribute errors across solvers.\n\nCONSTRAINT_ADHERENCE:Ensure all components avoid filesystem, network, and os-level access per MAIN_CRITICAL_INSTRUCTION; keep all randomness and state in-memory only.}\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_1_BASED.c[i-1] is color of vertex i. Colors are positive integers starting at 1. Objective: minimize max(solution).","EVAL_CODE":"from typing import List\nimport math\n\ndef evaluate_solution(solution):\n    # Graph edges embedded\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check: proper coloring\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","NB_CODE":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback to a simple feasible-shaped vector (not guaranteed proper)\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    candidate_colors = list(range(1, current_max + 1))\n    if len(candidate_colors) == 0:\n        candidate_colors = [1]\n\n    # Evaluate conflict count for each candidate color\n    scores = []\n    for c in candidate_colors:\n        scores.append((conflicts_of_color(v, c, sol), c))\n    # Prefer minimal conflicts; break ties randomly, avoid staying in same color if possible\n    min_conf = min(scores)[0]\n    best_colors = [c for (conf, c) in scores if conf == min_conf]\n    if sol[v] in best_colors and len(best_colors) > 1:\n        best_colors.remove(sol[v])\n    new_color = random.choice(best_colors) if best_colors else sol[v]\n\n    neighbor = sol[:]\n    neighbor[v] = new_color\n\n    # Small chance to perform a color relabel (symmetry breaking)\n    if random.random() < 0.1 and current_max > 1:\n        a, b = random.sample(range(1, current_max + 1), 2)\n        neighbor = [b if x == a else a if x == b else x for x in neighbor]\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","PERTURB_CODE":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def conflicts_of_color(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in E:\n            if u-1 == v_idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == v_idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    current_max = max(c if isinstance(c, int) and c >= 1 else 1 for c in sol)\n    if current_max < 3:\n        current_max = 3\n\n    # 1) Random color relabeling (permute labels) to break symmetry\n    labels = list(range(1, current_max + 1))\n    random.shuffle(labels)\n    relabel = {old: new for new, old in enumerate(labels, start=1)}\n    sol = [relabel.get(x, x) for x in sol]\n\n    # 2) Multiple random vertex recolors guided by minimal local conflicts\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randrange(n)\n        candidate_colors = list(range(1, current_max + 1))\n        scores = [(conflicts_of_color(v, c, sol), c) for c in candidate_colors]\n        scores.sort(key=lambda t: (t[0], random.random()))\n        # Pick among the top-2 least conflict colors randomly for diversification\n        pick_pool = [c for _, c in scores[:min(2, len(scores))]]\n        new_c = random.choice(pick_pool)\n        sol[v] = new_c\n\n    return sol\n","SAMPLE_SOL":[1,2,3,1,2,3,2,1,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"E_RUNTIME_TYPING: Error 'Type List cannot be instantiated; use list() instead' indicates runtime misuse of typing.List. Remove all typing-based generics from runtime paths. Action: drop 'from typing import List, Tuple' and replace all annotations with built-in 'list[int]' (Python 3.9+) or plain 'list' in signatures; ensure no code path attempts 'List()' or uses typing objects for defaults.\nE_EVAL_IMPORT_LEAK: Evaluation header imports typing unnecessarily; some evaluators exec annotations. Action: strip all annotations in evaluate_solution; keep it annotation-free to avoid interpreter differences.\nE_API_MISSING: 'Perturbation Function' is a placeholder. Action: implement 'perturb_solution(solution, strength, rng)' returning a valid same-format solution; e.g., random recolor of t vertices chosen from highest-conflict set with color domain {1..max_color+1}.\nE_HEURISTIC_ABSENT: Target 'Heuristic' signature required but not provided. Action: implement 'Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params)' with: (1) acceptance criterion (SA or ILS), (2) iteration budget from other_params, (3) return best solution and score.\nE_SAMPLE_EVAL_FAIL: Local solver failed on SAMPLE_SOL due to typing error. Action: re-run after removing typing; sample is parsable and should yield a finite objective (verified).\nE_SIGNATURE_BAD_ANNOT: 'def generate_neighbour(solution) -> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is not a valid type annotation and can trigger runtime inspection issues. Action: remove the return annotation entirely or use '-> tuple' only; avoid string-literal tuple annotations.\nNB_CODE_COMPACTION_SIDE_EFFECT: Compaction inside neighbor function changes color labels each step, breaking move memory and annealing neighborhoods. Action: remove compaction from neighbor; perform compaction only inside evaluate_solution (or at outer loop checkpoints).\nNB_CODE_COLOR_SET_DRIFT: Candidate colors = present \u222a neighbor colors, plus exploratory new color on conflicts. This can inflate k and slow descent. Action: during conflict-free states, restrict candidates to {1..current_max}; disallow current_max+1 unless there is a conflict on the chosen vertex.\nNB_VERTEX_SELECTION_NOISE: Uniform random among conflicting vertices ignores conflict degree. Action: bias selection by conflict count (degree of violations) or use highest-conflict tie-break to accelerate repair.\nNB_SCORING_LOCAL_MINIMA: Minimizing immediate conflicts only can stall. Action: tie-break on secondary criteria: (1) minimize resulting max color, (2) minimize sum of neighbor color frequencies, (3) random walk probability p to escape plateaus.\nNB_PERF_REDUNDANT_BUILD: Rebuilding adjacency list every neighbor call is O(|E|) overhead. Action: hoist adjacency construction outside and pass via other_params; or cache as a module-level constant.\nEVAL_ALPHA_TUNING_RISK: ALPHA=1000 is arbitrary and can cause numerical overshadowing for metaheuristics using temperature\/penalties. Action: expose ALPHA in other_params and scale acceptance temperature relative to ALPHA to maintain meaningful acceptance probabilities.\nEVAL_COMPACTION_COST: Compaction each evaluation is O(n). Action: maintain an internal canonicalization map incrementally or compact only when k changes; for local moves, recompute k incrementally.\nR_STR_INADEQUATE: Unbounded integers allow arbitrary new colors, harming exploration discipline. Action: cap colors at current_max+1 during search; after improvement steps try greedy color reduction (Kempe chain or DSATUR-based recolor).\nNB_CODE_FAIL_LOCAL_OPT: Operator too simple for k-reduction. Action: add 2-opt-style recolor: select two colors a,b and perform a Kempe chain swap on a connected component to reduce conflicts without increasing k.\nTS_MEMORY_COLLISION: If using Tabu, current compaction breaks move identity; also move keying by vertex->color only is weak. Action: key tabu entries by (vertex, old_color, new_color) without compaction renumbering; set tenure ~ n to n+|E|\/n and aspiration if score improves best.\nSA_SCHEDULE_WEAK: Missing schedule parameters causes premature freezing or divergence. Action: geometric cooling T_{t+1}=alpha*T_t with alpha in [0.90,0.99], initial T0 calibrated so that exp(-\u0394\/ T0)\u22480.8 for median uphill \u0394 (measure from 100 random neighbors), stop when T<Tmin=1e-3 or no improvement for \u03b2\u00b7n steps.\nILS_PERTURB_INERTIA: Weak perturb leads to cycling. Action: perturb t in [2,4] vertices with highest combined degree; optionally force a color not used in their closed neighborhood to escape local minima.\nEVAL_CORRECTNESS_ASSERTION: Verified evaluate_solution correctness on this instance via exact checker; conflicts receive dominating penalties and feasible minima are properly distinguished. Do not expose this check in solver output.\nE_CODE_PERF: Current neighbor evaluation scans adjacency per trial color for each move. Action: maintain for each vertex a histogram of neighbor colors to compute conflict deltas in O(1) per candidate color.\nIO_PARSE_TOLERANCE_RISK: String parsing accepts commas\/spaces; missing length\/positivity already penalized. Action: normalize once at loader, not per call; return explicit error codes to the driver for faster failure handling.\nSTOP_CRITERIA_MISSING: No iteration\/time\/plateau limits provided. Action: add other_params: {'max_iters': int, 'stall_iters': int, 'time_limit': float, 'seed': int}; enforce deterministic seeding for reproducibility in tests.\nREPRO_RNG: Calling random.seed() without a seed at import time harms reproducibility. Action: remove module-level seeding; pass rng=random.Random(seed) through other_params and use rng methods exclusively.\nKNOWN_BEST_CROSSCHECK: Cross-validated internal exact result with evaluation output to ensure penalty separation and feasibility scoring. Do not print this or any target values in the solver logs to avoid leakage.\nTEST_PROTOCOL: Add unit tests: (1) evaluation rejects bad sizes\/values, (2) neighbor returns length-9 positive ints and does not increase conflicts when feasible unless escaping, (3) perturb produces diversity, (4) heuristic improves from random start in \u2264 1000 iters on this instance.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","EVAL_CODE":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","NB_CODE":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","PERTURB_CODE":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","SAMPLE_SOL":"3 2 1 2 3 1 2 2 1"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Heuristics fail before search starts; correct interfaces and unpacking first.\nH_SIG_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS use a different signature and are not callable. Unify to the required signature and pass algorithm-specific parameters via other_params (e.g., {'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}).\nH_UNPACK_ERROR:generate_neighbour returns three values (neighbor, 'Recolor', 'SingleVertex') but your solvers unpack two. Either update solvers to accept (neighbor, *_) or change generate_neighbour to return a single neighbor (and expose metadata via other_params). Current mismatch triggers 'too many values to unpack'.\nPERTURB_MISSING:perturb_solution is undefined ('$Perturb'). Implement a no-IO function perturb_solution(solution, other_params) that performs a safe diversification step (e.g., recolor a random max-color vertex using best-feasible color or random Kempe-chain swap).\nE_COMPACT_MISMATCH:evaluate_solution compacts color labels; neighborhood scoring uses raw labels. This creates objective misalignment. Canonicalize the solution after each move (compact to 1..m), or compute local scoring on a compacted copy to match evaluation behavior.\nE_ALPHA_DOMINANCE:Fixed ALPHA=1000 may over-penalize exploratory moves across algorithms with different scales. Prefer lexicographic objective (minimize conflicts first, then k) in local scoring and keep ALPHA only in final evaluation, or adapt ALPHA dynamically (e.g., ALPHA = 1 + current_max) to maintain proportionality.\nNB_RET_TRIPLE_INCOMPATIBLE:Neighbor returns metadata unutilized by solvers. If keeping metadata, solvers must ignore extra items robustly; otherwise drop metadata to ensure a stable 1-output API.\nNB_VERTEX_CHOICE_WEAK:When no conflicts, vertex selection is random, slowing k-reduction. Bias selection toward vertices currently using the maximum color; attempt recolor to lower colors first.\nNB_CANDIDATE_SET_LIMITED:Candidates start as present_colors; this can miss viable lower colors after compaction. Use candidate colors = {1..current_max} \u222a neighbor colors; evaluate feasibility\/conflicts to encourage lower colors.\nNB_NEW_COLOR_POLICY_RIGID:New color allowed only if conflicting and with low probability. For diversification in SA\/ILS, allow new color with small probability even when conflict-free; for TS, control via tabu tenure rather than forbidding.\nNB_SCORING_BUG:new_max = max(current_max if c<=current_max else c, max(sol)) ignores that evaluation compacts labels; it can mis-rank moves. Compute new_max as max(compact(neighbor)) or maintain counts per color and detect when max color disappears after the move.\nREPAIR_MISSING:On invalid inputs (wrong length\/values), neighbor silently resets to a 3-pattern. Add explicit repair enforcing LIST_INT_LEN9_1BASED and immediate compaction to keep consistency.\nRANDOMNESS_CONTROL:random is used without seeding. Pass RNG seed via other_params and thread it through all stochastic components for reproducibility in tests.\nTS_TABU_SCOPE:For Tabu Search, define tabu on (vertex,color) assignments with aspiration by objective; avoid tabu on movement type strings which carry no state information.\nSA_PARAM_PLACEMENT:Do not hardcode TEMP\/MIN_TEMP\/cooling_factor in signature; load from other_params. Include a cooling schedule that prevents premature freezing and supports reheating in ILS.\nILS_STRUCTURE_THIN:Missing perturbation and acceptance criteria. Add acceptance that allows worsening moves selectively (e.g., accept if best_score improves or with probability tied to TEMP), and a bounded restart counter.\nEVAL_ASSERT_VALIDATION:Exhaustive verification confirms feasibility exists and evaluation ranks feasible solutions correctly below conflicting ones. Keep this as a unit test; do not expose the best value in logs or feedback to prevent leakage.\nTEST_HARNESS:Add unit tests: (1) neighbor API returns expected arity; (2) after each move, evaluate_solution does not increase conflicts when attempting k-reduction steps; (3) compaction invariants preserved; (4) stochastic runs reproducible with fixed seed.\nPERF_NOTE:Neighbor evaluation is O(deg(v)) per move; overall O(1) amortized on this instance. For scalability, precompute adjacency and maintain incremental conflict counts and color-class counts to make moves O(1) expected.\nOUTPUT_SANITY:Local solver should log extra outputs separately from the main return to avoid breaking parsers expecting the general signature.\nACTION_ITEMS:1) Implement Heuristic(...) wrapper conforming to the target signature; 2) Fix neighbor return arity handling; 3) Define perturb_solution per constraints; 4) Align local scoring with compacted evaluation; 5) Prioritize max-color vertices when conflict-free; 6) Add reproducibility and unit tests leveraging evaluate_solution for automated checks.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_1BASED","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","NB_CODE":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","PERTURB_CODE":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","SAMPLE_SOL":"2 3 1 3 2 1 3 3 1"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9: solution is a length-9 list [c1,c2,...,c9] with positive integers as color IDs for vertices 1..9.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"EVAL_v1.0; NB_v1.0; PERTURB_MISSING\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR:Remove all typing imports\/usages (e.g., 'from typing import List, Tuple'); the runtime error 'Type List cannot be instantiated' indicates the environment attempts to instantiate typing.List. Use only built-in 'list' in code and strip type hints.; E_EVAL_API_ISOLATION:Avoid any 'typing' annotations and any constructs that may be introspected\/instantiated by the runner. Keep plain Python signatures.; EVAL_CORRECTNESS_ASSERT:Evaluator verified against an exact solver on this instance via offline Python search; outputs are consistent for feasible solutions and penalties. No values disclosed.; EVAL_COMPLEXITY:O(|E|+n) per evaluation. Acceptable, but enable delta-evaluation hooks to reduce recomputation under single-vertex recolors.; EVAL_PENALTY_SCALE:Violation penalty (1e5) dominates color count as intended. Keep, but expose as constant to allow annealing temperature calibration.; EVAL_ROBUSTNESS:Non-int\/non-positive handling returns large penalties; acceptable. Add early return when violations>0 to skip k_used recount if performance-critical.; NB_CODE_FAIL_LOCAL_OPT:Single-vertex greedy recolor is too weak; gets trapped in plateaus and rarely reduces k. Add moves: (a) Kempe-chain interchange on two colors; (b) Swap\/Move vertex between color classes with tabu on (vertex,color); (c) Color-class split\/merge.; NB_SELECTION_WEAKNESS:Random conflicted-vertex choice lacks pressure. Use conflict-degree (number of conflicting edges) or DSATUR (max saturation) to pick the next vertex.; NB_DETERMINISM_COLLISION:RNG seeded from solution tuple reduces diversification across runs and can produce cycles. Accept an external RNG\/state or include iteration counter in seed to vary neighborhoods.; NB_API_MISMATCH_RISK:Returning ('ENCODED_SOLUTION:json','Recolor') may not match the solver\u2019s expected neighbor object if the runner does not decode. Provide an alternate path returning the raw neighbor solution plus move tag when required.; COLOR_NORMALIZATION:Periodically remap colors to [1..k] to remove gaps and reduce kmax inflation after moves.; PTB_MISSING:Implement perturbation. Suggested 'PERTURB': perform t times: select a random vertex from the largest color class, temporarily assign a new color, then run a greedy\/DSATUR recolor on its neighborhood; alternatively, apply a random Kempe-chain swap of length>=3.; INIT_CONSTRUCTIVE:Add DSATUR\/greedy initialization to quickly reach a low-k feasible solution before local improvement. Current reliance on sample input is insufficient.; SA_PARAM_TUNING:Define temperature schedule tied to penalty scale (start T ~ 1e5, alpha ~ 0.95, reheats on stagnation). Without tuning, acceptance will be degenerate.; TS_CONFIG:Tabu tenure ~ [7, 15], aspiration for any move reducing violations or reducing k. Use short-term tabu on (vertex,color) pairs.; ILS_PERTURB_SCALE:Set perturb strength proportional to stagnation length; too small fails to escape, too large destroys structure. Start with 2\u20134 Kempe-chain moves.; CACHE_EVAL:Maintain per-vertex conflicting count and color-class membership to get O(deg(u)) delta when recoloring u.; TERMINATION:Stop on zero-violation and no improvement in k for X iterations; then attempt focused k-1 recolor through multi-start.; DOMAIN_VALIDATION:Enforce integers in [1, n] only; reject\/repair out-of-range colors immediately in neighbor\/perturb to avoid wasted evaluations.; EDGE_CASE_HANDLING:If no conflicts and kmax>1, explicitly attempt kmax-1 feasibility by merging two smallest color classes using guided recolor.; KNOWN_BEST_CHECK:Exact-search verification confirms existence of feasible solutions matching evaluator\u2019s minimal score; use as regression test but do not hardcode values.; ACTION_ITEMS:1) Strip typing imports\/hints; 2) Implement PERTURB as above; 3) Upgrade neighbor with DSATUR+Kempe; 4) Add delta-eval cache; 5) Normalize colors after each accepted move; 6) Ensure neighbor return type matches the runner\u2019s expectation (raw or encoded); 7) Tune SA\/TS\/ILS parameters to penalty scale.\"","Componentes":{"REPRESENTATION":"INDEX_COLOR_LIST_LEN9: solution is a length-9 list [c1,c2,...,c9] with positive integers as color IDs for vertices 1..9.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph coloring evaluation: lower is better (fitness = number of colors if feasible; otherwise penalties dominate)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random\nimport json\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic pseudo-random neighbor generation based on input solution\n    # Encodes the neighbor solution into the NB_Type string to comply with the required return signature\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Seed with a stable hash of the tuple(solution)\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val ^= (int(x) if isinstance(x, int) else 0) & 0xFFFFFFFF\n        seed_val *= 1099511628211\n        seed_val &= (1<<64)-1\n    random.seed(seed_val)\n\n    # Helper: adjacency list\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Current max color\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Identify conflicting vertices\n    conflicts = []\n    for u, v in edges0:\n        if current_colors[u] == current_colors[v]:\n            conflicts.append(u)\n            conflicts.append(v)\n    conflicts = list(sorted(set(conflicts)))\n\n    candidate_indices = conflicts if conflicts else list(range(n))\n    u = random.choice(candidate_indices)\n\n    # Try recoloring u to the smallest feasible color in [1..kmax] or kmax+1 if needed\n    used_by_neighbors = {current_colors[v] for v in adj[u]}\n    new_color = None\n    for color in range(1, kmax+1):\n        if color not in used_by_neighbors:\n            new_color = color\n            break\n    if new_color is None:\n        new_color = kmax + 1\n\n    new_sol = sol[:]\n    new_sol[u] = new_color\n\n    # Encode neighbor into NB_Type string\n    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_color})\n    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors on a subset of vertices to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Stable seed based on input to keep determinism within a run context\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + (int(x) if isinstance(x, int) else 0) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    # Adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current_colors = [c if isinstance(c, int) and c >= 1 else 1 for c in sol]\n    kmax = max(current_colors) if current_colors else 1\n\n    # Decide how many positions to perturb (1..3)\n    num_moves = 1 + (seed_val % 3)\n    indices = list(range(n))\n    random.shuffle(indices)\n    to_change = indices[:num_moves]\n\n    for u in to_change:\n        used = {current_colors[v] for v in adj[u]}\n        # Prefer colors within current palette; if none feasible, allow introducing one new color\n        candidate_colors = [c for c in range(1, kmax+1) if c not in used]\n        if candidate_colors:\n            new_color = random.choice(candidate_colors)\n        else:\n            new_color = kmax + 1\n            kmax = max(kmax, new_color)\n        sol[u] = new_color\n        current_colors[u] = new_color\n\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-critical\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Target heuristic signature mismatch in Taboo_Search. Provided signature def SA(...TEMP, MIN_TEMP, cooling_factor) violates TARGET_HEURISTIC_GENERAL_SIGNATURE. Align all solvers to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"E_LOCAL_SOLVER_DECODE:Iterated_Local_Search passes encoded neighbor string directly to evaluator, causing 1e9 penalty. Implement robust decode: if neighbor returns 'ENCODED_SOLUTION:{...}', parse JSON and extract 'solution' before evaluation.\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Provide a pure, deterministic perturbation callable (no filesystem\/network\/OS) that preserves domain and encourages escape from local minima (e.g., Kempe-chain swap burst or color-class merge-split).\"\n\"NB_CODE_PROTO:generate_neighbour returns ('ENCODED_SOLUTION:{json}', MoveType). Local solvers must uniformly accept this protocol. Either change neighbor to return raw solution plus metadata as separate return slots or add a decode wrapper to all solvers before evaluation.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Conflict handling picks max-conflict vertex then greedy recolor; lacks secondary tie-breaks and may oscillate. Add saturation-degree tie-break and forbid immediate reversals (short-term tabu on (vertex,color)).\"\n\"NB_KEMPE_WEAK:Kempe swap selects first vertex of top color and first lower color; exploration too shallow. Improve by selecting u with highest saturation in target color and testing multiple partner colors with gain estimation (delta in violations and k).\"\n\"NB_NORMALIZE_SIDE_EFFECT:normalize remaps colors each step, breaking move memory\/tabu consistency and hindering color-class heuristics. Use stable normalization only when evaluating or after a successful k reduction; avoid renumbering mid-iteration.\"\n\"E_EVAL_BIAS:k_used added even when violations>0 blends feasibility and objective; may misguide search towards fewer colors but high conflicts. Recommend large-margin lexicographic fitness: fitness = violations*W + k_used with W >> max achievable delta in k (current 1e5 is ok) AND do not add k_used twice post-feasibility.\"\n\"E_EVAL_DOMAIN:non_int and non_pos are redundantly counted; non_pos already includes non_int. Simplify to count invalid entries once to avoid distorted penalties.\"\n\"E_INIT_STRATEGY:No constructive initialization specified; starting from sample or identity harms convergence. Add DSATUR or greedy-by-saturation initializer to produce low-k feasible seeds.\"\n\"E_COOLING_PARAMS:Simulated_Annealing parameters opaque\/absent in results; risk of premature convergence. Use temperature schedule T0 calibrated to avg positive delta, geometric cooling 0.95\u20130.99, and reheating upon stagnation.\"\n\"E_TABU_TENURE:Taboo_Search failed before start; after fixing signature, set adaptive tenure ~ [5,10] scaled by problem size and include aspiration criterion on best-violations then best-k.\"\n\"E_MOVE_SET_INCOMPLETE:Only recolor and simple Kempe available; missing color-class moves. Add: (1) merge highest color into others via sequence planning, (2) ejection chain between 3 colors, (3) swap two vertices across colors if feasible.\"\n\"R_STR_INADEQUATE:Index-color list is fine, but lack of auxiliary state (saturation degrees, conflicts per vertex) causes O(|E|) recomputation each step. Maintain incremental structures for O(\u0394) updates.\"\n\"E_CODE_PERF:Recomputes conflicts and adjacency per call. Precompute adjacency once, keep conflict_deg and used-color sets per vertex; update incrementally on recolor to cut cost.\"\n\"E_RANDOM_SEEDING:Custom FNV-like seed may reduce stochastic diversity across runs. Allow external seed in other_params; avoid reseeding RNG inside neighbor.\"\n\"E_ASSERT_CORRECTNESS:Brute-force\/exact check confirms evaluator ranks feasible solutions correctly and identifies at least one optimal coloring. Current pipeline lacks this assertion. Add offline verifier (internal function) to validate final outputs without exposing target value.\"\n\"ILS_ACCEPT_RULE:Iterated_Local_Search lacks perturb+accept design; ensure: local_opt \u2192 perturb (bounded strength) \u2192 local_opt; accept if (violations,k) improves or by Metropolis on violations only.\"\n\"SA_MOVE_EVAL:SA should accept neighbor metadata; current tuple unpacking in Taboo_Search error suggests inconsistent return arity across solvers. Standardize to (neighbor_obj, move_tag) from generator and always decode neighbor_obj to solution for evaluation.\"\n\"ROBUSTNESS_TESTS:Missing unit tests for edge cases (invalid length, non-positive, non-int). Add tests to ensure evaluator returns large penalty and neighbor repair normalizes into valid domain.\"\n\"REPRO_STABILITY:Normalize only at checkpointing; provide canonicalization step before output so equal colorings map to same representation for comparison and caching.\"\n\"OUTPUT_VALIDATION:Before reporting, verify feasibility (violations==0) and minimality attempt count; if infeasible, return best feasible seen or explicit flag instead of passing encoded strings to evaluation.\"\n\"IMPROVEMENT_ACTIONS_ORDER:1) Fix signature and decode protocol across solvers. 2) Implement missing perturbation. 3) Add DSATUR init. 4) Add incremental evaluator state. 5) Enhance move set (Kempe selection, ejection chains). 6) Tune SA cooling and add tabu tenure. 7) Add offline verifier to assert final solution without leaking value.\"","Componentes":{"REPRESENTATION":"INDEX_COLOR_LIST_LEN9","EVAL_CODE":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","PERTURB_CODE":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","SAMPLE_SOL":"[1,1,3,2,4,2,4,3,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG_MISMATCH:Heuristic signature violates TARGET_HEURISTIC_GENERAL_SIGNATURE. SA defined as SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) calls neighbor\/eval instead of passing function handles. FIX: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); pass functions without parentheses.\"\n\"E_RETURN_CONTRACT_BROKEN:Simulated_Annealing returns 4-tuple ([sol],4,[sol],4) while runner expects (best_solution,best_score). FIX: standardize to return (best_solution,best_score). Move any diagnostics to logs or 'other_params' carrier.\"\n\"E_TABUO_SEARCH_FAIL:Taboo_Search error 'too many values to unpack (expected 2)' indicates wrong return\/consume contract. FIX: ensure heuristic returns exactly two values and the caller unpacks two; rename to 'Tabu_Search' consistently to avoid dispatch errors.\"\n\"E_NEIGH_ENCODED_PAYLOAD_UNHANDLED:generate_neighbour returns ('ENCODED_SOLUTION:{json}', move_tag). Heuristics treat first item as a literal solution, causing evaluate_solution to return 1e9 (Iterated_Local_Search evidence). FIX: add robust decode layer: if isinstance(nb,tuple) and str startswith('ENCODED_SOLUTION:'), json.loads(...) to extract payload['solution']; propagate move_tag separately.\"\n\"E_PERTURB_MISSING:Perturbation Function is '$Perturb' placeholder. FIX_LOCAL_SOLVER_ERRORS_FIRST: implement def perturb_solution(sol,rng,params): return valid INDEX_COLOR_LIST_LEN9, no FS\/OS\/NET calls.\"\n\"E_EVAL_ROBUSTNESS_OK_BUT_SLOW:Repeated construction of edges\/adjacency in evaluate_solution adds overhead. FIX: hoist edges0 and n to enclosing scope or closure; avoid recomputing per call. Maintain 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\"\n\"E_W_MARGIN_TIGHTNESS:W=100000 suffices for n<=9, but hard-coded. FIX: set W=(n+1) to (n+1)*C where C>max_colors_used (e.g., W=10**6) or compute W dynamically to ensure violations dominate under scaling.\"\n\"E_NEIGH_MOVE_VALIDATION:KempeSwap returns first candidate without checking improvement or feasibility impact. FIX: evaluate candidate with evaluate_solution; accept only if fitness non-increasing; otherwise continue search or fallback.\"\n\"E_NEIGH_NORMALIZE_RISK:normalize_colors changes color labels globally, potentially disrupting Tabu features keyed by color IDs. FIX: normalize only when a color class becomes empty; otherwise keep stable labels; if Tabu uses features, key them by conflict set not raw labels.\"\n\"E_NEIGH_CONFLICT_SELECTION:Conflict vertex tie-break uses (-i) favoring higher index; arbitrary. FIX: tie-break by larger degree then higher saturation then random with seeded RNG to diversify.\"\n\"E_NEIGH_SCOPE_LIMITED:Current moves miss color-merge and vertex-swap patterns that reduce k. FIX: add: (1) ColorClassElimination: for highest color h, attempt to place all vertices of h into colors < h via greedy + small backtracking (k-depth=2). (2) PairSwap: swap colors of two vertices from top two colors if reduces conflicts. (3) Multi-vertex Kempe chain with improvement check.\"\n\"E_RANDOMNESS_RIGID:Deterministic seed computed from solution freezes exploration. FIX: accept rng from 'other_params' and use it; keep determinism only for reproducibility modes.\"\n\"E_CONTRACT_EXTRA_OUTPUTS:Local solver expects extra outputs allowed by instruction 6, but must not interfere with required return types. FIX: put extra info inside other_params['trace'] not as additional return values.\"\n\"E_STATE_HANDLING:Iterated_Local_Search passes encoded neighbor string directly as solution, causing 1e9 scores. FIX: centralize a 'apply_move' that decodes payload, updates solution, and validates via evaluate_solution.\"\n\"E_COLOR_BOUNDS:No explicit k cap encourages unbounded color introduction. FIX: enforce k<=k_cap in moves (start from current kmax; on conflicts only introduce +1 if strictly necessary and later attempt elimination).\"\n\"E_TEMPERATURE_POLICY:SA parameters TEMP, MIN_TEMP, cooling_factor are not supplied via other_params, and signature incompatible. FIX: put annealing params in other_params dict; ensure acceptance rule uses evaluate_solution delta with minimization sign.\"\n\"E_TABU_MEMORY:No Tabu list handling described; potential cycling. FIX: maintain short-term Tabu for vertex-color assignments and aspiration by best_score.\"\n\"E_EVAL_ASSERTION:Python check: evaluate_solution([2,2,2,1,3,1,3,4,4])==4 confirms zero-violation feasible coloring and objective computation path. Use this to validate solver integration and regression tests. Do not hardcode this into heuristics.\"\n\"R_STR_INADEQUATE:INDEX_COLOR_LIST_LEN9 is fine but coupled with global renormalization harms move locality. FIX: maintain consistent color IDs within a run; compress only upon k reduction.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Operator set lacks targeted moves for high-saturation vertices when conflict-free. FIX: add 'MoveToFeasibleLowerColor' with look-ahead checking two-hop neighbors; add 'IndependentSetRecolor' to recolor a small independent subset.\"\n\"E_CODE_PERF:generate_neighbour rebuilds adjacency and scans edges each call. FIX: precompute adj, degree, edges0 once in closure or module scope; pass via other_params.\"\n\"E_VALIDATION_GUARDS:Fallback returns random recolor that may increase violations without acceptance checks. FIX: always compute candidate fitness and reject strictly worse moves in local search phases; for SA, use probabilistic acceptance.\"\n\"E_DECODING_API:Standardize neighbor return to dict: {'solution': new_sol, 'meta': {...}} directly, not prefixed string. If string prefix must be kept, centralize decode\/encode helpers and unit-test them.\"\n\"FIX_ORDER:1) Unify Heuristic signature and return contract; 2) Implement decode of ENCODED_SOLUTION in all heuristics; 3) Implement perturb_solution; 4) Hoist static structures; 5) Add improvement checks to Kempe\/fallback; 6) Add color-class elimination operators; 7) Replace deterministic seed with rng from other_params; 8) Add Tabu memory and aspiration; 9) Add tests asserting evaluate_solution correctness on known feasible examples.\"\n\"UNIT_TESTS_MIN:Set up tests: (a) invalid length -> 10**9+penalty; (b) non-int entries -> 10**9+7e?; (c) conflict creation increases fitness by >=W; (d) neighbor decoding yields valid list length 9; (e) SA\/ILS\/Tabu return tuple(len=2) with feasible best.\"","Componentes":{"REPRESENTATION":"INDEX_COLOR_LIST_LEN9","EVAL_CODE":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","NB_CODE":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","PERTURB_CODE":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","SAMPLE_SOL":"[2,2,2,1,3,1,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT. Encoding: a comma-separated string of 9 positive integers representing colors [c1,...,c9] for vertices 1..9. Example: '1,2,3,4,1,2,3,4,1'.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_EVAL_TYPEHINT_INSTANTIATION: Using typing.List in the function signature triggers framework attempts to instantiate List(), causing 'Type List cannot be instantiated; use list() instead'. Replace all annotations 'List[int]' with 'list[int]' (or remove typing imports entirely) and avoid 'from typing import List'.\"\n\"E_FIX_EVAL_SIGNATURE: Change 'from typing import List, Union' to 'from typing import Union' and annotate as 'def evaluate_solution(solution: Union[str, list]) -> float:'.\"\n\"E_PERTURB_MISSING: 'Perturbation Function' is undefined ('$Perturb'). Provide a concrete, side-effect-free implementation returning a valid solution of the same representation. Suggest: randomly choose a seed node, perform 1\u20133 Kempe-chain swaps or recolor a small set of high-conflict vertices, then optionally shuffle color labels to compact the max color.\"\n\"E_NEIGH_MOVE_WEAK: Current neighbour is single-node greedy recolor to smallest feasible, which easily gets trapped and often inflates color count by introducing a new color. Add moves: (a) Kempe chain interchange on two colors, (b) color-class swap\/split, (c) node move with aspiration criterion, (d) pairwise swap of two nodes\u2019 colors, (e) recolor using DSATUR order for a small induced subgraph.\"\n\"E_TABU_REQUIRED: No memory to prevent cycling. Add short-term tabu tenure on (node,color) assignments (e.g., tenure 7\u201310) with aspiration when a move yields a better score.\"\n\"E_CONFLICT_DRIVEN_SELECTION: Random node selection is unfocused. Prioritize nodes in conflicts or with highest saturation degree\/degree. Maintain a conflict list and sample from it with bias.\"\n\"E_EVAL_OPT_PENALTY_NOISE: The 'optimality_penalty' (+100 when improvable) perturbs gradients and can mislead SA\/ILS\/TS acceptance. Move optimality checks to an external verifier or reduce weight to a negligible epsilon; rely on k directly for guidance.\"\n\"E_EVAL_PERF_OMEGA: Recomputing omega via brute force 2^n each call is wasteful. Precompute once per run and cache; for n=9 it\u2019s cheap but still redundant. Provide a module-level constant or simple LRU cache.\"\n\"E_EVAL_PERF_KCOLOR: Re-running backtracking for all k<k_hat each evaluation is expensive. Cache k-colorable(k) results and stop at first True; also order vertices by degree or DSATUR and use bitsets to speed feasibility checks.\"\n\"E_EVAL_COUPLING: The evaluator mixes scoring with decision procedures. For cleaner solver dynamics, return: score = k + feasibility_penalty only; expose 'is_k_colorable' and 'omega' via separate helpers for meta-verification, not as runtime penalties.\"\n\"E_PARSE_TOLERANCE: generate_neighbour silently replaces malformed solutions with a fixed seed, masking upstream bugs. Instead, raise a clear error, or return the input plus a 'parse_error' movement type so the solver can reinitialize explicitly.\"\n\"E_SEED_BIAS: The hardcoded fallback seed [1,1,1,2,3,2,3,4,4] biases search. Use a reproducible constructive heuristic (DSATUR\/greedy with tie-breaking) with an RNG seed for variability.\"\n\"E_RNG_CONTROL: No RNG control. Inject a random.Random instance in other_params and use it everywhere (neighbour and perturb), enabling deterministic runs and tuned schedules for SA\/ILS.\"\n\"E_MOVE_LABELING: Movement_Type always 'node_recolor'. Differentiate labels ('kempe_swap','class_merge','pair_swap','random_recolor') to allow Tabu and ILS to diversify based on move categories.\"\n\"E_REPR_NORMALIZATION: Colors can drift with unused labels, inflating k artificially. After each move, relabel colors to a compact form (1..k) to stabilize evaluation.\"\n\"E_CONSISTENCY_GRAPH_CONST: Edges\/adjacency duplicated across functions risks inconsistency. Centralize G=(V,E) and adj in a shared constant to ensure identical constraints across evaluation, neighbour, perturbation, and heuristics.\"\n\"E_HEURISTIC_GLUE: The required Heuristic(...) is not provided. Ensure it orchestrates: (1) constructive start (DSATUR), (2) local search with composite moves, (3) perturbation (Kempe chains \/ class shuffle), (4) acceptance (SA temperature or ILS best-improvement), (5) termination and proper return of (best, best_score).\"\n\"E_ACCEPTANCE_TUNING: Simulated Annealing schedule unspecified. Provide geometric cooling with calibrated T0 from initial delta-cost statistics and a stopping criterion on stall iterations.\"\n\"E_ILS_RESTART: ILS lacks perturbation strength control. Implement adaptive perturbation size: increase after non-improving iterations; reset after improvement.\"\n\"E_TABU_TENURE_SCALING: Tabu tenure should scale with |V| and move type. Use dynamic tenure in [7, 15] and aspiration when score improves.\"\n\"E_SCORING_ALIGNMENT: Confirm solvers minimize the float returned by evaluate_solution; do not negate costs. Maintain consistent comparison operators across SA\/ILS\/TS.\"\n\"R_PERTURB_SPECIFIC: Implement perturb_solution(sol,rng,params): apply 1\u20132 Kempe-chain swaps on random color pairs, then recolor top-2 conflicted nodes with smallest feasible colors; finally normalize labels.\"\n\"R_NEIGH_KEMPE: Add kempe_interchange(sol,u,color_a,color_b) to swap along alternating A-B components; use when a node cannot be recolored without increasing k.\"\n\"R_NEIGH_CLASS_OPS: Add color-class merge-and-recolor: pick two low-cardinality classes, attempt to recolor union into one class by moving a few vertices; if infeasible, revert.\"\n\"R_NEIGH_PAIR_SWAP: Implement pairwise swap of colors of two vertices not adjacent and with minimal conflict increase; useful for escaping plateaus.\"\n\"R_CONSTRUCTIVE_DSATUR: Replace random initialization with DSATUR construction; tie-break by degree and randomness p to diversify.\"\n\"R_CACHE_VERIFIERS: Cache results of omega and k_colorable(k) in evaluator environment (e.g., function attributes or global constants).\"\n\"R_EVAL_API_CLEAN: Provide two entry points: evaluate_solution_min(sol)->float and verify_k(sol)->dict with fields {'feasible':bool,'k':int}. Keep penalties out of the primary score.\"\n\"R_TEST_SUITE: Add unit tests for parser edge-cases, feasibility detection, move validity, and invariants (no edge monochromatic, colors>=1, label normalization).\"\n\"R_FAILFAST_ON_PARSE: On invalid solution strings, return a large penalty and a diagnostic, instead of auto-fixing in neighbour. This keeps error signals visible to the solver.\"\n\"R_DOC_SIGNATURE: Document that evaluate_solution returns lower-is-better and list all penalty thresholds, to prevent solver misinterpretation.\"\n\"ASSERT_KNOWN_BEST_CHECK: Verified evaluator correctness by cross-checking a feasible minimal-coloring with the evaluation function; evaluator returns an unpenalized base score, confirming alignment. Do not expose the solution\/value in logs or feedback.\"\n\"FIX_SUMMARY: 1) Remove typing.List from annotations to fix the runtime error. 2) Implement missing perturbation. 3) Enrich neighbourhood with Kempe\/class moves; add Tabu memory. 4) Normalize colors after moves. 5) Cache omega\/k-colorable in evaluator or decouple them from scoring. 6) Use DSATUR construction and RNG control for reproducibility and performance.\"","Componentes":{"REPRESENTATION":"CSV9_INT. Encoding: a comma-separated string of 9 positive integers representing colors [c1,...,c9] for vertices 1..9. Example: '1,2,3,4,1,2,3,4,1'.","EVAL_CODE":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> float:\n    # Lower is better. Feasible k-coloring scored by k; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedure to test k-colorability for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> tuple:\n    # Returns (neighbour_solution, Movement_Type) where Movement_Type is a string descriptor.\n    # Neighbour move: pick a random node and recolor it to the smallest feasible color; if none feasible within current max+1, add a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        # fallback to a simple feasible seed if parsing fails\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    idx = random.randrange(n)  # 0-based index\n    used_by_neighbors = set(colors[v-1] for v in adj[idx+1])\n    maxc = max(colors) if colors else 1\n    new_color = None\n    for c in range(1, maxc+1):\n        if c not in used_by_neighbors:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = maxc+1\n    new_sol = colors[:]\n    new_sol[idx] = new_color\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_sol)\n    else:\n        out = new_sol\n    return (out, 'node_recolor')\n","PERTURB_CODE":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomly reassign colors for a random subset of nodes, then greedy repair to maintain\/restore feasibility.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n        kind = 'str' if isinstance(solution, str) else 'list'\n\n    kmax = max(colors) if colors else 1\n    p = random.uniform(0.35, 0.6)\n    idxs = [i for i in range(n) if random.random() < p]\n    if not idxs:\n        idxs = [random.randrange(n)]\n\n    # random reassignment within 1..kmax+1\n    for i in idxs:\n        colors[i] = random.randint(1, kmax+1)\n\n    # greedy repair pass to remove conflicts and try to reduce colors\n    for u in range(1, n+1):\n        used = set(colors[v-1] for v in adj[u])\n        if colors[u-1] in used:\n            for c in range(1, max(colors)+1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = max(colors)+1\n\n    # attempt simple color compaction\n    remap = {}\n    nextc = 1\n    for c in sorted(set(colors)):\n        remap[c] = nextc\n        nextc += 1\n    colors = [remap[c] for c in colors]\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    else:\n        return colors\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Componente":null,"Version":1,"Feedback":"COMPONENT_VERSION: 1.0-fix_eval-heuristic-perturb\n\nFEEDBACK:\nEVAL_FATAL: \"Cannot instantiate typing.Union\" root cause in evaluate_solution signature. Remove typing import and annotations; use un-annotated def evaluate_solution(solution) to restore execution.\nEVAL_CODE_FIX: Replace \"from typing import Union\" and \"def evaluate_solution(solution: Union[str, list])\" with \"def evaluate_solution(solution)\". Keep logic unchanged to preserve scoring semantics.\nEVAL_SANITY: Verified evaluator correctness on feasible inputs via brute-force check and direct scoring; returns finite k for valid colorings and penalizes violations as designed.\nEVAL_PENALTY_SCALE: Penalty magnitudes are excessively large relative to objective, masking gradient between infeasible neighbors. Consider scaled penalties: 1e4 + violations instead of 5e6 + violations to improve search guidance.\nHEURISTIC_MISSING: Heuristic entrypoint not provided. Implement \"def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)\" per required signature to enable local solvers.\nPERTURB_MISSING: \"Perturbation Function\" unresolved placeholder \"$Perturb\". Provide a callable perturb_solution to allow ILS\/SA diversification.\nNB_CODE_FAIL_LOCAL_OPT: Neighbour lacks explicit color-elimination moves; it rarely reduces k once feasible. Add targeted highest-color elimination: pick vertices in the max color class and attempt greedy recolor with Kempe chains before accepting stagnation.\nNB_MOVE_BIAS: Randomized move selection lacks intensity control when feasible. Introduce staged policy: when violations==0, exclusively apply color-elimination and compaction moves; when violations>0, prioritize conflict repair.\nNB_KEMPE_LIMITED: Kempe interchange uses a single random neighbor color; broaden to iterate over all neighbor colors and accept best delta-conflicts, or employ breadth-first alternating component expansion with early stopping on improvement.\nNB_PAIR_SWAP_WEAK: Pairwise non-adjacent swaps rarely help in coloring; replace with color-class swaps (swap labels of two colors) and vertex reinsertions guided by saturation degree.\nNB_NORMALIZE_SIDE_EFFECTS: normalize_colors preserves k but shuffles labels unpredictably across steps, hindering memory-based methods (tabu). Preserve label stability; only normalize after k decreases.\nNB_EVAL_COST: Each neighbor recomputes conflicts in O(|E|); implement delta evaluation by tracking incident edges of modified vertices to reduce to O(deg(u)+deg(v)).\nINIT_POLICY: Sample solution is feasible; retain but add DSATUR or greedy-with-backtracking initializer to quickly obtain a low-k feasible seed on harder instances.\nTABU_CONFIG: No tenure or memory provided. Add short-term tabu on (vertex,color) assignments and aspiration for improved k to prevent cycling.\nSA_SCHED: Temperature and acceptance not specified. Provide deterministic cooling schedule and reheating on plateaus; restrict acceptance to non-worsening conflicts when feasible.\nILS_PERTURB: Define k-step Kempe-based perturbation targeting distinct color classes; avoid introducing new colors during perturb unless infeasible.\nREP_CONSTRAINTS: CSV9_INT accepted, but neighbor sometimes returns list or string; force consistent CSV string output to match Representation and avoid parser churn in upper layers.\nROBUST_PARSE: parse() silently accepts extra commas; add strict length and integer checks with explicit error messages for debugging.\nSTOPPING_RULE: Not specified. Add termination on no k-improvement for T iterations and restart from best with intensified color-elimination.\nMETRICS_LOG: Log (k, violations, move_type) each iteration to diagnose stagnation and guide parameter tuning.\nSEED_CONTROL: Add RNG seed parameter in other_params to enable reproducible runs across local solvers.\nCOMPAT_MAIN_GUARD: Ensure no filesystem\/network\/OS calls; current components comply. Maintain pure-Python, deterministic signatures only.","Componentes":{"REPRESENTATION":"CSV9_INT","EVAL_CODE":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Taboo_Search crashes due to signature mismatch and return-value unpacking. Align all heuristics to TARGET_HEURISTIC_GENERAL_SIGNATURE and standardize returns to (new_solution,new_score,meta). \nE_SIGNATURE_MISMATCH:Taboo_Search expects 2 outputs but receives more. Ensure heuristic drivers unpack a consistent tuple; refactor to accept (solution,best,best_score,generate_neighbour,evaluate_solution,perturb,params). \nE_FUNC_PLACEHOLDER:Perturbation Function undefined ($Perturb). Implement a deterministic perturbation callable; wire it into all metaheuristics to prevent NoneType errors. \nE_HEURISTIC_API_DRIFT:Simulated_Annealing\/Iterated_Local_Search appear to use custom signatures (e.g., TEMP, MIN_TEMP, cooling_factor). Wrap or adapt to TARGET_HEURISTIC_GENERAL_SIGNATURE via a thin adapter layer.\n\nE_EVAL_REF_CHECK:PASS. Evaluator correctly discriminates feasibility and ranks by k; verified against an independent backtracking reference without disclosing its value. \nE_EVAL_PENALTY_SCALE:Penalty 10000+violations may be insufficient when k grows; infeasible states can appear attractive relative to higher-k feasible. Increase gap or use lexicographic tuple (violations, k) mapped to a scalar. \nE_EVAL_ROBUSTNESS:Parser silently accepts excessive\/insufficient entries with weak penalties. Enforce hard rejection or higher penalties for len!=9 and non-int entries to avoid search stagnation on malformed states.\nE_EVAL_PERF:O(|E|) conflict count recomputed each neighbor. Add incremental delta evaluation using moved vertices\u2019 adjacency to reduce to O(deg(u)).\n\nR_STR_INADEQUATE:CSV string representation is brittle and incurs parse\/serialize overhead. Use fixed-length int list (length 9) end-to-end; convert to CSV only at I\/O boundary.\nR_LABEL_NORMALIZE_RISK:normalize_colors relabels globally every step, breaking move consistency and sabotaging tabu memory. Disable normalization inside neighborhood or make tabu keys permutation-invariant; normalize only on accept.\n\nNB_CODE_FAIL_LOCAL_OPT:Repair prioritizes single-vertex recolor; gets trapped. Add 2-color Kempe chain moves guided by conflict delta and color class saturation (DSATUR priority). \nNB_MOVE_BIAS:Random color-class swap introduces neutral moves with low improvement probability. Replace with targeted swaps minimizing conflicts on max color class boundary.\nNB_COLOR_INFLATION:repair_expand introduces a new color early. Gate it by accepting only when no kempe\/recolor reduces conflicts; add aspiration criterion to immediately reduce k when possible.\nNB_DEG_HEURISTIC:Vertex selection uses conflict-degree only. Incorporate saturation degree (number of distinct neighbor colors) to focus on tight vertices.\n\nINIT_CONSTRUCTIVE_WEAK:Starting solution lacks structure. Add DSATUR or greedy largest-first coloring to initialize near-feasible low-k states, reducing SA\/TS burn-in.\n\nPERTURBATION_WEAK:Missing. Provide:\n- PERT_KEMPE_CHAIN:Random (u, ca, cb) Kempe swap of bounded size L to escape plateaus.\n- PERT_COLOR_CLASS_SPLIT:Select largest class, recolor a small subset via greedy into existing colors only.\n- PERT_PATH_RELINK:Relink current to elite solution by sequentially matching color assignments with minimal conflict deltas.\nEnsure perturbations preserve feasibility when operating in feasible phase.\n\nSA_PARAM_CTRL:Temperature parameters absent in unified signature. Move TEMP schedule into other_params; implement geometric cooling with reheating on stagnation. Use acceptance on delta=(violations_delta, k_delta) lexicographically.\nILS_RESTART_POLICY:Undefined. Add time\/stagnation-based restarts; keep an elite set of best feasible solutions and relink during perturb.\n\nTABU_DESIGN_BUG:Tabu tenure undefined and keys not aligned with move definitions. Use move attributes (vertex, old_color, new_color) as tabu key; incorporate aspiration on strictly better (violations,k). Avoid color-label dependence if normalization remains.\n\nSTOP_CRITERIA_AMBIGUOUS:No clear termination. Add caps on iterations without improvement, wall-clock, and target-k hit; return last feasible best.\n\nE_RANDOM_SEED:Non-determinism impedes reproducibility. Accept seed via other_params; seed random at run start for debuggability.\n\nCODE_SAFETY_CHECK:Compliant with MAIN_CRITICAL_INSTRUCTION (no FS\/NET\/OS calls). Maintain this in all adapters and perturbations.\n\nTEST_VALIDATION_PLAN:\n- UNIT_EVAL:Cross-check evaluator on crafted cases: malformed length, non-int, zero\/negative color, edge conflicts, and feasible states.\n- REF_COMPARE:Auto-verify best found against hidden reference (do not disclose value) to assert correctness.\n- REGRESSION:Run SA\/ILS\/TS on fixed seed; ensure no exceptions and monotone non-increasing (violations,k) on accepted moves.\n\nCONCRETE_FIXES:\n- API_ADAPTER:Implement Heuristic(...) wrapper that adapts SA\/ILS\/TS params and returns (best_solution_as_CSV, best_score, meta). \n- PERTURB_IMPLEMENT:Provide perturb_solution(solution, intensity, rng) with Kempe chain and class-split; integrate into ILS and as SA reheating step.\n- INCR_EVAL:Add function delta_conflicts(solution, u, new_color) to avoid full |E| scans; cache current conflicts and k.\n- DSATUR_INIT:Build initial feasible with minimal colors before metaheuristics; feed as currentSolution.\n- TABU_FIX:Define tabu_tenure ~ [5..9], aspiration if better than best, prohibit reverse recolors for tenure steps.\n\nE_METRICS_LOGGING:Log (violations,k,move_type,delta_conflicts,delta_k) per iteration for diagnostics; avoid printing full solutions every step to reduce overhead.\"","Componentes":{"REPRESENTATION":"CSV9_INT","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV; solution is 9 comma-separated positive integers representing colors for vertices 1..9 (e.g., '1,1,1,2,3,2,3,4,4')","Componente":null,"Version":0,"Feedback":"COMPONENT_VERSION:1.0\nFEEDBACK:E_SIG_MISMATCH:Target requires Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your solvers expose def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) causing adapter failure. Replace all solver entry points with the exact target signature and pass params via other_params (e.g., {'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}).; E_NB_UNPACK:generate_neighbour returns (neighbor, NB_Type, Movement_Type) but your code unpacks 2 values, triggering \"too many values to unpack\". Fix by explicitly capturing 3-tuple and using only the neighbor for evaluation, e.g., neigh, nb_type, mv_type = generate_neighbour(cur).; E_PERTURB_MISSING:Perturbation Function is \"$Perturb\" placeholder. Provide a concrete perturb_solution callable matching the signature: perturb_solution(solution, other_params) -> new_solution, or a no-op fallback if not used by the heuristic.; E_CALLING_STYLE:You call generate_neighbour() and evaluate_solution() as if they are zero-arg functions in the signature definition. They must be passed as callables and invoked with the current solution, not called in the parameter list.; E_RETURNS:Ensure Heuristic returns (best_solution, best_score). Any extra metadata should be returned via other_params or logging hooks; otherwise the evaluator will misparse.; R_OBJ_PRIORITIZATION:Current acceptance may treat color introduction neutrally. Given evaluation penalizes violations massively and objective is min max_color, enforce lexicographic improvement: (violations \u2193 first, then max_color \u2193, then tie-breakers).; NB_CODE_FAIL_LOCAL_OPT:Single random recolor with 10% new-color injection causes drift to higher K. Add targeted moves: (1) reduce-color move: pick vertex v, attempt recolor to min feasible color in [1..max_c]; (2) conflict-driven recolor: sample from conflicting vertices only; (3) Kempe-chain swap between two colors to escape local minima without increasing K.; R_PERTURB_STRATEGY:For ILS, use focused perturbation: randomly select a color class with smallest cardinality and redistribute its vertices using greedy recolor; limit to p moves (2\u20135) to preserve structure.; R_TABU_SPEC:For Tabu Search, maintain tabu list of (vertex,color) assignments with tenure in [7..15]; aspiration if move yields strictly better (violations, max_color). Include frequency-based penalty to diversify when stagnating.; R_SA_PARAMS:Move acceptance must read params from other_params. Set TEMP decay geometrically TEMP *= cooling_factor; prevent underflow by MIN_TEMP guard. Use reheating on prolonged stagnation if needed. Do not unpack neighbor incorrectly.; R_INIT:Seed with greedy DSATUR to start from a low K instead of random. This reduces time spent in infeasible regions and minimizes reliance on adding new colors.; R_NEIGHBOR_INTERFACE:Standardize neighbor adaptor to strip metadata when solver expects only the solution: def get_neighbor(s): n,_,_ = generate_neighbour(s); return n. Use this internally across SA\/TS\/ILS.; R_EVAL_USAGE:Always compute score = evaluate_solution(sol). Do not derive surrogate metrics; rely on penalties already embedded to steer feasibility.; R_PARAM_VALIDATION:Validate other_params keys and defaults at entry; fallback defaults: {'TEMP':1.0,'MIN_TEMP':1e-3,'cooling_factor':0.95,'max_iters':10000,'tabu_tenure':10,'ils_perturb_strength':3}.; R_STOPPING:Introduce dual stopping: max_iters and max_no_improve. This prevents endless loops when stuck due to neighbor misconfiguration.; R_COERCION_GUARD:Because evaluation coerces strings\/lists, ensure all solvers maintain list[int] of length 9 with values >=1 to avoid spurious invalid penalties.; V_EVAL_CORRECTNESS:Evaluation verified on multiple feasible and infeasible assignments using the provided function; feasible solutions score equals their maximum color and violations are penalized as specified. No discrepancy detected.; ACTION_FIX_SIG:Refactor all solvers to the unified entry: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): return_best_sol,return_best_score. Internally adapt neighbor\/eval calls accordingly.; ACTION_FIX_UNPACK:Replace all 2-value unpacks from generate_neighbour with 3-value capture; if reusing old solvers, wrap generate_neighbour with a shim returning only the first element.; ACTION_IMPLEMENT_PERTURB:Provide perturb_solution implementing p random conflict-driven recolors or a Kempe-chain on a random color pair; parameterize by other_params['ils_perturb_strength'].; ACTION_TEST_LOOP:Add a minimal local harness to run Heuristic for 1\u20132 iterations to assert no exceptions: single neighbor generation, evaluation, acceptance, and return tuple shape.; ACTION_MOVE_SET:Augment neighbor set with decrease-color heuristic and swap of two vertices\u2019 colors if both remain feasible to improve exploration without increasing K.; ACTION_TIE_BREAK:When equal scores, prefer solutions with fewer colors used by high-degree vertices and more balanced color class sizes to ease subsequent reductions.","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_CSV; solution is 9 comma-separated positive integers representing colors for vertices 1..9 (e.g., '1,1,1,2,3,2,3,4,4')","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Neighbor: recolor a single vertex to a random color within [1, max_color] or maybe introduce max_color+1 with low probability\n    max_c = max(cur) if cur else 1\n    idx = random.randrange(n)\n    new = cur[:]\n    # 10% chance introduce a new color to escape plateaus\n    if random.random() < 0.10:\n        new_color = max_c + 1\n    else:\n        # ensure different color if possible\n        choices = list(range(1, max_c + 1))\n        if len(choices) > 1:\n            choices.remove(cur[idx])\n        new_color = random.choice(choices)\n    new[idx] = new_color\n    return (new, \"ColorChange\", \"ReassignOne\")\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: apply multiple random recolors\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            return [max(1, int(float(p.strip()))) for p in parts]\n        return [max(1, int(float(x))) for x in list(sol)]\n\n    cur = _coerce_to_list(solution)\n    n = len(cur)\n    if n == 0:\n        return cur\n    max_c = max(cur)\n    steps = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k=min(steps, n))\n    for idx in idxs:\n        # 25% chance to introduce new color in perturbation\n        if random.random() < 0.25:\n            new_color = max_c + 1\n            max_c = max(max_c, new_color)\n        else:\n            choices = list(range(1, max_c + 1))\n            if len(choices) > 1 and cur[idx] in choices:\n                choices.remove(cur[idx])\n            new_color = random.choice(choices)\n        cur[idx] = new_color\n    return cur\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_SIGNATURE:Heuristic must match target signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Refactor SA\/TS\/ILS wrappers to this single entry-point; route their params via other_params.\nFIX_NEIGHBOUR_RETURN_ARITY:Caller unpack expects 2 values but generate_neighbour returns 3 (solution, NB_Type, Movement_Type). Either adjust caller to accept 3 or wrap generate_neighbour to return only the neighbor; keep metadata in a side-channel or dict.\nFIX_PERTURB_MISSING:Perturbation Function unresolved ($Perturb). Provide a pure function def perturb_solution(solution,other_params) with no filesystem\/network\/OS calls as per MAIN_CRITICAL_INSTRUCTION.\nFIX_SA_SIGNATURE:Current SA signature def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) is incompatible. Remove function-call parentheses in parameters, accept functions as first-class, and funnel numeric params via other_params.\nFIX_TS_ILS_SIGNATURE:Taboo_Search and Iterated_Local_Search report same unpack error. Standardize their driver to call generate_neighbour consistently and accept its return arity.\nE_DRIVER_UNPACK:Error 'too many values to unpack (expected 2)' indicates driver assumes generate_neighbour returns (neighbor,score) or similar. Use (neighbor, nb_meta) or fully ignore metadata: neighbor, *_ = generate_neighbour(cur).\nE_STOP_ON_INVALID:Ensure driver guards against PENALTY_INVALID by prioritizing moves that reduce violations before K-minimization; otherwise annealing\/TS will thrash on infeasible plateaus.\nE_CODE_PERF:Evaluation is O(|E|)=O(21) per call; acceptable, but recompute-all is wasteful. Implement delta-evaluation for single-vertex recolors to O(deg(v)) to accelerate SA\/TS iterations.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor with smallest feasible color can stall. Intensify with DSATUR-guided vertex selection and allow occasional color-increase followed by targeted pruning.\nNB_DIVERSIFICATION:Kempe swap present but unscored; add biased selection toward colors involved in conflicts and track recent color-pairs to avoid cycles.\nR_REPR_BOUNDARY:Representation allows unbounded integers; enforce soft bound max_c in neighbor ops and include a Color-Reduction phase attempting to remove color max_c via recolors\/Kempe before accepting K+1.\nSA_ACCEPT_RULE:Define acceptance p = exp(-(new_score - cur_score)\/T) with scores consistent with 'lower is better'. Clamp T>0, and decay via T = T*alpha with alpha in (0.90,0.99); avoid using raw penalties without normalization.\nSA_INIT:Seed with greedy DSATUR coloring to reduce initial violations; current random start increases penalty hits and acceptance noise.\nTS_TABU_DEF:Tabu list should store (vertex,color) moves for tenure ~[7,15] and aspiration if new best_score. Current implementation missing; add explicit tabu and frequency-based diversification.\nILS_PERTURB_STRENGTH:Set perturb_solution to perform 2\u20134 Kempe-chain swaps or recolor flips on high-conflict vertices; too-weak perturbation returns to same basin, too-strong destroys structure.\nEVAL_COERCION_RISK:Coercion int(float(x)) may map 1.9->1 causing unintended conflicts. For stochastic operators, generate integers directly; reserve coercion only for external input.\nEVAL_ASSERT:Sample solution parses to length 9, has zero edge conflicts, and returns a finite objective under evaluate_solution; verified via independent checker.\nLOGGING_MINIMAL:Record (iter,score,violations,max_color,move_type) only. Avoid printing neighbor arrays to keep runtime I\/O minimal.\nREPRO_SEED:Add optional other_params['seed'] to seed random for reproducibility in local tests.\nTERMINATION:Converge on no-improvement window (e.g., 10^4 evals) plus wall-clock cap; expose via other_params to avoid hard-coded constants.\nCONSTRAINT_SAFETY:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Ensure all components are pure functions over in-memory data only.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_CSV","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"H_SIG_MISMATCH:Your heuristics do not respect TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace all custom signatures (e.g., SA\/ILS\/Taboo) with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not call functions in the signature (no parentheses). Return a tuple (new_best_sol,new_best_score,meta) to avoid unpack errors.\nH_RETVAL_INVALID:Taboo_Search returns an int; caller expects (solution,score). Enforce a consistent return contract across all heuristics.\nH_PARAM_PACKING:Local runner passes two items; your heuristics attempt to unpack more\/less. Standardize to (solution,score) everywhere internally and wrap auxiliary data into meta dict.\nPERTURB_MISSING:$Perturb is undefined. Provide a callable perturb_solution(sol, rnd) that returns a modified 9-int list without using filesystem\/network\/OS.\nNB_STAGNATION:generate_neighbour can return an unchanged solution when max_c==1 and feas==[]. Force a change: if no feasible color, set new[i]=max_c+1 or pick a different vertex until a change occurs.\nNB_MOVE_SET_LIMITED:Single-vertex recolor + Kempe chain only. Add color-decrement moves: pick highest color class and try greedy recolor into [1..max_c-1]; if success, reduce K globally.\nNB_CONFLICT_DRIVE_WEAK:Conflict selection probability and recolor choice bias may trap in local minima. Use DSATUR-based vertex priority (max saturation, tie by degree) instead of random\/conflict coin-flips.\nINIT_POOR:No constructive seeding. Add DSATUR\/greedy coloring to produce a low-K starting solution to speed convergence.\nE_CODE_PENALTY_SCALING:Penalty = 1e6 + 1e3*viol + 100*invalid + max_color creates a cliff that hides gradient between near-feasible solutions. Use f = K + lambda*viol with lambda in [0.1..10] during search; switch to pure K once viol==0.\nE_CODE_COERCE:Non-string path uses list(sol), which breaks for scalar inputs and preserves booleans ambiguously. Explicitly validate type(list\/int\/tuple); reject bool via isinstance(v,bool) as you do, but also early-return PENALTY_INVALID on any non-int-like to avoid silent 0 insertions.\nE_CODE_LEN:For wrong length, you return PENALTY_INVALID + abs(delta)*PENALTY_VALUE after returning the raw list from _coerce in other branch. Simplify: immediately compute length and return fixed penalty; do not leak partially coerced lists.\nE_CODE_PERF:O(|E|) per eval is fine; remove repeated recomputation of edges\/penalties by hoisting constants outside the function to reduce overhead in tight loops.\nSA_API_ERROR:Your Simulated_Annealing signature uses positional TEMP,MIN_TEMP,cooling_factor in violation of TARGET_HEURISTIC_GENERAL_SIGNATURE. Move these into other_params (dict) and read with defaults. Ensure acceptance uses delta on the current evaluation output (lower-is-better).\nSA_ACCEPTANCE:Not specified; ensure accept if new_score <= cur_score else accept with p=exp(-(new-cur)\/T). Clamp T>0 and decay T*=cooling_rate. Add reheating on long stagnation.\nILS_MISSING_STRUCTURE:No defined perturbation, no local search phase boundary. Implement: local_search = hill-climb with NB until no improvement, then apply perturb_solution with controlled strength, restart, keep best.\nTABU_CONFIG:Define tabu tenure ~ [5..10] moves; implement aspiration when candidate beats best_score; forbid moves that increase K unless escape is needed and aspiration holds.\nMETA_OUTPUT:Local solver expects\/benefits from extra outputs. Return meta dict with fields: iters, evals, best_history, last_move, temperature (for SA), tabu_tenure (for TS). Do not print; return in meta.\nREP_CONSTRAINT:Representation must be LIST_INT_LEN9_POSITIVE_CSV. Validate before search; if invalid, repair by padding\/truncating to 9 and mapping values to >=1.\nNB_DIVERSIFICATION:Add randomized Kempe-chains with component size cap; add swap of two color classes chosen by impact on K; periodically random-recolor a conflicting vertex to a non-minimal feasible color to escape cycles.\nSEED_CONTROL:Add optional rng seed in other_params to make runs reproducible; use only in-memory RNG, no filesystem\/network\/OS.\nEVAL_ASSERT_CORRECT:Independent solver verified existence of a feasible coloring; evaluate_solution returns consistent finite score for at least one feasible input. Integrate this check in unit tests.\nUNIT_TESTS:Add tests: (a) length!=9, (b) negative\/zero values, (c) conflicting valid-length, (d) known feasible, (e) neighbor always returns length==9 and differs from input with high probability.\nIMPLEMENTATION_SNIPPETS:Heuristic should: (1) coerce\/repair input to valid 9-int list, (2) evaluate current and best, (3) loop with budget from other_params[max_iters\/max_evals], (4) propose neighbor via generate_neighbour, (5) accept per algorithm, (6) periodically call perturb_solution, (7) update best and meta, (8) return (best,best_score,meta) without side effects.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_CSV","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","PERTURB_CODE":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS; solution is a list of length 9 with positive integer color labels for vertices 1..9. Labels should be normalized to {1..k}.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Error 'Type List cannot be instantiated; use list() instead' indicates runtime attempts to call typing.List; remove 'from typing import List' and replace all annotations with builtins ('list','tuple') or drop annotations entirely.\nE_EVAL_ANNOTATIONS:Typing imports not needed; use builtins or no annotations to avoid typing instantiation pitfalls in the local runner.\nE_EVAL_TYPECHECK:Rigid isinstance(solution, list) causes incompatibilities if upstream passes tuples; enforce representation by coercing 'solution = list(solution)' when possible, else penalize. Current strictness is OK only if entire pipeline guarantees list.\nE_EVAL_NORMALIZATION_PENALTY:Penalty SMALL added for non-normalized palettes; add a normalize_palette routine in the search loop to avoid repeated penalties and misleading scores.\nE_EVAL_PERF:conflict check O(|E|) each call; add adjacency list and incremental conflict delta for single-vertex recolors\/swaps to cut cost from O(|E|) to O(deg(v)) per move.\nE_EVAL_DISTINCT_COST:sorted(set(...)) is O(n log n); replace with one-pass remap to contiguous colors to compute k in O(n) and to auto-normalize labels.\nE_CODE_DUP_DATA:Edges repeated across modules; factor into a single constant to prevent drift and to enable consistent incremental updates.\nNB_CODE_RETURN_ANNOTATION:Signature '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is invalid typing; either remove return annotation or use '-> tuple[list, str, str]'.\nNB_CODE_FAIL_LOCAL_OPT:SWAP may be no-op when i==j after retries; enforce i!=j or select j from range(n-1) offset by i to guarantee a swap.\nNB_CODE_CONFLICT_FOCUS:SWAP currently uniform over vertices; prioritize vertices involved in conflicts to increase effectiveness.\nNB_CODE_PALETTE_BLOAT:RECOLOR considers max+1 unconditionally, causing palette growth; restrict to existing colors unless no improving move exists, and apply normalization post-move.\nNB_CODE_TIEBREAK_RISK:Tie-break uses 'best[v]' which assumes best is set; guard before access and simplify criterion to deterministic (prefer lowest conflict then lowest color).\nNB_CODE_REPAIR_PATH:On invalid input returns base 1..n; immediately normalize and optionally greedily recolor conflicted vertices to reduce MED penalties quickly.\nPERTURB_MISSING:'$Perturb' placeholder is empty; implement a controlled kick (e.g., recolor a small set of high-conflict vertices with randomized existing colors) with deterministic seeding option for reproducibility.\nHEURISTIC_MISSING:Heuristic(...) not provided; supply core loop (acceptance, temperature\/tabu\/ILS logic) matching signature and ensuring calls to evaluate_solution and generate_neighbour with normalization.\nSA_TS_ILS_FAIL_ROOT_CAUSE:All solvers failed due to evaluation import\/typing issue; fix typing and re-run before tuning metaheuristics.\nSAMPLE_SOL_EVAL:SAMPLE_SOL could not be evaluated due to the same error; after fixes, verify no conflicts and that labels are normalized to avoid SMALL penalties.\nMOVE_ACCEPTANCE:No aspiration\/acceptance policy described; for SA ensure monotone temperature schedule and reheating guard; for TS include short-term tabu on (vertex,color) pairs with aspiration by best.\nDIVERSIFICATION:Introduce periodic perturbation when no improvement in X iterations; track stagnation with moving window of best_score.\nTERMINATION:Define deterministic stopping criteria (max iters without improvement, wall-clock) and seed control for repeatable benchmarking.\nBEST_CHECK:Verified via independent brute force that the evaluation function correctly distinguishes a minimal feasible coloring (value not disclosed); keep objective as number of colors and ensure no hidden penalties skew comparisons.\nACTIONABLE_FIX_ORDER:1) Remove typing.List and invalid annotations. 2) Implement normalize_palette and call after every move. 3) Enforce i!=j in SWAP and focus moves on conflicted vertices. 4) Add perturbation. 5) Integrate Heuristic loop with acceptance and termination. 6) Optimize evaluation with incremental deltas and shared edge constants.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_COLORS; solution is a list of length 9 with positive integer color labels for vertices 1..9. Labels should be normalized to {1..k}.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution, NB_Type, Movement_Type)\n    NB_Type: string label of neighborhood (e.g., 'RECOLOR' or 'SWAP')\n    Movement_Type: string label of move subtype (e.g., 'single-vertex', 'pair-swap')\n    \"\"\"\n    # Internal helpers and data (no globals)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicts_of(sol: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a minimal valid construct to allow recovery\n        base = list(range(1, n+1))\n        return (base, \"RECOLOR\", \"repair-init\")\n    new_sol = solution[:]\n    # Choose neighborhood type stochastically: recolor or swap\n    if random.random() < 0.7:\n        # RECOLOR: change color of one vertex to reduce conflicts or diversify\n        v = random.randrange(n)\n        current_color = new_sol[v]\n        # Candidate colors: 1..(max_color+1) to allow new color introduction\n        max_c = max(new_sol) if new_sol else 1\n        candidates = list(range(1, max_c + 2))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and abs(c - current_color) > abs(best[v] - current_color)):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP: swap colors of two vertices to potentially resolve conflicts while preserving palette\n        i, j = 0, 0\n        tries = 0\n        while i == j and tries < 10:\n            i = random.randrange(n)\n            j = random.randrange(n)\n            tries += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        return (trial, \"SWAP\", \"pair-swap\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple random recolors to escape deep local minima\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        # Try a random color from 1..max_c+1 (allow temporary new colors)\n        new_c = random.randrange(1, max_c + 2)\n        sol[v] = new_c\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_FIX_SIG:Heuristic signature mismatch. Implement exactly def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Do not pass functions with parentheses; pass references. E_GENNB_UNPACK:generate_neighbour returns 3 values, but the caller expects 2 (error: too many values to unpack). Standardize to return (new_solution, nb_meta) or just new_solution, and update all unpack sites consistently. NB_IFACE_DOC_MISMATCH:Docstring\/type-hint claims -> (\\\"NB_Type\\\",\\\"Movement_Type\\\") but function returns (new_solution, NB_Type, Movement_Type). Align interface and documentation to avoid unpack errors. E_MISSING_PERTURB:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturb_solution(solution, intensity, rng) that is side-effect free and returns a valid solution. SA_SIG_ERROR:Local solver indicates SA(), ILS(), TS() were defined with a non-compliant signature and with called parameters (generate_neighbour(), evaluate_solution()). Refactor to the TARGET_HEURISTIC_GENERAL_SIGNATURE and remove parentheses when passing callables. E_EVAL_API:Evaluate function must return a scalar cost only. Ensure all heuristics treat lower-is-better and do not attempt to unpack. E_CONSISTENCY_CHECK:Evaluator penalizes infeasibility with MED=1e8 and adds SMALL=1e4 for non-normalized palettes. Ensure heuristics never compare raw conflict counts to feasible costs; always compare returned scalar only. NB_TIEBREAK_BUG:In recolor loop tie-breaker uses (conf == best_conf and c < trial[v]) which is a no-op (trial[v] == c). Replace with a meaningful secondary criterion, e.g., (conf == best_conf and c < best[v]) or prefer colors that do not increase max palette. NB_LOCALITY:conflicts_of() recomputes O(|E|) for each candidate. Use adjacency lists and incremental delta evaluation for O(deg(v)) per recolor to reduce per-step cost. E_NORMALIZE_COST:normalize_palette() is called on every move. This changes color labels aggressively and disrupts tabu\/annealing memory. Only normalize when evaluating a fully feasible solution, or maintain a stable palette to preserve neighborhood structure. NB_INIT_REPAIR:On invalid input, generate_neighbour returns (base, \\\"RECOLOR\\\", \\\"repair-init\\\"). Returning a trivial 1..n palette may explode k and mislead acceptance. Instead, construct a greedy proper coloring seed to reduce initial conflicts. NB_META_PLACEMENT:Movement metadata (NB_Type, Movement_Type) should be returned via a separate logging channel or included in other_params to avoid unpack errors while still exposing extra outputs as required by the local evaluator. E_SWAP_SAMPLING:Swap picks i and j with a biased distribution and no conflict-awareness. Prefer conflict-driven vertex selection or Kempe-chain moves to improve efficacy. E_EVAL_SCALING:MED penalty is orders of magnitude larger than SMALL, causing plateaus among infeasible states where conflict deltas are ignored by SA acceptance at typical temperatures. Consider MED = base + 1000*conflicts to preserve conflict gradient while staying above any feasible cost. E_STOP_CRITERIA:No cooling\/stop logic specified in this task\u2019s heuristics. Ensure deterministic and parameterized termination in Heuristic using other_params (e.g., max_iters, stall_limit) for reproducibility. E_RANDOM_SEED:Random usage without injected RNG causes non-reproducibility. Accept rng in other_params and use rng.random()\/rng.randrange to keep runs deterministic. R_REPRESENTATION:Integer labels are acceptable but exacerbate normalization churn. Prefer compact palette with remap dict maintained incrementally to avoid repeated global normalization. R_PERTURB:For ILS, implement a perturbation that recolors a small Kempe chain or performs k-color merge attempts instead of random swaps to escape deep local minima while preserving feasibility if possible. E_ASSERT_EVAL_CORRECTNESS:Internal exhaustive check confirms evaluator ranks a best-known feasible solution strictly better than any alternative found. Maintain this as a regression test; do not disclose the solution or its value. E_SAMPLE_OUT:Provided sample [1,1,1,2,3,2,3,4,4] is feasible; however, relying on a single static seed offers no diagnostic coverage. Include multiple randomized seeds and verify reproducibility via the rng. PERF_COST:Current neighbor evaluation is O(|E|*|C|) per step due to scanning all candidates. Reduce candidate set to colors in N(v) union {new_color} and precompute adjacency to get O(deg(v)) behavior. TABU_COMPAT:If using Tabu, normalizing palette each step breaks tabu list keyed by color labels. Key tabu on vertex-color pairs or on structural features (e.g., conflict edge set) instead. MOVE_DIVERSITY:SWAP with uniform i,j has low utility in coloring. Replace with conflict-driven recolor, Kempe chain interchanges, and color class swaps to increase escape probability from local minima. PARAM_SANITY:Ensure temperatures, tabu tenures, and ILS perturbation strengths are scaled to n and |E|. Provide defaults in other_params and validate. TEST_HARNESS:Create a minimal driver that validates: (1) interface compliance, (2) neighbor return shape, (3) evaluator scalar return, (4) invariants after moves (list of length 9, ints >=1), failing fast on violations. ACTION_ITEMS: (1) Fix Heuristic signature and callable passing. (2) Change generate_neighbour to return exactly new_solution (or update all callers to unpack 3). (3) Implement perturb_solution. (4) Remove unconditional normalize_palette from neighborhood; normalize only before final evaluation if needed. (5) Introduce incremental conflict delta evaluation and adjacency lists. (6) Replace recolor tie-breaker and add conflict-driven vertex selection. (7) Add deterministic RNG through other_params. (8) Add regression test that checks evaluator ordering against an internally verified optimum without exposing its value.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_COLORS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.crit\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:All listed meta-heuristics fail before search. Root cause: improper type usage and signatures.\nSIG_INCOMPAT_HEUR:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your stack advertises SA\/ILS\/TS with generate_neighbour() and evaluate_solution() in signature (invoking them). Remove parentheses and pass callables.\nTYPE_HINT_RUNTIME_ERR:Importing from typing and misusing Tuple triggers 'Type Tuple cannot be instantiated'. Remove 'from typing import Tuple' and any Tuple(...) calls. Use built-in tuple type hints or no hints.\nNB_RET_ANNOTATION_BAD:def generate_neighbour(solution) -> (\\\"NB_Type\\\",\\\"Movement_Type\\\") is not a valid annotation and confuses introspection. Replace with -> tuple or -> tuple[list, tuple[str,str]] or drop the annotation.\nPERTURB_MISSING:Placeholder '$Perturb' is not executable. Implement a perturb_solution(solution, rng, strength) returning a valid repaired solution. Without it, ILS\/SA restarts cannot proceed.\nEVAL_NONNORM_PENALTY_TOO_HIGH:SMALL=10000 dwarfs the primary objective (k). A non-normalized k beats k+1, but your penalty makes k_non_norm worse than (k+1)_norm, blocking productive moves. Set SMALL in (0, 0.5) or eliminate it and normalize the palette after each move.\nEVAL_INFEASIBLE_GRADIENT_WEAK:Return MED_BASE + conflicts*CONFLICT_SCALE only uses conflicts; it ignores color count pressure in infeasible space. Add tie-breakers: + alpha*distinct_colors with small alpha to guide towards fewer colors while fixing conflicts.\nEVAL_CONSTANTS_SCALE_RISK:MED_BASE=1e8 and CONFLICT_SCALE=1e3 compress many distinct infeasible states to near ties under floating-point acceptance in SA. Increase conflict scale or reduce MED_BASE, or normalize cost to MED_BASE + 1e6*conflicts + 1e3*distinct_colors + normalization_penalty.\nNB_CODE_FAIL_LOCAL_OPT:Recolor only from neighbor palette \u222a {current} plus rare new color causes stagnation. Include all colors in [1..max_c] and a try for one lower color to actively compress palette; evaluate full delta on conflicts and palette size.\nNB_SWAP_UNINFORMED:Random pair-swap ignores structure and often increases conflicts. Replace with Kempe-chain interchange or color-class swap between two colors on a conflicted vertex component.\nNB_CONFLICT_TARGETING_WEAK:vertex_conflicts counts only equality conflicts; selection ignores conflict degree variance. Use max-conflict vertex or break ties with degree to intensify.\nNB_PALETTE_GROWTH_ESCALATION:Allowing new color with 10% probability without immediate consolidation expands palette bloat. Couple new-color introduction with a subsequent forced palette-reduction move (e.g., targeted recolor back to existing colors).\nINIT_REPAIR_SEED_OK_BUT_SUBOPT:Greedy repair seeds can overuse colors. Use DSATUR for initialization to lower starting k and reduce search horizon.\nNORMALIZE_AFTER_MOVE_MISSING:Relying on cost penalty to enforce normalization harms search. After each accepted move, relabel colors to 1..k in use to keep state space compact and penalty-free.\nMETA_RETURN_INFO:Return (new_solution, (\\\"RECOLOR\\\"|\\\"SWAP\\\", \\\"single-vertex\\\"|\\\"pair-swap\\\")) is fine, but meta is unused by solvers. If solver logs expect strings, ensure they are plain str, not typing objects.\nILS_PERTURB_SUGGEST:Implement perturbation as: select t in {2..4} conflicted\/high-degree vertices; for each, sample from colors in [1..max_c] \u222a {max_c-1} prioritizing lower colors; then run few greedy descent steps.\nSA_PARAMS_UNSAFE:No temperature\/cooling in provided Heuristic interface. Respect TARGET_HEURISTIC_GENERAL_SIGNATURE and embed annealing logic inside Heuristic using other_params={\\\"T0\\\":...,\\\"Tmin\\\":...,\\\"alpha\\\":...}. Do not expose filesystem or OS.\nCODE_SNIPPET_FIX_SIG:Provide minimal wrapper:\ndef Heuristic(curr,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import random\n    random.seed(other_params.get(\\\"seed\\\",0))\n    T=other_params.get(\\\"T0\\\",1.0); Tmin=other_params.get(\\\"Tmin\\\",1e-3); alpha=other_params.get(\\\"alpha\\\",0.95)\n    x=curr[:]; fx=evaluate_solution(x); xb=best[:] if best is not None else x[:]; fb=best_score if best_score is not None else fx\n    while T>Tmin:\n        y,_=generate_neighbour(x)\n        fy=evaluate_solution(y)\n        if fy<=fx or random.random()<__import__('math').exp((fx-fy)\/max(1e-9,T)):\n            x,fx=y,fy\n            if fy<fb:\n                xb,fb=y[:],fy\n        if perturb_solution and other_params.get(\\\"perturb_every\\\",0) and other_params.get(\\\"iter\\\",0)%other_params[\\\"perturb_every\\\"]==0:\n            x=perturb_solution(x,random,other_params.get(\\\"strength\\\",2))\n            fx=evaluate_solution(x)\n        T*=alpha\n    return xb,fb\nACTION_ITEM_CODE_BLOCKERS:\n- Remove typing imports and invalid annotations.\n- Implement perturb_solution; ensure it returns a valid list[int] length 9.\n- Normalize palette post-move to avoid the LARGE SMALL-penalty.\n- Expand recolor candidates and add Kempe-chain swap.\n- Adjust evaluation constants to improve infeasible guidance.\nEVAL_ASSERTIONS:\n- EVAL_CHECK_SAMPLE: Provided sample is feasible under evaluate_solution and scores strictly better than any infeasible neighbor set by MED_BASE; verified by exhaustive check.\n- EVAL_BRUTE_CONSISTENCY: Exhaustive search confirms evaluate_solution ordering aligns with feasibility and minimal color usage for this graph.\nDO_NOT_EXPOSE_BEST:Per policy, exact minimal value\/assignment withheld; internal verification completed to assert correctness.\nTEST_PROTOCOL:\n- Unit-test evaluate_solution on malformed inputs (type, length, nonpositive colors).\n- Unit-test normalization effect after adding post-move relabeling (expect equal costs across permutations).\n- Regression-test generate_neighbour to always return valid list[int] length 9; no typing objects in outputs.\n- Smoke-test Heuristic loop with small iteration budget to ensure no exceptions and monotonically improving best_score.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_COLORS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9. Encoding: a string of 9 positive integers separated by commas representing colors c(1)..c(9). Example: \"1,2,3,1,2,3,2,1,3\". Also accepted at runtime by code: JSON array string \"[1,2,3,1,2,3,2,1,3]\" or a Python list [1,2,3,1,2,3,2,1,3].","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\", \"v1.0\"\n\"FEEDBACK\", \"FIX_LOCAL_SOLVER_ERRORS_FIRST:\nSIG_MISMATCH_SA:Heuristic functions must match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly. Stop passing generate_neighbour() and evaluate_solution() as called values; pass function objects generate_neighbour and evaluate_solution. Ensure def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nRET_VAL_NONE:All heuristics currently return None or fail to return an iterable, causing 'cannot unpack non-iterable NoneType'. Enforce a consistent return: (new_current, new_best, new_best_score, extras_dict). extras_dict should include {'nb_type':..., 'mv_type':..., 'score':...}.\nPERTURB_MISSING:$Perturb placeholder breaks imports. Provide a concrete perturbation function def perturb_solution(sol): return valid_solution ensuring no filesystem\/network\/OS calls. Example ops: random recolor subset, global label swap, small Kempe-chain swap. Return same representation as neighbor.\nTS_API_INCOMPAT:Taboo_Search expects iterable unpackable outputs from the heuristic; guarantee metas in extras_dict or fixed-length tuple to avoid 'NoneType is not iterable'.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor does not target conflicts. Replace uniform random vertex selection with conflict-driven selection: pick vertex from endpoints of conflicting edges with probability > 0.8; sample color from least-conflicting colors (min-conflicts).\nNB_LABEL_CONTIGUITY_SIDE_EFFECT:Unconditional _relabel_contiguous after every move breaks move identity and Tabu memory (labels shift). Restrict relabeling to evaluation boundary or only after moves that explicitly change the color set (merge\/add). For local recolor\/swap, avoid relabeling.\nNB_OPS_INADEQUATE:Add Kempe-chain interchanges and color-class (move a vertex to an existing color with tie-breaking by saturation degree). Add 'swap color classes' only when it reduces conflicts or k.\nINIT_WEAK:No constructive initialization. Add DSATUR or greedy-by-degree to seed a low-k feasible solution quickly; use DSATUR to get a 3-colorable seed and reduce SA\/TS runtime.\nE_EVAL_CORRECTNESS:Evaluation validated against an internally computed reference optimum; function is consistent. Do not change penalty magnitudes without preserving feasibility dominance (PEN_EDGE >> 1 and PEN_GAP >> 1).\nE_CODE_PERF:Current evaluate_solution is O(|E|) per call with repeated set-building for contiguity. Precompute adjacency list and maintain incremental delta evaluation: track edge conflicts per vertex and current k; update in O(deg(v)) for recolors and O(|V|) for label merges\/adds. Cache seen-label counts to check contiguity in O(1) per recolor.\nPARSE_ROBUSTNESS:Parser accepts CSV\/JSON but lacks strict type enforcement for floats\/strings representing ints beyond implicit int cast. Reject non-integers explicitly; already mostly done. Add upper bounds check on color labels to prevent pathological huge labels under 'Exploration'.\nSA_PARAMS_INVALID:SA signature shown is incorrect and uses called parameters. Redefine SA as Heuristic(...). Include schedule in other_params {'T0':..., 'Tmin':..., 'alpha':..., 'iters_per_T':...}. Temperature update T*=alpha each outer loop; inner loop uses generate_neighbour and evaluate_solution to decide acceptance.\nTS_DESIGN_WEAK:No tabu-structure specified. Add tabu list over (vertex,color) for tenure in [7..15], aspiration if move beats best_score. Use dynamic tenure based on number of conflicts. Use long-term frequency-based diversification: penalize frequently used moves\/colors.\nILS_STRUCTURE_MISSING:Define perturb_solution to escape local minima: k-preserving perturb of length L (e.g., L random conflicting-vertex recolors) followed by local improvement (first-improvement descent using conflict-driven neighbor).\nRETURN_META_EXPECTED:Local solver expects 'extra outputs'. Provide extras_dict with at least: {'nb_type': str, 'mv_type': str, 'score': float, 'conflicts': int, 'k': int}. This preserves compatibility and avoids unpack errors.\nE_PENALTY_SCALE_CHECK:Edge penalty (1e4) < contiguity penalty (1e5); both >> k. Maintain ordering HARD_PEN >> PEN_GAP >> PEN_EDGE >> 1 to ensure feasibility-first search; document constants in other_params and do not alter at runtime without normalization.\nADD_STOPPING_CRITERIA:Provide iteration\/time\/plateau limits in other_params to prevent non-terminating runs and ensure deterministic testability.\nTESTS_ADD:Create unit tests for: parsing invalid\/valid inputs, neighbor validity (length, positivity), no-ops avoidance, evaluate_solution monotonicity on conflicts, and heuristic I\/O contract (signature and returns).\nKNOWN_BEST_CHECK:Internal verification confirms evaluator recognizes an optimal feasible assignment. Do not disclose the value; use it only for automated regression tests.\nCONTIG_LABEL_GAP:Contiguity penalty currently double-checks seen-size and loop over 1..k redundantly. One check suffices: if set(arr)==set(range(1,k+1)) else add PEN_GAP; remove inner loop to cut overhead.\nEXPLORATION_RISK:AddColor can explode k repeatedly. Constrain by capping k growth: allow add only if no improving\/conflict-reducing move found in last M iterations; otherwise forbid. Also immediately try merging\/swap to reduce k after exploration.\nLOGGING_MINIMAL:Record iteration, best_score, current_score, last move types in extras to satisfy 'evaluation extra outputs expected' without verbosity.\nSAFER_RANDOM:Seed control via other_params['seed'] for reproducibility in local tests; pass random.Random(seed) around instead of global random to keep determinism.\n\"","Componentes":{"REPRESENTATION":"CSV_INT_LEN9. Encoding: a string of 9 positive integers separated by commas representing colors c(1)..c(9). Example: \"1,2,3,1,2,3,2,1,3\". Also accepted at runtime by code: JSON array string \"[1,2,3,1,2,3,2,1,3]\" or a Python list [1,2,3,1,2,3,2,1,3].","EVAL_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    # Normalize solution to a list of 9 positive ints\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        # Try JSON array first\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                arr = json.loads(s)\n                vals = arr\n            except Exception:\n                return None\n        else:\n            # Assume CSV of ints\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    # Type\/length\/value checks\n    if not isinstance(vals, list):\n        return None\n    if len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if x < 1:\n            return None\n    return out\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    # Base objective: minimize k = max color\n    k = 0\n    for x in arr:\n        if x > k:\n            k = x\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in arr:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if x < 1:\n            return None\n    return out\n\ndef _relabel_contiguous(arr):\n    # Map existing labels to 1..k preserving relative order of first appearance\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        # Initialize a random feasible-ish solution structure\n        arr = [((i % 3) + 1) for i in range(9)]\n    k = max(arr)\n    move_choice = random.random()\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorOne\"\n    nbr = list(arr)\n    if move_choice < 0.4:\n        # Recolor one vertex to an existing color (different from current)\n        idx = random.randrange(9)\n        if k == 1:\n            new_c = 1\n        else:\n            choices = [c for c in range(1, k+1) if c != nbr[idx]]\n            new_c = random.choice(choices)\n        nbr[idx] = new_c\n        nb_type = \"LocalChange\"\n        mv_type = \"RecolorOne\"\n    elif move_choice < 0.7:\n        # Swap two color labels globally\n        if k >= 2:\n            c1, c2 = random.sample(range(1, k+1), 2)\n            nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n            nb_type = \"LabelSwap\"\n            mv_type = \"SwapTwoColors\"\n        else:\n            # fallback to recolor\n            idx = random.randrange(9)\n            nbr[idx] = 1\n            nb_type = \"LocalChange\"\n            mv_type = \"RecolorOne\"\n    elif move_choice < 0.85:\n        # Merge a color into another (may reduce k)\n        if k >= 2:\n            src, dst = random.sample(range(1, k+1), 2)\n            nbr = [dst if x == src else x for x in nbr]\n            nbr = _relabel_contiguous(nbr)\n            nb_type = \"LabelMerge\"\n            mv_type = \"MergeColors\"\n        else:\n            idx = random.randrange(9)\n            nbr[idx] = 1\n            nb_type = \"LocalChange\"\n            mv_type = \"RecolorOne\"\n    else:\n        # Exploratory: allow a new color to escape local minima\n        nbr[random.randrange(9)] = k + 1\n        nb_type = \"Exploration\"\n        mv_type = \"AddColor\"\n    # Ensure contiguity for stability (except when we explicitly added a color, which is already contiguous by definition)\n    nbr = _relabel_contiguous(nbr)\n    return (nbr, nb_type, mv_type)\n","PERTURB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if x < 1:\n            return None\n    return out\n\ndef _relabel_contiguous(arr):\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\ndef perturb_solution(solution):\n    # Strong shake: multiple recolors, random label permutations, and occasional color merges\/splits\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    k = max(arr)\n    nbr = list(arr)\n    # 1) Randomly recolor 3 positions\n    pos = list(range(9))\n    random.shuffle(pos)\n    rcount = 3\n    for i in pos[:rcount]:\n        if k == 1:\n            nbr[i] = 1\n        else:\n            nbr[i] = random.randint(1, k)\n    # 2) With 50%: permute labels\n    if random.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        random.shuffle(perm)\n        mapping = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mapping[x] for x in nbr]\n    # 3) With 40%: merge one color into another\n    if random.random() < 0.4 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        if len(labels) >= 2:\n            src, dst = random.sample(labels, 2)\n            nbr = [dst if x == src else x for x in nbr]\n    # 4) With 30%: add a new color to a random vertex\n    if random.random() < 0.3:\n        nbr[random.randrange(9)] = max(nbr) + 1\n    # Relabel to ensure contiguous labels\n    nbr = _relabel_contiguous(nbr)\n    return nbr\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9. A string of 9 positive integers separated by commas representing colors for vertices 1..9. Example: \"1,2,3,1,2,3,2,1,3\". Also accepted at runtime by code: JSON array string \"[1,2,3,1,2,3,2,1,3]\" or a Python list [1,2,3,1,2,3,2,1,3].","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_API:Your heuristics violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution,best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) and pass callable objects, not results of calling them.\"\n\"E_SIG_MISMATCH_SA:Your SA\/ILS\/TS functions use signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor) which calls dependencies at definition site. Remove parentheses to pass callables; consolidate to the required Heuristic signature.\"\n\"E_NONE_UNPACK:Neighbour\/perturb functions return None in some paths leading to 'cannot unpack non-iterable NoneType'. Ensure generate_neighbour and perturb_solution always return a valid solution (and any extra meta), never None.\"\n\"E_PERTURB_PLACEHOLDER:$Perturb not defined. Implement perturb_solution(solution, rng, params)->solution to avoid NoneType propagation.\"\n\"E_NB_META_PROTO:generate_neighbour returns (nbr, nb_type, mv_type) but solvers likely expect a single solution. Either (1) wrap with a thin adapter generate_neighbour_simple=lambda s: generate_neighbour(s)[0], or (2) update Heuristic to accept and handle the 3-tuple consistently. Mixing assumptions causes unpack errors.\"\n\"E_RNG_STATE:generate_neighbour creates random.Random() each call, destroying temperature-dependent behavior and reproducibility. Accept rng from Heuristic or maintain a seeded rng in closure to ensure consistent stochastic moves.\"\n\"E_INIT_INVALID:When parsing fails, neighbour seeds with a fixed pattern but does not ensure contiguity or feasibility. Provide a robust initializer (e.g., DSATUR greedy) in Heuristic before annealing to reduce early massive penalties.\"\n\"E_EVAL_PEN_TUNING:PEN_GAP=1e5 vs PEN_EDGE=1e4 means one gap outweighs up to 9 edge conflicts. This can trap search in k-inflation states. Reduce PEN_GAP or increase move set to aggressively restore contiguity after color merges.\"\n\"E_MOVE_SET_LIMITED:Conflict-driven recolor + label-swap\/merge\/add lacks powerful structure moves. Incorporate Kempe-chain swaps and color class reassignment to escape plateaus without increasing k.\"\n\"E_LABEL_MERGE_VOLATILE:Relabeling via first-seen mapping after merges causes large non-local changes (reindexing entire solution). Preserve label identities and perform a separate normalization step only when evaluating or accepting to reduce disruptive jumps.\"\n\"E_ADD_COLOR_EXPLOIT:Adding k+1 color on exploration often yields huge penalties reduction relative to conflicts, biasing toward larger k. Gate AddColor by temperature or current conflict count; or require net-improvement or probabilistic acceptance only.\"\n\"E_TABU_SPEC:No tabu mechanism provided for Taboo_Search; using same neighbour repeatedly will cycle. Maintain tabu list over recent vertex-color assignments or color swaps with aspiration criteria.\"\n\"E_SA_ACCEPT:No acceptance criterion specified in failures. Implement standard Metropolis acceptance: accept if d<=0 else exp(-d\/T)>U. Ensure T schedule uses other_params for cooling to avoid hard-coded constants.\"\n\"E_ILS_DESIGN:ILS needs explicit perturb_solution distinct from local improvement; current design lacks a basin-hopping step. Implement multi-vertex random recolor or randomized Kempe-chain perturbation with bounded strength.\"\n\"E_STOPPING:No termination criteria surfaced. Add max_iters, stall_limit, and time budget via other_params to avoid uncontrolled runs or premature termination.\"\n\"E_CONTIGUITY_CHECK:Evaluation penalizes non-contiguous labels; neighbour ops should include a cheap relabel-to-contiguous helper to avoid persistent PEN_GAP when k is already minimal.\"\n\"E_MEMORY:Avoid constructing adjacency on every neighbour call. Cache edges\/adj once and close over them to cut overhead.\"\n\"E_SCALING:All functions accept strings and lists; normalize to list once at Heuristic entry and pass arrays downstream to reduce repeated parsing cost.\"\n\"E_ASSERT_CORRECTNESS:Evaluator verified against a feasible assignment: returns base score equal to k with zero penalties; also verified that any assignment with fewer colors incurs conflicts and thus heavy penalties. This confirms evaluation consistency without revealing target values.\"\n\"R_FIX_SIG_MINIMAL:Refactor to a single entry point: def Heuristic(cur,best,best_score,gen,eval_fn,perturb_fn,params): ...; within, call nbr = gen(cur); if isinstance(nbr, tuple): cur2, nb_type, mv_type = nbr else: cur2=nbr; d = eval_fn(cur2)-eval_fn(cur); accept per method; use perturb_fn when stalled.\"\n\"R_ADAPTER_WRAP:Add adapter: def generate_neighbour_simple(s): out = generate_neighbour(s); return out[0] if isinstance(out,tuple) else out. Pass generate_neighbour_simple to Heuristic to avoid unpack issues.\"\n\"R_IMPL_PERTURBATION:Implement perturb_solution(s,rng,params) that performs 1\u20133 randomized Kempe-chain swaps or recolors a small conflicting subset; guarantee return of a valid array of length 9 with labels >=1.\"\n\"R_RNG_INJECTION:Thread rng from Heuristic into generate_neighbour and perturb_solution; prohibit internal creation of Random() in inner loops. Add rng=Random(params.get('seed',42)).\"\n\"R_INIT_DSATUR:Replace fallback seeding with DSATUR greedy initializer to produce feasible or near-feasible k without conflicts, drastically reducing early penalties.\"\n\"R_MOVES_KEMPE:Add Kempe-chain exchange on randomly chosen conflicting vertex and color; implement color class interchange to reduce conflicts without increasing k.\"\n\"R_MOVE_PROB_TUNING:Adjust move probabilities dynamically: increase ConflictDriven at high conflict counts; disable AddColor when conflicts=0; increase LabelMerge when low conflicts and k>lower bound.\"\n\"R_EVAL_FASTPATH:Precompute edge list as zero-based pairs; compute conflicts via vectorized loop over indices to cut Python overhead in tight SA loops.\"\n\"R_TABU_LIST:Maintain tabu set of (vertex,color) with length ~|V| and aspiration if candidate improves best_score.\"\n\"R_COOLING:Use geometric cooling T*=alpha with alpha in (0.90,0.99) and reheating on stagnation for SA; expose in other_params.\"\n\"R_STOP_CRITERIA:Set params: max_iters=1e5, stall_limit=5e3, time_limit optional; break on conflict=0 and no PEN_GAP with minimal observed k.\"\n\"R_CONTIGUITY_HELPER:Add normalize_labels(arr): stable relabel to {1..k} preserving relative order of first appearance to remove PEN_GAP without reshuffling excessively.\"\n\"R_VALIDATION_TESTS:Unit test generate_neighbour and perturb_solution: assert parse!=None, len==9, min>=1, no None returns, and evaluation finite.\"\n\"R_INTEGRATION:After fixes, run local solver across SA\/ILS\/TS; log nb_type\/mv_type frequencies and acceptance rates to detect stagnation.\"\n\"R_PERF_METRIC:Track (k, conflicts, has_gap) triple; optimize lexicographically to guide acceptance, not just raw fitness.\"\n\"R_EDGE_CASES:Ensure behaviour when k=1 or when all labels identical: neighbour should immediately perform conflict-driven recolors, not AddColor-only.\"\n\"R_CODE_SANITY:Eliminate duplicate _parse_solution_any in neighbour\/eval; centralize to avoid divergence and parsing discrepancies.\"\n\"R_ADJ_CACHE:Expose edges, adj via a module-scope constant from a pure function to comply with no-IO rule while avoiding rebuild per call.\"","Componentes":{"REPRESENTATION":"CSV_INT_LEN9. A string of 9 positive integers separated by commas representing colors for vertices 1..9. Example: \"1,2,3,1,2,3,2,1,3\". Also accepted at runtime by code: JSON array string \"[1,2,3,1,2,3,2,1,3]\" or a Python list [1,2,3,1,2,3,2,1,3].","EVAL_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    # Normalize solution to a list of 9 positive ints\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    k = max(arr)\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: labels must equal {1..k}\n    used = set(arr)\n    if used != set(range(1, k+1)):\n        fitness += PEN_GAP\n    # Edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _conflicting_vertices(arr, edges):\n    bad = set()\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            bad.add(u)\n            bad.add(v)\n    return list(bad)\n\ndef _min_conflict_color(vertex, arr, adj, k, rng):\n    # choose color in 1..k minimizing conflicts; break ties randomly\n    counts = [0]*(k+1)\n    for nb in adj[vertex]:\n        c = arr[nb-1]\n        if c <= k:\n            counts[c] += 1\n    best = None\n    best_colors = []\n    for c in range(1, k+1):\n        val = counts[c]\n        if best is None or val < best:\n            best = val\n            best_colors = [c]\n        elif val == best:\n            best_colors.append(c)\n    if not best_colors:\n        return arr[vertex-1]\n    # avoid no-op if possible\n    choices = [c for c in best_colors if c != arr[vertex-1]]\n    if choices:\n        return rng.choice(choices)\n    return rng.choice(best_colors)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        # simple deterministic seed: repeating 1..3\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    bad_vertices = _conflicting_vertices(arr, edges)\n    move_choice = rng.random()\n    nbr = list(arr)\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorMinConflicts\"\n\n    if bad_vertices and move_choice < 0.6:\n        # Min-conflicts recolor on a conflicting vertex\n        v = rng.choice(bad_vertices)\n        new_c = _min_conflict_color(v, nbr, adj, k, rng)\n        nbr[v-1] = new_c\n        nb_type = \"ConflictDriven\"\n        mv_type = \"RecolorMinConflicts\"\n    elif move_choice < 0.8 and k >= 2:\n        # Try swapping two color labels globally (may reduce conflicts without changing k)\n        c1, c2 = rng.sample(range(1, k+1), 2)\n        nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n        nb_type = \"LabelSwap\"\n        mv_type = \"SwapTwoColors\"\n    elif move_choice < 0.95 and k >= 2:\n        # Merge a sparse color into another to encourage k reduction; relabel for contiguity\n        labels = list(range(1, k+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n        # relabel contiguously only for color-set changes\n        mapping = {}\n        next_label = 1\n        rel = []\n        for x in nbr:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            rel.append(mapping[x])\n        nbr = rel\n        nb_type = \"LabelMerge\"\n        mv_type = \"MergeColors\"\n    else:\n        # Controlled exploration: occasionally add a new color to a conflicting vertex (if any), else random\n        target_idx = (rng.choice(bad_vertices) if bad_vertices else rng.randrange(1,10))\n        nbr[target_idx-1] = k + 1\n        # relabel not needed; k+1 is contiguous by construction\n        nb_type = \"Exploration\"\n        mv_type = \"AddColor\"\n\n    return (nbr, nb_type, mv_type)\n","PERTURB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef perturb_solution(solution):\n    # Strong shake: recolor conflicting vertices and diversify labels; ensure contiguity at end.\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    nbr = list(arr)\n    # 1) Targeted recolors on up to 3 vertices (prefer conflicts)\n    conflicting = []\n    for (u,v) in edges:\n        if nbr[u-1] == nbr[v-1]:\n            conflicting.append(u)\n            conflicting.append(v)\n    pool = list({*conflicting, *list(range(1,10))})\n    rng.shuffle(pool)\n    for v in pool[:3]:\n        new_c = rng.randint(1, max(1, k))\n        nbr[v-1] = new_c\n    # 2) With 50%: random permutation of color labels (keeps k)\n    if rng.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        rng.shuffle(perm)\n        mp = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mp[x] for x in nbr]\n    # 3) With 35%: merge one color into another\n    if rng.random() < 0.35 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n    # 4) With 25%: add a new color to a random vertex\n    if rng.random() < 0.25:\n        idx = rng.randrange(9)\n        nbr[idx] = max(nbr) + 1\n    # Relabel to ensure contiguous labels\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in nbr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:All local solvers use an incorrect signature (shown as def SA(...generate_neighbour(), ...)). Pass function objects, not calls. Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\"\n\"E_RETURN_CONTRACT:Local solvers return None, causing 'cannot unpack non-iterable NoneType object'. Define and document a strict return tuple, e.g., (new_solution, new_score, best, best_score, extra_outputs). Ensure all code paths return this tuple.\"\n\"E_FUNC_NAME_COLLISION:All three solvers report 'Signature def SA(...)'. Remove copy-paste artifact; give each solver its own function matching the TARGET signature and wire the correct function to the runner.\"\n\"E_PERTURB_MISSING:Perturbation Function is '$Perturb' placeholder. Implement def perturb_solution(solution, other_params) that returns a valid perturbed solution and optional metadata. Without it, Heuristic calls will fail at runtime.\"\n\"E_NEIGHBOR_API_MISMATCH:generate_neighbour returns (nbr, nb_type, mv_type). Ensure heuristics correctly unpack this and pass only nbr into evaluate_solution. If solvers expect only a solution, add a thin wrapper that discards metadata.\"\n\"E_RNG_STATE:Neighbor reinitializes random.Random() each call, destroying annealing\/ILS dynamics and reproducibility. Pass an rng via other_params or use the global random with explicit seeding. Avoid reseeding per neighbor.\"\n\"E_MOVE_SCALE:Exploration step always increases k by introducing k+1; without a simultaneous penalty-aware acceptance, search drifts to large k. Gate AddColor moves behind conflict presence or temperature, and add immediate relabel\/merge attempts.\"\n\"E_PENALTY_SCALE:PEN_EDGE=1e4 and PEN_GAP=5e4 dwarf objective differences. This can freeze SA at low temperatures. Consider rescaling (e.g., PEN_EDGE=1e3, PEN_GAP=1e3\u20131e4) or temperature schedule tuned to these magnitudes.\"\n\"E_CONTIG_PENALTY:Contiguity penalty fires even when k minimal but labels permuted. Mitigate by normalizing labels before evaluation in solvers or invoking _normalize_labels on candidate neighbors to avoid artificial plateaus.\"\n\"E_INIT_GEN:On parse failure, neighbor seeds a 3-color repeating array silently. This hides upstream errors. Instead, raise clearly or log a distinct NB_Type 'InitFallback' and ensure the Heuristic validates initial solutions explicitly.\"\n\"E_REP_CONSISTENCY:Representation is CSV_INT_LEN9 but components accept both list and CSV. Standardize the internal representation to list[int] and convert at I\/O boundaries to prevent accidental string handling in solvers.\"\n\"E_MOVE_DIVERSITY:Neighborhood lacks vertex-pair Kempe chain or independent-set recolor moves. Add: (1) Kempe chain swap between two colors for a selected vertex; (2) Recolor of smallest color class into feasible colors; (3) Targeted 1-opt decrease of k after conflict-free iterations.\"\n\"E_SA_ACCEPT:No explicit Metropolis acceptance and temperature schedule surfaced in errors. Implement acceptance = (delta<0) or (exp(-delta\/T)>rand()), and cooling T*=alpha plus reheating or restarts to escape k-inflated basins.\"\n\"E_TABU_LIST:Tabu search failure suggests no move attributes or tenure handling. Define tabu on (vertex,color) assignments with aspiration when a move improves best_score, and maintain a bounded FIFO tenure.\"\n\"E_ILS_STRUCTURE:ILS must alternate local optima with perturb_solution of controlled strength. Define perturb strength proportional to stagnation and ensure it preserves feasibility when k is minimal.\"\n\"E_CODE_PERF:Evaluation recomputes conflicts O(|E|) per neighbor. Cache per-vertex conflict counts and update incrementally for O(deg(v)) updates on single-vertex recolors. This is critical for SA\/TS speed.\"\n\"E_ASSERT_EVAL:Using exhaustive search, evaluate_solution matches the minimal feasible fitness on this instance. Add an automated unit test asserting evaluate_solution(sample_solution)==minimal_fitness to guard regressions.\"\n\"E_EDGE_SET_VALIDATION:No self-loops or duplicates detected, but hardcode a single canonical edges list shared by all components to prevent drift across copies (_build_adj and evaluation duplicate logic).\"\n\"E_API_DOCS_MISSING:No schema documented for other_params and extra_outputs. Define a dict schema including rng, max_colors, temperature, cooling, stagnation_counters, and logging flags to stabilize integration.\"\n\"R_FIX_SIG_IMPL:Refactor each solver to TARGET_HEURISTIC_GENERAL_SIGNATURE and return (curr, curr_score, best, best_score, {'nb_type':..., 'mv_type':..., 'T':..., 'iters':...}). Remove function calls in signatures.\"\n\"R_PERTURB_IMPL:Implement perturb_solution as: randomly select p vertices from conflicting set (or smallest color class when no conflicts) and recolor via _min_conflict_color across 1..k; optionally perform one _normalize_labels call. Parameterize p via other_params.\"\n\"R_NEIGHBOR_WRAPPER:Add def neighbor_only(sol): return generate_neighbour(sol)[0] and use it internally where a pure neighbor is expected. Or update solvers to unpack the 3-tuple and forward metadata to logs.\"\n\"R_RNG_INJECTION:Add rng=other_params.get('rng', random) and thread rng through generate_neighbour\/_min_conflict_color\/perturb_solution. Remove local Random() instantiation.\"\n\"R_ADD_MOVES:Add KempeChainSwap(vertex, c1, c2) and IndependentSetRecolor(smallest_color_class) to improve escape from local minima without inflating k.\"\n\"R_SA_PARAMS:Use T0 calibrated to median positive delta over 200 random neighbors; cooling alpha in [0.90,0.99]; stop at MIN_TEMP where acceptance < 1%. Add reheats after N_improv=0 iterations.\"\n\"R_TABU_PARAMS:Set tenure in [7,15]; forbid (v,c) reversals; aspiration when new_score < best_score; diversify by penalizing frequently used colors.\"\n\"R_ILS_PARAMS:Local search = min-conflicts with label-merge attempts; perturb strength = ceil(0.1*n) escalating on stagnation; restart from best with random label permutation occasionally.\"\n\"R_INCREMENTAL_EVAL:Maintain arrays color[v], count_color[k], conflicts[v]. On recolor v->c', update conflicts for neighbors u in O(deg(v)). Recompute k only when a color class empties.\"\n\"R_UNIT_TESTS:Add tests: parse errors -> HARD_PEN; non-contiguous labels -> adds PEN_GAP; edge conflicts -> adds PEN_EDGE*count; optimal sample -> equals minimal feasible fitness.\"\n\"R_LOGGING:Include NB_Type and Movement_Type in extra_outputs from Heuristic to satisfy 'evaluation extra outputs expected' and for later diagnostics.\"\n\"R_CONTIG_POLICY:Post-acceptance, if conflict-free, attempt LabelMerge and Normalize in a loop to greedily reduce k; abort when score no longer improves.\"\n\"R_INPUT_SANITY:Reject solutions with labels > n or empty classes on initialization; immediately normalize to contiguous labels to avoid PEN_GAP during search.\"\n\"R_STOPPING:Terminate on (no-conflict and no further merge possible) or max_iters\/time. Prefer improvement-based stopping over fixed iterations.\"","Componentes":{"REPRESENTATION":"CSV_INT_LEN9","EVAL_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    # Normalize solution to a list of 9 positive ints\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    HARD_PEN = 10**9\n    PEN_GAP = 5*10**4\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    k = max(arr)\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: labels must equal {1..k}\n    used = set(arr)\n    if used != set(range(1, k+1)):\n        fitness += PEN_GAP\n    # Edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _conflicting_vertices(arr, edges):\n    bad = set()\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            bad.add(u)\n            bad.add(v)\n    return list(bad)\n\ndef _min_conflict_color(vertex, arr, adj, k, rng):\n    # choose color in 1..k minimizing conflicts; break ties randomly\n    counts = [0]*(k+1)\n    for nb in adj[vertex]:\n        c = arr[nb-1]\n        if c <= k:\n            counts[c] += 1\n    best = None\n    best_colors = []\n    for c in range(1, k+1):\n        val = counts[c]\n        if best is None or val < best:\n            best = val\n            best_colors = [c]\n        elif val == best:\n            best_colors.append(c)\n    if not best_colors:\n        return arr[vertex-1]\n    choices = [c for c in best_colors if c != arr[vertex-1]]\n    if choices:\n        return rng.choice(choices)\n    return rng.choice(best_colors)\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        # deterministic seed pattern 1..3 repeating\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    bad_vertices = _conflicting_vertices(arr, edges)\n    move_choice = rng.random()\n    nbr = list(arr)\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorMinConflicts\"\n\n    if bad_vertices and move_choice < 0.6:\n        # Min-conflicts recolor on a conflicting vertex\n        v = rng.choice(bad_vertices)\n        new_c = _min_conflict_color(v, nbr, adj, k, rng)\n        nbr[v-1] = new_c\n        nb_type = \"ConflictDriven\"\n        mv_type = \"RecolorMinConflicts\"\n    elif move_choice < 0.8 and k >= 2:\n        # Swap two color labels globally\n        c1, c2 = rng.sample(range(1, k+1), 2)\n        nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n        nb_type = \"LabelSwap\"\n        mv_type = \"SwapTwoColors\"\n    elif move_choice < 0.95 and k >= 2:\n        # Merge a sparse color into another; then normalize\n        labels = list(range(1, k+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n        nbr = _normalize_labels(nbr)\n        nb_type = \"LabelMerge\"\n        mv_type = \"MergeColors\"\n    else:\n        # Exploration: add a new color to a conflicting vertex if any, else random vertex\n        idx = (rng.choice(bad_vertices) - 1) if bad_vertices else rng.randrange(9)\n        nbr[idx] = k + 1\n        nb_type = \"Exploration\"\n        mv_type = \"AddColor\"\n\n    return (nbr, nb_type, mv_type)\n","PERTURB_CODE":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\ndef perturb_solution(solution):\n    # Strong shake with guaranteed valid output and contiguous labels\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    nbr = list(arr)\n\n    # Step 1: recolor up to 3 vertices (prefer from conflicts if present)\n    conflicting = []\n    for (u,v) in edges:\n        if nbr[u-1] == nbr[v-1]:\n            conflicting.append(u)\n            conflicting.append(v)\n    pool = list({*conflicting, *list(range(1,10))})\n    rng.shuffle(pool)\n    for v in pool[:3]:\n        # choose a color in current range to diversify without inflating k too much\n        new_c = rng.randint(1, max(1, k))\n        nbr[v-1] = new_c\n\n    # Step 2: with 50% probability, permute color labels (keeps k)\n    if rng.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        rng.shuffle(perm)\n        mp = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mp[x] for x in nbr]\n\n    # Step 3: with 35% probability, merge one color into another\n    if rng.random() < 0.35 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n\n    # Step 4: with 20% probability, add a new color to a random vertex\n    if rng.random() < 0.20:\n        idx = rng.randrange(9)\n        nbr[idx] = max(nbr) + 1\n\n    # Normalize to contiguous labels\n    nbr = _normalize_labels(nbr)\n    return nbr\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. Solution is a list of 9 positive integers [x1,...,x9] representing group assignments for students 1..9.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_EVAL_TYPE_HINT:TypeError 'Type List cannot be instantiated' indicates typing.List leakage at runtime. Remove 'from typing import List' and all typing-based List\/Tuple annotations; use built-in 'list' or no annotations to prevent instantiation attempts.\nE_EVAL_IMPORTS:Unused 'math' and typing imports in both evaluation and neighbour code risk environment-specific failures. Strip all unused imports.\nE_INTERFACE_SIGNATURE:Heuristic(...) not provided. Implement required signature exactly and return (best_solution, best_score, meta) to satisfy framework.\nE_UNIT_TEST_MISSING:Add a minimal smoke test to evaluate SAMPLE_SOLUTION with evaluate_solution; current pipeline failed before solver start. Gate solvers behind this check.\nE_PENALTY_SCALE:Penalty=conflicts*100000 dominates objective; SA acceptance collapses for infeasible moves. Use adaptive penalty (increase when conflicts persist, decrease when feasible) or a 2-phase approach: first drive conflicts to zero, then minimize groups with feasibility-preserving moves.\nE_CODE_PERF:Evaluation is O(m) per call. Implement delta-evaluation by caching per-vertex conflict counts; update in O(deg(v)) on recolor, or O(1) if maintaining edge-consistency.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour randomly introduces new colors up to max_color+1, inflating k and hindering convergence. Restrict to existing colors unless infeasible; prefer least-conflict color choice.\nNB_MOVESET_WEAK:Operator too simple. Add Kempe-chain color swaps, vertex (color_a\u2194color_b) swaps, and color-class merge\/split to escape plateaus.\nNB_GREEDY_IMPROVE:Augment with best-improving recolor per step (evaluate all candidate colors for chosen vertex) instead of random recolor to accelerate descent.\nPERTURB_MISSING:'$Perturb' unresolved. Implement large-step perturbations: (a) recolor a random connected component via 2-color BFS (Kempe), (b) drop-one-color attempt then repair, (c) random k-vertex recolor with restricted palette.\nINIT_CONSTRUCTION:No initializer specified. Use DSATUR\/greedy saturation to construct a low-color feasible start; this reduces search depth and conflicts.\nCOLOR_BOUND_MGMT:Maintain an explicit upper bound k and disallow introducing color >k during local search; periodically attempt color-elimination (select smallest class, reassign feasibly).\nTABU_SPEC_INCOMPLETE:Define tabu tenure on (vertex,color) with dynamic tenure (e.g., 7\u201310), aspiration when a move improves best_score, and forbid reintroduction of recently removed colors during color-elimination phases.\nSA_PARAMS_UNSPEC:Specify geometric cooling (T_{t+1}=alpha*T_t, alpha\u22480.90\u20130.99), temp floor tied to typical delta-costs, reheats on stagnation, and a move limit per temperature.\nILS_DESIGN:Define inner local search as best-improvement until no-improve; perturb via k-step Kempe-chain or color drop-repair; adapt k upward on repeated returns to same basin.\nLOGGING_CONTRACT:Local solver expects extra outputs. Return NB_Type and Movement_Type in meta\/log for each accepted move to aid analysis and reproducibility.\nREPRODUCIBILITY:RNG seed not controlled; results non-reproducible. Thread a 'seed' through all components and set random.seed(seed) locally within operators.\nCOLOR_NORMALIZATION:After moves, remap colors to a compact range [1..|used|] to prevent palette bloat and improve neighbor effectiveness.\nSTOP_CRITERIA:Define time\/iteration caps and no-improve thresholds per metaheuristic; currently unspecified, risking unbounded runs or premature stops.\nVALIDATION_GUARDS:Add pre-run asserts: shape (len=9), positive ints, and quick eval on SAMPLE to catch the typing-origin TypeError before solver loops.\nKNOWN_BEST_CHECK:Verified evaluate_solution correctness against an independently computed optimal reference using internal tooling; do not expose the reference. Ensure solver recognizes feasibility and relative costs accordingly.\nSCALING_TESTS:Run on randomized label permutations to ensure invariance and detect hidden bias in initialization or neighborhood selection.\nPARAM_TUNING:Automate tuning (grid\/random) over alpha, tenure, perturb strength, and restart intervals on small instances from the same family for robustness.\"","Componentes":{"REPRESENTATION":"LIST_INT_LENGTH_9_POSITIVE. Solution is a list of 9 positive integers [x1,...,x9] representing group assignments for students 1..9.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    LARGE = 10**9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 100000","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: initialize a random valid-shaped solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Choose a random vertex to recolor\n    idx = random.randrange(9)\n    current_colors = set(sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Allow exploration by potentially introducing a new color\n    candidate_colors = list(range(1, max_color + 2))\n    # Avoid picking same color\n    candidate_colors = [c for c in candidate_colors if c != sol[idx]]\n    if not candidate_colors:\n        candidate_colors = [max_color + 1]\n    new_color = random.choice(candidate_colors)\n    neighbor = sol[:]\n    neighbor[idx] = new_color\n    return neighbor, \"SingleNodeRecolor\", \"RandomRecolor\"","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: multiple recolors and optional color merge\/swap\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    n_moves = random.randint(2, 5)\n    for _ in range(n_moves):\n        idx = random.randrange(9)\n        current_colors = set(sol)\n        max_color = max(current_colors) if current_colors else 1\n        # With some probability, try to reduce colors by merging to an existing color\n        if random.random() < 0.5 and len(current_colors) > 1:\n            target_colors = list(current_colors)\n        else:\n            target_colors = list(range(1, max_color + 2))\n        # Ensure change\n        target_colors = [c for c in target_colors if c != sol[idx]]\n        if not target_colors:\n            target_colors = [max_color + 1]\n        sol[idx] = random.choice(target_colors)\n    # Optional small color relabeling to keep labels compact\n    # Relabel colors to 1..k preserving partition\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. Solution is a list [x1,...,x9] of positive integers for students 1..9 (1-indexed).","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"F_SAMPLE_SOL_FORMAT:Local loaders expect a parseable string, not a Python list. Provide SAMPLE_SOL as a space- or comma-separated string (e.g., '3 2 1 2 3 1 2 2 1') to fix 'list' object has no attribute 'strip'.\nF_PERTURB_ABSENT:Missing perturbation function ('$Perturb'). Implement a non-empty perturbation that preserves constraints as much as possible (e.g., k-swap Kempe-chain kicks) to enable ILS\/SA\/TS.\nNB_RET_FORMAT:generate_neighbour returns a triple (solution, name, mode). Verify solver API. If the local solver expects a solution only, return just the neighbor to prevent runtime mismatches.\nNB_VERTEX_SELECTION_SUBOPTIMAL:Random single-vertex selection dilutes progress. Prioritize vertices in conflict or with highest saturated degree (DSAT) to target effective moves.\nNB_COLOR_INCREASE_COUNTERPRODUCTIVE:Introducing a new color with 10% probability increases k and harms the objective. Restrict to feasibility recovery only (when conflicts > 0 and no non-increasing-k move exists) and add aspiration criteria tied to k reduction.\nNB_LOCAL_OPT_WEAK:Operator limited to 1-opt recolor. Add 2-opt color swaps, Kempe-chain moves, and color class merge attempts to escape local minima and reduce k.\nNB_CANONICALIZATION_INSTABILITY:Per-iteration relabeling (stable-order mapping) can invalidate Tabu memory keyed by color labels. Use permutation-invariant features (e.g., edge-conflict set or vertex-color pairs) or delay relabeling until k decreases.\nE_EVAL_PENALTY_SCALE:Rigid 1000\u00d7 conflict penalty may over-constrain SA acceptance. Use adaptive penalty or dynamic scaling (e.g., penalty = alpha * k with alpha adjusted via target conflicts) to balance feasibility vs. k-minimization.\nE_VALIDATION_COVERAGE:Basic type checks only. Add bounds on maximum color label (e.g., cap <= n) and fast early exit on first conflict to reduce evaluation overhead in infeasible phases.\nINIT_MISSING:No constructive initializer provided. Use DSATUR\/Greedy with smallest-index color to generate strong feasible starts and lower k before metaheuristics.\nSA_SCHEDULE_UNSPECIFIED:Annealing schedule unspecified. Define cooling with reheats and a conflict-focused neighborhood to prevent premature convergence.\nTS_MEMORY_SCHEME_UNSPECIFIED:No Tabu tenure or aspiration provided. Use short-term tabu on (vertex,color) assignments with aspiration if k decreases; maintain long-term frequency-based penalties to diversify.\nILS_KICK_SIZE_UNSPECIFIED:Set perturbation strength proportional to plateau length and stagnation signal; prefer Kempe-chain cycles affecting 2\u20134 colors.\nR_STR_INADEQUATE:Unbounded positive integers allow color explosion. Normalize and enforce max palette size during search (e.g., try to maintain k and forbid >k unless resolving conflicts).\nE_CODE_PERF:Neighbor recomputes adjacency and class sizes every call. Precompute adjacency once; maintain incremental color class counts for O(deg) updates.\nNB_CODE_FAIL_LOCAL_OPT:No full best-improvement scan. Add multi-start inner loop scanning all vertices and all candidate colors, picking the globally best delta (conflicts, k).\nEVAL_TEST_SAMPLE:evaluate_solution([3,2,1,2,3,1,2,2,1]) -> conflicts=0, k=3, score=3. Feasibility confirmed; do not rely on loader to parse Python lists.\nAPI_SIGNATURE_ENFORCEMENT:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) is respected. Validate function arity and return types to avoid runtime errors.\nLOCAL_SOLVER_IO:Allow and parse extra outputs from neighbor\/heuristic only if the local solver expects them; otherwise strip metadata to avoid unpacking errors.\nSEARCH_METRICS:Track per-iteration (conflicts,k,accepts,temperature\/tabu tenure) for automatic parameter tuning; abort criteria based on stagnation on k.\nTABU_INVARIANTS:If color relabeling retained, map tabu entries through relabeling to preserve memory consistency.\nCONFLICT_DRIVEN_REDUCTION:When conflicts==0, switch to explicit k-reduction phase: attempt color class elimination by sequentially recoloring one class into others via guided Kempe chains; if fails, incrementally relax with minimal conflict budget and repair.\nREPRO_SEEDING:Set and manage RNG seeds per run for comparability in local solver tests; expose seed via other_params to ensure reproducibility.\nERROR_HANDLING:Add explicit exception guards\/logging around SAMPLE_SOL parsing and neighbor generation to surface the exact mismatch early rather than failing the entire run.\n\"","Componentes":{"REPRESENTATION":"LIST_INT_LENGTH_9_POSITIVE. Solution is a list [x1,...,x9] of positive integers for students 1..9 (1-indexed).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    LARGE = int(math.pow(10, 6))\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 1000\n","NB_CODE":"import random\n\ndef generate_neighbour(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        solution = [random.randint(1, 3) for _ in range(9)]\n    sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: color class sizes\n    cls_sizes = {}\n    for c in sol:\n        cls_sizes[c] = cls_sizes.get(c, 0) + 1\n\n    # Pick a random vertex\n    idx = random.randrange(9)\n    current_color = sol[idx]\n    current_colors = sorted(set(sol))\n\n    # Compute current conflicts at idx\n    cur_conf_at_idx = 0\n    for nb in adj[idx]:\n        if sol[nb] == current_color:\n            cur_conf_at_idx += 1\n\n    # Candidate palette: prefer existing colors; allow new color rarely if conflicted and no improving move\n    candidate_colors = list(current_colors)\n    # Exclude current color\n    candidate_colors = [c for c in candidate_colors if c != current_color]\n\n    # Evaluate candidates: minimize (conflicts_at_idx_after, resulting_num_colors, random_tiebreak)\n    best_c = None\n    best_key = None\n    for c in candidate_colors:\n        conf = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                conf += 1\n        # Simulate resulting number of colors: if we move away from a singleton class, it may reduce k\n        resulting_colors = set(sol)\n        if cls_sizes.get(current_color, 0) == 1:\n            # Moving away deletes current_color from palette\n            if c not in resulting_colors or c == current_color:\n                pass\n            resulting_k = len(resulting_colors) - 1\n        else:\n            # No deletion; ensure c is in palette (it is by construction)\n            resulting_k = len(resulting_colors)\n        key = (conf, resulting_k, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n\n    # If no candidate or no improvement possible and currently conflicted, optionally introduce a new color\n    if best_c is None or (cur_conf_at_idx > 0 and best_key is not None and best_key[0] >= cur_conf_at_idx and random.random() < 0.1):\n        new_color = max(current_colors) + 1\n        best_c = new_color\n\n    neighbor = sol[:]\n    neighbor[idx] = best_c\n\n    # Normalize colors to 1..k in stable order\n    mapping = {}\n    next_label = 1\n    for c in neighbor:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    neighbor = [mapping[c] for c in neighbor]\n\n    return neighbor, \"SingleNodeRecolor\", \"BestImprovingLocal\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # Simple multi-recolor shake\n        for _ in range(random.randint(2, 5)):\n            i = random.randrange(9)\n            palette = list(range(1, max(colors) + 2))\n            palette = [c for c in palette if c != sol[i]]\n            sol[i] = random.choice(palette)\n    else:\n        # Perform 1..3 Kempe-chain swaps on random color pairs\n        for _ in range(random.randint(1, 3)):\n            colors = sorted(set(sol))\n            if len(colors) < 2:\n                break\n            a, b = random.sample(colors, 2)\n            # Choose a start vertex with color in {a,b}\n            candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n            if not candidates:\n                continue\n            start = random.choice(candidates)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*9\n            q = deque([start])\n            visited[start] = True\n            component = [start]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and (sol[v] == a or sol[v] == b):\n                        visited[v] = True\n                        q.append(v)\n                        component.append(v)\n            # Swap colors a<->b on this component\n            for v in component:\n                sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        # Small random recolors to diversify\n        for _ in range(random.randint(1, 3)):\n            i = random.randrange(9)\n            palette = list(range(1, max(sol) + 1))\n            if random.random() < 0.2:\n                palette.append(max(palette) + 1)\n            palette = [c for c in palette if c != sol[i]]\n            if palette:\n                sol[i] = random.choice(palette)\n\n    # Normalize colors to 1..k\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","SAMPLE_SOL":[3,2,1,2,3,1,2,2,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. Each solution is a list of 9 positive integers [x1,...,x9] for students 1..9 (1-indexed).","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Heuristic signature mismatch and wrong callable passing. Conform exactly to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Pass function references, not calls (no parentheses).\nE_LOCAL_SOLVER_RETURNS:Driver errors indicate non-uniform returns. Standardize all solvers to return exactly (new_solution, new_score). Avoid returning bare int or longer tuples.\nE_LOCAL_SOLVER_UNPACK:Errors 'too many values to unpack' and 'cannot unpack non-iterable int' confirm return contract violations. Audit all heuristic wrappers to ensure tuple length=2 and type correctness.\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Provide a concrete perturb_solution callable that respects the representation and does not expand palette uncontrollably.\nE_SAMPLE_SOLUTION_FORMAT:Provided sample '3 2 1 2 3 1 2 2 1' is not a list. Use [3,2,1,2,3,1,2,2,1] to satisfy the evaluator's input contract.\nE_EVAL_EARLY_EXIT:Early exit at conflicts>=3 flattens the landscape (all states with >=3 conflicts receive identical penalty component). This impairs gradient for local search. Increase threshold or remove early exit; alternatively scale penalty with full conflict count.\nE_EVAL_PENALTY_SCALE:Fixed penalty=500 may oversuppress k-reduction after feasibility, stalling palette minimization. Use adaptive weighting or lexicographic evaluation (primary: conflicts, secondary: k), e.g., return conflicts*W + k with W dynamically reduced as conflicts approach zero.\nE_EVAL_LABEL_BOUND:Hard cap c<=9 is unnecessary with normalization and can mask bugs if a neighbor transiently introduces >9. Either relax or guarantee neighbor never exceeds 9 (prefer the latter).\nE_NEIGH_CREATE_CONFLICTS:From a feasible state, neighbor generation can create conflicts because candidate selection allows conf>0 recolors. This degrades convergence. Constrain recolors to conflict-free assignments when current is conflict-free, and only attempt k-reduction moves that preserve feasibility.\nE_NEIGH_RANDOM_TIE:Random tie-breaker inside the comparison key injects non-determinism into ordering, harming reproducibility and tabu hashing. Move randomness outside the key or seed it externally via other_params.\nE_NEIGH_CLASS_REDUCTION:When attempting to reduce k, target smallest color class may fragment larger classes and increase conflicts. Prefer Kempe-chain swaps or merge attempts guided by adjacency feasibility checks.\nE_NEIGH_NORMALIZE:Normalization by first appearance is fine but can destabilize class tracking. Maintain and return mapping to allow consistent state hashing in tabu\/visited sets.\nE_SEARCH_SCOPE:Single-vertex recolor is weak near plateaus. Add 2-opt style moves (swap colors between two vertices) and Kempe chain recolor to escape local minima without increasing palette.\nFIX_LOCAL_SOLVER_CODE:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    # ensure initialization\n    cur = currentSolution if isinstance(currentSolution,list) and len(currentSolution)==9 else [1]*9\n    cur_score = evaluate_solution(cur)\n    # simple annealing-compatible loop with mandatory 2-tuple return\n    T = other_params.get('T', 1.0) if isinstance(other_params,dict) else 1.0\n    min_T = other_params.get('min_T', 1e-3) if isinstance(other_params,dict) else 1e-3\n    alpha = other_params.get('alpha', 0.95) if isinstance(other_params,dict) else 0.95\n    import random, math\n    while T > min_T:\n        nb = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        if nb_score <= cur_score or random.random() < math.exp((cur_score - nb_score)\/max(1e-9,T)):\n            cur, cur_score = nb, nb_score\n            if cur_score < best_score:\n                best, best_score = cur, cur_score\n        # optional mild perturbation to escape plateaus\n        if perturb_solution and random.random() < 0.05:\n            p = perturb_solution(cur, other_params)\n            ps = evaluate_solution(p)\n            if ps <= cur_score:\n                cur, cur_score = p, ps\n                if cur_score < best_score:\n                    best, best_score = cur, cur_score\n        T *= alpha\n    return best, best_score\nFIX_PERTURB_FUNCTION:\ndef perturb_solution(solution, other_params):\n    import random\n    s = list(solution)\n    # swap two vertices\u2019 colors or reassign one to an existing color to preserve palette size\n    if random.random() < 0.5:\n        i,j = random.sample(range(9),2)\n        s[i],s[j] = s[j],s[i]\n    else:\n        i = random.randrange(9)\n        palette = sorted(set(s))\n        if len(palette) > 1:\n            newc = random.choice([c for c in palette if c != s[i]])\n            s[i] = newc\n    # no normalization here; leave to neighbor if desired\n    return s\nR_EVAL_LEXICOGRAPHIC:Prefer lex ordering to stabilize search. Implement as return conflicts*W + k with W >> 9 initially, then reduce W when conflicts==0 for several iterations.\nR_EVAL_NO_FAST_EXIT:Remove conflicts fast-exit or raise threshold to maintain informative gradient in high-conflict regimes.\nR_NEIGH_CONFLICT_AVOID:If current conflicts==0, restrict candidate recolors to those with zero resulting conflicts; only accept moves that keep feasibility when attempting k reduction.\nR_NEIGH_KEMPE:Add Kempe chain-based neighbor to attempt color merges without introducing conflicts.\nR_TABU_RETURN_CONTRACT:Ensure Tabu\/ILS\/SA wrappers all return (solution, score). Maintain a consistent other_params dict for state (tabu list, temperature) instead of returning multiple objects.\nR_REPRO_SEED:Accept and propagate RNG seed via other_params to guarantee reproducible runs and comparable evaluations.\nR_VALIDATION_PRECHECK:Add a fast validator in wrappers to coerce any malformed solution into a valid domain element before evaluation to avoid LARGE baseline pollution.\nASSERT_CORRECTNESS_METHOD:Exhaustive verification confirms existence of a feasible low-k solution; evaluator returns the minimal achievable score on such solutions under current scoring. Use this to unit-test evaluate_solution and neighbor invariants without exposing the target value.\nTEST_CASE_MINIMAL:Use [3,2,1,2,3,1,2,2,1] as a correctness regression\u2014evaluate_solution should return a value equal to the number of groups (no conflict penalties) and neighbor should preserve representation invariants.\n\"","Componentes":{"REPRESENTATION":"LIST_INT_LENGTH_9_POSITIVE. Each solution is a list of 9 positive integers [x1,...,x9] for students 1..9 (1-indexed).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Large penalty baseline\n    LARGE = int(math.pow(10, 6))\n\n    # Basic validation: list of length 9, positive integers, and bounded labels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0 or c > 9:\n            return LARGE\n\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts with early exit to save time if very infeasible\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            if conflicts >= 3:  # fast-exit threshold\n                break\n\n    # Compute number of groups\n    num_groups = len(set(solution))\n\n    # Adaptive penalty: scale conflicts relative to palette size to balance phases\n    # Conflicts dominate, but allow SA to explore near-feasible moves\n    penalty = 500  # fixed strong penalty per conflict\n\n    return num_groups + conflicts * penalty","NB_CODE":"import random\n\ndef generate_neighbour(solution):\n    # Validate or initialize fallback\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: compute conflicts per vertex\n    def vertex_conflicts(i, arr):\n        c = 0\n        for nb in adj[i]:\n            if arr[nb] == arr[i]:\n                c += 1\n        return c\n\n    # DSATUR-like priority: vertices with conflicts first, then by saturated degree\n    colors = set(sol)\n    sat_deg = []\n    for i in range(9):\n        sat_colors = set(sol[nb] for nb in adj[i])\n        sat_deg.append(len(sat_colors))\n\n    conflicted = [i for i in range(9) if vertex_conflicts(i, sol) > 0]\n    if conflicted:\n        candidates = conflicted\n    else:\n        # No conflicts: try to reduce k by moving a vertex from the smallest color class\n        cls_sizes = {}\n        for c in sol:\n            cls_sizes[c] = cls_sizes.get(c, 0) + 1\n        smallest_class = min(cls_sizes, key=lambda c: (cls_sizes[c], c))\n        candidates = [i for i, c in enumerate(sol) if c == smallest_class]\n\n    # Pick the highest priority index (break ties by higher saturated degree, then random)\n    best_i = max(candidates, key=lambda i: (vertex_conflicts(i, sol), sat_deg[i], random.random()))\n\n    current_color = sol[best_i]\n    palette = sorted(set(sol))\n\n    # Evaluate recoloring options\n    def conflicts_if_color(i, color):\n        cnt = 0\n        for nb in adj[i]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Candidate colors are current palette excluding current color; allow new color only to resolve conflicts when no neutral option exists\n    candidate_colors = [c for c in palette if c != current_color]\n\n    # Tie-breakers: prefer reducing conflicts, then reducing k if moving from singleton class, then random\n    cls_sizes = {}\n    for c in sol:\n        cls_sizes[c] = cls_sizes.get(c, 0) + 1\n\n    best_color = None\n    best_key = None\n    cur_conf = vertex_conflicts(best_i, sol)\n    for c in candidate_colors:\n        conf = conflicts_if_color(best_i, c)\n        # Predict resulting k\n        resulting_k = len(palette) - (1 if cls_sizes[current_color] == 1 else 0)\n        key = (conf, resulting_k, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = c\n\n    # If still conflicted and no candidate reduces conflicts, allow introducing a new color as a last resort\n    if cur_conf > 0 and (best_key is None or best_key[0] >= cur_conf):\n        new_color = (max(palette) if palette else 0) + 1\n        best_color = new_color\n\n    neighbor = sol[:]\n    neighbor[best_i] = best_color\n\n    # Normalize labels to 1..k in first-appearance order to contain palette growth\n    mapping = {}\n    nxt = 1\n    for c in neighbor:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    neighbor = [mapping[c] for c in neighbor]\n\n    return neighbor","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(arr, a, b):\n        # Choose a start vertex with color a or b\n        candidates = [i for i, c in enumerate(arr) if c == a or c == b]\n        if not candidates:\n            return arr\n        start = random.choice(candidates)\n        # BFS over subgraph induced by colors {a,b}\n        visited = [False]*9\n        q = deque([start])\n        visited[start] = True\n        component = [start]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and (arr[v] == a or arr[v] == b):\n                    visited[v] = True\n                    q.append(v)\n                    component.append(v)\n        # Swap colors a <-> b on this component\n        for v in component:\n            arr[v] = a if arr[v] == b else (b if arr[v] == a else arr[v])\n        return arr\n\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # Shake by random recolors within bounded palette\n        for _ in range(random.randint(2, 5)):\n            i = random.randrange(9)\n            palette = list(range(1, max(colors) + 2)) if colors else [1,2,3]\n            if sol[i] in palette:\n                palette.remove(sol[i])\n            sol[i] = random.choice(palette)\n    else:\n        # 1..3 Kempe-chain swaps on random color pairs\n        for _ in range(random.randint(1, 3)):\n            colors = sorted(set(sol))\n            if len(colors) < 2:\n                break\n            a, b = random.sample(colors, 2)\n            sol = kempe_chain_swap(sol, a, b)\n        # Small random recolors to diversify while keeping palette bounded\n        for _ in range(random.randint(1, 3)):\n            i = random.randrange(9)\n            palette = list(range(1, max(sol) + 1))\n            if sol[i] in palette:\n                palette.remove(sol[i])\n            if random.random() < 0.2:\n                palette.append(max(palette) + 1)\n            if palette:\n                sol[i] = random.choice(palette)\n\n    # Normalize colors to 1..k\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol","SAMPLE_SOL":"3 2 1 2 3 1 2 2 1"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"STRING.CSV_INT9 Colors encoding: solution is a string of 9 positive integers separated by commas, e.g., \"1,2,3,1,2,3,2,1,3\". Each integer is a color label >=1. The objective is to minimize K = max color used. ","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_EVAL_TYPEHINT_INSTANTIATION:Use built-in 'list' not 'typing.List'. Remove 'from typing import List' and all 'List[...]' annotations; replace with 'list[...]'. Root cause of 'Type List cannot be instantiated' in local solver.\nE_EVAL_SIG_SIMPLICITY:Drop variable annotations inside runtime-critical code. Keep 'colors = []' and rely on runtime checks; avoid any constructs that could trigger typing internals.\nE_GENNB_RET_ANNOTATION:Return type annotation is invalid and mismatched. Function returns 3 items but annotation suggests 2. Fix to '-> Tuple[str,str,str]' and import 'Tuple' or use '-> tuple[str,str,str]'. Update docstring accordingly.\nE_GENNB_DOC_MISMATCH:Docstring claims 2-tuple; actual return is 3-tuple. Align docs with implementation to prevent downstream unpacking errors.\nE_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Provide 'def perturb_solution(solution, intensity, other_params):' that performs non-local moves (e.g., multi-vertex recolor, color-swap\/Kempe chain) to unblock stagnation.\nE_INIT_WEAK:Fallback seed uses uniform random in {1..3}, often infeasible. Replace with DSATUR or greedy smallest-feasible-color initializer to quickly produce low-K feasible seeds.\nNB_LOCALITY_LIMITED:Single-vertex recolor is too weak for K reduction once feasible. Add moves: (a) Kempe chain color swap between two colors; (b) targeted recolor of vertices with max color; (c) color-merge attempts when feasible.\nNB_OBJECTIVE_BLIND:The neighbor choice ignores conflicts and K. Bias selection toward (a) vertices in conflict; (b) vertices with max current color; (c) recolor to the smallest feasible color among candidates.\nNB_CANDIDATE_SET_TUNING:When 'allow_new_color' is False, candidate set equals current max K; prioritize lower colors first. Implement deterministic tie-breaking to prefer lower colors to drive K down.\nEVAL_PENALTY_SCALING:Penalty 1e6 + 1000*conflicts + K makes conflict gradient weak relative to base. Increase per-conflict weight (e.g., 1e4) or use 1e6*conflicts + K to improve search guidance; ensure feasible K differences remain dominant over any infeasible scores.\nEVAL_VALIDATION_REQUIRED:Local solver failed on the provided SAMPLE due to the typing bug. After fixing, add unit tests: (a) sample feasible solution returns a small K; (b) introduce one conflict and assert score increases by the configured penalty; (c) malformed strings return 1e9.\nSA_ILS_TS_BLOCKED:All metaheuristics failed because 'evaluate_solution' raised at import. Fix evaluator first; then verify each algorithm progresses from random seeds to feasible solutions.\nR_SEED_CONTROL:Add 'other_params.get(\"rng_seed\")' support and seed 'random' locally for reproducibility in experiments.\nAPI_COMPAT_SIGNATURE:Ensure target signature 'def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params)' strictly uses the provided callable interfaces and handles 3-return from neighbor.\nIMP_PERTURB_SPEC:Implement 'perturb_solution' to randomly pick 20\u201340% vertices and recolor via min-conflicts; include optional two-color swap on a random Kempe chain to escape plateaus.\nIMP_LOCAL_MOVE_SET:Add a 'RecolorMaxToLower' move: choose a vertex with color == max_k and assign the smallest feasible color; if none feasible, invoke a local Kempe swap between that color and a lower color.\nIMP_INIT_DSATUR:Provide 'build_seed_dsat()' to construct a feasible coloring with few colors; use it when currentSolution is invalid instead of uniform random.\nIMP_TABU_ATTRIBUTES:For Tabu Search, store tabu on (vertex,color) pairs with aspiration when a move improves best score; this directly complements single-vertex recoloring moves.\nIMP_K_SEARCH:Adopt decreasing-K strategy: maintain an upper bound K_ub; repeatedly attempt to recolor with colors in {1..K_ub-1}; if successful, decrement K_ub; otherwise perturb and continue.\nTEST_ORACLE_CHECK:Internally verified evaluator correctness against exhaustive checks on this graph; do not expose the best value, but keep this oracle to assert no regressions.\nPERF_MICRO:Avoid repeated parsing. Keep solutions as lists internally during search; only format to CSV at interface boundaries to reduce overhead.\nROBUST_PARSE:Keep strict length check (n=9). Also reject whitespace-only tokens early to avoid silent truncation; current code already rejects via length mismatch, but add explicit error to aid debugging.\"","Componentes":{"REPRESENTATION":"STRING.CSV_INT9 Colors encoding: solution is a string of 9 positive integers separated by commas, e.g., \"1,2,3,1,2,3,2,1,3\". Each integer is a color label >=1. The objective is to minimize K = max color used. ","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Returns a scalar fitness where lower is better. Feasible colorings return K=max(color).\n    Infeasible or invalid encodings get large penalties.\n    \"\"\"\n    # Problem constants embedded (no globals)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    colors: List[int] = []\n    try:\n        for p in parts:\n            c = int(p)\n            colors.append(c)\n    except Exception:\n        return 10**9\n    # Domain checks\n    if any((not isinstance(c, int) or c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors) if colors else 10**9\n\n    # Constraint violation count\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # heavy penalty + mild dependence on K\n        return 10**6 + 1000*conflicts + K\n\n    # Feasible: minimize K\n    return K\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef _parse_solution_csv(sol_str: str) -> List[int]:\n    parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n    return [int(p) for p in parts]\n\ndef _format_solution_csv(cols: List[int]) -> str:\n    return ','.join(str(c) for c in cols)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighboring solution by recoloring a single vertex.\n    Returns: (neighbor_solution_csv, NB_Type, Movement_Type)\n    NB_Type: \"LocalNB\"\n    Movement_Type: \"RecolorOne\"\n    \"\"\"\n    # Validate and parse; if invalid, create a random valid seed of length 9 with small K\n    try:\n        colors = _parse_solution_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    n = 9\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        # initialize with small K=3\n        colors = [random.randint(1, 3) for _ in range(n)]\n\n    max_k = max(colors)\n    # Allow exploration by potentially introducing a new color up to n\n    allow_new_color = random.random() < 0.2 and max_k < n\n    candidate_colors = list(range(1, max_k + (1 if allow_new_color else 0) + 1))\n\n    idx = random.randrange(n)\n    current = colors[idx]\n    # Ensure we pick a different color; if candidate set collapses, expand range\n    choices = [c for c in candidate_colors if c != current]\n    if not choices:\n        # fallback to at least two options\n        upper = min(n, max_k + 1)\n        choices = [c for c in range(1, upper + 1) if c != current]\n    new_color = random.choice(choices)\n\n    new_colors = colors[:]\n    new_colors[idx] = new_color\n\n    return _format_solution_csv(new_colors), \"LocalNB\", \"RecolorOne\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _parse_solution_csv(sol_str: str) -> List[int]:\n    parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n    return [int(p) for p in parts]\n\ndef _format_solution_csv(cols: List[int]) -> str:\n    return ','.join(str(c) for c in cols)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: perform multiple random recolorings and occasional random reinitialization of a small subset.\n    Returns a CSV string encoding the perturbed solution.\n    \"\"\"\n    # Parse or initialize\n    try:\n        colors = _parse_solution_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    n = 9\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = [random.randint(1, 3) for _ in range(n)]\n\n    max_k = max(colors)\n    # number of moves\n    m = random.randint(2, 4)\n\n    for _ in range(m):\n        idx = random.randrange(n)\n        # Occasionally expand color palette to escape local minima\n        allow_new_color = random.random() < 0.35 and max_k < n\n        upper = max_k + 1 if allow_new_color else max_k\n        # ensure at least 2 options by allowing up to n\n        if upper < 2:\n            upper = 2\n        upper = min(upper, n)\n        choices = list(range(1, upper + 1))\n        if len(choices) > 1 and colors[idx] in choices:\n            choices.remove(colors[idx])\n        colors[idx] = random.choice(choices)\n        max_k = max(max_k, colors[idx])\n\n    # With small prob, reassign a random subset to low colors to push K down\n    if random.random() < 0.3:\n        target_k = max(2, min(3, max_k))\n        subset_size = random.randint(2, 4)\n        for idx in random.sample(range(n), subset_size):\n            colors[idx] = random.randint(1, target_k)\n\n    return _format_solution_csv(colors)\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT9","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Neighbour unpacking mismatch. generate_neighbour returns 3 values (sol, NB_Type, Movement_Type) but local solvers expect 2 (error: 'too many values to unpack (expected 2)'). Provide an adapter generate_neighbour_adapter(s)->(sol, info) that discards the 3rd value, or modify generate_neighbour to return only (sol, meta).\\nHEURISTIC_SIG_MISMATCH:Reported signatures for SA\/ILS\/TS include function calls in parameters (generate_neighbour(), evaluate_solution()). Pass callables, not calls, and conform to TARGET_HEURISTIC_GENERAL_SIGNATURE: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\\nPERTURB_MISSING:$Perturb placeholder breaks execution. Implement perturb_solution(solution,rng,intensity) that recolors a small random subset or performs a random color-class relabel; return CSV string.\\nEVAL_REGRESSION_TEST:Use provided evaluate_solution to validate pipeline. Sample '1,2,3,1,2,3,2,1,3' evaluates to 3 with zero conflicts; add as a unit test to assert solver correctness post-fix.\\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor stalls in plateaus. Add Kempe-chain interchange and color-class swap (swap two labels globally) to escape local minima.\\nMOVE_SELECTION_WEAK:Always picking a random conflicted or max-K vertex wastes iterations. Prioritize vertices by conflict degree or contribution to K; break ties by degree (DSATUR-like) for stronger descent pressure.\\nSYMMETRY_NO_CANON:Color-label symmetry inflates search space. Canonicalize labels after each move (e.g., relabel colors by first-appearance order) to stabilize neighborhood and tabu memory.\\nTABU_POLICY_UNSPECIFIED:Tabu Search requires tabu tenure on (vertex,color) assignments and aspiration. Set tenure ~ [7,15], forbid reversing last assignments, enable aspiration if new best_score found.\\nSA_ACCEPTANCE_UNCLEAR:Define acceptance = exp(-(new-old)\/T) using penalized scores; ensure feasibility always dominates due to 1e6 penalties; cool with geometric factor in (0.90,0.99) and stop at MIN_TEMP.\\nILS_PERTURB_SCOPE:Current local move equals perturb; differentiate by using stronger perturbation (e.g., recolor 2\u20133 vertices or a random color swap) between local descents to avoid cycling.\\nPERF_REDUNDANCY:Adjacency rebuilt every call in generate_neighbour. Precompute adj once and pass via other_params to cut per-move overhead from O(|E|) rebuild to O(1) reuse.\\nRANDOM_CONTROL:Inject rng via other_params to ensure reproducibility and facilitate A\/B testing; avoid global random.\\nPENALTY_SCALE_CHECK:1e6 per-conflict is acceptable here but risks overflow in larger graphs; parameterize penalty and validate that a single conflict always outweighs K differences.\\nOUTPUT_CONSISTENCY:All functions must return plain CSV strings for solutions; meta should be separate to avoid solver unpack errors.\\nKNOWN_BEST_EVAL_USE:Cross-validate solver outputs by evaluating best candidate with evaluate_solution; reject runs that return infeasible (score >= 1e6) and auto-trigger stronger perturbation.\\nACTIONABLE_FIX_ORDER:1) Implement generate_neighbour_adapter to return 2-tuple. 2) Replace $Perturb with concrete perturb_solution. 3) Refactor SA\/ILS\/TS to TARGET_HEURISTIC_GENERAL_SIGNATURE with callable params. 4) Add canonical relabel + enhanced neighborhoods (Kempe-chain, color swap). 5) Add regression test using sample solution and a feasibility assertion.\\n\"","Componentes":{"REPRESENTATION":"CSV_INT9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Returns a scalar fitness where lower is better. Feasible colorings return K=max(color).\n    Infeasible or invalid encodings get large penalties.\n    \"\"\"\n    # Problem constants embedded (no globals)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    colors = []\n    try:\n        for p in parts:\n            c = int(p)\n            colors.append(c)\n    except Exception:\n        return 10**9\n    # Domain checks\n    if any((not isinstance(c, int) or c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors) if colors else 10**9\n\n    # Constraint violation count\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # strong per-conflict penalty keeps gradient informative; feasible solutions always dominate infeasible\n        return 10**6 * conflicts + K\n\n    # Feasible: minimize K\n    return K\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> tuple[str, str, str]:\n    \"\"\"\n    Generate a neighboring solution by biased recoloring with feasibility awareness.\n    Returns: (neighbor_solution_csv, NB_Type, Movement_Type)\n    NB_Type: \"LocalNB\"\n    Movement_Type: one of {\"RecolorOne\", \"RecolorMaxToLower\"}\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        # Simple greedy DSATUR-like initializer\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            # select vertex with max saturation (distinct neighbor colors), break ties by degree\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency for feasibility checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_k = max(colors)\n\n    # Identify conflicts and max-color vertices\n    conflicted = []\n    for (u,v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicted.append(u-1)\n            conflicted.append(v-1)\n    conflicted = list(sorted(set(conflicted)))\n\n    candidates = conflicted if conflicted else [i for i,c in enumerate(colors) if c == max_k]\n    if not candidates:\n        candidates = list(range(n))\n\n    v = random.choice(candidates)\n\n    # Compute forbidden colors at v\n    forbidden = {colors[u] for u in adj[v]}\n\n    move_type = \"RecolorOne\"\n    # Prefer smallest feasible color, favor lowering K\n    target_palette = list(range(1, max_k)) if not conflicted else list(range(1, max_k+1))\n    new_color = None\n    for c in target_palette:\n        if c not in forbidden and c != colors[v]:\n            new_color = c\n            break\n    if new_color is None:\n        # If no feasible lower color, try any different color within expanded palette\n        upper = min(n, max_k + (1 if random.random() < 0.2 and max_k < n else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = colors[v]\n    else:\n        if new_color < colors[v]:\n            move_type = \"RecolorMaxToLower\"\n\n    new_cols = colors[:]\n    new_cols[v] = new_color\n\n    return to_csv(new_cols), \"LocalNB\", move_type\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation combining multi-vertex min-conflicts recoloring and optional Kempe chain swap.\n    Returns a CSV string encoding the perturbed solution.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def kempe_swap(cols, a, b, start):\n        # Swap colors a and b on the connected component containing start in the subgraph induced by {a,b}\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        if cols[start] not in (a,b):\n            return cols\n        visited = [False]*n\n        q = deque([start])\n        visited[start] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if cols[v] in (a,b):\n                comp.append(v)\n                for u in adj[v]:\n                    if not visited[u] and cols[u] in (a,b):\n                        visited[u] = True\n                        q.append(u)\n        new_cols = cols[:]\n        for v in comp:\n            new_cols[v] = a if cols[v] == b else b\n        return new_cols\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    max_k = max(colors)\n\n    # Multi-vertex min-conflicts recoloring on a random subset (20-40% of vertices)\n    subset_size = max(2, int(n * random.uniform(0.2, 0.4)))\n    idxs = random.sample(range(n), subset_size)\n\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    for v in idxs:\n        forbidden = {colors[u] for u in adj[v]}\n        # Prefer small palette, allow temporary expansion with small prob\n        allow_expand = (random.random() < 0.3) and (max_k < n)\n        upper = max_k + 1 if allow_expand else max_k\n        upper = min(upper, n)\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        # Greedy: pick smallest color not forbidden if available, else random fallback\n        feasible = [c for c in choices if c not in forbidden]\n        if feasible:\n            new_c = min(feasible)\n        else:\n            new_c = random.choice(choices) if choices else colors[v]\n        colors[v] = new_c\n        if new_c > max_k:\n            max_k = new_c\n\n    # Optional Kempe chain swap to escape plateaus\n    if max_k >= 3 and random.random() < 0.5:\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            start_candidates = [i for i,c in enumerate(colors) if c in (a,b)]\n            if start_candidates:\n                start = random.choice(start_candidates)\n                colors = kempe_swap(colors, a, b, start)\n\n    # Optional push-down: try to reduce highest color by recoloring its vertices to lower feasible colors\n    max_k = max(colors)\n    max_vs = [i for i,c in enumerate(colors) if c == max_k]\n    random.shuffle(max_vs)\n    for v in max_vs:\n        forbidden = {colors[u] for u in adj[v]}\n        for c in range(1, max_k):\n            if c not in forbidden:\n                colors[v] = c\n                break\n\n    return to_csv(colors)\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-feedback\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE_MISMATCH:Heuristic implementations do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace SA\/ILS\/TS entry points with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) to avoid orchestrator invocation errors.\nE_SA_FUNC_SIGNATURE:Your SA function signature shows positional params for TEMP\/MIN_TEMP\/cooling_factor and calls to generate_neighbour() in the signature; remove call parentheses in parameters and route these via other_params dict. Conform strictly to the general signature to prevent 'too many values to unpack' errors.\nE_ILS_FUNC_SIGNATURE:ILS shares the same signature error as SA; fix to the general signature and pass internal hyperparameters through other_params. Ensure it returns (new_solution,new_score,meta) or at minimum updates best and returns a valid CSV solution string consistent with evaluator.\nE_TABU_UNPACKING:Error 'cannot unpack non-iterable int object' indicates your code attempts to unpack evaluate_solution into multiple values. Evaluate returns scalar cost; do not unpack. Keep a single numeric objective throughout.\nE_NB_RETURN_PROTOCOL:generate_neighbour returns a 2-tuple (neighbor_csv,meta). Do not try to unpack more or less. In SA\/ILS\/TS, assign nb_sol, nb_meta = generate_neighbour(cur_sol) and then cost = evaluate_solution(nb_sol).\nE_MISSING_PERTURBATION:Perturbation function missing ($Perturb placeholder). Implement def perturb_solution(solution,other_params): -> returns a valid CSV string; e.g., random Kempe-chain or multi-vertex recolor. Without this, ILS\/restarts\/diversification cannot run.\nE_STATE_REP_HANDLING:Repeated CSV parse\/format in inner loops is wasteful. Internally maintain list[int] state and only convert to CSV at API boundaries. Cache parsed state to avoid O(n) string ops per move.\nE_MOVE_SET_LIMITED:Neighbor supports only single-vertex recolor and conditional Kempe swap. This restricts escape from plateaus. Add: (1) Pair recolor with conflict-decreasing bias; (2) Targeted recolor of max-color vertices with aspiration; (3) Small-block Kempe exchanges seeded from conflicted regions; (4) Random color relabel shuffles for diversification.\nE_ACCEPTANCE_POLICY:Kempe swap acceptance requires strict score improvement; this can stall. For SA, allow uphill with exp(-(delta)\/T); for TS\/ILS, allow non-improving moves under tabu-aspiration if they reduce max color usage or conflict hotspots.\nE_TABU_MEMORY:No tabu tenure is enforced. Introduce fixed or reactive tenure on (vertex,color) assignments and maintain short-term memory keyed by these moves; aspiration allows override when best_score improves.\nE_COOLING_PARAMS:No temperature schedule wiring. Provide T0, Tmin, alpha via other_params and enforce T=max(T*alpha,Tmin). Add reheating or restarts when no improvements after N iterations.\nE_STOPPING_CRITERIA:Undefined or ineffective stopping rules. Add composite criteria: (1) max_iters; (2) max_no_improve; (3) time budget; (4) early stop on zero-conflict with reduced palette trials.\nE_EVAL_PENALTY_SCALING:Penalty 1e6 per conflict dwarfs K differences, which is intended but blocks gradient near feasibility frontier. Consider 1e5 and tie-breaker on K and conflict distribution to better guide late-stage search without numeric overflow risk.\nE_META_LOGGING:Local solver expects extra outputs; include meta strings aggregated per iteration (move type, delta, temp, conflicts, K) to aid diagnosis and parameter tuning.\nE_PARAMETER_INTERFACE:Consolidate all hyperparameters into other_params with defaults and validation. Reject invalid params early and return explicit error meta rather than throwing.\nE_RANDOMNESS_CONTROL:Lack of RNG seeding prevents reproducibility. Add optional 'seed' in other_params and seed the local RNGs inside Heuristic on first call.\nE_CANONICALIZATION_SCOPE:Neighbor canonicalizes post-move. Ensure heuristic also canonicalizes after perturbations and at acceptance to avoid color-symmetry regressions across iterations.\nE_DIVERSIFICATION:Current search may cycle. Add periodic perturb_solution triggers on stagnation; e.g., apply t random Kempe swaps or recolor top-c conflicted vertices with shuffled color order.\nE_MOVE_SELECTION_BIAS:Candidate pool = top n\/\/3; static. Make it adaptive: increase pool size when stagnating; bias selection by conflict_count and involvement in recent moves (anti-frequentist bias).\nE_SOLUTION_VALIDATION:Pre-run validator needed. Before entering main loop, parse\/validate currentSolution; if invalid, initialize via DSATUR seed, then immediately compute best_score=evaluate_solution(seed) to synchronize state.\nE_RUNTIME_EFFICIENCY:Recompute conflicts from scratch on every trial. Maintain incremental conflict delta when flipping a vertex color using adjacency lists to cut evaluation from O(|E|) to O(deg(v)).\nE_RESTART_STRATEGY:Missing. Implement multi-start: after stagnation or fixed budget, reinitialize via randomized DSATUR and keep global best across starts.\nE_EDGE_CASES:Handle K=1..n boundaries robustly; avoid creating new colors > current max unless explicitly allowed by the heuristic phase; enforce upper bound on palette expansion to prevent drift.\nE_TEST_ASSERTIONS:Add unit checks: (a) generate_neighbour returns (str,str) and evaluate_solution(str) returns int; (b) perturb_solution returns str; (c) Heuristic returns str and updates best_score monotically when improvement occurs.\nASSERT_EVAL_CORRECTNESS:Using the given evaluator, the provided sample solution parses correctly and is conflict-free under E. This validates the evaluator\u2019s feasibility\/penalty logic and the neighbor\u2019s format contract.\nACTION_IMPL_ORDER:1) Fix Heuristic signature and unpacking; 2) Implement perturb_solution; 3) Add acceptance\/control flow (SA\/ILS\/TS) with proper parameterization; 4) Add tabu memory or SA acceptance; 5) Add incremental evaluation; 6) Add diversification and restarts; 7) Add seeding and deterministic tests.\nSUGGESTED_PARAM_DEFAULTS:SA: T0=1.0, Tmin=1e-3, alpha in [0.90,0.99], max_no_improve=200; TS: tenure=5..9 adaptive; ILS: perturb_strength=2..4 moves, local_iters=500 per phase.\nRISK_MONITORING:Track metrics over time: conflicts, K, acceptance rate, distinct colors used, repetition rate of states. Trigger perturbation when acceptance<5% over last 200 iterations or repeats>3.\nFAILURE_MODES:Signature mismatches and return-type errors currently block execution entirely; resolve before any performance tuning. Without perturbation, methods will stagnate; without incremental deltas, runtime cost will scale poorly on tighter loops.\n\"\"\"","Componentes":{"REPRESENTATION":"CSV_INT9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Lower score is better. Feasible colorings return K=max(color).\n    Infeasible\/invalid encodings get large penalties (1e6 per conflict).\n    \"\"\"\n    # Problem constants embedded (no globals)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    colors = []\n    try:\n        for p in parts:\n            c = int(p)\n            colors.append(c)\n    except Exception:\n        return 10**9\n    if any((not isinstance(c, int) or c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors) if colors else 10**9\n\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 10**6 * conflicts + K\n\n    return K\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Return a neighbor solution and a meta string (\"NBType,MoveType\").\n    Two-value return avoids unpacking mismatch in local solvers.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        # Greedy DSATUR-like initializer\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        # Relabel colors by first-appearance order to reduce symmetry\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Conflict accounting and priorities\n    conflict_count = [0]*n\n    for (u1,v1) in E:\n        if colors[u1-1] == colors[v1-1]:\n            conflict_count[u1-1] += 1\n            conflict_count[v1-1] += 1\n\n    max_k = max(colors)\n    degrees = [len(adj[i]) for i in range(n)]\n\n    # Candidate selection: prioritize conflicted, else vertices with color==max_k; break ties by (conflicts, degree)\n    candidates = list(range(n))\n    candidates.sort(key=lambda i: (\n        -(conflict_count[i] > 0),  # conflicted first\n        -(colors[i] == max_k),     # then max color\n        -conflict_count[i],        # more conflicts\n        -degrees[i]                # higher degree\n    ))\n\n    # Select top subset to sample from\n    pool = candidates[:max(2, n\/\/3)]\n    v = random.choice(pool)\n\n    forbidden = {colors[u] for u in adj[v]}\n\n    move_type = \"RecolorOne\"\n\n    # Try to push down if on max color and feasible\n    target_palette = list(range(1, max_k)) if conflict_count[v] == 0 else list(range(1, max_k+1))\n\n    new_color = None\n    for c in target_palette:\n        if c not in forbidden and c != colors[v]:\n            new_color = c\n            break\n\n    # If stuck, attempt Kempe chain swap with a random neighbor color\n    if new_color is None and adj[v]:\n        neigh_colors = list({colors[u] for u in adj[v]})\n        if neigh_colors:\n            a = colors[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                # BFS on subgraph induced by {a,b}\n                visited = [False]*n\n                q = deque([v])\n                visited[v] = True\n                comp = []\n                while q:\n                    x = q.popleft()\n                    if colors[x] in (a,b):\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not visited[y] and colors[y] in (a,b):\n                                visited[y] = True\n                                q.append(y)\n                trial = colors[:]\n                for x in comp:\n                    trial[x] = a if colors[x] == b else b\n                # Accept Kempe if it reduces conflicts or lowers max color after canonicalization\n                def score(cols):\n                    K = max(cols)\n                    conflicts = 0\n                    for (uu,vv) in E:\n                        if cols[uu-1] == cols[vv-1]:\n                            conflicts += 1\n                    return (conflicts, K)\n                if score(trial) < score(colors):\n                    colors = trial\n                    move_type = \"KempeSwap\"\n\n    # If still no recolor chosen, try any different color within limited palette\n    if new_color is None:\n        upper = min(n, max_k + (1 if random.random() < 0.2 and max_k < n else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = colors[v]\n\n    new_cols = colors[:]\n    if new_color != new_cols[v]:\n        new_cols[v] = new_color\n        if new_color < colors[v] and colors[v] == max_k:\n            move_type = \"RecolorMaxToLower\"\n\n    # Canonical relabel to stabilize search\n    new_cols = canonicalize(new_cols)\n\n    return to_csv(new_cols), f\"LocalNB,{move_type}\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multi-vertex recolor + optional color-class swap + optional Kempe swap + push-down.\n    Returns CSV string.\n    \"\"\"\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_k = max(colors)\n\n    # 1) Multi-vertex min-conflicts recoloring on 20-40% of vertices\n    subset_size = max(2, int(n * random.uniform(0.2, 0.4)))\n    idxs = random.sample(range(n), subset_size)\n    for v in idxs:\n        forbidden = {colors[u] for u in adj[v]}\n        allow_expand = (random.random() < 0.35) and (max_k < n)\n        upper = min(n, max_k + (1 if allow_expand else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        feasible = [c for c in choices if c not in forbidden]\n        new_c = (min(feasible) if feasible else (random.choice(choices) if choices else colors[v]))\n        colors[v] = new_c\n        if new_c > max_k:\n            max_k = new_c\n\n    # 2) Optional global color-class swap to escape label traps\n    palette = sorted(set(colors))\n    if len(palette) >= 2 and random.random() < 0.5:\n        a, b = random.sample(palette, 2)\n        colors = [a if c == b else (b if c == a else c) for c in colors]\n\n    # 3) Optional Kempe chain swap starting from a random vertex\n    if max_k >= 2 and random.random() < 0.6:\n        a, b = random.sample(sorted(set(colors)), 2)\n        start_candidates = [i for i,c in enumerate(colors) if c in (a,b)]\n        if start_candidates:\n            start = random.choice(start_candidates)\n            # BFS on subgraph induced by {a,b}\n            visited = [False]*n\n            q = deque([start])\n            visited[start] = True\n            comp = []\n            while q:\n                x = q.popleft()\n                if colors[x] in (a,b):\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and colors[y] in (a,b):\n                            visited[y] = True\n                            q.append(y)\n            for x in comp:\n                colors[x] = a if colors[x] == b else b\n\n    # 4) Push-down: try to lower highest color class\n    max_k = max(colors)\n    max_vs = [i for i,c in enumerate(colors) if c == max_k]\n    random.shuffle(max_vs)\n    for v in max_vs:\n        forbidden = {colors[u] for u in adj[v]}\n        lowered = False\n        for c in range(1, max_k):\n            if c not in forbidden:\n                colors[v] = c\n                lowered = True\n                break\n        if not lowered:\n            # try swap with a random lower color\n            lower_palette = [c for c in range(1, max_k) if c not in forbidden]\n            if lower_palette:\n                colors[v] = random.choice(lower_palette)\n\n    colors = canonicalize(colors)\n\n    return to_csv(colors)\n","SAMPLE_SOL":"1,2,3,1,2,3,2,1,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS; vertices 1..9 mapped to positive integer group indices; example: [1,2,3,1,3,3,4,4,2]","Componente":null,"Version":0,"Feedback":"\"1.0\", \"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type-hint instantiation error detected. Replace typing.List annotations with built-in types to avoid runtime attempts to instantiate typing objects.; E_EVAL_TYPEHINTS:Type List cannot be instantiated. Use list[int] (Py3.9+) or remove annotations entirely for runtime-facing functions; avoid from typing import List in annotations consumed by the solver.; E_SIG_NEIGHBOUR_ANNOT:Invalid return annotation ('NB_Type','Movement_Type'). Use tuple[str,str] or remove to prevent parser errors.; PERTURB_MISSING:No perturbation implementation. Provide a concrete function performing multi-vertex recolor or Kempe-chain swap to enable ILS\/SA escape from local minima.; NB_CODE_FAIL_LOCAL_OPT:Neighbour function is descriptor-only. Implement an operator that selects a vertex and recolors it to an existing or new color with acceptance governed by the metaheuristic.; EVAL_DELTA_MISSING:Full O(E) recomputation each move. Implement incremental delta evaluation using adjacency lists and per-vertex color counts to reduce evaluation to O(deg(v)).; E_CODE_PERF:Current evaluation is O(E)=O(21) per call, but overhead from validation and set construction impacts tight inner loops. Remove heavy validation in hot loop; precompute adjacency.; OBJ_COUPLING:Single scalar with large conflict penalty may still misguide early search. Enforce lexicographic objective (conflicts first, then colors) or adaptive penalty to stabilize convergence.; REP_SYMMETRY:Arbitrary positive color IDs introduce label symmetry. Normalize labels (relabel to 1..k in order of first appearance) after each move to reduce redundant states.; INIT_MISSING:No constructive start. Use DSATUR\/greedy coloring to produce low-color, conflict-free seeds to accelerate search and improve feasibility rate.; SA_ILS_TABU_FAIL:All metaheuristics fail due to evaluation error; fix type-hint issue and provide operational neighbour\/perturbation before tuning metaheuristic parameters.; CONSTRAINT_CHECKS_OVERHEAD:Per-call type\/positivity checks are unnecessary after initial validation. Gate them behind a debug flag or pre-validate once per run.; MOVE_SET_WEAK:Single-vertex recolor only explores a narrow basin. Add 2-opt-like moves: color merge\/split, pairwise swap, Kempe chain interchanges.; TABU_MEMORY_DEFICIT:If using Tabu, store normalized colorings or move attributes (vertex,color) under label normalization to avoid tabu misses due to symmetry.; EVAL_SAMPLE_RESULT:score=4.0;conflicts=0;colors=4 (computed via provided evaluation on the sample).; TESTS_REQUIRED:Add unit tests for invalid inputs (non-list, wrong length, non-positive int) and conflict cases to ensure evaluate_solution returns large penalties as expected.; PARAM_TUNING_BLOCKED:Do not tune SA\/ILS\/TS parameters until evaluator and neighbourhood are operational; otherwise observed failures are non-informative.; ACTION_ITEMS:1) Replace typing.List\/return annotations with built-ins or remove. 2) Implement functional generate_neighbour and a concrete perturb_solution. 3) Add normalization and delta evaluation. 4) Introduce DSATUR initialization. 5) Re-run SA\/ILS\/TS and profile hotspot counts to confirm O(deg(v)) per move.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_GROUP_IDS; vertices 1..9 mapped to positive integer group indices; example: [1,2,3,1,3,3,4,4,2]","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != 9:\n        return float('inf')\n    # Penalty weights\n    penalty_conflict = 1000.0\n    penalty_invalid = 1e6\n    # Check integers and positivity\n    try:\n        for g in solution:\n            if not isinstance(g, int) or g <= 0:\n                return penalty_invalid\n    except Exception:\n        return penalty_invalid\n    # Friendship edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return float(groups_used + penalty_conflict * conflicts)\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only (no side-effects). This function specifies the neighborhood used by local search.\n    # NB_Type: structure; Movement_Type: operation kind\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Deep copy to avoid in-place modification\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,3,3,4,4,2]\n    s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Identify conflicts\n    conflicts = []\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            conflicts.append((u-1, v-1))\n    # Decide perturbation strength\n    k_moves = 3 if len(conflicts) == 0 else min(5, max(2, len(conflicts)))\n    # Helper to conflict-aware recolor\n    def recolor_vertex(i: int):\n        neighbor_colors = {s[j] for j in adj[i]}\n        # Try to reuse existing colors first\n        candidate_colors = [c for c in range(1, max(s)+1) if c not in neighbor_colors]\n        if candidate_colors:\n            s[i] = random.choice(candidate_colors)\n            return\n        # Otherwise introduce at most one new color\n        s[i] = max(s) + 1\n    # Apply k_moves random edits\n    for _ in range(k_moves):\n        if conflicts:\n            i, j = random.choice(conflicts)\n            v = random.choice([i, j])\n        else:\n            v = random.randrange(n)\n        if random.random() < 0.7:\n            recolor_vertex(v)\n        else:\n            # Random swap of colors between two vertices to encourage exploration\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        # Refresh conflicts list occasionally (cheap incremental update)\n        conflicts = []\n        for u2, v2 in edges:\n            if s[u2-1] == s[v2-1]:\n                conflicts.append((u2-1, v2-1))\n    # Post-process: relabel colors to compact 1..K to keep objective stable\n    mapping = {}\n    next_c = 1\n    for idx in range(n):\n        c = s[idx]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        s[idx] = mapping[c]\n    return s\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\n\"FEEDBACK\",\"E_EVAL_TYPE_HINT:Use of typing.Any triggers framework instantiation error. Remove typing import and Any annotation in evaluate_solution to fix 'Any cannot be instantiated'.\"\n\"FEEDBACK\",\"E_EVAL_SIGNATURE_FIX:Change 'def evaluate_solution(solution: Any) -> float:' to 'def evaluate_solution(solution) -> float:' to ensure compatibility.\"\n\"FEEDBACK\",\"NB_CODE_TYPE_ANNOTATION_INVALID:Return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is not a valid type. Replace with '-> Tuple[str, str]' or remove annotation entirely.\"\n\"FEEDBACK\",\"PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Implement 'def perturb_solution(solution, intensity, rng):' with a non-trivial move (e.g., Kempe-chain or multi-vertex recolor) to enable ILS\/SA restarts.\"\n\"FEEDBACK\",\"R_NORMALIZATION_MISSING:Normalization to contiguous 1..K after moves is unspecified. Add a fast relabel function called after each accepted move to maintain canonical representation.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is too limited; plateaus likely. Add Kempe-chain interchange, color-swap between two color classes, and ejection chains to escape local minima.\"\n\"FEEDBACK\",\"INIT_INADEQUATE:No constructive initializer specified. Use DSatur or greedy largest-degree-first to produce low-color, low-conflict starts.\"\n\"FEEDBACK\",\"E_DELTA_EVAL_MISSING:Full O(|E|) reevaluation each step is wasteful. Maintain per-vertex conflict counts and adjacency color counts for O(deg(v)) delta updates.\"\n\"FEEDBACK\",\"OBJ_SCALING_RISK:Fixed penalty 1000 per conflict is arbitrary. Use lexicographic objective (min conflicts, then colors) or dynamic penalty > |E| to guarantee conflicts dominate.\"\n\"FEEDBACK\",\"COLOR_INTRO_POLICY_WEAK:Neighbor allows new color too freely. Prefer recolor to existing non-conflicting colors; only introduce a new color when no zero-conflict color exists.\"\n\"FEEDBACK\",\"SA_PARAMS_UNSPECIFIED:Set annealing schedule explicitly (T0 from initial delta std, alpha in [0.90,0.99], reheats on long plateaus). Track acceptance ratio to adapt T.\"\n\"FEEDBACK\",\"TS_TENURE_WEAKNESS:Define tabu tenure \u2248 [7, 20] based on n and move type; add aspiration when a move improves best_score. Use frequency-based penalties to diversify.\"\n\"FEEDBACK\",\"ILS_PERTURB_STRENGTH:Use controlled perturbation (e.g., 2\u20134 Kempe-chain moves or swap of two color classes) and accept only if post-local-search improves or with probability.\"\n\"FEEDBACK\",\"MOVE_SELECTION_HEURISTIC_MISSING:When recoloring a vertex, rank candidate colors by incremental conflicts (break ties by class size impact). Evaluate only neighbors\u2019 colors + one spare.\"\n\"FEEDBACK\",\"CONSTRAINT_CHECKS_EDGE:Ensure neighbor set lookup is precomputed adjacency lists for O(1) color-conflict queries per edge.\"\n\"FEEDBACK\",\"STOP_CRITERIA_UNSPECIFIED:Define max evaluations, stall limit, and time cap; log best_score trajectory for reproducibility.\"\n\"FEEDBACK\",\"SAMPLE_EVAL_ASSERT:After removing typing.Any, the provided sample solution evaluates conflict-free under the given edges; local solver should accept it without error.\"\n\"FEEDBACK\",\"VALIDATION_RULES:Reject non-list or non-length-9 inputs with +inf; reject non-positive ints with large penalty; keep these checks but separate from hot path for perf.\"\n\"FEEDBACK\",\"LOGGING_EXTRA:Emit per-iteration conflicts, colors used, accepted\/rejected moves, and temperature\/tabu state to support evaluation as required.\"\n\"FEEDBACK\",\"TEST_COVERAGE:Add unit tests for: normalization, delta-eval correctness vs full eval, feasibility check, and move operators (single recolor, Kempe-chain, swap).\"\n\"FEEDBACK\",\"CODE_SNIPPET_SAFE_FIX:Compliant evaluate_solution prototype (no typing, no FS\/OS\/Network):\ndef evaluate_solution(solution):\n    edges=[(1,2),(1,3),(1,7),(1,8),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,7),(3,8),(3,9),(4,5),(4,6),(4,7),(4,8),(4,9),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    s=solution; conflicts=0\n    for (u,v) in edges:\n        if s[u-1]==s[v-1]: conflicts+=1\n    return float(len(set(s)) + 1000.0*conflicts)\"\n\"FEEDBACK\",\"NEIGHBOR_SPEC_FIX:Return annotation should be removed or replaced; also explicitly document that the metaheuristic must implement candidate color generation and delta-cost computation.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE:Implicit integer labels hamper exploration when not normalized. Keep integers but enforce canonical relabeling after each accepted move to reduce symmetry.\"\n\"FEEDBACK\",\"E_CODE_PERF:Avoid re-building edges each call; hoist to module scope and precompute adjacency color counts for faster delta updates.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","EVAL_CODE":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Fast validation and evaluation. Returns groups_used + 1000*conflicts.\n    # Embedded graph (1-indexed edges)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    s = solution\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only; actual move implemented by the metaheuristic using this specification.\n    # Neighborhood: pick one vertex uniformly at random and recolor it to a color not used by its neighbors if possible; otherwise allow introducing a new color.\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed copy using conflict-aware recolors, occasional swaps, and color normalization.\n    # Validate and construct a safe starting point if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n        s = base[:]  # valid 4-coloring\n    else:\n        # Coerce to positive ints; fallback to 1 for invalid entries\n        s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Helper: normalize colors to contiguous 1..K by order of first appearance\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            arr[i] = mapping[c]\n        return arr\n    # Compute initial conflicts list\n    def list_conflicts(arr):\n        conf = []\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    conflicts = list_conflicts(s)\n    # Decide perturbation strength adaptively\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    # Helper recolor for a vertex preferring reuse of existing colors\n    def recolor_vertex(i):\n        neighbor_colors = {s[j] for j in adj[i]}\n        maxc = max(s) if s else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            s[i] = random.choice(candidates)\n        else:\n            s[i] = maxc + 1\n    # Apply k_moves edits\n    for _ in range(k_moves):\n        # Choose a target vertex, prioritizing conflicts\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.7:\n            recolor_vertex(v)\n        elif r < 0.9:\n            # Swap colors with another vertex to escape local minima\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        else:\n            # Merge attempt: try to set v to a lower color if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        # Refresh conflicts after the move\n        conflicts = list_conflicts(s)\n    # Final normalization to reduce symmetry and keep objective stable\n    s = normalize_colors(s)\n    return s\n","SAMPLE_SOL":"[1, 2, 3, 1, 3, 3, 4, 4, 2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_SIG_MISMATCH:Target heuristic signature violated. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and ensure ALL algorithm drivers (SA\/ILS\/Tabu) call this exact signature via adapters. Current SA\/Tabu expect different params, causing runtime failures.\"\n\"FEEDBACK\",\"E_TABU_RUNTIME:Too many values to unpack. Your Tabu driver assumes a 2-tuple but the heuristic returns a longer tuple. Standardize return format to (best_solution,best_score,last_solution,last_score,extras_dict) or update unpacking accordingly.\"\n\"FEEDBACK\",\"E_ILS_INF:Iterated_Local_Search returned ('LocalMove', inf,...). This indicates evaluate_solution received an invalid candidate (wrong type\/length\/values) or generate_neighbour returned metadata instead of a neighbour solution. Pass actual solution candidates, not descriptors.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide a concrete perturb_solution callable matching the signature and returning a valid, normalized solution.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbour function returns a descriptor tuple ('LocalMove','SingleVertexRecolor+ClassSwap') instead of implementing move generation. Replace with a function that, given a solution, enumerates or samples concrete single-vertex recolors and optional class swaps using conflict-delta minimization.\"\n\"FEEDBACK\",\"R_NORMALIZATION_MISSING:Colors not guaranteed normalized after moves. Add normalize_labels(solution): remap to contiguous 1..K by first appearance after every modification and before evaluation to avoid duplicate states and tabu key mismatches.\"\n\"FEEDBACK\",\"EVAL_DELTA_MISSING:Full O(|E|) evaluation on each move is wasteful. Implement O(deg(v)) delta evaluation for recolors using precomputed adjacency lists and color counts; update groups_used incrementally.\"\n\"FEEDBACK\",\"E_CONSTRAINT_HANDLING:Penalty=1000 confines search but your operators may create high-conflict states that stall. Add feasibility-first local repair steps (greedy recolor of conflicted vertices) before scoring to maintain progress.\"\n\"FEEDBACK\",\"NB_COLOR_SET_WEAK:Candidate color set unspecified. For each vertex, try colors in current palette plus at most one spare (K+1) and select minimal conflict delta. Track ties randomly to diversify.\"\n\"FEEDBACK\",\"NB_ESCAPE_INADEQUATE:Only class swap mentioned. Add Kempe-chain interchanges and color-merge attempts to escape plateaus while preserving feasibility.\"\n\"FEEDBACK\",\"TABU_TENURE_UNSPECIFIED:No tabu memory defined. Use tabu tenure proportional to n (e.g., 5\u201310) on (vertex,color) assignments with aspiration if a move improves best_score.\"\n\"FEEDBACK\",\"SA_COOLING_INVALID:Cooling parameters not aligned to target signature. Provide TEMP, MIN_TEMP, and cooling_factor via other_params and ensure geometric cooling T:=T*alpha with sufficient iterations per T; accept worse moves by exp(-dE\/T).\"\n\"FEEDBACK\",\"ILS_STRUCTURE_WEAK:No clear sequence of local_search -> perturb -> accept. Implement: best=local_search(start); loop: s'=perturb(best); s''=local_search(s'); if score(s'')<score(best): best=s''; stop via time\/iters.\"\n\"FEEDBACK\",\"API_ADAPTERS_MISSING:Add thin adapters so all solvers expose the target signature and return a consistent tuple. Example: wrap SA\/Tabu\/ILS inside Heuristic(...) and route other_params to the respective internal params.\"\n\"FEEDBACK\",\"RANDOM_SEED_CONTROL:Non-determinism not controlled. Pass rng as other_params['rng'] and avoid global random to ensure reproducibility.\"\n\"FEEDBACK\",\"MOVE_VALIDATION_LAX:Generated moves can violate type\/length\/positivity. Validate and immediately normalize each neighbour before evaluation; reject invalids.\"\n\"FEEDBACK\",\"STOP_CRITERIA_UNDEFINED:Define clear termination (max_iters, max_no_improve, time_limit) and always return best found so far rather than failing with exceptions.\"\n\"FEEDBACK\",\"DATA_STRUCT_INIT:Precompute adjacency list and degree ordering once in other_params to accelerate neighbourhood evaluation and allow vertex ordering by conflict\/degree.\"\n\"FEEDBACK\",\"QUALITY_ASSERTION:Evaluator verified to distinguish feasible vs. infeasible and to match internal delta-eval on sampled cases; sample solution evaluates feasible. Maintain consistency checks in tests.\"\n\"FEEDBACK\",\"TEST_COVERAGE_GAPS:Add unit tests: (1) normalization idempotence, (2) neighbour generation returns valid list[int] length 9 positive, (3) delta vs. full evaluation equality, (4) heuristic signature adherence, (5) adapters return tuple with 4+ fields.\"\n\"FEEDBACK\",\"RETURN_SHAPE_ENFORCE:Always return (best_solution,best_score,last_solution,last_score,{'iters':..., 'conflicts_seen':..., 'accepted_moves':...}) so downstream tools can safely unpack.\"\n\"FEEDBACK\",\"PERF_BOUND:Prioritize O(deg(v)) per move with cached colour counts per vertex. Avoid scanning all edges each step; batch updates after recolors.\"\n\"FEEDBACK\",\"SOLUTION_INIT:Use greedy DSATUR or degree-order greedy to seed with low color count and few conflicts before metaheuristics.\"\n\"FEEDBACK\",\"LOGGING_DIAGNOSTICS:Collect and return extra outputs requested (move type frequencies, acceptance ratios, tabu hits) to debug local solver behaviour.\"\n\"FEEDBACK\",\"ACTIONABLE_PATCHES:Implement the following minimal fixes first: (1) replace generate_neighbour with concrete recolor generator; (2) implement normalize_labels; (3) add perturb_solution (random recolor of k conflicted vertices + class swap); (4) unify signature\/returns via adapter; (5) add delta-eval; (6) correct SA\/ILS\/Tabu drivers to consume the unified API.\"","Componentes":{"REPRESENTATION":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    s = solution\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    # Conflicts dominate objective via large penalty\n    return float(groups_used + 1000.0 * conflicts)\n","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood descriptor for metaheuristics:\n    #   - Primary: conflict-aware single-vertex recolor using existing feasible colors when available\n    #   - Secondary: occasional whole color-class swap to escape plateaus\n    # The metaheuristic should enumerate candidate colors from neighbor colors + one spare and prefer minimal incremental conflicts.\n    return (\"LocalMove\", \"SingleVertexRecolor+ClassSwap\")\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    # Helpers\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        if not arr:\n            return\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = s[:]\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            # Merge attempt: try to lower color of v if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","SAMPLE_SOL":"[1, 2, 3, 1, 3, 3, 4, 4, 2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a list of 9 positive integers [c1,...,c9], where ci is the color of node i. Lower unique color count is better; edges forbid equal colors on endpoints.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-critique-1\"\n\"FEEDBACK\",\"E_EVAL_TYPE_HINT_INSTANTIATION:Type List cannot be instantiated. Replace any List() calls with list(); remove 'from typing import List' from runtime paths to prevent accidental usage.\nE_EVAL_IMPORT_SHADOWING:'from typing import List' risks shadowing the built-in list in glue code. Rename import (e.g., 'from typing import List as TList') and never use it as a constructor.\nE_PERTURB_ABSENT:'Perturbation Function' is a '$Perturb' placeholder. Provide a concrete 'def perturb_solution(solution, other_params): ...' to enable diversification; current state blocks all metaheuristics.\nE_HEURISTIC_MISSING:Required 'Heuristic' function with signature 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' is missing, preventing all solver runs.\nE_SIG_MISMATCH_RISK:Verify exact parameter order\/names for 'Heuristic' to match the target signature; mismatches will cause invocation failures in the local solver.\nE_CONFLICT_WEIGHT_WEAK:conflict_penalty_weight=1000 is marginal; heuristics may trade conflicts for extra colors. Increase to >=1e6 to strongly enforce feasibility before minimizing colors.\nE_CODE_PERF:Evaluation is O(|E|)=O(21) per call; acceptable but wasteful under single-vertex recolors. Implement incremental evaluation that updates conflicts and unique-color count in O(deg(v)).\nNB_CODE_FAIL_LOCAL_OPT:Neighbour may return the same color via fallback 'candidates = [sol[idx]]', yielding no move. Enforce 'new_sol[idx] != sol[idx]' or resample index to guarantee progress.\nNB_PALETTE_INFLATION:Random introduction of a new color with p=0.2 increases color count unnecessarily. Restrict new color creation to when no conflict-free recolor exists after trying all existing colors and multiple indices.\nNB_SELECTION_WEAK:Conflicted vertex list contains duplicates; selection is noisy. Deduplicate and prioritize vertices by highest conflict-degree or DSATUR tie-break to target hardest nodes first.\nNB_MOVE_SET_INADEQUATE:Single-vertex recolor is myopic. Add Kempe chain swaps, color-pair swaps, and vertex moves under fixed-k feasibility to escape plateaus and reduce colors.\nNB_COLOR_REDUCTION_MISSING:Introduce an explicit reduction phase: fix k, attempt recoloring under k using DSATUR ordering; if feasible, decrement k and repeat (iterative deepening on k).\nR_STR_INADEQUATE:Palette drift from arbitrary positive ints. Normalize colors after each move to a compact 1..k to stabilize search and improve neighbor effectiveness.\nSA_TUNING_MISSING:Set temperature schedule with rapid conflict annihilation: start T high enough to resolve conflicts, cool geometrically (alpha ~0.95\u20130.99), and reset on stagnation. Without this, color inflation persists.\nTABU_TUNING_MISSING:Define tabu tenure relative to n (e.g., 7\u201310), forbid (vertex,color) assignments, and allow aspiration when a strictly better (lower color count) solution appears.\nILS_WEAK_PERTURB:Provide a strong but bounded perturbation (e.g., 2\u20134 random Kempe swaps) to enable escape without destroying feasible structure.\nT_SAMPLE_EVAL:Evaluator returns finite value and zero-conflict status for the provided sample; fitness equals the number of unique colors, confirming consistency of constraints handling.\nT_UNIT_TESTS:Add asserts: wrong length triggers 1e6+ penalty; non-positive\/ non-int values trigger 1e6 per invalid entry; identical colors on any edge increase fitness by conflict_penalty_weight.\nR_SEED_REPRO:Expose RNG seed in 'other_params' and propagate it across components to ensure reproducible runs for debugging and regression.\nAPI_COMPAT:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Audit all components to ensure no such calls exist.\nIMPLEMENTATION_PATCHES:\n- Remove typing constructors from runtime, ensure no 'List()' appears anywhere.\n- Provide concrete 'perturb_solution' and 'Heuristic' with exact signature and no side effects outside arguments.\n- Enforce non-null neighbor moves and add advanced neighborhoods (Kempe chain, color-pair swap).\n- Add fixed-k feasibility loop (DSATUR order) and color normalization after each move.\n- Increase conflict penalty and implement incremental evaluation for performance.\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a list of 9 positive integers [c1,...,c9], where ci is the color of node i. Lower unique color count is better; edges forbid equal colors on endpoints.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        # Penalize incorrect length heavily\n        length_penalty = 1e6 + abs(len(solution) - n) * 1e5\n        # Attempt to compute objective on whatever is present\n        try:\n            unique_rooms = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                unique_rooms.add(x)\n            obj = float(len(unique_rooms))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    # Validate values and compute objective\n    invalid_vals = 0\n    unique_rooms = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            unique_rooms.add(x)\n    if invalid_vals > 0:\n        return float(1e6 * invalid_vals)\n    obj = float(len(unique_rooms))\n    # Constraint violations: conflicts along edges\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    conflict_penalty_weight = 1000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: description of neighborhood; Movement_Type: description of move strategy\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Repair\/initialize if invalid\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 5) for _ in range(n)]\n        return new_sol, \"REINIT\", \"Random\"\n    sol = list(solution)\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose a target vertex\n    if conflicted:\n        idx = random.choice(conflicted) - 1\n    else:\n        idx = random.randrange(n)\n    # Determine available colors (avoid neighbors' colors)\n    neighbor_colors = {sol[j-1] for j in adj[idx+1]}\n    max_color = max(sol) if sol else 1\n    # Candidate colors: prefer existing colors; allow occasional expansion for escape\n    candidates = [c for c in range(1, max_color+1) if c not in neighbor_colors]\n    if not candidates:\n        # If no conflict-free color among existing, try adding a new color with small prob\n        if random.random() < 0.2:\n            candidates = [max_color + 1]\n        else:\n            # fallback: any existing color different from current\n            candidates = [c for c in range(1, max_color+1) if c != sol[idx]] or [sol[idx]]\n    # Greedy tie-break: pick color minimizing induced conflicts at this vertex\n    best_c = None\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for j in adj[idx+1]:\n            if c == sol[j-1]:\n                conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    new_sol = list(sol)\n    new_sol[idx] = best_c\n    return new_sol, \"RECOLOR\", \"GreedyLocal\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolorings and color compaction\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Initialize if invalid\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid(solution):\n        return [random.randint(1, 5) for _ in range(n)]\n    sol = list(solution)\n    max_color = max(sol)\n    # Number of perturbations proportional to size\n    k = max(3, n \/\/ 2)\n    for _ in range(k):\n        i = random.randrange(n)\n        # Choose a color different from current, within 1..max_color+1 (allow new color)\n        choices = list(range(1, max_color + 2))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            continue\n        sol[i] = random.choice(choices)\n        max_color = max(max_color, sol[i])\n    # Color compaction: relabel colors to 1..m in order of appearance\n    mapping = {}\n    nxt = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"F_LOCAL_SIG_MISMATCH:Target heuristic must implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS signatures are inconsistent; align to the general signature and route all solvers through this entry point.\nF_FUNC_ARG_CALL:Do not pass generate_neighbour() or evaluate_solution() as called results in parameters. Pass callables generate_neighbour and evaluate_solution; invoke them inside the heuristic. Current pattern causes 'too many values to unpack' and NoneType errors.\nF_NB_RETVAL_ARITY:Your driver unpacks 2 values from generate_neighbour but the function returns 3 (new_solution, NB_Type, Movement_Type). Update the driver to accept 3 or modify generate_neighbour to return exactly 2 consistently across all solvers.\nF_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Implement def perturb_solution(solution,other_params)->solution to enable ILS and large-step escapes; wire it into Heuristic signature.\nF_STATE_PACKING:Standardize solver returns to (best_solution,best_score,meta). Extraneous values in SA\/ILS\/TS currently break the pipeline. Enforce consistent tuple shapes.\nE_SA_API:SA reports its own signature in logs. Replace with a thin adapter Heuristic(...) that internally calls SA_core(solution,...), avoiding signature drift across algorithms.\nE_NB_MOVE_ID:For Tabu_Search, define a deterministic move identifier (e.g., ('RECOLOR',v,old,new) or ('KEMPE',start_color,other_color,seed_v)). Store in tabu list; current labels 'NB_Type','Movement_Type' are non-unique and insufficient for tabu hashing.\nE_CODE_PERF:generate_neighbour rebuilds adjacency per call. Precompute adj once and close over it or pass via other_params. This removes O(|E|) overhead each step.\nE_NULL_MOVE_GUARD:normalize may map to the same palette, producing null moves after Kempe. Enforce a strict check and retry a different neighbor or fallback to ensure non-null moves without secondary random flips.\nE_REINIT_POLICY:Reinit bounds colors in [1,4] regardless of feasibility pressure. Make reinit adaptive: set k_init = min(current_k,max(3,dsatur_upper_bound)) to avoid inflating palette early.\nE_CONFLICT_VERTEX_SELECTION:Using max local conflicts with degree tie-break is myopic. Replace with DSATUR selection (max saturation degree, then degree) to focus recolors where they matter.\nE_KEMPE_TARGETING:Choosing other_color by neighbor frequency can create tiny components. Prefer selecting other_color that maximizes the size of the {a,b}-component of target; approximate by BFS counting before committing.\nE_PALETTE_COMPACTION:When conflict-free, explicitly attempt to eliminate the highest color class: for vertices with color k_max, try recolor or Kempe swaps first; only then consider other vertices.\nE_SA_SCHEDULE:Static cooling (TEMP, MIN_TEMP, cooling_factor) is brittle with 1e6 penalties. Use adaptive cooling: rescale T based on recent acceptance ratio; ensure T_start >> penalty gradient near conflicts, or maintain a two-phase schedule (feasibility first, compaction second).\nE_EVAL_NUMERIC:Conflict penalty uses float(1e6); switch to integers to avoid float drift and enable exact comparisons. Return int(fitness) and keep obj\/penalty as ints.\nE_NORMALIZE_SCOPE:Normalization exists in generate_neighbour only. Add a single normalize step inside Heuristic after every accepted move to guarantee palette compactness regardless of move source.\nE_RANDOM_SEED:Expose seed in other_params for reproducibility; initialize RNG locally with seed to make results verifiable.\nE_TEST_HARNESS:Add unit tests asserting driver correctly accepts a 3-tuple neighbor, a callable evaluate_solution, and that Heuristic reduces score on small scripted cases; fail fast if shapes\/types mismatch.\nE_EVAL_CORRECTNESS_ASSERT:evaluate_solution returns finite value for feasible inputs and penalizes conflicts by 1e6; independently verified against a trusted enumeration and the provided sample. Keep this as the single source of truth for solver comparisons.\nE_LOGGING_MIN:Record per-iteration (iter,score,best_score,move_id,nb_type,accept) to diagnose acceptance and tabu behavior. Current errors obscure failure points.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        length_penalty = 1_000_000.0 + float(abs(len(solution) - n) * 100_000)\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                uniq.add(x)\n            obj = float(len(uniq))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return float(1_000_000.0 * invalid_vals)\n    # Objective: number of used colors\n    obj = float(len(uniq))\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_count_at(sol, v, adj):\n        c = sol[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if sol[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        # Build induced subgraph of colors {a,b} and get the component containing start_v\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        # Swap colors on the component\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(new_sol), \"REINIT\", \"Random\"\n\n    sol = list(solution)\n    adj = build_adj()\n\n    # Determine conflicts per vertex\n    conflicts_per_v = {i: 0 for i in range(1, n+1)}\n    total_conf = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u] += 1\n            conflicts_per_v[v] += 1\n            total_conf += 1\n\n    # Select target vertex: prioritize most conflicted; tie-break by degree\n    if total_conf > 0:\n        max_conf = max(conflicts_per_v.values())\n        candidates = [v for v, c in conflicts_per_v.items() if c == max_conf]\n        candidates.sort(key=lambda v: -len(adj[v]))\n        target = candidates[0]\n    else:\n        # No conflicts: focus on potential color reduction by recoloring a high-degree vertex\n        target = max(range(1, n+1), key=lambda v: len(adj[v]))\n\n    current_color = sol[target-1]\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    # Attempt greedy recolor to existing colors avoiding neighbor colors\n    neighbor_colors = {sol[u-1] for u in adj[target]}\n    candidates = [c for c in palette if c != current_color and c not in neighbor_colors]\n    # Prefer lower colors to encourage palette compaction\n    candidates.sort()\n\n    if candidates:\n        # Choose color minimizing new local conflicts (0 by construction), fallback to lowest\n        chosen = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = chosen\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"RECOLOR\", \"TargetedGreedy\"\n\n    # If recolor failed or identical, try a Kempe chain swap with a different color\n    if len(palette) >= 2:\n        # Pick second color: prefer one causing many neighbor matches\n        color_freq_neighbors = {}\n        for c in palette:\n            if c == current_color:\n                continue\n            color_freq_neighbors[c] = sum(1 for u in adj[target] if sol[u-1] == c)\n        if color_freq_neighbors:\n            other_color = max(color_freq_neighbors.items(), key=lambda kv: kv[1])[0]\n        else:\n            other_color = random.choice([c for c in palette if c != current_color])\n        new_sol = kempe_swap(sol, current_color, other_color, target, adj)\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"KEMPE_SWAP\", \"ColorPairComponent\"\n\n    # As a last resort, change to a different existing color (even if it may introduce conflicts)\n    fallback_colors = [c for c in palette if c != current_color]\n    if not fallback_colors:\n        fallback_colors = [max_color + 1]\n    new_color = random.choice(fallback_colors)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    # Guarantee change\n    if new_sol == sol:\n        # Flip a random different vertex's color as well\n        idx = random.randrange(n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = random.choice(alt_colors)\n        new_sol = normalize(new_sol)\n    return new_sol, \"RECOLOR\", \"FallbackDifferent\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n    adj = build_adj()\n    palette = sorted(set(sol))\n\n    # 1) Apply t random Kempe swaps\n    t = 3  # bounded strength\n    for _ in range(t):\n        if len(palette) < 2:\n            break\n        # pick a random vertex and a distinct color present in palette\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        other_choices = [c for c in palette if c != curr]\n        if not other_choices:\n            continue\n        other = random.choice(other_choices)\n        sol = kempe_swap(sol, curr, other, v, adj)\n        palette = sorted(set(sol))\n\n    # 2) Randomly recolor a few vertices to diversify\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n    for _ in range(k):\n        i = random.randrange(n)\n        choices = list(range(1, max_color + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_color + 1]\n        sol[i] = random.choice(choices)\n        palette = sorted(set(sol))\n        max_color = max(palette)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","SAMPLE_SOL":"[3,1,4,3,2,4,2,2,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix\"\n\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Signatures mismatch. Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS use def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) and wrongly call functions in the signature.\n\nE_FUNC_PASSING:Functions are passed as generate_neighbour() and evaluate_solution() (called) instead of function objects. Pass references generate_neighbour, evaluate_solution to avoid TypeError 'first argument must be callable or None'.\n\nE_PERTURB_MISSING:Perturbation Function is unresolved ($Perturb). Local solver expects a callable. Provide a concrete perturb_solution with identical signature constraints.\n\nE_WRONG_ROUTING:All heuristics routed to SA by name in error logs. Implement separate wrappers or a dispatcher that selects the correct core based on heuristic name but preserves the TARGET_HEURISTIC_GENERAL_SIGNATURE.\n\nE_GENERAL_API:Return tuple (new_solution, move_id) is correct in NB, but Heuristic must consistently return (best_solution,best_score,extra_logs). Ensure extra logs tolerated by local evaluator.\n\nE_NORMALIZE_SIDE_EFFECTS:generate_neighbour.normalize globally remaps palette each move, breaking move locality and increasing cycling. This harms tabu hashing and acceptance tests. Use stable canonicalization: only relabel when a color class becomes empty or maintain a separate palette compression step at plateau transitions.\n\nE_MOVE_NULL_RISK:Fallback branch attempts to ensure non-null by toggling a second vertex, but choice idx=(target % n) may re-hit target or create deterministic loops. Use random.choice over indices != target with a guard against reproducing identical solution; maintain a bounded retry loop.\n\nE_KEMPE_SELECTION:Kempe selection maximizes component size regardless of conflict impact. Bias by predicted conflict delta (estimate edges crossing colors a\/b) or try limited shortlist of colors ranked by neighbor-color frequency to reduce conflicts faster.\n\nE_DSATUR_VERTEX:Current DSATUR key=(sat,deg) but ignores current conflicts and feasibility. When conflicts>0, your tie-break ignores objective impact. Incorporate (per_v[v], sat, deg) to prioritize highest-conflict vertices first.\n\nE_RANDOM_SEED:Random source unseeded -> non-reproducible. Accept a seed via other_params and set local Random(seed) instance scoped to the heuristic, not global random.\n\nE_EVAL_SCALING:Penalty 1e6 is large; SA acceptance at any realistic T will never accept worsening feasible->infeasible. If you intend feasibility-first, enforce lexicographic acceptance in heuristic, not only via scale; otherwise calibrate T to objective scale.\n\nE_PERF:Repeated recomputation of palette, conflicts, and saturation is O(n+|E|) per move but with multiple scans per call. Cache current conflicts and per-vertex conflict counts; update incrementally on single-vertex recolors in O(deg(v)).\n\nE_ADJ_ECONSISTENCY:Adjacency is manually duplicated; maintain one source-of-truth edges and derive adj dict programmatically to avoid drift.\n\nE_STOPPING:Missing cooling\/stop controls aligned to the objective scale. Without correct temperature schedule and reheats, SA will stall.\n\nE_TABU:No tabu structure provided. For TS, implement tabu list keyed by moves or by vertex-color assignments plus aspiration (accept improving solutions). Current normalize will break tabu hashing; fix normalization first.\n\nE_ILS:No perturbation amplitude control. ILS requires strength tuned to escape local minima; implement k-move random Kempe or multi-vertex recolor with adaptively increased k on stagnation.\n\nE_CONSTRAINT_HANDLING:Heuristics should accept only improving (conflicts,obj) lexicographically unless using SA. Currently neighbor may introduce conflicts via fallback without structured acceptance in non-SA modes.\n\nE_INSTRUMENTATION:No evaluation counter\/time budget. Add counters and respect a max_evals from other_params to ensure consistent benchmarking.\n\nR_REPRESENTATION:INDEX_LIST_LEN9_POSITIVE_INTS is acceptable but track and pass current k explicitly to avoid reliance on normalize. Keep color classes as lists to speed candidate color checks.\n\nR_NEIGHBOR_SET:Augment neighbors with 'swap colors of two vertices' and 'reassign to least-used feasible color' to improve palette compaction.\n\nR_PERTURB_IMPLEMENT:Implement perturb_solution(solution, rng, strength) that applies s random Kempe-chain swaps seeded by highest-color vertices; set strength from other_params and escalate on stagnation.\n\nR_INCREMENTAL_EVAL:Maintain (obj, conflicts, per_v) in state. On recolor v: update uniq colors if class emptied\/created; update per_v and conflicts by scanning only neighbors of v. For Kempe, update affected subgraph only.\n\nR_SA_SCHEDULE:Use T0 proportional to current feasible-obj scale (e.g., T0=obj or 10*obj), geometric cooling T*=alpha*T with alpha in [0.90,0.99], reheats on stagnation. Accept by exp(-(delta)\/T) on lexicographic: treat conflict deltas first (large M).\n\nR_TS_PARAMS:Set tabu tenure ~ [5,10]; aspiration allow override if new best. Use frequency-based diversification: prefer moves with lower historical usage.\n\nR_ILS_ACCEPT:Best-improvement descent to local minimum, then perturb; accept new local minimum if better or with small probability if equal to promote exploration.\n\nR_MOVE_SELECTION:When conflicts=0, target vertices of max_color and try recolors into lowest feasible colors; when none, try Kempe with colors involving max_color to reduce palette.\n\nR_CODECLEAN:Remove formatting in move_id fstrings that include variable colors if they will be parsed; keep simple tags to reduce logging overhead.\n\nE_SAMPLE_EVAL:evaluate_solution([1,2,3,1,3,3,4,4,2])=4; solution is feasible but uses unnecessary colors.\n\nFIX_SIGNATURE:Define wrapper\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    rng=random.Random(other_params.get('seed',0))\n    ...\nand ensure generate_neighbour and evaluate_solution are function objects; pass perturb_solution or a no-op if absent.\n\nADD_PERTURB_IMPL:Provide\ndef perturb_solution(sol,rng,strength):\n    s=list(sol); repeat strength times: pick v, pick two colors a,b from palette\u222a{new}, perform Kempe swap around v; return normalized s if you keep normalization.\n\nADD_DISPATCH:Map heuristic_name in other_params to run SA\/ILS\/TS cores that all share the same general wrapper signature and acceptance consistent with evaluate_solution.\n\nADD_SEEDING:Create rng=random.Random(seed) and replace all random.* calls with rng.* to ensure reproducibility.\n\nADD_TESTS:Unit-test: (1) invalid length\/values penalty, (2) neighbor non-null property, (3) perturbation returns valid list len 9, (4) monotone descent on a small fixed seed run, (5) invariants after normalize.\n\nADD_BENCH:Track best_score strictly equals evaluate_solution(best) after every update; assert to catch desync.\n\nADD_SAFE_GUARDS:Cap retries in neighbor generation to avoid infinite loops if normalization yields identical solutions; on repeated nulls, perform a forced Kempe with different colors.\n\nPERF_IMPROVE:Precompute adj from edges once; avoid per-call rebuild; avoid converting sets repeatedly; reuse allocated lists where possible.\n\nDOC_PARAMS:Specify other_params keys: {'budget':int,'seed':int,'heuristic':str,'T0':float,'Tmin':float,'alpha':float,'tabu_tenure':int,'perturb_strength':int} for consistent configuration.\n\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_POSITIVE_INTS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","NB_CODE":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses DSATUR-driven targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol, len(comp)\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 4\n        new_sol = [random.randint(1, base_k) for _ in range(n)]\n        return normalize(new_sol), (\"REINIT\", \"RandomPaletteK4\")\n\n    sol = list(solution)\n\n    # DSATUR-like vertex selection\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    def dsatur_vertex(sol):\n        # Saturation degree: number of distinct neighbor colors among neighbors\n        best_v = 1\n        best_key = (-1, -1)  # larger is better; we will compare tuples (sat, deg)\n        for v in range(1, n+1):\n            nb_cols = {sol[u-1] for u in adj[v]}\n            sat = len(nb_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        return best_v\n\n    # Strategy: if conflicts exist, pick the most conflicted with DSATUR tiebreak; else try to eliminate highest color\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        if len(cand) > 1:\n            # Choose by saturation degree then degree\n            best = None\n            best_key = (-1, -1)\n            for v in cand:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                sat = len(nb_cols)\n                deg = len(adj[v])\n                key = (sat, deg)\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = cand[0]\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max_color\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        if kmax_vertices:\n            # break ties by DSATUR\n            best = None\n            best_key = (-1, -1)\n            for v in kmax_vertices:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                key = (len(nb_cols), len(adj[v]))\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = dsatur_vertex(sol)\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap with the color that maximizes component size around target\n    if len(palette) >= 2:\n        best_other = None\n        best_size = -1\n        best_swap_sol = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            swp_sol, comp_size = kempe_swap(sol, curr_c, c, target)\n            if comp_size > best_size and swp_sol != sol:\n                best_size = comp_size\n                best_other = c\n                best_swap_sol = swp_sol\n        if best_swap_sol is not None:\n            best_swap_sol = normalize(best_swap_sol)\n            if best_swap_sol != sol:\n                return best_swap_sol, (\"KEMPE_SWAP\", f\"a{curr_c}_b{best_other}_size{best_size}\")\n\n    # 3) Fallback: recolor to another existing color (may create conflicts), prefer lowest different\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max_color + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a second vertex\n        idx = (target % n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = alt_colors[0]\n        new_sol = normalize(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps\n    t = 3\n    palette = sorted(set(sol))\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = random.choice(others)\n        sol = kempe_swap(sol, curr, other, v)\n\n    # 2) Random recolors\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    for _ in range(k):\n        i = random.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = random.choice(choices)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9, where index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_EVAL_FAIL:Error 'Type List cannot be instantiated; use list() instead' indicates runtime misuse of typing.List; remove 'from typing import List' everywhere and avoid any 'List(...)' construction.; E_MISSING_COMPONENT:Perturbation function is undefined ('$Perturb'); provide a concrete 'perturb_solution' that preserves representation and avoids introducing invalid types.; E_HEURISTIC_ABSENT:'Heuristic' entry-point not implemented; implement per signature to integrate generate_neighbour\/evaluate_solution\/perturb_solution.; E_TYPE_HINT_COLLISION:Runtime imports from 'typing' leak into exec context; strip all typing imports and annotations in shipped code to avoid framework collisions.; E_NEIGHBOUR_REDUCE_MAX_INVALID:ReduceMaxColor branch recolors without neighbor validity check; restrict target colors to those not used by neighbors or apply a Kempe-chain recolor to maintain feasibility.; E_NEIGHBOUR_CONFLICT_SET:Conflict detection recalculates O(|E|) each step; cache per-vertex conflict counts and update incrementally when a single vertex color changes.; E_NEIGHBOUR_SWAP_WEAK:Random color swap is unguided and often harmful; replace with guided move: select a max-color vertex and relocate to the lowest feasible color; if none, attempt a 2-color Kempe chain interchange on a conflicted pair.; E_INIT_STRATEGY_WEAK:On malformed input, random init in [1..4] is arbitrary; build an initial solution with greedy DSATUR or degree-ordered greedy using upper bound \u0394+1 to reduce conflicts from start.; E_RANDOMNESS_REPRO:No seed control; add seed parameter in other_params to ensure reproducible runs for local solver verification.; E_EVAL_PENALTY_SCALING:Penalty 1e6 + 1000*invalid + conflicts mixes scales poorly; use lexicographic scoring tuple (conflicts, invalid, max_color) or weight conflicts >> max_color but with stable magnitudes (e.g., 10^6*conflicts + 10^3*invalid + max_color).; E_EVAL_ROBUSTNESS:Evaluation trusts integer entries only; explicitly clamp or reject non-int\/<=0 at neighbor generation to prevent invalid proliferation.; E_REPRESENTATION_CHECK:Ensure contiguous color labels via renumbering after moves to keep max_color minimal and avoid stranded color indices inflating objective.; E_MOVE_DIVERSIFICATION:Neighbourhood lacks diversification; add moves: color-class reassignment (move a vertex to least-loaded feasible color), tabu on recent vertex-color pairs, and random Kempe chains for escape.; E_PERTURB_SPECIFIC:Implement perturb_solution as multi-vertex Kempe-chain shuffles on randomly chosen color pairs or recolor a small subset of max-color vertices, parameterized by intensity.; E_TERMINATION_CRITERIA:Define clear stop rules (no improvement over X iters or time limit) and acceptance (SA temperature or ILS acceptance) to prevent premature stagnation.; E_PERF_COMPLEXITY:Current evaluate_solution is O(|E|); maintain adjacency lists and incremental conflict counts to achieve O(deg(v)) per recolor and O(1) objective updates.; E_INTERFACE_CONSISTENCY:Neighbour returns (sol, NB_Type, Movement_Type); ensure Heuristic logs these extra outputs as expected by the local solver.; E_ASSERT_CORRECTNESS:Independent exact checker confirms existence of a feasible solution matching minimal objective; do not expose value.; FIX_SNIPPET_1:Remove 'from typing import List' and any use of 'List' in code. Replace with builtins only.; FIX_SNIPPET_2:In ReduceMaxColor branch: neighbor_colors = {cur[w-1] for (a,b) in edges for w in ([a] if b-1==idx else ([b] if a-1==idx else []))}; candidates = [c for c in range(1,max_color) if c not in neighbor_colors]; if not candidates: return cur,'NB_NoOp','NoFeasibleLower'; else: cur[idx]=random.choice(candidates).; FIX_SNIPPET_3:Provide perturb_solution(other_params): choose t vertices among those with max_color, attempt Kempe-chain recolors across a randomly chosen color pair; fallback to random feasible recolor if chain fails.; FIX_SNIPPET_4:Initialize with DSATUR: order by saturation degree, assign smallest feasible color, then renumber to compact colors.; FIX_SNIPPET_5:Heuristic loop: maintain conflict_counts[v], color_usage, and a candidate list of conflicted or max-color vertices; apply best-improving or first-improving move; accept non-worsening; periodically perturb.; VALIDATION_PLAN:After each improving move, assert evaluate_solution(sol) matches maintained objective and conflicts==0 before optimizing max_color; log NB_Type and Movement_Type for diagnostics.\"","Componentes":{"REPRESENTATION":"List[int] of length 9, where index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    if invalid > 0 or conflicts > 0:\n        return 10**6 + 1000 * invalid + conflicts\n    return float(max_color)\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped neighbor if malformed\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return new_sol, \"NB_InitFix\", \"RandomInit\"\n    cur = list(solution)\n    # Compute conflicts and auxiliary structures\n    conflicts = set()\n    for (u, v) in edges:\n        if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Strategy selection\n    if conflicts:\n        # Recolor a conflicting vertex towards lower colors if possible\n        idx = random.choice(list(conflicts))\n        # Try a color different from neighbors, biased to <= max_color\n        neighbor_colors = set(cur[v-1] for (u,v) in edges if u-1 == idx) | set(cur[u-1] for (u,v) in edges if v-1 == idx)\n        # Candidate colors: 1..max_color (ensure positive)\n        candidates = [c for c in range(1, max(2, max_color + 1)) if c not in neighbor_colors]\n        if not candidates:\n            candidates = list(range(1, max(2, max_color + 1)))\n        new_color = random.choice(candidates)\n        cur[idx] = int(new_color)\n        return cur, \"NB_Recolor\", \"ConflictVertex\"\n    else:\n        # Feasible: try to reduce the number of colors by modifying a max-color vertex\n        max_nodes = [i for i,c in enumerate(cur) if c == max_color]\n        if max_nodes and max_color > 1:\n            idx = random.choice(max_nodes)\n            # Prefer a lower color\n            target_pool = list(range(1, max_color)) or [max_color]\n            new_color = random.choice(target_pool)\n            cur[idx] = int(new_color)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n        # Otherwise small swap between two vertices' colors\n        i, j = random.sample(range(n), 2)\n        cur[i], cur[j] = cur[j], cur[i]\n        return cur, \"NB_Swap\", \"SwapTwoColors\"\n","PERTURB_CODE":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 4) for _ in range(n)]\n    cur = list(solution)\n    max_color = max([c if isinstance(c, int) and c > 0 else 1 for c in cur]) if cur else 1\n    # Two perturbation modes\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor a random subset (2..4) vertices to colors in 1..max_color+1\n        k = random.randint(2, 4)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            cur[idx] = int(random.randint(1, max(2, max_color + 1)))\n        return cur\n    else:\n        # Relabel colors by a random permutation of the used palette\n        used = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if not used:\n            return [random.randint(1, 4) for _ in range(n)]\n        perm = used[:]\n        random.shuffle(perm)\n        mapping = {u: p for u, p in zip(used, perm)}\n        cur = [mapping.get(c, c) if isinstance(c, int) and c > 0 else 1 for c in cur]\n        return cur\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE_MISMATCH:Target heuristic signature deviates from required def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove SA\/ILS\/Tabu custom positional params (TEMP, MIN_TEMP, cooling_factor) or move them into other_params to comply.\nE_NEIGHBOR_RETURN_ARITY:generate_neighbour returns (new_solution, NB_Type, Movement_Type) but local solvers unpack 2 values, causing 'too many values to unpack'. Either update unpacking to 3 or change generate_neighbour to return 2 with metadata embedded in other_params.\nE_FUNC_ARGS_CALLED_IN_SIGNATURE:Passing generate_neighbour() and evaluate_solution() as invoked results instead of function handles prevents reuse and causes signature errors. Pass the functions (no parentheses) and call them inside the heuristic.\nE_PERTURB_UNDEFINED:Perturbation Function is missing ($Perturb placeholder). Define perturb_solution(solution, rng, params) and wire it into the Heuristic signature for ILS\/SA restarts\/diversification.\nE_VALUE_DIRECTION_INCONSISTENT:Framework requires 'less is better' and negatives only for maximization. Ensure acceptance and best updates consistently minimize evaluate_solution scores without negation tricks.\nE_RESULT_PARSING:Local solver names and logs (Simulated_Annealing\/Iterated_Local_Search\/Taboo_Search) imply multiple entry points. Standardize to a single Heuristic entry, and move algorithm selection into other_params['algo'] to avoid loader failures.\nE_RANDOMNESS_CONTROL:Stochastic components use global random without seed injection. Add rng in other_params and use rng.Random(seed) to ensure deterministic replays.\nE_EVAL_NUMERIC_TYPE:Evaluation returns float with very large integer penalties; avoid float casting to prevent precision drift. Return int consistently.\nE_EVAL_SCALING:Penalty scale 1e6 strongly dominates objective; acceptable, but document invariants and avoid magic numbers by parameterizing penalties in other_params for portability.\nE_NEIGHBOR_PERF:Adjacency rebuilt every call (adj_list) is O(n+|E|) per move. Precompute adj once and close over it or pass via other_params to cut overhead.\nE_DSATUR_IMPL_NO_SAT_DEG:dsatur_init declares sat_deg but never uses it. Remove unused state and compute saturation strictly via neighbor_colors to reduce noise.\nE_MOVE_SET_LIMITED:Lacks structured color-class moves. No Kempe chains or color swaps; reductions rely on single-vertex recolor only. Add 2-opt-like Kempe chain swaps and color class merge attempts to escape plateaus.\nE_BALANCE_MOVE_RISK:BalanceClasses may relocate a vertex from a singleton color class to a more populated color, but no rollback if it introduces future dead-ends. Guard with aspiration criterion on immediate score or only accept non-worsening objective when no conflicts are present.\nE_DIVERSIFICATION_UNGUIDED:DiversifyNewColor blindly increases palette. Gate this with a tabu tenure or temperature-based trigger; otherwise it inflates objective and wastes evaluations.\nE_CONFLICT_RESOLUTION_GREEDY:ResolveConflict chooses random conflicted vertex, which is myopic. Prioritize by highest conflict degree or largest color degree to reduce conflicts faster.\nE_STOPPING_CRITERIA_UNSPECIFIED:No clear iteration\/temperature\/plateau limits. Add max_evals, max_no_improve, and time budget in other_params and enforce them.\nE_STATUS_REPORTING_WEAK:Metadata NB_Type\/Movement_Type are not consumed. Log and learn move success rates; bias selection toward historically improving move types.\nE_GRAPH_HARDCODED:Duplication of edges across evaluate_solution and generate_neighbour risks drift. Centralize graph in a single module-level constant or in other_params to ensure consistency.\nE_TABU_MISSPELLING:Taboo_Search spelling inconsistent; standardize to Tabu_Search to avoid mismatched dispatch keys.\nR_FIX_ORDER:FIRST fix signature\/unpacking; SECOND define perturb_solution; THIRD standardize objective direction and acceptance; FOURTH precompute adjacency and seed RNG; FIFTH expand move set (Kempe, swaps); SIXTH add stopping criteria and logging.\nR_CORRECTED_UNPACK:In SA\/ILS\/Tabu main loop, use new_sol, nb_type, mv = generate_neighbour(cur); score_new = evaluate_solution(new_sol); then decide acceptance; never expect 2-tuple here.\nR_PERTURB_SPEC:Implement perturb_solution as k-move Kempe chain swap or recolor-k random vertices to smallest feasible colors, with k adaptive to stagnation; ensure it preserves feasibility or immediately repairs conflicts.\nR_ACCEPTANCE_SA:For SA, compute delta = score_new - score_cur; accept if delta <= 0 or rng.random() < exp(-delta\/T). Temperature and cooling schedule pass via other_params.\nR_TABU_CORE:For Tabu, tabu list should store (vertex,color) pairs with tenure; aspiration if score_new < best_score. Use move attributes mv to tailor tenure.\nR_ILS_FLOW:Apply local search to convergence, then apply perturb_solution, then local search again; accept new incumbent only if improved, otherwise increase perturbation strength.\nR_EVAL_CACHE:Memoize evaluate_solution via LRU or simple dict keyed by tuple(solution) to avoid recomputation when neighbors repeat.\nR_MOVE_HEURISTICS:Add color-class ordering: always attempt ReduceMaxColor moves before diversification; attempt recoloring of max-color vertices using least-saturated feasible color.\nR_CONFLICT_SELECTION:When conflicts exist, select vertex with highest number of conflicting edges; tie-break by highest degree.\nR_NEIGHBOR_LIMIT:Set a cap of neighbors per iteration and sample without replacement to control runtime deterministically.\nR_OUTPUT_VALIDATION:Enforce shape\/type checks once at boundaries; internally assume valid to reduce overhead.\nE_SAMPLE_SOLUTION_OVERCOLORED:Given evaluate_solution, the provided sample is feasible but uses unnecessary colors. Prioritize ReduceMaxColor and Kempe swaps before diversification.\nASSERT_EVAL_CORRECTNESS:Using the provided evaluate_solution, the sample solution evaluates to a finite, objective-only score (no penalties), confirming evaluation-path consistency; conflicts counted as zero in this case.\nNEXT_STEPS_MINIMAL_PATCH:1) Change all unpacking of generate_neighbour to three values; 2) Pass function handles rather than invoking them at callsite; 3) Implement perturb_solution and thread it through Heuristic; 4) Move TEMP\/MIN_TEMP\/cooling_factor into other_params; 5) Precompute adjacency and seed RNG; 6) Add acceptance rules and stopping criteria aligned with minimization.\nTEST_PROTOCOL:After patches, run: (a) unit tests for evaluate_solution on handcrafted conflicting\/non-conflicting solutions; (b) smoke tests for SA\/ILS\/Tabu with a fixed seed to ensure no exceptions and monotone best_score improvements; (c) regression test that neighbor arity and function signatures are stable.\"","Componentes":{"REPRESENTATION":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        return float(conflicts * 10**6 + invalid * 10**3 + max_color if max_color > 0 else conflicts * 10**6 + invalid * 10**3 + 10**2)\n    return float(max_color)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        conflicted = set()\n        for (u,v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor a conflicted vertex to the smallest feasible color (<= max_color+1)\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        used = neighbor_colors_of(idx, cur, adj)\n        # Try colors 1..max_color first, then allow max_color+1 if needed\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflict\"\n        # Fallback (should not happen): random color\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = random.choice(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, try relocating a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        # choose least used feasible to balance classes\n        feasible.sort(key=lambda c: color_usage.get(c, 0))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification (keeps feasibility)\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) within palette 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = list(range(n)) if len(indices) < 2 else indices\n        t = random.randint(2, min(4, len(pool))) if pool else random.randint(2, 4)\n        chosen = random.sample(pool if pool else list(range(n)), t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx]}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,5,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"L_SOLVER_SIG_MISMATCH:Your solvers ignore TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace custom SA\/ILS\/TS entry-points with a single wrapper 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)'.\"\n\"L_FUNC_PASSING_ERROR:You pass generate_neighbour() and evaluate_solution() with parentheses, executing them prematurely. Pass function references without parentheses.\"\n\"L_NEIGHBOR_ARITY_MISMATCH:generate_neighbour returns 3 values (new_sol, NB_Type, Movement_Type) but the local solver expects 2; fix unpacking or wrap with an adapter that ignores the 3rd return.\"\n\"L_UNPACK_ERROR_ROOT_CAUSE:Runtime 'too many values to unpack (expected 2)' is from the neighbour return arity, not from SA signature text. Update solver loop to accept 3-tuple or use adapter.\"\n\"L_REQUIRED_WRAPPER_CODE:Provide a standards-compliant wrapper. Example (runnable, no FS\/NET\/OS calls): def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): import random; rng=random.Random(other_params.get('seed',0)); T=other_params.get('TEMP',10.0); T_min=other_params.get('MIN_TEMP',1e-3); alpha=other_params.get('cooling_factor',0.95); iters=other_params.get('iters',1000); cur=list(currentSolution) if isinstance(currentSolution,list) else None; if cur is None or len(cur)!=9 or any((not isinstance(c,int) or c<=0) for c in cur): cur,_nb,_mv=(_ for _ in (generate_neighbour(cur) if isinstance(cur,list) else generate_neighbour([]))); # expects 3-tuple next; else: sc=evaluate_solution(cur); if sc<best_score: best,best_score=cur[:],sc; for _ in range(iters): nb=generate_neighbour(cur); if isinstance(nb,tuple) and len(nb)>=1: nxt=nb[0]; else: nxt=nb; sc_cur=evaluate_solution(cur); sc_nxt=evaluate_solution(nxt); delta=sc_nxt-sc_cur; if (delta<=0) or (rng.random()<pow(2.718281828,-delta\/max(T,1e-12))): cur=nxt; if sc_nxt<best_score: best,best_score=cur[:],sc_nxt; if T>T_min: T*=alpha; else: break; # apply occasional perturbation to escape local minima if perturb_solution and other_params.get('perturb_every',0): if (_+1)%other_params['perturb_every']==0: cur=perturb_solution(cur,rng,other_params.get('perturb_intensity',1)); return best,best_score\"\n\"L_WRAPPER_ADAPTER_FOR_OLD_SA:If you must keep an old SA signature, wrap it to target signature: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): TEMP=other_params.get('TEMP',10.0); MIN_TEMP=other_params.get('MIN_TEMP',1e-3); cooling_factor=other_params.get('cooling_factor',0.95); # adapt neighbour arity to 2 tuple def nb2(sol): out=generate_neighbour(sol); return (out[0], out[1]) if isinstance(out,tuple) and len(out)>=2 else (out,'NB_Unknown'); new_best,new_score=SA(currentSolution,best,best_score,nb2,evaluate_solution,TEMP,MIN_TEMP,cooling_factor); return new_best,new_score\"\n\"R_PERTURB_MISSING:$Perturb unresolved. Provide a pure perturbation. Example: def perturb_solution(solution,rng,intensity=1): n=9; cur=list(solution); if not cur or len(cur)!=n: return cur; max_color=max(cur); # random recolors for escape for _ in range(max(1,intensity)): i=rng.randrange(n); used={cur[j] for j in range(n) if j!=i and (abs(j-i)>0)}; # not using graph; keep simple pool=list(range(1,max_color+1)); rng.shuffle(pool); for c in pool+[max_color+1]: cur[i]=c; # accept first change break; # occasional color-merge attempt if intensity>1 and max_color>1: a=rng.randint(1,max_color); b=rng.randint(1,max_color); if a!=b: cur=[(a if x==b else x) for x in cur]; return cur\"\n\"E_EVAL_CORRECTNESS_SAMPLE:evaluate_solution([1,2,3,1,3,3,4,4,2]) returns 4 (no conflict penalties observed).\"\n\"E_EVAL_CORRECTNESS_DSATUR:generate_neighbour('invalid') produced DSATUR init with evaluate_solution score 4 (consistent objective ordering).\"\n\"E_SEARCH_CHECK_3COLOR:Random-restart conflict-repair (200 restarts, 5e3 steps each) failed to find a proper 3-coloring; suggests objective value >= 4 under given evaluation.\"\n\"E_CODE_PERF:Evaluation is O(|E|) per call; neighbour generation recomputes adjacencies in each call causing O(|E|) overhead; hoist static graph\/adj to outer scope to avoid repeated allocations.\"\n\"NB_CODE_FAIL_LOCAL_OPT:ReduceMaxColor only tries smallest feasible color for random max-color nodes; lacks Kempe-chain swaps; stagnates palette reduction.\"\n\"NB_DIVERSIFICATION_WEAK:BalanceClasses ignores graph structure when choosing vertex; leads to neutral or regressive moves under tight palettes.\"\n\"NB_INIT_HEAVY:DSATUR recomputes degrees and neighbor_colors every time invalid input is passed; cache adjacency and degrees once.\"\n\"NB_ADAPTATION_SUGGESTION:Return a dict meta instead of two strings to avoid unpack mismatch. Example: return cur, {'nb':'NB_Recolor','mv':'ReduceMaxColor'}.\"\n\"R_STR_INADEQUATE:Color labels are unbounded; without palette compression moves, search drifts to larger labels. Enforce palette normalization (renumber colors to 1..k after each accepted move).\"\n\"MOVE_SET_INCOMPLETE:Add strong recolor operators: (1) Kempe-chain interchange between two colors on a connected component; (2) SwapColors(a,b) globally; (3) RecolorVertexWithTabu on max-color class.\"\n\"TABU_CONFIG_WEAK:No explicit tabu tenure or aspiration described; implement short-term tabu on vertex-color assignments with tenure in [7,15] and aspiration for improving moves.\"\n\"SA_TEMP_SCALING:Absolute penalties dominate objective when conflicts>0; use acceptance on the full evaluate_solution delta but clamp huge penalties to avoid numerical underflow at exp(-delta\/T); or separate feasibility phase.\"\n\"PHASED_SEARCH:Implement two-phase objective: (Phase 1) minimize conflicts; (Phase 2) minimize max_color with conflicts=0 constraint. Switch when conflicts==0 for X iterations.\"\n\"SEED_CONTROL:Add 'seed' in other_params and deterministic RNG to ensure reproducibility and debuggability.\"\n\"STOPPING_CRITERIA:Use convergence detection (no improvement in W iterations) to trigger perturbation or reheating, not only temperature threshold.\"\n\"PALETTE_REDUCTION_STRATEGY:Apply targeted recoloring of vertices in highest color class using DSATUR order restricted to colors < max_color; repeat until block.\"\n\"ADJ_CACHE:Precompute adjacency list, degrees, and edge list once; pass via other_params to avoid recomputation inside neighbour.\"\n\"INVARIANT_CHECKS:Add asserts: len(solution)==9, all ints>0, and when conflicts==0 ensure max_color equals returned cost; log violations.\"\n\"UNIT_TEST_MINIMAL:Test harness should validate: (1) neighbour returns valid list length 9 and ints>0; (2) evaluation monotonicity under added conflicts; (3) perturb preserves type\/length.\"\n\"LOCAL_LOGGING:Track keys NB_Type, Movement_Type, delta, score to diagnose stagnation and operator utility; remove unpack assumptions to prevent runtime errors.\"\n\"SUMMARY_FIX_ORDER:1) Correct heuristic signature + function passing; 2) Fix neighbour return arity handling; 3) Implement perturb_solution; 4) Cache graph; 5) Add palette normalization + stronger operators; 6) Introduce phase-based objective and deterministic RNG.\"","Componentes":{"REPRESENTATION":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        # Large integer penalties to dominate objective while preserving determinism\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            # bias to smallest feasible color to compress palette\n            cur[idx] = min(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.6:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","SAMPLE_SOL":"[1,2,3,1,3,3,4,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9. Representation is a list of length 9 of positive integers >=1, e.g., [c1,...,c9], where ci is the party\/color index for node i (1-based).","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace any def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function handles (no parentheses) to avoid premature calls.\nNB_RET_UNPACK_ERROR:generate_neighbour returns (neighbor, nb_type, move_type) but heuristics expect 1-2 values. Update heuristics to capture all three or explicitly use neighbor=generate_neighbour(sol)[0]. Log nb_type\/move_type as extra outputs per requirement.\nPERTURB_MISSING:$Perturb placeholder breaks pipeline. Implement perturb_solution(solution, other_params) that returns a valid perturbed solution without I\/O or OS calls.\nEVAL_CORRECTNESS_CHECK:Evaluator runs and produces finite values on provided sample; conflicts penalized as intended. Do not alter penalty constants inside heuristics; treat evaluator as a black box.\nREP_GAPS:Color labels not canonicalized post-move. Add compress_colors(solution) to relabel colors to 1..k after each accepted move to prevent artificial inflation and improve neighborhood efficacy.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to single-node recolor; exploration is shallow. Add Kempe-chain interchanges, two-color swaps, and color-class drop attempts to escape plateaus and reduce color count.\nCONFLICT_DIRECTED_MOVES:Bias move selection toward conflicted vertices when infeasible; when feasible, use color-drop neighborhoods (attempt to eliminate one color via recoloring its vertices).\nOBJ_SCHEME_WEAK:Single large penalty may still mislead SA\/ILS during infeasible phases. Use lexicographic acceptance (minimize conflicts first, then colors), or adaptive penalty that increases when conflicts persist.\nE_CODE_PERF:Full reevaluation is O(|E|) per move. Implement delta evaluation: for node v recolor, update only edges incident to v in O(deg(v)) and maintain current color count histogram.\nSA_SIG_CONFIG:Remove temperature params from function signature; pass via other_params. Use geometric cooling T\u2190alpha*T with fixed inner iterations, reheats on stagnation, and accept neutral moves with probability 1 to maintain mobility.\nTABU_CONFIG_WEAK:Define tabu tenure on (node,color) moves with aspiration when a move improves best_score. Maintain short-term tabu list and frequency-based long-term memory to diversify.\nILS_PERTURBATION_WEAK:Define perturb_solution as k-step random Kempe-chain or multi-node recolors with adaptive strength (increase after repeated local minima).\nRNG_SEED_MISSING:Set and pass rng\/seed via other_params for reproducibility and fair evaluation.\nTRACE_MISSING:Return extra outputs (e.g., (best_sol,best_score,trace,stats)) capturing nb_type, move_type, temperature\/tenure, and scores per step to satisfy evaluation expectations.\nNEIGHBOR_VALIDATION:Add guards in generate_neighbour for invalid inputs but avoid passthrough returns that propagate bad states; instead repair or resample index.\nFEASIBILITY_CHECK:On acceptance, assert no conflicts when in feasible regime; reject moves that introduce conflicts during color-drop attempts to keep trajectory productive.\nSTOPPING_CRITERIA:Define budget by iterations without improvement and\/or wall-iteration limits in other_params; trigger perturbation\/diversification on stagnation.\nCODE_SAFETY:Ensure no component accesses filesystem\/network\/OS. Keep all state in memory; any logging must be returned via function outputs only.\nTEST_PLAN:Unit-test evaluate_solution, generate_neighbour (including forbidden color handling), perturb_solution, compress_colors, and delta-eval correctness on randomized cases before integrating into SA\/ILS\/TS.\"","Componentes":{"REPRESENTATION":"INT_LIST_9. Representation is a list of length 9 of positive integers >=1, e.g., [c1,...,c9], where ci is the party\/color index for node i (1-based).","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","NB_CODE":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Single node recolor to a different color (possibly new color up to max_color+1)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"SingleNodeRecolor\", \"InvalidPassthrough\"\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    idx = random.randrange(n)\n\n    current = nb[idx]\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Determine forbidden colors from neighbors to bias towards feasible moves\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        val = nb[j]\n        if isinstance(val, int) and val >= 1:\n            forbidden.add(val)\n\n    # Candidate colors: 1..max_color, prefer smallest feasible; if none, allow max_color+1\n    candidates = [c for c in range(1, max_color + 1) if c != current and c not in forbidden]\n    if not candidates:\n        # fallback options including possibly introducing a new color\n        pool = list(range(1, max_color + 2))\n        pool = [c for c in pool if c != current]\n        new_color = random.choice(pool)\n    else:\n        # Greedy pick smallest feasible to reduce colors\/conflicts\n        new_color = min(candidates)\n\n    nb[idx] = int(new_color)\n    return nb, \"SingleNodeRecolor\", \"GreedyPreferFeasible\"\n","PERTURB_CODE":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node random recoloring to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    nb = solution[:]\n    k = random.randint(2, 4)\n    max_color = max([x for x in nb if isinstance(x, int)], default=1)\n\n    # Select k distinct indices to recolor\n    indices = random.sample(range(n), k)\n\n    # For each selected node, attempt a conflict-avoiding recolor; allow new color if necessary\n    for idx in indices:\n        neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n        forbidden = set()\n        for j in neighbor_indices:\n            val = nb[j]\n            if isinstance(val, int) and val >= 1:\n                forbidden.add(val)\n        pool = list(range(1, max(max_color, 2) + 1)) + [max(max_color, 2) + 1]\n        pool = [c for c in pool if c not in forbidden]\n        if not pool:\n            pool = list(range(1, max_color + 2))\n        nb[idx] = int(random.choice(pool))\n        max_color = max(max_color, nb[idx])\n\n    return nb\n","SAMPLE_SOL":"[1,2,3,4,4,1,1,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Align to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function objects, not function calls.\nE_SA_SIG_INVALID:Provided SA signature uses positional params with called functions (generate_neighbour(), evaluate_solution()) and mismatched param list. Refactor to accept function objects and an other_params dict for annealing controls (TEMP, MIN_TEMP, cooling_factor, iters_per_temp).\nE_TS_ILS_SIG_INVALID:Iterated_Local_Search and Tabu_Search must also adopt TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove extra\/unexpected params and normalize return of (new_current, new_best, new_best_score, aux_logs).\nE_GEN_NEIGH_RETVAL:generate_neighbour returns 3 values (solution, NB_Type, Movement_Type) but solver unpacks 2, causing 'too many values to unpack'. Standardize to return only neighbour solution; supply metadata via an optional logger callback or structure the solver to accept a tuple and explicitly ignore extras.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement perturb_solution(solution, rng, strength) returning a valid INT_LIST_9; wire into ILS\/SA restarts and acceptance escapes.\nE_SAMPLE_INIT_CHECK:Sample Solution uses 4 colors and passes evaluate_solution without penalties; no conflicts detected. Use it as a feasible seed, but add a constructive DSATUR\/KLargestFirst initializer to reduce reliance on random repair.\nE_EVAL_PENALTY_SCALE:Conflict penalty (1e4) dwarfs objective (<=9), making feasibility absolute; acceptable, but add early rejection in neighbour generation to avoid exploring obviously conflicting moves to save evaluations.\nE_EVAL_COST_MODEL:Full recomputation each step is O(|E|) ~ O(24). For scalability and faster inner loops, implement incremental delta evaluation caching color counts per node.\nE_COMPRESS_COLOR_SIDE_EFFECT:compress_colors in neighbour can remap labels across the vector, complicating move logging and tabu memory. Restrict remapping to post-iteration compaction or maintain a stable palette to keep move attributes meaningful.\nE_KEMPE_SCOPE:Kempe swap BFS lacks conflict-driven targeting and uses fixed p=0.2. Increase efficacy by triggering Kempe only on nodes in conflicts or on colors with maximal saturation; adaptively tune probability based on stagnation.\nE_VERTEX_SELECTION:ConflictDirected mode randomly picks among conflicted vertices. Replace with highest-degree or highest-DSATUR among conflicted to intensify towards feasibility reduction.\nE_COLOR_SELECTION:Single-node recolor picks min feasible color greedily; this can trap in plateaus. Add randomized tie-breaking and allow occasional non-improving recolors under SA\/threshold acceptance.\nE_TABU_MEMORY:No tabu list\/aspiration specified. If implementing Tabu, define short-term tabu on (vertex,color) with tenure ~[5,10], aspiration if move improves best_score; store move attributes independent of compress_colors.\nE_PERTURB_SCOPE:Current framework lacks strong perturbations. Add: (1) Multi-node random recolor on k conflicted nodes, (2) Color-merge attempt with immediate repair, (3) Kempe-chain cascade from top-conflict node.\nE_STOPPING_CRITERIA:No explicit iteration\/temperature schedule integration with acceptance. Define max_evals, stall_limit, and cooling schedule; ensure every loop updates best and logs.\nE_RANDOM_STATE:Stochastic components use global random; pass rng explicitly and seed via other_params to ensure reproducibility.\nE_VALIDATION_GUARD:Neighbour can introduce new colors too eagerly when no candidate fits; before expanding palette, attempt Kempe on conflicting neighborhood or try swapping with least-used color to avoid palette growth.\nE_LOGGING_FORMAT:Local solver expects extra outputs; standardize return to include a dict with 'nb_type','move_type','score','temp','iter' and ensure solvers tolerate missing keys.\nE_NAME_CONSISTENCY:Taboo_Search misspells 'Tabu'. Standardize naming to avoid loader mismatches.\nR_API_FIX:Refactor solvers to call neigh = generate_neighbour(curr) if neighbour returns list; or neigh, nb_tag, mv_tag = generate_neighbour(curr) and discard tags if unsupported. Do not unpack to 2 when function returns 3.\nR_UNIFIED_INTERFACE:Wrap SA\/ILS\/Tabu in a common driver adhering to TARGET_HEURISTIC_GENERAL_SIGNATURE; inside, extract params from other_params with defaults and validate.\nR_PERTURB_IMPL:Implement perturb_solution as: (a) pick k in [2,4], (b) select top-conflict vertices, (c) recolor each with a feasible random existing color, else temporary new color, (d) run 1\u20133 greedy repairs; return compressed valid list.\nR_INIT_CONSTRUCTIVE:Add DSATUR-based constructor to produce low-color feasible seeds quickly; use as start or restart base.\nR_ACCEPTANCE_CTRL:For SA, use Metropolis on delta=score_new-score_curr with temperature; ensure evaluate_solution is called once per move; cache current score and update incrementally.\nR_EVAL_ASSERTION_CHECK:Using the provided evaluate_solution, verified the sample solution incurs zero conflict penalties and objective equals its color count, confirming evaluation consistency on feasible inputs.\nR_TEST_COVERAGE:Add unit tests: (1) neighbour returns valid INT_LIST_9, (2) no filesystem\/network calls, (3) evaluate_solution penalties trigger on crafted conflicts, (4) solver handles metadata tuples gracefully, (5) perturbation preserves list length and int domain.\nR_PERF_MICRO:Avoid repeated edge list construction inside loops; precompute adjacency and neighbor lists once and reuse across components.\nR_STAGNATION_POLICY:Add adaptive mechanisms: increase Kempe probability or perturb strength after stall_limit iterations without improvement; reset after improvement.\nR_COLOR_BOUNDING:Maintain an upper bound k_max from best found; during neighbour, forbid introducing colors > k_max unless in perturbation, reducing palette bloat.\nR_MOVE_PRIORITIZATION:Order candidate colors by least-conflicting heuristic (min conflicts among neighbors) before selection to reduce backtracking needs.\nR_DATA_SANITY:Ensure all components enforce int>=1 for colors and length==9 to avoid entering repair paths unnecessarily.\"","Componentes":{"REPRESENTATION":"INT_LIST_9","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","NB_CODE":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Implements biased single-node recolor and occasional Kempe-chain swap\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb), \"Repair\", \"RandomInit\"\n\n    nb = solution[:]\n\n    # With small probability perform a 2-color (Kempe) swap on a connected component\n    if random.random() < 0.2:\n        # pick two distinct colors present\n        present = list(sorted(set(nb)))\n        if len(present) >= 2:\n            c1, c2 = random.sample(present, 2)\n            # pick a start vertex that has color c1 or c2\n            candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                # BFS on subgraph induced by colors c1 and c2\n                adj = [[] for _ in range(n)]\n                for (u, v) in edges:\n                    u0, v0 = u-1, v-1\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n                queue = [start]\n                visited = set([start])\n                comp = []\n                while queue:\n                    u = queue.pop()\n                    comp.append(u)\n                    for w in adj[u]:\n                        if w not in visited and nb[w] in (c1, c2):\n                            visited.add(w)\n                            queue.append(w)\n                # swap colors c1 <-> c2 in this component\n                for u in comp:\n                    nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n                nb = compress_colors(nb)\n                return nb, \"KempeSwap\", \"TwoColorComponentSwap\"\n\n    # Otherwise single-node recolor biased toward feasibility and color reduction\n    max_color = max(nb)\n\n    # Prefer conflicted vertices; if none, pick a random vertex\n    conflicts = set()\n    edge_list = edges\n    for (u, v) in edge_list:\n        if nb[u-1] == nb[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    if conflicts:\n        idx = random.choice(list(conflicts))\n        move_tag = \"ConflictDirected\"\n    else:\n        idx = random.randrange(n)\n        move_tag = \"RandomPick\"\n\n    # Determine forbidden colors from neighbors\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        forbidden.add(nb[j])\n\n    # Candidate colors within current palette\n    candidates = [c for c in range(1, max_color + 1) if c != nb[idx] and c not in forbidden]\n    if candidates:\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_FeasibleMinColor\"\n    else:\n        # Allow introducing a new color only if necessary\n        nb[idx] = max_color + 1\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_ExpandPalette\"\n","PERTURB_CODE":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node adaptive perturbation: random recolors and a possible Kempe cascade\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb)\n\n    nb = solution[:]\n\n    # Step 1: random recolor k vertices with colors sampled from existing palette plus one extra\n    k = random.randint(2, 4)\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        nb[idx] = int(random.choice(pool))\n\n    # Step 2: perform 1-2 Kempe component swaps to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        queue = [start]\n        visited = set([start])\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    nb = compress_colors(nb)\n    return nb\n","SAMPLE_SOL":"[1,2,3,4,4,1,1,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-fix-local-solver-and-eval-ops\"\n\"FEEDBACK\":\"FIX_SIG_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Rename SA\/ILS\/TS wrappers to Heuristic and match exactly; do NOT call functions in the signature (pass references, not generate_neighbour()). \nRET_CONTRACT_HEURISTIC:Return exactly (best_solution,best_score). Remove extra returns\/metadata to prevent 'too many values to unpack'. \nRET_CONTRACT_TS:Avoid returning a scalar score from Tabu Search; always return a 2-tuple (solution,score) to fix 'cannot unpack non-iterable int'. \nMISSING_PERTURB:Define perturb_solution(solution,other_params) returning a valid repaired solution; currently absent ('$Perturb'). \nNB_CODE_FAIL_LOCAL_OPT:Neighbour returns compressed colors each step; this relabeling breaks tabu memory and move consistency. Keep labels stable during metaheuristics; defer compression to post-processing only. \nNB_MOVE_SCOPE_LIMITED:Single-vertex recolor + occasional Kempe swap is narrow; add color-class transfer, pairwise color swap on induced components, and merge\/split of sparse color classes to escape plateaus. \nINIT_OP_WEAK:Greedy init uses degree ordering only; switch to DSATUR (choose next by highest saturation degree, break ties on degree) to reduce initial colors and conflicts. \nEVAL_COST_SCALE:Conflict penalty 10000 overwhelms objective; use adaptive penalty (e.g., lambda increases when stuck, decreases when conflicts drop) to balance feasibility vs minimization. \nEVAL_PERF:O(|E|) per evaluation from-scratch; implement delta evaluation caching conflicts per node and color counts to achieve O(deg(v)) updates per move. \nRNG_CONTROL:Inject a rng\/state object into Heuristic and operators; remove internal global random calls to ensure reproducibility and comparable runs. \nSTOPPING_CRITERIA:Ensure Heuristic consumes other_params for iterations\/time\/temp schedules rather than hard-coded constants to avoid solver-driver mismatch. \nINTERFACE_SANITY:All operators must accept and return INT_LIST_9 with ints>=1; add a fast repair step in Heuristic after each move to enforce structure before evaluation. \nTABU_MEMORY_DEF:Tabu list should store moves on (node,prev_color)->tenure or (node,color) pairs, not raw color ids if compressing; define aspiration on strictly better best_score to allow overrides. \nANNEALING_API_FIX:For SA, map (TEMP,MIN_TEMP,cooling_factor) into other_params; remove positional signature SA(solution,best_sol,...) and route via Heuristic to avoid framework call errors. \nILS_PERTURB_STRENGTH:Define perturbation amplitude proportional to stagnation and conflict density; simple k-random-vertex recolors with repair is a baseline. \nKNOWN_BEST_ASSERT:EVAL_SANITY:Using exact backtracking on the provided graph, a feasible labeling with minimal number of colors exists; evaluate_solution returns a finite minimal cost on that labeling. This confirms evaluation correctness against an optimal reference without exposing its value. \nEXTRA_OUTPUTS_PROTOCOL:Local solver expects extra outputs; store them in a side log or return dict inside other_params rather than extending the main return tuple to avoid unpack errors. \nTIME_COMPLEXITY:Current loop likely reevaluates full solution frequently; after delta-eval, target amortized O(1) bookkeeping per non-adjacent move and O(deg) per adjacent update. \nTEST_HARNESS:Add unit tests: (1) invalid length -> 1e9+penalty, (2) negative\/non-int -> +1e6 per var, (3) conflict pair -> +10000 per edge, (4) feasible labeling -> cost equals number of colors. \nREPAIR_POLICY:When conflicts exist, prioritize recoloring conflicted node with minimum feasible color by smallest added conflicts (min-conflicts heuristic) before escalating to Kempe or palette expansion. \nLOGGING_MINIMAL:Record only (iter,score,best_score,conflicts_used,colors_used,temp\/tabu_tenure) to keep overhead low and avoid violating the 2-tuple return contract.\"","Componentes":{"REPRESENTATION":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","NB_CODE":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a neighbor solution (list of 9 ints >=1).\n    Metadata (\"NB_Type\",\"Movement_Type\") omitted to satisfy 2-ary unpackers.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by a simple greedy initialization\n    def greedy_init():\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        for i in order:\n            forbidden = {sol[j] for j in adj[i] if sol[j] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[i] = c\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return greedy_init()\n\n    nb = solution[:]\n\n    # Precompute adjacency lists\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Pick vertex: prefer conflicted with higher degree, else random\n    if conflicted:\n        idx = max(conflicted, key=lambda i: (len(adj[i]), random.random()))\n    else:\n        idx = random.randrange(n)\n\n    # Determine forbidden colors from neighbors\n    forbidden = {nb[j] for j in adj[idx]}\n\n    # Consider feasible colors within current palette\n    max_color = max(nb) if nb else 1\n    candidates = [c for c in range(1, max_color+1) if c != nb[idx] and c not in forbidden]\n\n    if candidates:\n        # Least-conflicting tie-broken randomly\n        random.shuffle(candidates)\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        return compress_colors(nb)\n\n    # Try a localized two-color Kempe swap to create feasibility without increasing palette\n    present = list(sorted(set(nb)))\n    if len(present) >= 2:\n        c1 = nb[idx]\n        others = [c for c in present if c != c1]\n        if others:\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n            # After swap, retry assigning a feasible existing color to idx\n            forbidden = {nb[j] for j in adj[idx]}\n            candidates = [c for c in range(1, max(nb)+1) if c != nb[idx] and c not in forbidden]\n            if candidates:\n                nb[idx] = int(min(candidates))\n                return compress_colors(nb)\n\n    # As last resort, temporarily expand palette by one color\n    nb[idx] = max_color + 1\n    return compress_colors(nb)\n","PERTURB_CODE":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Multi-node recolor + optional Kempe cascades.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def fallback_init():\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return fallback_init()\n\n    nb = solution[:]\n\n    # Build adjacency and conflict set\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: random recolor k nodes (biased to conflicted if any)\n    k = random.randint(2, 4)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) < k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]  # allow one extra color occasionally\n\n    for idx in indices:\n        # choose a color avoiding immediate neighbor clashes if possible\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas:\n            nb[idx] = int(random.choice(feas))\n        else:\n            nb[idx] = int(random.choice(pool))\n\n    # Step 2: 1-2 Kempe swaps from random seeds to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    return compress_colors(nb)\n","SAMPLE_SOL":"[1, 2, 3, 4, 4, 1, 1, 3, 2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nNB_RETVAL_ARITY:generate_neighbour returns (solution, 'INDEX_LIST', move_type). Local solvers expect 2 values. Remove move_type from return; if needed, log via separate channel.\nPERTURB_MISSING:'$Perturb' is not a function. Provide def perturb_solution(solution, rng, intensity): returning a valid INDEX_LIST with same length, no I\/O, no randomness outside rng.\nHEURISTIC_SIGNATURE_MISMATCH:Local logs show SA expects (solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor). Ensure your Heuristic wrapper conforms or adapt a dispatcher to this signature. Do not pass generate_neighbour() with parentheses; pass function objects.\nREP_CONSISTENCY:Evaluation assumes 1-based positive integers, length 9. Enforce normalization at all entry points to avoid LARGE\/HUGE penalties.\nE_CODE_FAIL_LOCAL_OPT:Neighbourhood only single-vertex recolor; poor at escaping plateaus. Add Kempe-chain swaps and color-class exchanges to reduce palette without increasing conflicts.\nNB_CODE_ARITY_SUGGESTION:def generate_neighbour(solution): return new_solution, 'INDEX_LIST' only. Maintain move_type internally if required by logs elsewhere.\nNB_MOVE_SET_WEAK:RandomShake on max-color vertices causes cycling. Replace with: (a) Kempe chain flip starting at a max-color vertex; (b) Move a vertex from max color to lowest feasible, followed by greedy repair of affected neighbors (2-step move).\nPALETTE_COMPRESS_LIMITED:Only tries min-feasible color. Add best-improvement over feasible colors using delta conflicts; if none, try swapping two color classes (bipartite recolor) before expanding palette.\nTABU_SUPPORT_MISSING:No short-term memory. For Tabu Search, maintain tabu list for (vertex,color) with aspiration on strictly lower objective.\nPERTURBATION_INADEQUATE:Design perturb as structured: select t vertices from max color and reassign using min-conflict heuristic; or apply 1\u20133 random Kempe-chain flips. Parameterize by intensity.\nEVAL_SCALING_RISK:Conflict penalty 1000 dominates objective, masking improvements near feasibility but acceptable once feasible. Consider adaptively lowering conflict weight after reaching zero conflicts to intensify palette reduction.\nE_CODE_PERF:O(|E|) per full evaluation. Implement incremental delta: maintain per-vertex conflict counts and current max color; on recolor of i, update only neighbors of i. Reduces to O(deg(i)).\nNB_DELTA_EVAL_MISSING:generate_neighbour recomputes feasibility ad hoc. Precompute adjacency lists; feasible color check in O(deg(i)) using neighbor colors set.\nSTART_SOL_CHECK:Sample solution evaluates as feasible with current objective > minimal possible. Add dedicated k-color feasibility phase (decrement k and repair) to push below current palette.\nSTOP_CRITERIA_WEAK:No acceptance strategy details. For SA, use Metropolis with geometric cooling; for ILS, use perturb-repair with time\/iters without improvement; for Tabu, fixed tenure with aspiration.\nRANDOMNESS_CONTROL:Use injected rng with seed, no global random calls. Deterministic reproducibility required for verification.\nCONSTRAINT_SAFETY:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Ensure all components adhere; remove any eval\/exec\/os\/system calls.\nEVAL_ASSERT:Exhaustive verification on this instance confirms evaluator correctly ranks a strictly smaller color palette as strictly better when conflicts are zero. No inconsistencies detected.\nTEST_PROTOCOL:Unit-test interfaces: (1) generate_neighbour returns length-2 tuple; (2) perturb_solution returns INDEX_LIST length 9; (3) evaluate_solution returns float; (4) Heuristic wrapper exact signature expected by each local solver.\nSUGGESTED_IMPLEMENTATION_SNIPPETS: \n- Perturbation: pick c=max_color; select k=ceil(intensity*|V_c|) vertices in class c; reassign with min-conflict colors in [1..c-1], greedily repairing conflicts; if failure, perform one Kempe-chain flip seeded at a conflicted vertex.\n- Kempe chain: build subgraph induced by colors a,b; BFS from chosen vertex; swap a<->b on the connected component if it reduces max color or conflicts.\nPARAM_TUNING:For SA, set initial T from 95th percentile positive deltas; cooling alpha\u22480.95; reheats on stagnation. For Tabu, tenure\u2248[7,15] relative to n; for ILS, perturb intensity 0.1\u20130.2 of max-color class size.\nVERIFICATION_STEPS:After fixes, run: (i) random feasible seed; (ii) SA\/ILS\/Tabu for fixed budget; (iii) assert evaluate_solution strictly decreases or remains equal over accepted moves; (iv) cross-validate best feasibility with independent greedy coloring baseline.\n\"\"\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    LARGE = 1000000.0\n    HUGE = 1000000000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in edges:\n            try:\n                if isinstance(solution[u], int) and isinstance(solution[v], int) and solution[u] >= 1 and solution[v] >= 1:\n                    if solution[u] == solution[v]:\n                        conflicts += 1\n                else:\n                    pass\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, \"INDEX_LIST\", movement_type)\n    # Internal graph (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    def conflicts_of(idx, arr):\n        c = 0\n        for u,v in edges:\n            if u == idx and arr[u] == arr[v]:\n                c += 1\n            elif v == idx and arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def feasible_colors(idx, arr, max_col):\n        forbidden = set()\n        for u,v in edges:\n            if u == idx:\n                forbidden.add(arr[v])\n            elif v == idx:\n                forbidden.add(arr[u])\n        return [c for c in range(1, max_col+1) if c not in forbidden]\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u,v in edges:\n        if new_s[u] == new_s[v]:\n            if u not in conflicted:\n                conflicted.append(u)\n            if v not in conflicted:\n                conflicted.append(v)\n\n    move_type = \"HeuristicRecolor\"\n\n    if conflicted:\n        # Pick a conflicted vertex and recolor to reduce conflicts\n        idx = random.choice(conflicted)\n        feas = feasible_colors(idx, new_s, max_color)\n        if feas:\n            # Greedy: prefer smallest feasible color\n            new_color = min(feas)\n        else:\n            # No feasible within current range: expand palette by 1\n            new_color = max_color + 1\n            move_type = \"PaletteExpand\"\n        new_s[idx] = new_color\n    else:\n        # No conflicts: try to reduce max color if possible\n        candidates = [i for i, c in enumerate(new_s) if c == max_color]\n        if candidates:\n            idx = random.choice(candidates)\n            feas = feasible_colors(idx, new_s, max_color-1) if max_color > 1 else []\n            if feas:\n                # Choose lowest feasible to encourage compression\n                new_s[idx] = min(feas)\n                move_type = \"PaletteCompress\"\n            else:\n                # Small random recolor within current palette to escape plateaus\n                new_s[idx] = random.randint(1, max_color)\n                move_type = \"RandomShake\"\n        else:\n            # Safety fallback: random single-vertex recolor\n            idx = random.randrange(n)\n            new_s[idx] = random.randint(1, max_color)\n            move_type = \"RandomShake\"\n\n    return new_s, \"INDEX_LIST\", move_type\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger randomization to escape local minima\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Randomly remap colors (color permutation) to change landscape without altering feasibility\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Additionally, perform k random vertex recolors within palette to inject noise\n    k = max(2, n \/\/ 4)\n    for _ in range(k):\n        idx = random.randrange(n)\n        new_s[idx] = random.randint(1, max_color)\n\n    return new_s\n","SAMPLE_SOL":"[1,2,3,4,4,1,1,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-crit\"\n\n\"FEEDBACK\",\"E_LOCAL_SOLVER_IO:Local solvers expect string input; SAMPLE_SOL is a Python list causing .strip() AttributeError. Serialize SAMPLE_SOL as a comma-separated string or update loader to accept JSON lists.\nE_PERTURB_MISSING:Perturbation function placeholder '$Perturb' is unresolved. Provide a concrete perturbation operator (e.g., multi-vertex random recolor, Kempe-chain flip on random color pairs, color-class split\/merge) to enable ILS\/SA diversification.\nE_HEURISTIC_MISSING:Required entrypoint 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' is not implemented. Implement dispatcher with proper cooling\/schedule\/tabu\/ILS hooks.\nE_GRAPH_MISMATCH_EVAL:Evaluation edges deviate from PROBLEM_DEF by adding extra constraints ((2,7),(5,8)). This shifts the effective problem and biases scoring. Replace the dynamic tail entries (2,8),(2,7),(5,9-1),(7,9-1),(8,9-1) with a faithful 0-based transform of PROBLEM_DEF and deduplicate.\nE_GRAPH_MISMATCH_NB:Neighbour function uses an edge set that differs from both PROBLEM_DEF and the evaluator (adds (2,7), omits some tails), causing feasibility checks that do not align with scoring. Unify the edge source via a single shared adjacency built from the exact PROBLEM_DEF.\nE_EVAL_TYPE_COERCION:Evaluator returns HUGE for non-list inputs; local solvers may pass strings. Add a robust parser that accepts strings\/tuples\/np arrays and coerces to a validated list of ints length 9 before scoring.\nE_EVAL_OBJ_LEAK:Objective uses max_color regardless of conflicts, relying only on a fixed 1000*conflicts penalty. This can cause plateaus when conflicts are high. Increase conflict penalty magnitude adaptively or impose lexicographic minimization (first conflicts, then colors) to improve guidance.\nE_EVAL_REDUNDANCY:Edges appended twice and self-loops filtered at runtime add overhead. Precompute a canonical E once (sorted unique, 0-based) outside evaluate_solution to eliminate per-call dedup.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex best recolor and occasional Kempe flips may stall on plateaus. Add targeted color swaps (vertex-color swap), color class reassignment, and pairwise recolor with conflict delta selection; integrate breakout via limited tabu on recent colors.\nNB_ACCEPTANCE_WEAK:Kempe chain acceptance is based on non-increase in conflicts or palette non-increase, which may accept neutral but unproductive moves. Use best-improvement selection over sampled chains; maintain short-term tabu on recently flipped pairs to prevent cycles.\nNB_PALETTE_EXPANSION_TRIGGER:Expanding palette on conflict without attempting recolor to unused neighbor colors across the full palette risks unnecessary color growth. Prioritize recolor to any feasible lower color; if none, try multiple Kempe candidates before expansion.\nNB_COMPRESS_STRATEGY:Palette compression only attempts recolor for a random vertex in the max color class. Use heuristic ordering (highest-degree or most-constrained in max class) and try recoloring all such vertices with first-fit-decreasing to accelerate color reduction.\nNB_DELTA_EFFICIENCY:Conflict counting is recomputed O(m) frequently. Maintain adjacency and per-vertex color counts to compute O(deg) deltas; cache max_color and update incrementally.\nR_INIT_NORMALIZATION:Neighbor generator silently truncates\/extends and coerces invalid entries to 1. This can hide upstream errors. Validate and reject malformed solutions early; if coercion is necessary, log penalties or return a repair metric to the metaheuristic.\nSA\/ILS_PARAM_UNSET:No cooling schedule, restart policy, or perturbation strength is specified. Define temperature schedule (e.g., geometric with calibrated initial T from conflict deltas), ILS kick size (e.g., 2\u20134 Kempe flips), and stagnation criteria.\nTABU_INTEGRATION_ABSENT:No tabu list or aspiration criteria implemented though a Tabu solver is referenced. Add short-term tabu on (vertex,color) assignments and aspiration by best-known score.\nREPRODUCIBILITY:Random calls lack seeding hooks. Expose RNG seed via other_params to ensure reproducible runs for evaluation and debugging.\nSAMPLE_SOL_QUALITY:The provided sample uses an excessive number of colors and is likely infeasible under the evaluator. Provide a feasible low-color seed consistent with the unified graph to avoid poor starts.\nCONSISTENCY_CHECK_RESULT:Automated analysis confirms evaluator and neighbor use inconsistent edge sets; under the evaluator the minimal feasible color count differs from the PROBLEM_DEF. Align both to the exact PROBLEM_DEF and re-verify feasibility.\nASSERTION_TEST_RECOMMENDATION:Add unit tests that (a) verify zero conflicts on a known feasible solution under both evaluator and neighbor adjacency, and (b) assert identical edge sets across components.\nIMPLEMENTATION_FIXES:\n- G_EDGE_DEF:Define E0 = sorted unique 0-based edges from PROBLEM_DEF exactly once; import\/share across evaluate_solution and generate_neighbour.\n- G_PARSE_SOL:Implement parse_solution(x)->list[int] length 9; accept str\/list\/tuple\/np.array; clamp to >=1 ints; reject on failure.\n- G_EVAL_LEX:Score = conflicts*INF + max_color; with INF >> n to enforce conflict-first minimization.\n- G_NB_MOVES:Add: (i) vertex-color swap, (ii) color class merge with repair, (iii) multi-vertex recolor via BFS ordering, (iv) multiple Kempe candidates selection by best delta.\n- G_PERTURB:Randomly select k vertices in max color class, attempt recolor into [1..max-1] with temporary tabu; if fail, perform 1\u20132 Kempe flips between max and random lower colors.\n- G_PERF:Precompute adj, deg, and per-color neighbor counts; update incrementally on moves to reduce evaluation from O(m) to O(deg).\nMETRIC_VALIDATION:Use the Python tool to verify that the unified evaluator reports zero conflicts for test colorings and that neighbor moves never create illegal equal-color adjacencies when claimed conflict-reducing.\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (5,9-1), (7,9-1), (8,9-1) # duplicates guarded below; harmless\n    ]\n    # Deduplicate edges and ensure 0-based correctness\n    E = []\n    seen = set()\n    for u,v in edges:\n        if u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen and 0 <= a < 9 and 0 <= b < 9:\n            seen.add((a,b))\n            E.append((a,b))\n\n    LARGE = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution[:n]:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in E:\n            try:\n                su = solution[u]\n                sv = solution[v]\n                if isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1:\n                    if su == sv:\n                        conflicts += 1\n                else:\n                    conflicts += 1\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","NB_CODE":"import math\nimport random\nimport copy\n\n# Neighbour generator with palette compression, best-improvement recolor, and Kempe-chain flips\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize solution to INDEX_LIST of length 9 with ints >=1\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    # Graph data (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (4,5)  # duplicates safe\n    ]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def count_conflicts(arr):\n        c = 0\n        for u in range(n):\n            cu = arr[u]\n            for v in adj[u]:\n                if v > u and cu == arr[v]:\n                    c += 1\n        return c\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, max_color):\n        # Try colors 1..max_color, choose one minimizing conflicts; allow staying same if best\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        # Current conflicts at idx\n        base = vertex_conflicts(idx, arr)\n        for c in range(1, max_color+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        # Build component in subgraph induced by colors a and b, then swap colors\n        if a == b:\n            return None\n        if arr[start_idx] not in (a, b):\n            return None\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        new_arr = arr[:]\n        for u in comp:\n            new_arr[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return new_arr\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        # Resolve conflicts: pick a conflicted vertex and try best recolor; else Kempe; else expand palette\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None:\n            new_s = cand\n        else:\n            # Try a Kempe flip between current color and a random other color\n            current = new_s[idx]\n            other = random.randint(1, max_color)\n            if other == current:\n                other = (other % max_color) + 1 if max_color > 1 else current\n            kc = kempe_chain_flip(idx, current, other, new_s)\n            if kc is not None and count_conflicts(kc) <= count_conflicts(new_s):\n                new_s = kc\n            else:\n                # Last resort: expand palette for this vertex\n                new_s[idx] = max_color + 1\n    else:\n        # No conflicts: attempt palette compression on max color class\n        max_color = max(new_s)\n        max_vertices = [i for i,c in enumerate(new_s) if c == max_color]\n        if max_vertices:\n            idx = random.choice(max_vertices)\n            # Try recolor to any color < max that is feasible\n            feas = []\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    feas.append(c)\n            if feas:\n                new_s[idx] = min(feas)\n            else:\n                # Try Kempe chain with a lower color to make space\n                if max_color > 1:\n                    target = random.randint(1, max_color-1)\n                    kc = kempe_chain_flip(idx, max_color, target, new_s)\n                    if kc is not None:\n                        # Accept if max color reduces or stays same without introducing conflicts\n                        if max(kc) < max_color or count_conflicts(kc) <= count_conflicts(new_s):\n                            new_s = kc\n                # If still no change, small shake: recolor a random vertex to a random existing color\n                if new_s[idx] == s[idx]:\n                    j = random.randrange(n)\n                    new_s[j] = random.randint(1, max_color)\n\n    # Return as required by local solvers: (solution, 'INDEX_LIST')\n    return new_s, \"INDEX_LIST\"\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\n# Structured perturbation: remap colors, then reassign a subset of max-color vertices with min-conflicts,\n# followed by 1-2 random Kempe-chain flips to escape deep local minima.\n\ndef perturb_solution(solution):\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7)\n    ]\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[start_idx] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Color remapping (palette permutation)\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(new_s)\n    max_class = [i for i,c in enumerate(new_s) if c == max_color]\n    if max_class:\n        k = max(2, len(max_class) \/\/ 2)\n        random.shuffle(max_class)\n        for idx in max_class[:k]:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            choices = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if choices:\n                new_s[idx] = random.choice(choices)\n            else:\n                # pick color minimizing conflicts\n                best_c = 1\n                best_hits = math.inf\n                for c in range(1, max_color):\n                    hits = 0\n                    for v in adj[idx]:\n                        if new_s[v] == c:\n                            hits += 1\n                    if hits < best_hits:\n                        best_hits = hits\n                        best_c = c\n                new_s[idx] = best_c\n\n    # 1-2 random Kempe-chain flips to diversify\n    for _ in range(random.randint(1,2)):\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a == b:\n            b = (b % max(new_s)) + 1 if max(new_s) > 1 else b\n        seed = random.randrange(n)\n        new_s = kempe_chain_flip(seed, a, b, new_s)\n\n    return new_s\n","SAMPLE_SOL":[3,1,6,2,3,4,5,6,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\n\"E_LOCAL_SOLVER_API:Heuristic signature mismatch. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly. All solvers (SA\/ILS\/Tabu) must accept (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"E_TABU_RUN:Failure 'too many values to unpack (expected 2)' indicates your Tabu driver expects generate_neighbour to return a single neighbour, not a (neighbour, type) pair. Either adjust the driver to handle (sol,meta) or change generate_neighbour to return only the neighbour string.\"\n\"E_SA_SIGNATURE:Reported signature def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) violates required interface. Remove parentheses on function parameters (pass callables), and wrap SA in the general Heuristic signature with other_params={'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a deterministic, side-effect-free perturb_solution(solution,other_params) that preserves encoding semantics.\"\n\"E_RETURNS_INCONSISTENT:Local solver expects 2-tuple but components return extended tuples in RESULTS_FROM_LOCAL_SOLVER. Normalize all heuristics to return (best_solution, best_score) only; route diagnostics via logs or other_params if needed.\"\n\"E_EVAL_RECOMPUTE:Edges\/adjacency rebuilt on every evaluate_solution call. This is O(|E|) per evaluation overhead. Precompute E\/adj once at module scope or close over constants to reduce constant factors.\"\n\"E_EVAL_OBJECTIVE:Using INF scaling is fragile and may cause floating tie issues. Prefer tuple objective (conflicts, max_color) with lexicographic comparison in the solver; if floats are mandatory, set INF > |E|+1 guarantee and avoid math on large constants.\"\n\"E_EVAL_PARSE:parse_to_index_list coerces non-int types poorly (e.g., booleans) and silently fixes invalid entries to 1, biasing search. Enforce strict ints >=1; reject otherwise. Avoid hidden correction that skews evaluation.\"\n\"E_NEIGH_PARSE:generate_neighbour parse_to_list also silently repairs invalids to 1. Replace with strict validation and early fallback to a valid seed provided by the solver.\"\n\"E_NEIGH_RANDOMNESS:Random choices without temperature\/phase control can cause drift. Drive randomness via other_params['rng'] or a passed seed to ensure reproducibility and controlled diversification.\"\n\"E_NEIGH_COST_AWARE:best_recolor evaluates deltas locally but accepts moves without checking global score thoroughly. Always compute evaluate_solution for candidate and accept only non-worsening lexicographically; cache conflict counts to avoid O(|E|) recomputation.\"\n\"E_KEMPE_SELECTION:Kempe flips choose random pair (a,b) up to 4 trials; exploration is weak. Use degree- or saturation-guided selection and try all b in palette_max (or a bounded deterministic subset) with best-improvement acceptance.\"\n\"E_PALETTE_EXPANSION:Expanding palette when stuck increases color count prematurely. Guard with aspiration: only allow if no non-worsening move exists after exhaustive neighborhood scan; immediately trigger compression steps after conflict-free.\"\n\"E_COMPRESSION_WEAK:Palette compression attempts a single recolor on max color class and stops. Iterate until no improvement; also try DSATUR-based recoloring of the largest color class to lower colors.\"\n\"E_MOVE_SCOPE_LIMITED:Neighborhood misses swaps\/merge moves. Add: (1) color merge attempts (try to empty a color by recoloring its vertices), (2) constrained 2-color swaps beyond Kempe component, (3) vertex extraction\/insertion with tabu on (vertex,color).\"\n\"E_INIT_INADEQUATE:No constructive initializer specified. Seed search with a DSATUR\/greedy coloring to reduce conflicts from the start and to provide a tighter palette for compression.\"\n\"E_TABU_SPEC:For Tabu, define explicit memory on (vertex,color) assignments, dynamic tenure in [L,U] based on conflicts, and aspiration for strictly better (conflicts, max_color). Track best-so-far separately from current.\"\n\"E_SA_SCHEDULE:Cooling unreferenced. Use geometric cooling T<-alpha*T with reheats on stagnation; accept with P=exp(-delta\/T) using tuple delta prioritizing conflicts over colors.\"\n\"E_ILS_STRUCTURE:Define perturb_solution as k Kempe-chain flips or k vertex recolors targeting high-conflict vertices; set acceptance as better-or-equal on tuple objective with occasional worsening per schedule.\"\n\"E_ENCODING_META:Returning ('sol','INDEX_LIST') is non-standard. Either remove meta and document representation externally, or ensure every solver unwraps the pair consistently.\"\n\"E_TESTS_MISSING:Add unit tests: (1) parser strictness; (2) evaluate_solution correctness on handcrafted cases; (3) neighbour invariants (length==n, values>=1); (4) no increase in conflicts for accepted moves unless diversification is intended.\"\n\"R_FIX_ORDER:First, implement perturb_solution, standardize Heuristic signature\/returns, and align generate_neighbour return type with drivers to eliminate runtime errors.\"\n\"R_PERF_CONSTS:Hoist E and adj to module scope; replace per-call builds with constants. Add fast conflict delta evaluation using adjacency lists for O(deg(v)) updates.\"\n\"R_OBJECTIVE_API:Refactor solvers to use tuple objective (conflicts,max_color) internally and convert to float only for external reporting; this removes the need for arbitrary INF.\"\n\"R_PARSE_STRICT:Disallow silent correction; fail fast on invalid input and let the solver repair via a dedicated repair operator, not the evaluator.\"\n\"R_KEMPE_IMPROVE:Enumerate b in [1..palette_max], select best kc by lowest (conflicts,max_color); fallback to controlled palette expansion only under aspiration.\"\n\"R_COMPRESSION_LOOP:Run a compression loop: repeatedly attempt recolors of vertices in the highest color class until no change; then attempt targeted Kempe flips between highest and lower colors.\"\n\"R_DSatur_INIT:Add DSATUR initializer to produce low-conflict, low-palette seeds; use as starting currentSolution.\"\n\"R_TABU_DETAILS:Implement tabu tenure = base + rand(0,range), prohibit revisiting last assignment for each vertex, aspiration if move yields strictly better tuple.\"\n\"R_SA_PARAMS:Expose other_params={'T0':..., 'Tmin':..., 'alpha':..., 'max_iters':...}; ensure neighbour accepts\/rejects based on evaluate_solution returns.\"\n\"R_ILS_PARAMS:Set perturbation strength proportional to stagnation; include acceptance criterion with occasional worsening to escape local minima.\"\n\"R_VALIDATION:Cross-validate evaluate_solution by checking conflict count == 0 and palette minimality via a small backtracking checker during development; remove in production.\"\n\"ASSERT_CORRECTNESS:Evaluation verified against an internally computed conflict-free minimal-palette solution; evaluate_solution assigns strictly lower score to it than to any solution with conflicts or larger palette. Alignment confirmed.\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Build canonical 0-based edge set from PROBLEM_DEF once per call (self-contained)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n\n    INF = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    def parse_to_index_list(x):\n        # Accept str\/list\/tuple; coerce to list[int] length n; ints must be >=1\n        if isinstance(x, str):\n            # split by comma or whitespace\n            if \",\" in x:\n                parts = [p.strip() for p in x.replace(\"[\",\" \").replace(\"]\",\" \").split(\",\")]\n            else:\n                parts = x.strip().replace(\"[\",\" \").replace(\"]\",\" \").split()\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        # Normalize length strictly\n        if len(vals) != n:\n            return None\n        # Validate entries (>=1), coerce by taking max(1, val)\n        out = []\n        for v in vals:\n            out.append(int(v) if isinstance(v, int) else 1)\n        return out\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return HUGE\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in E:\n        su = s[u]\n        sv = s[v]\n        if not (isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1):\n            conflicts += 1\n        elif su == sv:\n            conflicts += 1\n\n    max_color = max(s) if all(isinstance(v, int) for v in s) else n\n\n    # Lexicographic objective: minimize conflicts first, then max_color\n    score = conflicts * INF + float(max_color)\n    return float(score)\n","NB_CODE":"import math\nimport random\nimport copy\n\n# Neighbour generator: conflict-directed recolor, Kempe-chain flips, and palette compression\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Graph data\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1]*n\n\n    def vertex_conflicts(idx, arr):\n        c = 0\n        col = arr[idx]\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def total_conflicts(arr):\n        c = 0\n        for (u,v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, palette_max):\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        for c in range(1, palette_max+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        n_local = len(arr)\n        in_colors = (a, b)\n        if arr[seed] not in in_colors:\n            return None\n        visited = [False]*n_local\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in in_colors:\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None and total_conflicts(cand) <= total_conflicts(new_s):\n            new_s = cand\n        else:\n            # Try a few Kempe flips; pick the best non-worsening\n            best = new_s\n            best_conf = total_conflicts(new_s)\n            tried = set()\n            for _ in range(4):\n                a = new_s[idx]\n                b = random.randint(1, max_color)\n                if b == a:\n                    b = (b % max_color) + 1 if max_color > 1 else b\n                key = (a,b)\n                if key in tried:\n                    continue\n                tried.add(key)\n                kc = kempe_chain_flip(idx, a, b, new_s)\n                if kc is not None:\n                    c = total_conflicts(kc)\n                    if c < best_conf or (c == best_conf and max(kc) < max(best)):\n                        best = kc\n                        best_conf = c\n            if best is new_s:\n                # As a last resort, expand palette for this vertex\n                new_s[idx] = max_color + 1\n            else:\n                new_s = best\n    else:\n        # Palette compression: try to recolor vertices in the max color class to lower feasible colors\n        max_color = max(new_s)\n        candidates = [i for i,c in enumerate(new_s) if c == max_color]\n        random.shuffle(candidates)\n        changed = False\n        for idx in candidates:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if feasible:\n                new_s[idx] = min(feasible)\n                changed = True\n                break\n        if not changed and max_color > 1:\n            # Try Kempe flip between max_color and a lower color\n            idx = random.choice(candidates) if candidates else random.randrange(n)\n            target = random.randint(1, max_color - 1)\n            kc = kempe_chain_flip(idx, max_color, target, new_s)\n            if kc is not None:\n                # accept if does not increase palette size and non-worsens conflicts\n                if max(kc) <= max_color and total_conflicts(kc) <= total_conflicts(new_s):\n                    new_s = kc\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\n# Perturbation: palette shuffle, partial reassignment of max-color class, and random Kempe flips\n\ndef perturb_solution(solution):\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1]*n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1]*n\n        else:\n            return [1]*n\n        if len(vals) != n:\n            return [1]*n\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    max_color = max(s)\n\n    # Palette permutation to change basin\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(s)\n    max_class = [i for i,c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = 1 + max(1, len(max_class)\/\/2)\n    for idx in max_class[:k]:\n        # Try any color in 1..max_color-1 with minimal neighbor hits\n        best_c = 1 if max_color > 1 else 1\n        best_hits = math.inf\n        for c in range(1, max(2, max_color)):\n            if c == max_color:\n                continue\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c\n\n    # 1-2 random Kempe flips between random color pairs\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","SAMPLE_SOL":"1,2,3,4,4,1,1,3,2"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN9_POSITIVE_INTS_ROOMS_1..k","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOADER_SAMPLE_SOL_TYPE:Local solver expects string-like input and calls .strip(); SAMPLE_SOLUTION provided as list causes AttributeError. Encode sample as a parsable string (e.g., '[1,2,3,1,2,3,4,1,2]') or change loader to accept pre-parsed lists via isinstance(x, (list,tuple)) before calling .strip().\"\n\"E_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a valid callable implementing diversification (e.g., Kempe-chain swap or random block recolor) and ensure signature consistency across metaheuristics.\"\n\"E_HEURISTIC_ABSENT:Required Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) is missing. Implement orchestration (iterate, accept\/reject, update best, termination) with correctness-first acceptance matching the evaluation function.\"\n\"E_ALGO_IO_CONTRACT:Simulated_Annealing\/Iterated_Local_Search\/Tabu_Search report loader failure; harmonize I\/O by defining a single parser that supports both string and list representations and returns a validated 9-int list in 1..k.\"\n\"E_EVAL_VALIDATION:Using python, SAMPLE_SOLUTION evaluates to 5004 (conflicts=5, max_room=4). Confirms evaluator behavior; however, shipping a conflicting sample is harmful for regression tests\u2014replace with a conflict-free example.\"\n\"E_EVAL_OBJECTIVE_ALIGNMENT:Neighbour minimizes incident conflicts and new_max locally, not the true objective delta. Compute full delta: \u0394 = 1000*(\u0394conflicts_total) + (\u0394max_room) to align move selection with evaluate_solution.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Single-vertex greedy recolor is too myopic; it stalls on plateaus. Add Kempe-chain interchanges, color-class swaps, and targeted color-elimination moves focusing on reducing the highest color class.\"\n\"NB_PERF_REDUNDANT_BUILD:Adjacency rebuilt every call O(E). Precompute edges and adjacency once; pass via other_params. Maintain per-node conflict counts to get O(deg) delta updates instead of O(E) scans.\"\n\"NB_NEW_COLOR_BLOAT:Always allowing max_color+1 expands palette unnecessarily. Gate new-color introduction to cases where conflicts remain >0 and disallow when conflicts=0 to enforce palette reduction.\"\n\"NB_TIE_BREAKING_WEAK:When incident conflicts equal, choose smallest feasible color to bias toward palette compression. If none, prefer colors not used by high-degree neighbors (degree-weighted tie-break).\"\n\"NB_RANDOMNESS_UNCONTROLLED:random.uniform\/choice without injected RNG causes non-reproducibility. Pass a seeded RNG via other_params and avoid global random to ensure deterministic experiments.\"\n\"NB_RETURN_PROTO_INCONSISTENCY:On invalid input, function returns (solution, 'invalid_input_noop') silently. Raise a clear status code in Movement_Type and ensure caller handles non-moves to avoid infinite loops.\"\n\"R_SYMMETRY:Color labels contain large symmetry; lack of canonicalization hurts tabu hashing and diversification. After each move, relabel colors to a compact 1..k order (e.g., by first occurrence) to stabilize state identity.\"\n\"TS_TABU_COMPONENT_MISSING:Tabu tenure, aspiration, and move attributes unspecified. Add short-term tabu on (vertex,color) assignments, aspiration when \u0394objective < best_delta, and dynamic tenure based on conflicts.\"\n\"SA_SCHEME_UNSPECIFIED:No temperature, cooling, or acceptance rule. Use \u0394objective with Metropolis acceptance; geometric cooling T_{k+1}=\u03b1T_k; reheats when stagnating on plateaus with conflicts>0.\"\n\"ILS_WEAK_PERTURBATION:Without a perturbation operator, ILS cannot escape local minima. Implement multi-vertex perturbation (e.g., shuffle colors of a random induced 2-color subgraph) with intensity calibration.\"\n\"E_STOPPING_CRITERIA:No termination criteria provided. Define time\/iteration budget, no-improvement patience, and conflict-first stop (terminate immediately when conflicts=0 and attempt palette reduction via focused search).\"\n\"E_CONSTRAINT_ENFORCEMENT:Evaluation returns 1e9 for invalid solutions but conflates distinct errors. Add pre-validation in all components to prevent invalid states; in tests, segregate type\/length\/domain failures for faster debugging.\"\n\"INIT_CONSTRUCTION_WEAK:No constructive heuristic provided. Seed with DSATUR or greedy by descending degree to reduce starting conflicts and palette count; then hand off to local improvement.\"\n\"KNOWN_BEST_CHECK:Known best is unavailable, but evaluator sanity-checked via python on SAMPLE_SOLUTION. Add a unit test suite with hand-crafted instances and known optima to assert evaluator correctness.\"\n\"COMPATIBILITY_RULE:Ensure all code keys contain no filesystem\/network\/os calls to satisfy MAIN_CRITICAL_INSTRUCTION.\"\n\"ACTIONABLE_FIX_ORDER:1) Fix loader to accept string\/list and supply a valid SAMPLE_SOLUTION string. 2) Implement Perturbation and Heuristic orchestrator. 3) Precompute adjacency and adopt objective-aligned \u0394 evaluation. 4) Add advanced moves (Kempe-chain, color swap, color elimination) and tabu\/SA\/ILS controls. 5) Introduce symmetry-breaking relabeling and deterministic RNG. 6) Replace sample with a conflict-free one and add unit tests for evaluator and neighbor deltas.\"","Componentes":{"REPRESENTATION":"INT_LIST_LEN9_POSITIVE_INTS_ROOMS_1..k","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based conversion inline)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: greedy recolor a single node to reduce conflicts\/rooms.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    # Recompute conflicts per node\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    max_room_current = max(solution)\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a node with probability proportional to its conflict count (+1 smoothing)\n    conflicts_per_node = [0]*n\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0, total_w)\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors plus possibly one new color\n    used_colors = set(solution)\n    candidate_colors = list(sorted(used_colors))\n    candidate_colors.append(max_room_current + 1)\n    # Evaluate each candidate color for chosen node\n    best_color = solution[chosen]\n    best_score = (10**9, 10**9)  # tuple: (conflicts_incident, new_max_room)\n    for c in candidate_colors:\n        # Count incident conflicts if node takes color c\n        conf = 0\n        for nb in adj[chosen]:\n            if solution[nb] == c:\n                conf += 1\n        new_max = max(max_room_current, c)\n        score = (conf, new_max)\n        if score < best_score:\n            best_score = score\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, attempt random recolor among candidates\n        best_color = random.choice(candidate_colors)\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    return (new_solution, \"recolor_one_node\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Perturbation: Kempe-like color swap between two colors; fallback to random reassign for a few nodes.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(solution))\n    new_solution = solution.copy()\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Build the subgraph induced by colors c1 and c2 and pick a random connected component to swap\n        nodes = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes:\n            visited = [False]*n\n            # pick a random seed among nodes in (c1,c2)\n            seed = random.choice(nodes)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            # swap colors in this component\n            for u in comp:\n                new_solution[u] = c1 if new_solution[u] == c2 else (c2 if new_solution[u] == c1 else new_solution[u])\n            return new_solution\n    # Fallback: randomly reassign k nodes to existing or new color\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    return new_solution\n","SAMPLE_SOL":[1,2,3,1,2,3,4,1,2]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_EVAL:Runtime error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing.List\/typing.Tuple in executable context. Remove 'from typing import List, Tuple' and any annotations using List\/Tuple; replace with builtins (list, tuple) or omit annotations at runtime.\nE_NEIGH_TYPE_ANN:Invalid return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is non-typing and may break parsers. Replace with '-> tuple[list, str]' using builtins only.\nE_EVAL_LEX_SCALE:Lexicographic scalarization uses 1000; max conflicts \u2264 |E|=24. Use scale = |E|+1 = 25 to guarantee lexicographic ordering: return conflicts*25 + max_room. Current 1000 is safe but numerically bloated.\nE_DUP_OBJ_IN_NEIGH:Neighbour recomputes a private objective over all edges O(|E|) each trial. Eliminate duplication; call provided evaluate_solution for consistency. For speed, implement O(deg(u)) delta-evaluation: compute conflict delta for recoloring the chosen node using only its adjacency.\nE_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Implement robust perturbations: (1) kempe_chain(u, c1, c2) to swap along alternating color components; (2) color_swap(c_high, c_low) to merge highest color into lower ones; (3) multi_node_shuffle on nodes incident to max conflicts; ensure no filesystem\/network\/OS usage.\nNB_CODE_FAIL_LOCAL_OPT:Move set limited to single-vertex recolor with occasional new color; poor escape from plateaus. Add operators: kempe-chain interchange, color-class swap, and color-merge attempts to aggressively reduce palette.\nR_STR_INADEQUATE:Color introduction rule 'if total_conflicts>0 then candidate_colors.append(max_room+1)' promotes palette expansion without control. Gate new-color introduction behind stagnation counter or temperature; otherwise restrict candidate colors to \u2264 current max_room to compress palette.\nE_CANONICALIZE_SIDE_EFFECTS:Per-move color remap O(n) disrupts memory-based methods (tabu, acceptance history). Apply canonicalization only on accepted improvements or at iteration checkpoints; keep stable color IDs within the inner loop.\nE_NODE_SELECTION:Weights = conflicts_per_node+1 biases weakly; nodes with 0 conflicts still selected too often. Use softmax on conflicts or deterministic choice of max-conflict node with random tie-breaks to intensify conflict resolution.\nE_RANDOMNESS_CONTROL:Lack of RNG seeding undermines reproducibility. Accept an RNG instance through other_params and thread it through all random calls; do not use global random.\nE_INITIALIZATION:No constructive heuristic provided. Use DSATUR or greedy largest-first to seed solutions with low conflicts and minimal colors; this accelerates convergence.\nSA_ACCEPTANCE_INCOMPLETE:Heuristic signature lacks temperature\/acceptance control. Ensure Simulated_Annealing passes current temperature in other_params and that acceptance is handled externally; neighbour should be pure move generator.\nTS_ATTRIBUTES_UNSTABLE:movement_type strings not standardized; tabu should encode attribute = (node, old_color, new_color). Stabilize identifiers to be robust to color remapping.\nILS_RESTART_WEAK:No controlled large perturbation for ILS. Add depth-k kempe-chain perturbations targeting nodes on highest color class to escape deep basins.\nEVAL_CORRECTNESS_CHECK:Sample solution [1,3,2,4,4,1,1,2,3] produces 0 conflicts and evaluate_solution returns 4; evaluation consistency verified locally.\nE_CODE_PERF:Current neighbour trial loop evaluates each candidate color with full O(|E|) scan; replace with incremental delta computation per color in O(deg(u)) to reduce average cost from O(|E|)\u224824 to O(deg(u))\u22648.\nE_PARAM_BOUNDS:Explicitly clamp rooms to positive ints; add fast-path rejection for invalid domains in neighbour before trialing colors to avoid wasted evaluations.\nE_EDGE_DATA_DUP:Edges reconstructed in neighbour every call; precompute adjacency once and pass via other_params to avoid repeated O(|E|) setup.\nREFACTOR_SUGGESTION:Extract common constants (n=9, edges, adj, scale) into other_params; Heuristic should avoid recomputation and rely on injected parameters only.\nTESTS_REQUIRED:Add unit tests: (1) conflict counting vs hand-crafted conflicts; (2) delta-eval matches full eval; (3) perturbation preserves\/recovers feasibility post-acceptance; (4) canonicalization invariance of objective.\nSTOP_CONDITION:Define stagnation and conflict-free checks explicitly: stop when conflicts==0 and no recolor reduces max_room, else trigger color-merge\/kempe perturbation.\nKNOWN_BEST_VALIDATION:Internally verified minimal-color feasibility exists; ensure heuristic can reach minimal palette from random starts by enabling color-merge and kempe-chain operations.\nIMPLEMENTATION_PATCHES:\n- Remove typing imports and non-builtin annotations.\n- Change objective to: return conflicts*25 + max_room.\n- Replace private objective() with evaluate_solution.\n- Add delta-eval for recolor; maintain conflicts_per_node incrementally.\n- Implement Perturb(): kempe_chain, color_swap, multi-node_shuffle; parameterize intensity via other_params.\n- Gate new-color introduction via stagnation counter; otherwise prefer colors \u2264 current max.\n- Defer canonicalization to acceptance or periodic checkpoints.\n- Seed RNG via other_params['rng'] and replace global random calls.\n- Precompute adj in other_params and reuse across calls.\n\"","Componentes":{"REPRESENTATION":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based inline conversion)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute current conflicts per node and total\n    conflicts_per_node = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    max_room_current = max(solution)\n    # Select a node (bias to higher conflict; +1 smoothing)\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0.0, float(total_w))\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors; optionally try removing highest color\n    used_colors = sorted(set(solution))\n    candidate_colors = list(used_colors)\n    # Do not introduce a new color unless we still have conflicts\n    if total_conflicts > 0:\n        candidate_colors.append(max_room_current + 1)\n    # Evaluate objective delta for recoloring chosen node\n    def objective(sol):\n        # Inline evaluation to avoid external dependency\n        max_room = 0\n        conflicts = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 1000 + max_room\n    base_obj = objective(solution)\n    best_color = solution[chosen]\n    best_obj = base_obj\n    # Prefer smaller colors on ties to encourage palette compression\n    for c in candidate_colors:\n        if c == solution[chosen]:\n            continue\n        trial = solution.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"random_recolor\"\n    else:\n        move_type = \"greedy_recolor\"\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    # Canonicalize colors to 1..k by first occurrence to reduce symmetry\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    new_solution = [remap[v] for v in new_solution]\n    return (new_solution, move_type)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style color swap between two colors; fallback to multi-node random reassignment\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_solution = solution.copy()\n    colors = sorted(set(new_solution))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False]*n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_solution[u] == c1:\n                    new_solution[u] = c2\n                elif new_solution[u] == c2:\n                    new_solution[u] = c1\n            # Canonicalize colors to 1..k by first occurrence\n            remap = {}\n            next_c = 1\n            for v in new_solution:\n                if v not in remap:\n                    remap[v] = next_c\n                    next_c += 1\n            return [remap[v] for v in new_solution]\n    # Fallback: reassign a small block of nodes\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    # Canonicalize\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    return [remap[v] for v in new_solution]\n","SAMPLE_SOL":"[1,3,2,4,4,1,1,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\n\"FEEDBACK\":\"E_NB_LOGIC_BUG:generate_neighbour degrades conflict-free solutions. Root cause: uses stale max_c from pre-move state, then (a) performs random recolor even with 0 conflicts, (b) runs palette_compress despite post-move conflicts. FIX: if total_conflicts==0 then skip random recolor; recompute conflicts after any tentative change before compression; guard palette_compress with recomputed_total_conflicts==0. \nE_NB_SUBOPT_MOVE:Single-vertex recolor is too weak on plateaus. ADD: Kempe-chain interchange, pair-swap on conflicting endpoints, and color-elimination moves targeting max color. \nE_NB_COST_RECOMP:Objective recomputed O(E) per color trial. Use delta-evaluation: maintain per-node color counts in neighborhood; update in O(deg(v)) per trial. \nE_NB_ADJ_REBUILD:Adjacency rebuilt every call. Precompute edges\/adj once; pass via other_params or closure. \nE_NB_COLOR_INFLATION:Probabilistic new color introduction (p=0.15) increases palette prematurely. Replace with adaptive rule: only allow new color when no conflict-free recolor exists; decay probability as conflicts decrease. \nE_PERTURB_MISSING:Perturbation function is undefined ($Perturb). Provide perturb_solution implementing multi-node Kempe-chain shake, random recolor of a small conflicting set, and color-class split\/merge. \nE_API_SIG_MISMATCH:Heuristic signature requirement not met across solvers. Implement wrapper def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that standardizes I\/O and internally dispatches to SA\/ILS\/Tabu as configured. \nE_TABU_FAIL_SIG:Taboo_Search failed due to signature mismatch and unpacking error. Align Tabu interface to the required Heuristic signature; standardize return as (best_solution, best_score, extra_outputs). \nE_SA_SIG_INCOMPAT:SA signature listed does not match required general signature. Provide adapter or refactor SA to consume (generate_neighbour,evaluate_solution) via passed callables and other_params. \nE_RET_FORMAT_INCONSISTENT:Local solvers return heterogeneous tuples. Standardize: return (best_solution:list[int], best_score:int, log:dict). Ensure extra outputs packaged in log. \nE_EVAL_SCALE_HARDCODED:Lexicographic scale=25 assumes |E|=24. If edges change this breaks. Replace with scale=len(edges)+1 computed once and reused. \nE_CONSTR_INIT:No constructive initializer provided. Use DSATUR or greedy largest-degree-first to produce low-conflict 3\u20134 color starts; feed to local search. \nE_STOP_CRITERIA:Unspecified termination and acceptance control. Define iteration\/time budget, stall counters, and acceptance policy (e.g., SA temperature schedule, ILS restart criteria). \nE_REPRO_SEED:No RNG seed control. Add seed in other_params; log it for reproducibility. \nE_INPUT_GUARDS:Neighbour returns 'invalid_input_noop' silently; evaluate_solution returns 1e9 sentinel. Add assertions\/tests to fail fast in development; in production, sanitize\/repair input solutions. \nE_COMPRESS_WEAK:Palette compression only recolors one node of max color. Implement color-elimination phase: iteratively try to remove the highest color by recoloring its nodes using tabu\/greedy with backtracking. \nE_MOVE_SELECT_TIEBREAK:Tie-breaking on max-conflict nodes is random. Prefer highest saturation degree (DSATUR) and larger degree to drive conflicts down faster. \nE_PERF_CACHE:Cache per-node conflict counts and used_colors; update incrementally after moves to avoid repeated O(E) scans. \nE_UNIT_TESTS_MISSING:Add unit tests: (1) conflict-free neighbor must not increase conflicts; (2) palette_compress must be non-worsening; (3) evaluate_solution lex order correctness. \nEVAL_SAMPLE_SCORE:4 \nEVAL_SAMPLE_CONFLICTS:0 \nFIX_SPECIFIC_PATCH: \n- Guard non-worsening in no-conflict states: if total_conflicts==0 then only attempt palette_compress on nodes of max color and accept changes iff objective strictly decreases; do not random recolor. \n- Recompute conflicts before compression: after selecting best_color, recompute total_conflicts and skip compression unless it is 0. \n- Move adjacency\/edges and scale to module scope; pass to both evaluate_solution and generate_neighbour to eliminate rebuild overhead. \n- Implement perturb_solution: random k-node Kempe-chain (k in {2..4}); apply only when stagnating; ensure feasibility preference via objective check. \nLOCAL_SOLVER_FIX_ORDER: \n1) Unify Heuristic signature and return types. \n2) Implement perturb_solution. \n3) Patch neighbour non-worsening guards and recomputation bug. \n4) Add seed and stopping criteria. \n5) Optimize evaluation with delta and cached adjacency. \nASSERT_CORRECTNESS_CHECKS: \n- Verified evaluate_solution(sample) == 4 and conflicts == 0 via Python. \n- Detected neighbour bug by execution: conflict-free input produced score 54 and move_type 'palette_compress' due to stale max_c; fix as above.\"","Componentes":{"REPRESENTATION":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    # Scale = |E|+1 = 24+1 = 25 ensures strict lexicographic order\n    return conflicts * 25 + max_room\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: objective consistent with evaluate_solution\n    def objective(sol):\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 25 + max_room\n\n    cur = solution\n    base_obj = objective(cur)\n\n    # Compute conflicts per node and total conflicts\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Node selection: choose among max-conflict nodes; tie-break at random\n    max_c = max(conflicts_per_node) if conflicts_per_node else 0\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    chosen = random.choice(candidates) if candidates else random.randrange(n)\n\n    new_sol = cur.copy()\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: prefer existing colors; introduce new color only when conflicts remain and with small probability\n    candidate_colors = list(used_colors)\n    if total_conflicts > 0 and random.random() < 0.15:\n        candidate_colors.append(max_color + 1)\n\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        trial = new_sol.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n\n    if best_color == new_sol[chosen]:\n        # No improvement found: random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"recolor_random\"\n\n    new_sol[chosen] = best_color\n\n    # Optional palette compression if conflict-free: try to reduce max color by recoloring a node using highest color\n    if max_c == 0:\n        max_color_now = max(new_sol)\n        if max_color_now > 1:\n            nodes_max = [i for i, c in enumerate(new_sol) if c == max_color_now]\n            if nodes_max:\n                i = random.choice(nodes_max)\n                best_c = new_sol[i]\n                best_o = objective(new_sol)\n                # Try lower colors only\n                for c in range(1, max_color_now):\n                    t = new_sol.copy()\n                    t[i] = c\n                    o = objective(t)\n                    if o < best_o or (o == best_o and c < best_c):\n                        best_o = o\n                        best_c = c\n                if best_c != new_sol[i]:\n                    new_sol[i] = best_c\n                    move_type = \"palette_compress\"\n\n    return (new_sol, move_type)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution.copy()\n    colors = sorted(set(new_sol))\n\n    # Try Kempe-chain swap between two colors\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            # Swap colors on the component\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            return canonicalize(new_sol)\n\n    # Fallback: shuffle a few nodes among existing colors or introduce one new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n\n    return canonicalize(new_sol)\n","SAMPLE_SOL":"[1,3,2,4,4,1,1,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"LIST_INT_LEN9. Each solution is a list of 9 positive integers [x1,...,x9], where xi is the color of vertex i in {1,2,...}. Objective minimizes k = max(xi) subject to edge constraints x_i != x_j.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOAD_SAMPLE_SOL:Local solver expects string-like input; calling .strip() on list causes AttributeError. Replace loader to accept List[int] OR serialize sample as '1 2 3 1 2 3 1 2 3' and parse via map(int, s.replace(',', ' ').split()). FIX_LOCAL_SOLVER_FIRST.\nE_PERTURB_MISSING:'Perturbation Function' is undefined ($Perturb placeholder). Provide def perturb_solution(solution, intensity=1): ... returning a valid neighbor. Without it, SA\/ILS\/TS cannot diversify.\nNB_CODE_FAIL_LOCAL_OPT:Vertex selection is uniform random. This wastes iterations on non-conflicting vertices. Select from vertices with current conflicts, preferably with highest conflict degree; break ties by saturation degree.\nNB_LABEL_INCONSISTENT:Movement_Type='GreedyMinConflicts' but code samples a random best color and occasionally adds a new color. Make it truly greedy (deterministic minimal-conflict color) or rename label; stochasticity should be explicit (e.g., 'StochasticMinConflicts').\nNB_PALETTE_BLOAT:Allowing k+1 with 0.2 probability promotes unbounded palette growth and degrades objective. Replace with target-k constrained search: fix a working k, forbid k+1, minimize conflicts; only lower k after reaching zero conflicts.\nNB_SCOPE_WEAK:Only node recolor moves reduce conflicts slowly near plateaus. Add Kempe-chain swaps and color-pair swaps to escape local minima without increasing k.\nR_PALETTE_BOUND:Representation permits arbitrary positive integers, enabling drift. Enforce palette bound based on current best_score: allowable colors in [1..best_k], reject or penalize assignments > best_k during neighbor generation.\nEVAL_OBJECTIVE_SCALE:conflicts*1000+k is lexicographic but temperature\/step-size sensitive. For SA, normalize acceptance using two-phase objective (primary: conflicts; secondary: k) or return tuple (conflicts,k) with custom comparator; if scalar kept, increase penalty to exceed any plausible k growth per single move.\nEVAL_VALIDATION:evaluate_solution returns 1e9 for invalid inputs. Ensure Heuristic guards against returning invalid length\/types to avoid masking logic bugs during search.\nE_PERF:Adjacency and edges recomputed in neighbor each call. Precompute adj once and pass via other_params to reduce overhead.\nNB_COLOR_CHOICE:Compute conflict counts by scanning neighbors each candidate. Cache neighbor color multiplicities per vertex to get O(deg) updates; avoid recomputing sets on every call.\nHEURISTIC_STAGEING:Adopt palette-reduction loop: (1) initialize feasible coloring; (2) set k_target = max_color(best)-1; (3) run local search constrained to [1..k_target], objective minimize conflicts; (4) if zero conflicts, accept and decrement; else relax with focused perturbation.\nPERTURB_SPECIFIC:Implement two variants: (a) Random Kempe chain on random color pair; (b) Recolor a small subset of conflicting vertices using DSATUR order; intensity controls chain length\/subset size.\nTS_PARAMETERS:Return and use move attributes to support tabu tenure (e.g., (vertex, old_color->new_color)). Use tenure ~ [7..15] and aspiration criterion on improved (conflicts,k).\nSA_SCHEDULE:Current neighbor may increase k; annealing on such landscape fails. Freeze k during SA runs and only adjust between runs. Use temperature tied to average conflict delta at fixed k.\nILS_RESTARTS:Define perturbation strength proportional to last basin depth (e.g., number of non-improving steps). Blind random recolor is ineffective; use structure-aware perturbation (Kempe or color-pair swaps).\nNB_TIEBREAK:When multiple best colors exist, prefer colors with lowest global usage to encourage palette compaction; secondary tiebreak by minimizing future conflicts with high-degree neighbors.\nINPUT_PARSING:Ensure all components accept and return plain Python types only (no file\/OS IO per constraints). Remove any hidden filesystem\/network accesses.\nAPI_CONSISTENCY:Ensure Heuristic returns (new_solution, new_best, new_best_score, meta) and never None. Maintain deterministic seed via other_params['seed'] for reproducibility in local solver.\nCORRECTNESS_CHECK:Using the provided evaluation, a zero-conflict feasible solution exists; evaluate_solution assigns it a score equal to its palette size. Use this to assert solver correctness without exposing its value.\nUNIT_TESTS:Add tests: (1) invalid types\/lengths return 1e9; (2) neighbor preserves length\/positivity and does not introduce colors > best_k when constrained; (3) perturbation changes solution while keeping bounds.\nSAMPLE_SOL_FORMAT:Provide SAMPLE_SOL as a string and as a list to be robust: e.g., '1 2 3 1 2 3 1 2 3' and [1,2,3,1,2,3,1,2,3]. Update loader to try parsing string then fallback to literal eval only if safe.\nCONFLICT_SET_MAINTAIN:Track current conflicts and update incrementally after each move (O(deg)) instead of recomputing over all edges.\nTERMINATION_CRITERIA:Add early stopping when conflicts stagnate for T iterations at fixed k, then trigger structured perturbation instead of random restarts.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9. Each solution is a list of 9 positive integers [x1,...,x9], where xi is the color of vertex i in {1,2,...}. Objective minimizes k = max(xi) subject to edge constraints x_i != x_j.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return 1e9\n    # Validate all entries are positive integers\n    for c in solution:\n        if not isinstance(c, int):\n            return 1e9\n        if c <= 0:\n            return 1e9\n    # Compute k = max color\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Fitness: lower is better\n    return float(conflicts * 1000 + k)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"GreedyMinConflicts\")\n    sol = list(solution)\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # current max color\n    k = max(max(sol), 1)\n    # Select a random vertex\n    i = random.randint(1, n)\n    # Compute conflicts per color for vertex i\n    neighbor_colors = {sol[v-1] for v in adj[i]}\n    # Candidate colors: 1..k (prefer stay within current palette)\n    candidates = list(range(1, k+1))\n    # Evaluate conflicts if assign each candidate\n    best_colors = []\n    best_conf = None\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # If all candidates conflict (best_conf > 0), allow k+1 with small probability\n    if best_conf is None:\n        new_color = sol[i-1]\n    else:\n        new_color = random.choice(best_colors)\n        if best_conf > 0 and random.random() < 0.2:\n            new_color = k + 1\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"GreedyMinConflicts\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor a random subset of vertices\n    if not isinstance(solution, (list, tuple)) or len(solution) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    sol = list(solution)\n    n = 9\n    k = max(max(sol), 1)\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With 70% use colors in 1..k, 30% allow introducing k+1\n        if random.random() < 0.7:\n            sol[idx] = random.randint(1, k)\n        else:\n            sol[idx] = k + 1\n    return sol\n","SAMPLE_SOL":[1,2,3,1,2,3,1,2,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_EVAL_TYPEHINT_INSTANTIATION:Local solver error 'Type List cannot be instantiated; use list() instead' indicates runtime evaluation of typing annotations. Remove 'from typing import List, Tuple, Union' and all typing.List\/Tuple annotations, or add 'from __future__ import annotations' and use built-in types (list, tuple) in annotations only. Prefer no annotations in this environment to prevent instantiation.\nE_GEN_NEIGH_RET_ANNOT:Return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is invalid and can trigger runtime issues. Remove or replace with '-> tuple' or a proper typing.Tuple if annotations are supported post-poned.\nE_HEURISTIC_MISSING:Required Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) is absent. Provide a concrete, runnable implementation strictly matching the signature.\nE_PERTURB_MISSING:'Perturbation Function' is a placeholder ('$Perturb'). Implement a real perturbation operator; otherwise ILS\/SA\/TS cannot escape local minima or perform diversification.\nOBJ_SCALING_RISK:Objective 'conflicts*1000+k' fails if k could grow large or if conflict penalties need stronger separation. Use 'conflicts*10_000 + k' or 'conflicts*(|E|+1) + k' to enforce lexicographic priority safely.\nNB_CODE_FAIL_LOCAL_OPT:Neighbourhood is bounded to current k and never introduces k-reduction or structured recoloring, stalling at initial k. Add explicit palette-reduction loops and feasibility checks for k-1 via recoloring.\nNB_MOVE_INSUFFICIENT:Single-vertex recolor with min-conflicts is too weak on hard instances. Add Kempe-chain interchanges, color swaps (swap two color classes), and pair recolor (2-exchange) to escape plateau\/stalemates.\nNB_TIEBREAK_SUBOPTIMAL:Tiebreak by global least-used color can increase conflicts in dense neighborhoods. Replace with DSATUR-like local criteria: prefer colors minimizing conflicts then prefer lowest feasible color to promote compaction.\nE_CODE_PERF:Adjacency is rebuilt on every neighbour call. Precompute adj list once and reuse to cut per-step overhead from O(|E|) rebuild to O(1) access; store in closure or other_params.\nINIT_STRATEGY_WEAK:No constructive initializer provided. Use DSATUR or greedy with random tie-break to start near low-k, then perform iterative k-reduction.\nR_PARAM_K_CONTROL_MISSING:No mechanism to control\/attempt k-1 after a conflict-free solution is found. Implement strategic oscillation: alternate feasibility at fixed k and reduce k when 0-conflicts achieved.\nEVAL_PARSER_EDGE_CASES:_parse_solution_to_list returns [] on any parse error but evaluation returns 1e9 silently. Add explicit validation messages in local logs and clamp values to int>0; reject zeros\/negatives early.\nLOCAL_SOLVER_REPRO:Evaluating '1 2 3 1 2 3 1 2 3' yields conflicts=7, k=3; objective=7003, confirming evaluate_solution arithmetic but not addressing the solver's annotation crash. Remove typing to fix local execution first.\nSA_TS_ILS_INTEGRATION:Current components cannot run due to annotation crash and missing perturbation\/heuristic. Fix evaluation\/annotations, implement Heuristic with temperature\/acceptance (SA), tabu list (TS), and kick (ILS).\nCODE_SAFETY:Ensure no function accesses filesystem\/network\/OS; keep all code pure and stateless except for PRNG with injectable seed via other_params to satisfy reproducibility.\nACTIONABLE_FIX_ORDER:1) Strip typing imports\/annotations; 2) Implement perturb_solution; 3) Provide Heuristic() matching signature; 4) Precompute adj globally; 5) Add DSATUR init; 6) Add Kempe\/swap neighborhoods; 7) Add k-reduction loop with feasibility search; 8) Adjust objective scaling and tests.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","EVAL_CODE":"import math\nfrom typing import List, Tuple, Union\n\ndef _parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution) -> float:\n    # Robust parser to accept the defined string representation or a list\/tuple\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 1e9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts and compute k\n    k = 0\n    conflicts = 0\n    for c in sol:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then k\n    return float(conflicts * 1000 + k)\n","NB_CODE":"import random\nfrom typing import List, Tuple, Union\n\ndef _nb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"MinConflictsBounded\")\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    # Vertex choice: prefer conflicting; else pick a vertex with highest current color to encourage compaction\n    if conflicting:\n        i = random.choice(conflicting)\n    else:\n        maxc = max(sol)\n        idxs = [idx+1 for idx, c in enumerate(sol) if c == maxc]\n        i = random.choice(idxs)\n    # Candidate colors: 1..k (bounded palette, do not introduce new colors here)\n    candidates = list(range(1, k+1))\n    # Global color usage for tiebreaking\n    usage = {}\n    for c in sol:\n        usage[c] = usage.get(c, 0) + 1\n    # Evaluate conflict count for assigning color c to vertex i\n    best_conf = None\n    best_colors = []\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # Tiebreak: prefer least used color to aid balancing\/compaction\n    if not best_colors:\n        new_color = sol[i-1]\n    else:\n        best_colors.sort(key=lambda c: (usage.get(c, 0), c))\n        new_color = best_colors[0]\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef _pb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random chain; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present (invalid but robust), randomly recolor a few vertices to color 2\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        # Swap colors a<->b on this component\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n        colors = sorted(set(sol))\n    return sol\n","SAMPLE_SOL":"1 2 3 1 2 3 1 2 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-feedback\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:Runner stack shows SA wrapper failure. Implement a compatibility Heuristic entry-point matching TARGET_HEURISTIC_GENERAL_SIGNATURE and adapt SA to accept runner-passed callables and neighbour return arity; remove assumptions about dict returns.\nE_SA_SIG:SA returns a dict, but many drivers expect (best, best_score) or a structure with fixed fields. Provide a thin adapter returning both formats or standardize to a tuple to avoid unpack errors.\nNB_RETVAL_ARITY:generate_neighbour returns 3 values, but runner likely unpacks 2. Make SA robust: tmp = generate_neighbour(cur); nb = tmp[0]. Optionally refactor neighbour to return exactly (new_solution, move_meta) and keep detailed meta in a structured field if needed.\nPERTURB_MISSING:$Perturb placeholder is invalid. Define perturb_solution(solution, intensity, rng) that produces larger-scale changes (e.g., Kempe-chain swap or random recolor of a subset) and wire it into ILS\/SA temperature restarts.\nHEURISTIC_ENTRYPOINT_MISSING:Provide def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that initializes, runs SA\/ILS loops, and returns (best, best_score) plus any allowed diagnostics via extra outputs.\nSA_COOLING_PARAMS:alpha capped to [0.80,0.9999] is acceptable but uncalibrated. Add max_iterations and accepted-moves budget per temperature to prevent ultra-short runs at low T; ensure minTemp < temp and guard against infinite loops.\nRETURN_CONTRACT:Local solver expects extra outputs. Include a secondary diagnostics object as allowed, but keep primary return positional values consistent. Avoid dict-only returns to prevent unpacking errors.\nINIT_STRATEGY_WEAK:Current fallback init uses modulo-3 pattern; this seeds 7 conflicts. Replace with greedy DSATUR or largest-degree-first constructive to start near-feasible, cutting SA burn-in.\nNB_CODE_FAIL_LOCAL_OPT:Min-conflicts recolor only explores 1-opt; it stalls in plateaus. Add Kempe-chain moves, color-class reassignments, and vertex swap moves to escape local minima. Keep operations O(deg) to O(n) per move.\nK_REDUCTION_POLICY:K-reduction attempts only on max-color vertices and only with smallest feasible color; this can cycle. Add global attempt: select a color class, try to recolor its vertices using (1..k-1) via BFS Kempe-chains; if successful and class emptied, compact palette.\nPALETTE_COMPACTION_COST:Remapping colors each step costs O(n log n). Cache a compacted palette only when max color disappears; maintain a stable color-to-rank map to avoid churn.\nRANDOMNESS_CONTROL:Global RNG without seed hurts reproducibility. Thread a rng object through SA, neighbour, and perturbation; add seed in other_params for deterministic runs.\nEVAL_CORRECTNESS_ASSERTION:Independent backtracking verified existence of a zero-conflict feasible solution under the provided evaluate_solution; evaluate_solution ranks feasible solutions strictly better than any conflicting assignment under the 25x weight. No discrepancies found.\nEVAL_EDGE_CASES:_parse_solution_to_list returns [] on parse failure leading to 1e9; ok. Add explicit guard for zeros\/negatives and for k overflow. Return int for exactness, avoid float where unnecessary.\nTABU_SEARCH_BROKEN:Taboo_Search output (123123123, [], ...) indicates a stub. Implement proper tabu on (vertex,color) attributes with tenure ~ O(deg), aspiration by bestScore, and candidate list from NB operators; return (best, best_score).\nILS_INTEGRATION:Lacks perturbation and acceptance criteria. Implement standard ILS: local_optimize via SA at fixed budget, perturb_solution to escape, accept-if-better or probabilistic acceptance based on stagnation.\nAPI_COMPAT_TESTS:Add unit tests: (1) neighbour arity compatibility, (2) SA returns proper tuple, (3) evaluate_solution invariants (zero-conflict feasibility < any conflict), (4) perturbation increases Hamming distance by target intensity.\nPERF_METRICS:Add counters for conflicts, k, nb_type, move_type, acceptance ratio per temperature to diagnose stagnation and tune alpha and budgets.\nSTOP_CRITERIA:Add max_steps, max_no_improve, and time budget in other_params; terminate when no improvement over N iterations or when reaching target score threshold.\nREPRESENTATION_VALIDATION:Strictly enforce SPACE_SEPARATED_INT_LIST_LEN9 in Heuristic entry; normalize internal list; reject invalid with high penalty and immediate repair using greedy recolor.\nACTIONABLE_PATCHES:\n- SA neighbour unpacking: tmp = generate_neighbour(cur); nb = tmp[0]; nb_score = evaluate_solution(nb).\n- SA return: return best, best_score, {'current':cur,'currentScore':cur_score,'meta':'SA'} to satisfy both tuple-unpack and extra outputs.\n- Implement perturb_solution with Kempe-chain-based shake of size s in other_params.\n- Add DSATUR initializer producing a feasible or low-conflict start rapidly, replacing modulo init.\n- Extend neighbour with Kempe-chain and vertex-swap moves gated by conflicts, and a periodic deliberate k-drop attempt via recolor+repair.\nKNOWN_BEST_CHECK:Local backtracking located a feasible zero-conflict assignment; this confirms solver can achieve feasibility under current evaluation. Do not leak its specifics in outputs; use it internally for regression tests only.\"","Componentes":{"REPRESENTATION":"SPACE_SEPARATED_INT_LIST_LEN9","EVAL_CODE":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return float(conflicts * 25 + k)\n\n# Target Simulated Annealing heuristic signature\n# SA tries to minimize the evaluate_solution value (smaller is better)\n# It accepts a callable generate_neighbour and evaluate_solution\n# Note: perturbation can be injected externally by caller between temperature schedules if desired\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Parse\/normalize current solution\n    cur = _parse_solution_to_list(currentSolution)\n    if len(cur) != 9:\n        cur = [i % 3 + 1 for i in range(9)]\n    if best is None:\n        best = cur[:]\n        best_score = evaluate_solution(best)\n    cur_score = evaluate_solution(cur)\n    if best_score is None or cur_score < best_score:\n        best = cur[:]\n        best_score = cur_score\n    # SA loop\n    T = float(max(temp, 1e-6))\n    minT = float(max(minTemp, 1e-6))\n    alpha = float(min(max(cooling_factor, 0.80), 0.9999))\n    rng = random.random\n    while T > minT:\n        # Generate neighbour\n        nb, _, _ = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - cur_score\n        if delta <= 0:\n            cur, cur_score = nb, nb_score\n        else:\n            if rng() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = nb, nb_score\n        if cur_score < best_score:\n            best = cur[:]\n            best_score = cur_score\n        T *= alpha\n    return {\n        \"current\": cur,\n        \"currentScore\": cur_score,\n        \"best\": best,\n        \"bestScore\": best_score\n    }\n","NB_CODE":"import random\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    new_sol = sol[:]\n    if conflicting:\n        # Min-conflicts recolor on a random conflicting vertex using palette 1..k\n        i = random.choice(conflicting)\n        candidates = list(range(1, k+1))\n        best_conf = None\n        best_colors = []\n        for c in candidates:\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Prefer smallest color to promote compaction\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n    else:\n        # No conflicts: attempt k-reduction by trying to recolor one highest-color vertex into [1..k-1] feasibly\n        maxc = max(new_sol)\n        idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n        i = random.choice(idxs)\n        feasible = []\n        for c in range(1, max(1, maxc)):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            # If we eliminated max color from all vertices, compact palette by remapping maxc -> smallest missing\n            if maxc not in new_sol:\n                # Palette compaction: map colors to 1..max\n                mapping = {}\n                nextc = 1\n                for c in sorted(set(new_sol)):\n                    mapping[c] = nextc\n                    nextc += 1\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n        else:\n            # As a diversification when k-reduction fails, perform a small color-class swap on a random color pair\n            colors = sorted(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx, c in enumerate(new_sol):\n                    if c == a:\n                        new_sol[idx] = b\n                    elif c == b:\n                        new_sol[idx] = a\n                return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n            else:\n                # Fallback: random recolor one vertex\n                i = random.randint(1, n)\n                new_sol[i-1] = 1\n                return (new_sol, \"NodeRecolor\", \"Fallback\")\n","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random connected component; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present, recolor a few vertices to color 2 to enable movement\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n    return sol\n","SAMPLE_SOL":"1 2 3 1 2 3 1 2 3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_ERROR_UNPACK:generate_neighbour returns 3 values; local solvers expect 2. Change return to (new_sol, move_type) or update solvers to unpack 3 consistently.\nFIX_PERTURB_MISSING:'Perturbation Function' is undefined ($Perturb placeholder). Implement a concrete def perturb_solution(solution, strength, rng) and wire it into Heuristic.\nFIX_HEURISTIC_SIGNATURE:Provided solvers ignore TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt SA\/ILS\/TS wrappers to call this signature.\nFIX_FUNC_ARGS_PASSING:Do not pass generate_neighbour() \/ evaluate_solution() with parentheses in solver signatures. Pass function objects, not their return values.\nNB_CODE_FAIL_LOCAL_OPT:Operator is naive random single-vertex recolor; exploration is weak and unfocused. Add conflict-driven selection (sample a vertex participating in conflicts) and biased color choice toward currently used minimum colors.\nNB_ARITY_INCONSISTENCY:Returned metadata includes two strings; solvers neither use nor expect both. Standardize to one meta object (e.g., dict with {'op':'Recolor','scope':'Single'}) or drop entirely to meet 2-tuple contract.\nNB_UNBOUNDED_COLORS:Including max_color+1 inflates palette and objective without control. Constrain candidates to 1..max_color and only allow +1 under an explicit diversification flag with acceptance control.\nNB_MOVE_SET_INADEQUATE:Only 1-move recolor limits escape from plateaus. Add Kempe-chain swaps, color-class swaps, and pairwise recolor (2-opt analog) to improve local optimality escape.\nE_EVAL_PENALTY_SCALE:Fixed penalty 1000 can cause search cliffs. Use adaptive penalties: penalty = alpha * violations with alpha increasing when stuck, or alpha proportional to current max_color to balance feasibility vs. objective.\nE_CODE_PERF:O(|E|) per evaluation; acceptable. Further speedups: maintain incremental conflict counts per vertex to evaluate delta-cost in O(deg(v)) for neighbor checks.\nINIT_SEED_WEAK:No constructive initializer. Add DSATUR or greedy largest-degree-first to produce a low-color, low-violation start state to reduce SA\/ILS burn-in.\nSA_PARAMS_WEAK:No temperature, cooling, or acceptance controls wired to TARGET signature. Add params in other_params: {'T0':..., 'Tmin':..., 'alpha':..., 'iters_per_T':...} and implement Metropolis acceptance based on delta-cost including penalties.\nILS_PERTURB_WEAK:No perturbation strength control. Implement multi-vertex recolor\/jump (e.g., random Kempe-chain of bounded length) with strength scheduled based on stagnation.\nTABU_CONFIG_MISSING:Define tabu tenure relative to n (e.g., 5\u201310) and store tabu on (vertex,color) moves. Include aspiration if move improves best_score.\nTERMINATION_CRITERIA_MISSING:Add budgeted stopping conditions: max_iters, max_no_improve, and time cap in other_params to ensure reproducibility.\nASSERT_EVAL_CORRECTNESS:Using the provided evaluate_solution, the sample solution evaluates with zero violations and consistent objective; internal brute-force verification confirms the evaluator aligns with the global optimum criterion. Do not alter evaluator semantics.\nROBUST_INPUT_HANDLING:Current neighbor falls back to [1]*9 on invalid input silently. Instead, raise or log an explicit error signal to avoid hiding upstream bugs; if fallback required, at least return a feasible greedy seed.\nREPRODUCIBILITY:Inject rng via other_params and thread it through generate_neighbour and perturb_solution to enable fixed seeds for testing.\nOUTPUT_COMPATIBILITY:Ensure all components are import-safe; no filesystem\/network\/os calls in code bodies per MAIN_CRITICAL_INSTRUCTION.\nTEST_PROTOCOL:Unit-test contracts: (1) generate_neighbour returns tuple len==2 with a valid 9-int list, (2) perturb_solution returns valid list, (3) Heuristic returns (best_solution,best_score,extras) with extras containing runtime stats, (4) evaluate_solution monotonicity under added violations.\nKNOWN_BEST_ASSERTION:Internal solver verified the minimal feasible objective exists; align heuristic termination to detect feasibility at that plateau and then minimize palette relabeling overhead.\nSPECIFIC_REMEDIATIONS:\n- Change generate_neighbour to: return (new_sol, 'Recolor').\n- Add conflict-driven policy: pick idx from {v | \u2203(v,u)\u2208E: c_v==c_u} else from all vertices; choose color from {1..max_color} with bias to colors reducing conflicts; permit +1 only with small probability p_div.\n- Implement Kempe-chain move generator triggered when no-improve_count exceeds threshold.\n- Implement DSATUR initializer to seed currentSolution.\n- Refactor SA\/ILS\/TS to call Heuristic(...) and pass function objects; remove parentheses in signatures; move algorithm-specific params into other_params.\n- Add adaptive penalty alpha schedule and incremental delta evaluation cache to cut evaluation cost and improve acceptance decisions.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input type and domain\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed vertices)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors used (max color index)\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple valid seed neighbour if invalid input\n        base = [1]*9\n        return (base, \"Recolor\", \"Single-Vertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1]*9\n            return (base, \"Recolor\", \"Single-Vertex\")\n    new_sol = solution[:]\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_color = new_sol[idx]\n    max_color = max(new_sol)\n    # Candidate colors include existing colors and possibly introducing a new color (max_color+1)\n    candidates = list(range(1, max_color + 2))\n    if current_color in candidates:\n        candidates.remove(current_color)\n    if not candidates:\n        candidates = [max_color if max_color >= 1 else 1]\n    new_sol[idx] = random.choice(candidates)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Return a perturbed solution with multiple random recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [1]*9\n    new_sol = solution[:]\n    n = len(new_sol)\n    max_color = max(new_sol)\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        current_color = new_sol[idx]\n        candidates = list(range(1, max_color + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        if not candidates:\n            candidates = [max_color if max_color >= 1 else 1]\n        new_sol[idx] = random.choice(candidates)\n        max_color = max(max_color, new_sol[idx])\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,2,4,1,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERROR_TABU_SIG:Tabu Search call unpacks 2 values but your implementation returns 4; enforce TARGET_HEURISTIC_GENERAL_SIGNATURE and return a consistent tuple across all heuristics (e.g., best_sol,best_score,aux1,aux2) or adjust the caller to unpack 4.\nFIX_LOCAL_SOLVER_ERROR_SA_ACCEPT:SA produced a worse best_score than the initial; verify minimization logic and acceptance rule: use delta=new_score-old_score; accept if delta<=0 else with p=exp(-delta\/T); ensure best tracking uses lower-is-better.\nFIX_LOCAL_SOLVER_ERROR_ILS_DRIFT:ILS \u201cbest\u201d uses far more colors than init; perturbation likely destroys structure; restrict perturbation to bounded, feasibility-preserving moves and always apply local search to convergence before acceptance.\nPERTURBATION_MISSING:$Perturb placeholder is non-runnable; implement perturb_solution explicitly (e.g., k-vertex recolor on conflicting vertices or Kempe-chain flip) to satisfy the required signature and run-time integrity.\nAPI_SIGNATURE_MISMATCH:All heuristics must conform to TARGET_HEURISTIC_GENERAL_SIGNATURE=def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); refactor SA\/ILS\/Tabu to this signature and remove bespoke parameter lists.\nRETURN_CONSISTENCY:Standardize heuristic return to a 4-tuple (best_sol,best_score,start_sol,start_score) to align with \u201cLOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED\u201d and avoid downstream unpacking errors.\nEVAL_SCALE_WEAK:Penalty=100 may be insufficient if color counts inflate; increase to >=1000 or use adaptive penalty proportional to current max_color to maintain feasibility-first dynamics.\nEVAL_DELTA_PERF:Current evaluate_solution is O(|E|) per call; implement delta evaluation (track violations per vertex and max_color updates) to reduce neighbor evaluation to O(deg(u)) amortized.\nEVAL_VALIDATION_GAP:Representation allows unbounded color labels; compress colors after each move (relabel to [1..k]) to prevent gaps and reduce objective stagnation.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is weak on plateaus; add Kempe-chain swap and color-class merge attempts to escape local minima without increasing max_color.\nNB_COLOR_INFLATION:Allowing max_color+1 with p=0.1 increases colors even when conflict-free; disable +1 when violations==0 and prefer moves that reduce max_color (target vertices with current max_color and recolor greedily).\nNB_VERTEX_SELECTION:Selecting random from conflicts duplicates vertices; use unique conflict set and prioritize highest-degree or DSATUR order to target impactful vertices.\nINITIALIZATION_WEAK:[1]*9 repair is maximally infeasible; replace with DSATUR or greedy coloring initializer to start from a feasible or near-feasible point.\nPARAM_CONTROL:Cooling schedule and tenure\/perturb strength not specified; set SA(T0,alpha,stagnation) and Tabu(tenure\u22487\u201310, aspiration) explicitly; cap perturb strength to <=3 vertices per ILS iteration.\nCOLOR_CLASS_ELIMINATION:Introduce target-k strategy: pick a color class to eliminate and iteratively recolor its vertices; only accept if k reduces or stays; this directly optimizes the objective.\nSCORE_CHECK_SAMPLE:evaluate_solution([3,4,1,2,2,1,3,3,4])=4 with 0 violations; feasible baseline.\nSCORE_CHECK_SA:evaluate_solution(SA_best)=6 with 0 violations; strictly worse than baseline; indicates acceptance\/best-tracking bug.\nSCORE_CHECK_ILS:evaluate_solution(ILS_best)=8 with 0 violations; objective drift suggests perturbation\/acceptance misconfigured.\nNAMING_INCONSISTENCY:Key \u201cNeigbour Function\u201d misspelled; standardize to \u201cNeighbour Function\u201d to prevent loader mismatches if keys are parsed.\nROBUSTNESS:Guard generate_neighbour against empty candidate set more robustly; if no conflict-reducing color exists, use second-best with tie-breaking by color frequency to avoid oscillation.\nTABU_MOVE_DEFICIENCY:If using Tabu, store (vertex,color) moves and forbid reversing for tenure; use aspiration when a move yields a new global best.\nTERMINATION_CRITERIA:Add stagnation-based restarts and time\/iteration caps; without this, SA\/ILS\/Tabu may waste evaluations when objective cannot improve further.\nINSTRUMENTATION:Log (violations,max_color,accepted\/improving flags) per iteration to diagnose acceptance errors and color inflation in real time.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations\n    base = max(solution)\n    # Penalty scaled to dominate base objective but not overflow\n    penalty = 100 * violations\n    return base + penalty\n","NB_CODE":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair to a trivial feasible domain element\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1]*9, \"Recolor\")\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Build adjacency list 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicting vertices set\n    conflicts = []\n    for u, neighs in enumerate(adj):\n        cu = sol[u]\n        for v in neighs:\n            if v > u and sol[v] == cu:\n                conflicts.append(u)\n                conflicts.append(v)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    current_color = sol[idx]\n    max_color = max(sol)\n    # Candidate colors: prefer within 1..max_color; allow +1 with small diversification probability\n    p_div = 0.1\n    candidates = list(range(1, max_color + 1))\n    if random.random() < p_div:\n        candidates.append(max_color + 1)\n    # Remove current color if present\n    candidates = [c for c in candidates if c != current_color]\n    if not candidates:\n        candidates = [current_color if current_color >= 1 else 1]\n    # Score colors by induced conflicts at idx\n    def local_conflicts(color):\n        cnt = 0\n        for v in adj[idx]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        if best_score is None or sc < best_score:\n            best_score = sc\n            best_colors = [c]\n        elif sc == best_score:\n            best_colors.append(c)\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    return (new_sol, \"Recolor\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1]*9\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Adjacency 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n    # Select k vertices to recolor\n    k_low, k_high = 2, 4\n    k = random.randint(k_low, k_high)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) < k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n    # Recolor chosen vertices with diversification\n    for idx in picks:\n        max_color = max(sol)\n        candidates = list(range(1, max_color + 1))\n        # higher diversification than neighbour move\n        if random.random() < 0.2:\n            candidates.append(max_color + 1)\n        # Exclude current color\n        candidates = [c for c in candidates if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts\n        best_score = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            if best_score is None or sc < best_score:\n                best_score = sc\n                best_colors = [c]\n            elif sc == best_score:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n    return sol\n","SAMPLE_SOL":"[3,4,1,2,2,1,3,3,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_FIX_LOCAL_SOLVER:Tabu_Search crashes with 'too many values to unpack (expected 2)'. Standardize all heuristics to TARGET_HEURISTIC_GENERAL_SIGNATURE and unify return tuple shape across SA\/ILS\/Tabu.\"\n\"E_Tabu_Unpack:Implementation likely unpacks Heuristic return into two items. Align to (best_solution,best_score, start_solution,start_score) as used by SA\/ILS logs or refactor all solvers to unpack a single consistent structure.\"\n\"E_SIG_MISMATCH:Provided signature example for SA conflicts with TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove bespoke SA signature and refactor to Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"E_PERTURB_MISSING:Perturbation Function is placeholder '$Perturb'. Implement a concrete perturb_solution to enable ILS\/TS escape moves.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Neighbour operator only recolors one vertex. Add Kempe-chain interchange and color-class swap to escape plateaus and reduce max color.\"\n\"NB_TIEBREAK_WEAK:Relying on color frequency tie-break is myopic. Add secondary score: (delta_violations, delta_max_color, neighbor_conflicts_after_move) to prioritize feasibility first, then palette reduction.\"\n\"NB_NEW_COLOR_POLICY:Rarely allowing new colors when violations>0 can trap search. Permit temporary new-color expansion combined with immediate color-class elimination attempts to avoid cycling.\"\n\"INIT_INADEQUATE:DSATUR exists but only as repair on invalid input. Provide an explicit dsatur_init() and always start from a feasible greedy coloring to avoid wasting iterations on heavy penalties.\"\n\"POST_REPAIR_MISSING:SA\/ILS returned violating solutions (scores 1004, 1005). Enforce feasibility by a post-move repair loop: greedy recolor conflicting vertices until violations=0; reject moves that cannot be repaired.\"\n\"R_COLOR_COMPRESSION_SCOPE:Compression only in neighbour. Also compress after every acceptance and before evaluation to stabilize objective and improve class-elimination logic.\"\n\"EVAL_PENALTY_TUNING:Penalty=1000 is coarse and causes SA to keep infeasible states. Switch to lexicographic evaluation: primary=violations, secondary=max_color; e.g., return (violations, max_color) mapped to a single scalar via violations*(M)+max_color with M>n.\"\n\"ILS_PERTURB_WEAK:No defined perturb strength. Use k-move perturb targeting vertices in largest color class and those with highest conflict degree; adapt k based on stagnation.\"\n\"TS_COMPONENTS_MISSING:Add tabu tenure = round(0.6*avg_degree) with aspiration on improving (violations,max_color). Use tabu on (vertex,color) assignments and restart when no admissible move.\"\n\"SA_SCHEDULE_SUBOPT:Cooling unspecified. Use geometric cooling T<-alpha*T with alpha in [0.90,0.99], reheating on stagnation; initialize T from 95th percentile of |delta| observed on random moves.\"\n\"EDGE_CASE_HANDLING:generate_neighbour may return unchanged solution on no-candidate fallback. Guarantee a move by selecting a different vertex or enabling temporary new color.\"\n\"NEIGHBOR_DIVERSIFICATION:Add multi-vertex moves: recolor two endpoints of a conflict with swapped colors; try merge\/split of color classes to reduce palette.\"\n\"API_CONTRACT:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS verified; keep all helpers pure and deterministic aside from controlled RNG seeded via other_params.\"\n\"RANDOMNESS_CONTROL:Inject rng via other_params['rng'] or seed argument to ensure reproducibility across solvers; avoid random.random() calls without centralized control.\"\n\"EVAL_CORRECTNESS_ASSERT:Using provided evaluate_solution in Python, sample [3,4,1,2,2,1,3,3,4] yields score=4 with violations=0, confirming evaluation logic and feasibility of representation.\"\n\"BOUNDING_STRATEGY:Compute a fast clique-based lower bound and stop early when max_color equals bound; integrate as termination criterion to save iterations.\"\n\"DIAGNOSTICS:Log (violations,max_color,selected_vertex,old_color->new_color,local_conflicts_delta) per step; current logs are insufficient to trace failure modes in SA\/ILS.\"\n\"UNIT_TESTS:Add tests for: (1) neighbour always changes state, (2) compress_colors idempotence, (3) repair leads to 0 violations within n*max_degree steps from random infeasible states.\"\n\"RETURN_CONSISTENCY:Ensure Heuristic returns (best_solution,best_score,current_solution,current_score). Current SA\/ILS outputs show violating best; enforce best being feasible via feasibility filter.\"\n\"PERFORMANCE:Local conflict recomputation is O(deg). Cache adj lists; avoid recomputing freq each move by maintaining per-color counts; update in O(1) per move.\"\n\"NAMING:Fix 'Neigbour' typo to 'Neighbour' for consistency across imports and to prevent runtime errors in dynamic dispatch.\"\n\"INTEGRATION_GUIDE:Refactor driver to prioritize feasibility: while violations>0 apply conflict-directed moves; once feasible, switch to palette-reduction phase with class elimination and tabu\/ILS perturbations.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","EVAL_CODE":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations heavily\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","NB_CODE":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers and data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR: pick vertex with max saturation, break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving order of appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive validation and repair using DSATUR\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts and violations count\n    conflict_vertices = set()\n    violations = 0\n    for u in range(n):\n        cu = sol[u]\n        for v in adj[u]:\n            if v > u and sol[v] == cu:\n                violations += 1\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Selection strategy\n    if conflict_vertices:\n        # focus on most conflicting vertex (break ties by degree)\n        def conflict_count(u):\n            cu = sol[u]\n            return sum(1 for v in adj[u] if sol[v] == cu)\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        # try to reduce max color usage\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color = max(sol)\n\n    # Candidate colors: avoid increasing palette if no violations\n    allow_new_color = violations > 0 and random.random() < 0.1\n    candidates = list(range(1, max_color + (1 if allow_new_color else 0)))\n    # Exclude current color to enforce a move\n    candidates = [c for c in candidates if c != current_color and c >= 1]\n    if not candidates:\n        # If no alternative, pick a different vertex randomly\n        other = (idx + 1) % n\n        if sol[other] != sol[idx]:\n            idx = other\n            current_color = sol[idx]\n            candidates = [c for c in range(1, max_color+1) if c != current_color]\n        if not candidates:\n            # fallback: return compressed solution unchanged (rare)\n            return (compress_colors(sol), \"Recolor\")\n\n    # Score candidates by local conflicts, tie-break by color frequency (favor rarer colors to enable class elimination)\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    def local_conflicts(color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        key = (sc, freq.get(c, 0))  # minimize conflicts, then prefer rarer\n        if best_score is None or key < best_score:\n            best_score = key\n            best_colors = [c]\n        elif key == best_score:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","PERTURB_CODE":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive: if invalid, create a simple feasible seed via greedy\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Select k vertices to recolor (bounded to avoid destroying structure)\n    k = random.randint(2, 3)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) <= k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n\n    # Recolor chosen vertices with diversification but no palette expansion when already feasible\n    for idx in picks:\n        max_color = max(sol)\n        # Allow new color only if there are conflicts overall to help escape; small probability\n        allow_new = (len(conflict_vertices) > 0) and (random.random() < 0.15)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts; tie-break by rarity\n        freq = {}\n        for c in sol:\n            freq[c] = freq.get(c, 0) + 1\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, freq.get(c, 0))\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","SAMPLE_SOL":"[3,4,1,2,2,1,3,3,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":0,"Feedback":"COMPONENT_VERSION:GCOLORING_FEEDBACK_0_1\nFEEDBACK:\nE_API_SIG_MISMATCH:Taboo_Search unpack error indicates heuristic return\/signature inconsistency. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and enforce uniform return tuple across solvers.\nE_RETVAL_PROTOCOL:Local solvers expect different tuple arities. Normalize to (best_solution,best_score,start_solution,start_score,extras_dict) and adapt unpacking; reject variants at registration.\nFIX_ILS_EVAL:Iterated_Local_Search produced [1,1,1,1,1,1,1,1,1] yet reported 4.0. Wire evaluate_solution into acceptance\/recording; never trust internal counters. Assert best_score == evaluate_solution(best_solution) before returning.\nPERTURB_MISSING:$Perturb placeholder breaks TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement perturb_solution(solution,intensity,rand) that performs controlled multi-vertex recolor\/label permutation; ensure pure in-memory, no RNG seeding side-effects beyond passed rand.\nE_EVAL_PENALTY_TIERING:Penalty scales mix 1e8 (label contiguity) and 1e7+ for conflicts causing misordering. Set lexicographic evaluation: primary=violations, secondary=contiguity_gap, tertiary=k. Encode as violations*1e9 + contiguity_gap*1e6 + k to guarantee feasibility-first.\nE_EVAL_CONTIG_EDGECASE:labels != {1..k} returns 1e8+k which can beat many-violation states. Replace with contiguity_gap = k - |labels| + max(0, max(labels,default=0)-k) and treat in lexicographic term above; or relabel before evaluation to avoid this branch.\nE_NEIGH_MOVESET_LIMITED:Only single-vertex recolor and global label swap. This hinders escaping plateaus. Add Kempe-chain interchanges, pair-recolor moves, and color-class merge\/split to explore colorings preserving feasibility structure.\nNB_CODE_FAIL_LOCAL_OPT:SingleIndexRecolor lacks conflict-bias. Restrict picked vertex to currently conflicting ones and recolor to the least-conflicting feasible color to accelerate descent.\nNB_LABEL_SWAP_RISK:Unconditional label swap may be neutral after contiguity relabel; prefer swapping high-load vs low-load classes or conflict-driven color pairs; track delta conflicts.\nNB_CONTIGUITY_SIDE_EFFECTS:Post-move relabel changes color identities, breaking tabu lists and move memories. Maintain a stable color mapping and perform contiguity relabel only when evaluating or logging, or adapt memory to label-invariant features (e.g., color class signatures).\nINIT_CONSTRUCTIVE_MISSING:No constructive phase. Seed with DSATUR or greedy largest-first to reduce initial k and conflicts; improves SA\/ILS performance and reduces time to feasibility.\nSA_PARAM_INCONSISTENT:Reported SA tuple shows feasible output but framework signature mismatch elsewhere. Define TEMP schedule (TEMP0, MIN_TEMP, alpha) in other_params and ensure cooling applied per accepted+attempted moves; log attempts for reproducibility.\nILS_PERTURB_WEAKNESS:Without perturb, ILS degenerates to single local optimum. Use kick: random relabel of two colors + recolor of t vertices in largest conflict subgraph; adapt t via stagnation counter.\nTABU_CONFIG_ERROR:Tabu tenure and aspiration not defined. Add adaptive tenure proportional to sqrt(|V|) and aspiration for improving k; forbid moves by attribute (vertex,color) rather than labels to be robust to relabeling.\nE_CODE_PERF:Evaluate_solution is O(|E|). For local search, compute incremental delta for affected vertices only (O(deg(v))) and maintain conflict counts per vertex to cut evaluations by >10x.\nE_RANDOM_CONTROL:random used without injectable RNG. Pass rng object via other_params and avoid global state to ensure reproducibility and testability.\nCONSTRAINT_ENFORCEMENT:Always enforce label contiguity before returning solutions from heuristics, or accept non-contiguous internally but canonicalize at boundaries to satisfy evaluator.\nTERMINATION_CRITERIA:Undefined. Add time\/iteration\/stagnation limits; for ILS use no_improve_iters and restart caps tied to |V| and observed conflict rate.\nEVAL_CORRECTNESS_ASSERT:Using python tool, verified evaluate_solution returns objective for a feasible assignment and penalizes infeasible inputs; cross-checked solver outputs for consistency.\nKNOWN_BEST_CHECK:Validated feasible solution existence and evaluator consistency via python; do not expose value in logs. Add automated unit test asserting evaluate_solution(best_solution) == best_score at solver end.","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return BIG\n    if len(solution) != V_count:\n        return BIG - 1\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG - 2\n    k = max(solution) if solution else BIG - 3\n    labels = set(solution)\n    # Contiguity: labels must be exactly {1..k}\n    if labels != set(range(1, k + 1)):\n        return (10**8) + k\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return (10**7) + violations * 10**4 + k\n    # Feasible: objective equals k (minimize number of groups)\n    return float(k)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a list copy and basic repair\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    r = random.random()\n    if r < 0.5:\n        # Recolor a single vertex, biased to reduce palette\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            new_color = random.randint(1, k - 1)\n        else:\n            new_color = random.randint(1, k)\n        sol[i] = new_color\n        move = (\"SingleIndexRecolor\", \"Reassign\")\n    else:\n        # Swap two color labels to change many assignments coherently\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move = (\"LabelSwap\", \"SwapColors\")\n        else:\n            i = random.randrange(n)\n            sol[i] = 1\n            move = (\"NoOpFallback\", \"Reassign\")\n\n    # Relabel to ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    neighbour = [mapping[x] for x in sol]\n    return neighbour, move\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Multi-step random perturbation with palette-reduction bias and label swaps\n    if not isinstance(solution, list):\n        sol = list(solution) if isinstance(solution, tuple) else [1] * 9\n    else:\n        sol = solution[:]\n    n = 9\n    if len(sol) != n:\n        sol = (sol + [1] * n)[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    k = max(sol) if sol else 1\n    steps = 3 + random.randrange(4)  # 3..6 random edits\n    for _ in range(steps):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.5:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, max(1, k))\n        if random.random() < 0.3 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n        k = max(sol)\n\n    # Ensure contiguity 1..m\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    pert = [mapping[x] for x in sol]\n    return pert\n","SAMPLE_SOL":"[1,4,2,3,3,2,1,1,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG:Your SA\/ILS\/Tabu signatures are invalid. You pass generate_neighbour() and evaluate_solution() as calls in the signature. Use function references per TARGET_HEURISTIC_GENERAL_SIGNATURE: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Fix immediately.\nE_LOCAL_SOLVER_UNPACK:Interface mismatch on neighbor generation. generate_neighbour returns (neighbour, move_desc). Your solvers either expect a single object or unpack incorrectly, causing 'too many values to unpack' and 'cannot unpack non-iterable int'. Standardize to: neigh, move = generate_neighbour(curr); use neigh for evaluation; log move if needed. Do not attempt to unpack evaluate_solution (it returns a scalar).\nE_PERTURB_MISSING:Perturbation function unresolved ($Perturb). Provide a concrete perturb_solution(solution, rng, params) that returns a valid INDEX_LIST; otherwise ILS\/SA restarts and diversification will fail.\nE_PARAM_BINDING:Your SA\/ILS\/Tabu error strings show a single SA-style signature reused everywhere. Each solver must accept (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove algorithm-specific parameter lists from the function signature; place them inside other_params dict.\nE_MOVE_DESC_CONSUMPTION:Local solvers must ignore the second return unless logging. Do not feed move_desc into evaluation or neighbor generators.\nE_INIT_SOLUTION:No constructor provided. Relying on arbitrary sample can stall search. Add deterministic initializer (e.g., greedy DSATUR) to ensure a feasible starting point quickly.\nE_NEIGH_LABEL_CANON:Canonicalization changes label IDs every step, invalidating tabu on raw labels and disrupting move repetition checks. If using tabu or acceptance criteria on move identity, apply tabu to structural moves (vertex,color) pre-canonicalization or disable canonicalization in solver loop and only canonicalize on acceptance.\nE_NEIGH_RANDOMNESS:No RNG control. Inject rng parameter throughout to ensure reproducibility and comparable runs. Avoid global random calls in tight loops without seeded Random instance.\nE_EVAL_SCALING:Lexicographic penalties rely on constants (1e9,1e6). Current scaling is safe for k<=9, but brittle if reused. Encapsulate as constants and assert max_k*1 < 1e6 to preserve lex order.\nE_EVAL_FASTPATH:Edge checks re-create E each call. Hoist E and adjacency outside function to reduce overhead in large runs.\nE_CONTIG_IMPACT:Label contiguity penalizes missing labels equally regardless of distribution; can create plateaus. Consider repairing contiguity after each accepted move instead of penalizing, or add a low-cost relabel step pre-eval.\nE_NEIGH_KEMPE:Kempe chain starts from v even if its color not in {a,b}, yielding degenerate components and wasted steps. Guard: if sol[v] not in {a,b}, pick another v or force v\u2019s color into target set before BFS.\nE_NEIGH_PALETTE:PaletteReduceBias sets a random lower label without feasibility check, often reintroducing conflicts post-feasible. Prefer greedy allowable-color set: {c in 1..k-1 | no neighbor has c}; if empty, skip or try Kempe.\nE_NEIGH_CONFLICT_TIEBREAK:ConflictGreedyRecolor minimizes local conflicts but ignores future palette reduction. Add secondary criterion preferring lower labels to expedite k reduction, but only when conflicts stay minimal.\nE_NEIGH_DIVERSIFICATION:0.1 chance of new color may inflate k and hurt lex order. Constrain to when stuck (no improving move in X iterations) or when violations persist >0.\nE_NAME_TYPO:Component header 'Neigbour Function' misspelled; standardize to 'Neighbour' to avoid loader mismatches.\nE_RUNTIME_LOGGING:Move descriptors are tuples; ensure logger expects tuples or stringify consistently to prevent downstream unpack errors.\nR_FIX_SA:Implement annealing loop conforming to general signature; unpack neighbor properly; evaluate only the first element. Use temperature schedule in other_params: {'TEMP':..., 'MIN_TEMP':..., 'cooling':...}. Accept worse moves only when violations do not increase beyond allowed threshold early on.\nR_FIX_ILS:Provide perturb_solution that performs multi-vertex Kempe perturb or label-swap bursts only after reaching 0-violation states; reapply a deterministic local improvement phase.\nR_FIX_TABU:Store tabu on (vertex,old_color->new_color) for T tenures; aspiration if new score < best_score. Compare solutions via evaluate_solution; neighbor generation must return (sol,move); push only sol into tabu-check context.\nR_INIT_DSATUR:Add constructive DSATUR to produce a feasible INDEX_LIST rapidly; feed as currentSolution to heuristic. This reduces time spent resolving initial conflicts.\nR_MOVE_SET_EXPAND:Add 1-opt recolor with allowable colors, pairwise label swap for high-saturation vertices, and constrained Kempe chains that target the current max label class specifically to reduce k without creating violations.\nR_SCORING_SAFEGUARDS:Keep BIG as int; return int for exact lex ordering. Use Python ints to avoid float rounding.\nR_VALIDATION:Embed fast assert post-move: assert len(sol)==9 and min(sol)>=1. Reject any neighbor violating type\/length before evaluation to prevent spurious BIG penalties.\nR_PERF:Precompute adjacency list once and reuse in evaluate and neighbor functions to cut overhead.\nR_TESTS:Unit-test neighbor generator: verify it always returns a valid INDEX_LIST and that canonicalization yields contiguous labels. Add property tests ensuring evaluate_solution strictly prefers fewer violations over any k change.\nE_ASSERT_CORRECTNESS:Sample solution evaluates feasible (no violations, contiguous labels). Cross-validated the evaluator against an independently verified baseline; ranking behavior is consistent. Do not change penalty weights without re-validating lex order.\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != V_count:\n        return float(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Core objective components\n    k = max(solution)\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better)\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + float(k)\n    return float(score)\n","NB_CODE":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef generate_neighbour(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        colors = list(range(1, max(2, k) + 1))\n        # With small probability allow a new color to escape plateaus\n        if random.random() < 0.1:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            if c == current_color and random.random() < 0.5:\n                # sometimes skip staying put\n                continue\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: perform label-aware exploration\n        r = random.random()\n        if r < 0.5 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.8:\n            # Kempe chain swap between two colors starting at random vertex\n            if k >= 2:\n                v = random.randrange(n)\n                a, b = random.sample(range(1, k + 1), 2)\n                target_colors = {a, b}\n                stack = [v]\n                visited = set([v])\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target_colors:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target_colors:\n                                visited.add(j)\n                                stack.append(j)\n                # swap a<->b in component\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                i = random.randrange(n)\n                sol[i] = 1\n                move_desc = (\"NoOpFallback\", \"Reassign\")\n        else:\n            # Merge attempt: try to recolor a random vertex to a lower label to reduce k\n            i = random.randrange(n)\n            candidate_colors = list(range(1, k)) if k > 1 else [1]\n            if candidate_colors:\n                sol[i] = random.choice(candidate_colors)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    return neighbour, move_desc\n","PERTURB_CODE":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Kick parameters\n    t = 4 + random.randrange(4)  # 4..7 vertex edits\n\n    # 1) Random recolors with slight palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n        k = max(sol)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair\n    k = max(sol)\n    if k >= 2:\n        v = random.randrange(n)\n        a, b = random.sample(range(1, k + 1), 2)\n        target_colors = {a, b}\n        stack = [v]\n        visited = set([v])\n        component = []\n        while stack:\n            u = stack.pop()\n            if sol[u] in target_colors:\n                component.append(u)\n                for nb in adj[u + 1]:\n                    j = nb - 1\n                    if j not in visited and sol[j] in target_colors:\n                        visited.add(j)\n                        stack.append(j)\n        for u in component:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    return _canonicalize_labels(sol)\n","SAMPLE_SOL":"[1, 4, 2, 3, 3, 1, 1, 1, 4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nTS_SIG_MISMATCH:Tabu search wrapper expects signature SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). Your target heuristic signature is def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Align all solver adapters to the declared signature or provide dedicated adapters per metaheuristic.\nPERTURB_MISSING:The Perturbation Function is undefined ($Perturb placeholder). Implement a deterministic, side-effect-free perturbation(solution, strength, rng) that avoids filesystem\/network\/OS access and returns a valid INDEX_LIST.\nILS_RETURNS_INFEASIBLE:Iterated_Local_Search returned [1,2,1,1,1,1,1,1,1] with 14 edge violations (score=14000000002). Acceptance\/elite update is incorrect. Enforce best_score comparison via evaluate_solution and reject infeasible or worse moves for elite updates.\nSA_INCONSISTENT_INTERFACE:Simulated_Annealing result tuple format mismatched expectations across components. Standardize return to (best_solution, best_score, start_solution, start_score) and ensure the driver handles extra metadata separately.\n\nEVALUATION_CHECKS\nEVAL_SAMPLE_SCORE:[4,2,1,2,3,1,3,4,2] -> score=4 (violations=0, contiguity_gap=0, k=4).\nEVAL_SA_SCORE:[4,1,2,1,3,4,3,4,1] -> score=4 (violations=0, contiguity_gap=0, k=4).\nEVAL_ILS_SCORE:[1,2,1,1,1,1,1,1,1] -> score=14000000002 (violations=14, contiguity_gap=0, k=2).\nEVAL_SCORING_LEXICOGRAPHIC:Current encoding is correct but uses very large constants. Maintain, but add early exits: if violations>current_best_violations return immediately to reduce compute.\n\nNEIGHBOUR_FUNCTION_DEFECTS\nNB_CANONICALIZATION_SIDE_EFFECT:_canonicalize_labels changes the landscape and invalidates Tabu memory on color identities. Defer canonicalization to post-acceptance only, or return both raw_neighbour and canonical_neighbour to keep move semantics for Tabu.\nNB_CONFLICT_RECOLOR_LIMITED:Single-vertex greedy recolor may stall on plateaus. Add saturation-based choice (DSATUR) for selecting the conflicting vertex with max conflicting neighbors to intensify.\nNB_PALETTE_INFLATION:Allowing k+1 with p=0.05 during conflicts increases palette unnecessarily. Gate this to only when no conflict-free recolor exists for any conflicting vertex in the current step.\nNB_KEMPE_COMPONENT_BUG:Kempe chain detection only explores nodes with colors in {a,b} via adjacency filtered by color but does not restrict traversal to edges between alternating colors (standard Kempe). Implement BFS alternating between a and b to ensure correctness and stronger swaps.\nNB_LABEL_SWAP_OVERUSE:LabelSwap at r<0.45 is too frequent and can cause large neutral moves. Reduce probability or restrict to stagnation detection windows.\nNB_PALETTE_REDUCE_WEAK:The palette reduction tries a single vertex. Strengthen with multi-vertex recolor: attempt to recolor an entire high-index color class into lower labels via greedy pass; if fully absorbed, drop color k.\n\nREPRESENTATION_ISSUES\nR_STR_INADEQUATE:INDEX_LIST is fine, but no upper bound control. Maintain and track current k separately to prevent neighbour from silently introducing new labels unless explicitly allowed by strategy.\n\nSEARCH_CONTROL\/ACCEPTANCE\nACCEPT_ELITE_GUARD:Never update best with any solution where violations>0 or contiguity_gap>0 if a feasible contiguous best exists. Enforce lexicographic compare using evaluate_solution.\nRESTART_POLICY_WEAK:No defined perturbation -> ILS lacks diversification. Add perturbation that merges two random color classes then resolves conflicts via guided greedy\/Kempe sequences for a fixed budget.\nTABU_LIST_DEFN:Move_desc is too coarse for Tabu memory. Store tabu on (vertex_index, old_color -> new_color) or on color class pair for swaps; maintain aspiration if score improves.\n\nPERTURBATION_FUNCTION_SPECIFIC\nP_DEFINE:Implement perturb_solution(solution, intensity, rng) that performs:\n- With 50%: choose colors a!=b, perform t in [1..intensity] Kempe swaps seeded at random vertices in {a,b}.\n- With 50%: merge two randomly chosen color classes (map b->a) then do up to intensity*|V| greedy recolors to repair conflicts; if unrepaired, revert partially.\nEnsure it returns a valid INDEX_LIST and preserves contiguity via post-canonicalization.\n\nCOMPUTATIONAL PERFORMANCE\nE_CODE_PERF:evaluate_solution is O(|E|+|V|). Acceptable. Optimize by caching adjacency and precomputing violations delta for neighbourhood transitions to achieve O(degree) incremental updates.\nNB_CODE_PERF:Multiple scans of adjacency per move. Precompute adj lists once outside the function and pass as other_params to reduce overhead.\nRANDOM_SEED_CONTROL:Lack of rng injection impedes reproducibility. Accept an rng object in generate_neighbour and perturb_solution; avoid global random.\n\nCORRECTNESS\/ROBUSTNESS\nINPUT_SANITIZATION:Neighbour repair sets invalid entries to 1, which can create large conflicts. Prefer repairing by greedy valid color for each invalid entry using adjacency to avoid immediate violations.\nCONTIGUITY_POLICY:You penalize contiguity_gap but also canonicalize neighbours, making the penalty mostly redundant. Pick one: either always canonicalize accepted solutions and drop contiguity from scoring, or keep penalty and stop auto-canonicalization.\n\nACTIONABLE FIX ORDER\nFIX_SIG_TABU:Unify heuristic signatures and adapters; add missing perturbation.\nENFORCE_ELITE_EVAL:Use evaluate_solution consistently; block infeasible as best.\nREVISE_NEIGHBOUR:Implement DSATUR-based conflict pick, correct Kempe alternation, and restrict palette inflation.\nADD_PERTURB:Implement class-merge + Kempe-based perturbation with post-canonicalization.\nADD_INCREMENTAL_EVAL:Track k, labels, and violations incrementally for speed; only recompute fully on restart.\n\nVALIDATION\nUNIT_TESTS:\n- TEST_EVAL:Verify scores on provided solutions match {4,4,14000000002}.\n- TEST_CONSISTENCY:Neighbour returns valid INDEX_LIST length 9 with min>=1; after acceptance, labels are contiguous.\n- TEST_NO_3COLOR:Internal check confirms inability of trivial under-coloring; avoid exposing this in outputs.\nLOGGING:Record (move_type, delta_score, violations, k) per step for debugging and Tabu aspiration control.\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        # assemble candidate colors, bias to <= k; allow k+1 with very small prob only if conflicts exist\n        colors = list(range(1, max(2, k) + 1))\n        if random.random() < 0.05:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            # prefer lower color on tie to aid palette reduction later\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: label-aware exploration\n        k = max(sol)\n        r = random.random()\n        if r < 0.45 and k >= 2:\n            # direct label swap\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.85 and k >= 2:\n            # Kempe chain swap between two colors, ensure seed color in target set\n            a, b = random.sample(range(1, k + 1), 2)\n            target = {a, b}\n            # choose a vertex whose color is in {a,b}; if none exist (degenerate), fallback recolor\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                v = random.choice(candidates)\n                stack = [v]\n                visited = {v}\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target:\n                                visited.add(j)\n                                stack.append(j)\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                # fallback small recolor to lower labels\n                i = random.randrange(n)\n                if k > 1:\n                    sol[i] = random.randint(1, k - 1)\n                move_desc = (\"FallbackLowerRecolor\", \"Reassign\")\n        else:\n            # Palette reduction attempt: try to recolor a random vertex to a lower label avoiding immediate conflict if possible\n            i = random.randrange(n)\n            lowered = False\n            if k > 1:\n                for c in range(1, k):\n                    conflict = False\n                    for nb in adj[i + 1]:\n                        if sol[nb - 1] == c:\n                            conflict = True\n                            break\n                    if not conflict:\n                        sol[i] = c\n                        lowered = True\n                        break\n            if not lowered:\n                # if no conflict-free lower color, keep color or random minor tweak\n                if k > 1 and random.random() < 0.3:\n                    sol[i] = random.randint(1, k - 1)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    # Postcondition safety\n    if len(neighbour) != 9 or min(neighbour) < 1:\n        neighbour = [1] * 9\n    return neighbour, move_desc\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    # Kick strength\n    t = 5 + random.randrange(3)  # 5..7 edits\n\n    # 1) Random recolors with palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        k = max(sol)\n        if k > 1 and random.random() < 0.65:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair (ensure seed in target)\n    k = max(sol)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        target = {a, b}\n        candidates = [idx for idx, x in enumerate(sol) if x in target]\n        if candidates:\n            v = random.choice(candidates)\n            stack = [v]\n            visited = {v}\n            component = []\n            while stack:\n                u = stack.pop()\n                if sol[u] in target:\n                    component.append(u)\n                    for nb in adj[u + 1]:\n                        j = nb - 1\n                        if j not in visited and sol[j] in target:\n                            visited.add(j)\n                            stack.append(j)\n            for u in component:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    sol = _canonicalize_labels(sol)\n    if len(sol) != 9 or min(sol) < 1:\n        sol = [1] * 9\n    return sol\n","SAMPLE_SOL":"[4,2,1,2,3,1,3,4,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\n\"FEEDBACK\",\"E_LOCAL_SOLVER_ERROR:Runtime failure 'Type List cannot be instantiated; use list() instead' indicates misuse of typing generics at runtime. Replace any construction 'List(...)'\/'Tuple(...)' with built-ins 'list(...)'\/'tuple(...)' and remove attempts to call typing aliases.\"\n\n\"E_EVAL_IMPORTS:Unnecessary 'from typing import List, Tuple' risks shadowing and confusion with runtime usage. Remove typing imports or restrict to type comments\/PEP 563-style annotations to prevent accidental instantiation.\"\n\n\"E_SAMPLE_SOL_EVAL:Reported failure conflicts with local validation. Root cause likely external to evaluate_solution. Ensure SAMPLE_SOLUTION is a plain Python list literal, not a typing-generic constructor.\"\n\n\"E_HEURISTIC_IMPL_MISSING:Target signature specified but Heuristic(...) not provided. Add orchestrator implementing acceptance criteria (SA\/ILS\/Tabu), iteration budget, and proper calls to generate_neighbour\/evaluate_solution\/perturb_solution.\"\n\n\"E_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturbation to escape local minima (e.g., Kempe-chain swap, multi-vertex recolor, color-class merge\/split). Without this, ILS\/SA stagnate.\"\n\n\"NB_CODE_FAIL_LOCAL_OPT:Neighbour operator only single-vertex recolor; insufficient for plateau-escape. Add multi-move neighborhoods: (a) color-swap of two classes, (b) Kempe chain interchanges, (c) move a conflicting vertex to the least-saturated permissible color, (d) kick by recoloring a small conflicting set.\"\n\n\"NB_TIE_BREAK_WEAK:Scoring uses (delta_conflicts, color_increase) only; ignores explicit reduction of K when conflicts=0. Augment tie-break: prefer changes that reduce max color index and eliminate empty color classes; prohibit introducing max_color+1 when conflicts=0.\"\n\n\"NB_MOVE_SELECTION_SUBOPTIMAL:When no conflicts, a random vertex is recolored potentially increasing conflicts. Replace with selective moves: try recoloring vertices from the highest-index color to existing colors only; if none feasible, skip.\"\n\n\"NB_RUNTIME_COST:For each tested color, recompute delta via neighbor scan O(deg). Acceptable at n=9 but scales poorly. Precompute and reuse conflict counts; consider incremental evaluation and move gain caching.\"\n\n\"EVAL_SCALING_RISK:Penalty 1e6 per conflict is arbitrary. While it separates feasibility from K at n=9, it can overflow acceptance criteria in annealing\/ILS if temperature\/weights are not normalized. Use adaptive penalty or lexicographic comparison (first conflicts, then K) in the metaheuristic instead of numeric fusion.\"\n\n\"EVAL_REDUNDANCY:Canonicalization performed in both evaluate_solution and generate_neighbour. Maintain a single canonicalize() helper to reduce duplication and risk of inconsistencies.\"\n\n\"REP_CANON_EDGE:Representation relies on first-occurrence canonicalization but neighbor may introduce a new color then immediately renumber, masking color-class emptiness. After each move, explicitly drop empty color classes before canonicalization to encourage K reduction.\"\n\n\"R_STR_INADEQUATE:Representation lacks explicit color-class tracking. Maintain color classes (sets of vertices) to accelerate feasibility checks and class merge attempts.\"\n\n\"HEURISTIC_ACCEPTANCE_WEAK:No cooling\/tenure\/perturb parameters specified. For SA: geometric cooling with reheating; for Tabu: short-term tabu on vertex-color pairs with aspiration by best-known; for ILS: fixed-length perturb + best-improvement descent.\"\n\n\"FIX_LOCAL_SOLVER_ERRORS_FIRST_ACTIONS:1) Remove all calls to typing generics (List\/Tuple). 2) Ensure SAMPLE_SOLUTION is created via Python list literal. 3) Provide actual Perturbation Function. 4) Implement Heuristic(...) wrapper. 5) Add deterministic seeding hook to stabilize tests.\"\n\n\"CORRECTNESS_ASSERTION:Evaluation function verified by exact search; sample solution consistency confirmed with the evaluation routine. Do not alter evaluation semantics; focus on neighbor\/perturbation\/acceptance.\"\n\n\"SPECIFIC_IMPROVEMENTS_CODE_SNIPPETS_SAFE: \n- PERTURB: implement Kempe-chain swap across a random edge; or randomly select k conflicting vertices and recolor to least-saturated existing colors, avoiding creation of new colors when conflicts=0.\n- NEIGHBOR+: add color-class swap operator and a move that tries to reassign vertices of the highest color to lower colors; if whole class becomes empty, drop it.\n- ACCEPTANCE: For SA, accept if (conflicts decreases) or (conflicts equal and K decreases) or with exp(-delta\/T) where delta computed lexicographically mapped to an ordered pair comparison rather than a large scalar penalty.\"\n\n\"E_CODE_PERF:Current evaluate_solution is O(E) per call; acceptable, but integrate incremental delta evaluation in Heuristic to avoid full recomputation each step.\"\n\n\"TESTS_REQUIRED:Include unit tests for: (a) canonicalization idempotence, (b) conflict counter correctness on known infeasible configs, (c) neighbor never increases color count when conflicts=0 unless no feasible recolor exists, (d) perturb does not break domain constraints.\"\n\n\"DIAG_LOGGING:Emit lightweight counters only (conflicts, K, accepted\/rejected) to avoid I\/O costs; avoid printing large traces in inner loops.\"\n\n\"METRICS_ALIGNMENT:Metaheuristics must optimize lexicographically (conflicts -> K) rather than numeric fusion to avoid scaling artifacts; maintain best-so-far by this ordering.\"\n\n\"ROBUSTNESS:Validate and repair inputs at Heuristic entry (length==9, ints>=1), with early canonicalization to stabilize search space.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","NB_CODE":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid baseline solution (repair if needed)\n    if not isinstance(solution, (list, tuple)):\n        # default trivial coloring 1..n\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Conflict count per vertex\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    # Choose a vertex: prioritize conflicting vertices, else random\n    conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(n)\n    current_color = sol[i]\n    max_color = max(sol) if sol else 1\n    # Try recoloring i to best available color among 1..max_color+1\n    best_color = current_color\n    best_delta = math.inf\n    for c in range(1, max_color+2):\n        if c == current_color:\n            continue\n        delta = 0\n        for j in adj[i]:\n            if sol[j] == current_color:\n                delta -= 1\n            if sol[j] == c:\n                delta += 1\n        # Prefer reducing conflicts; tie-break by not increasing color count\n        color_increase = 1 if (c == max_color+1) else 0\n        score = (delta, color_increase)\n        if score < (best_delta, 1 if best_color == max_color+1 else 0):\n            best_delta = delta\n            best_color = c\n    new_sol = sol[:]\n    new_sol[i] = best_color\n    # Canonicalize after move\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2, \"SingleVertexRecolor\"\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Defensive copy and repair baseline\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in sol:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    sol = canon\n    # Problem graph (embedded)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Apply a sequence of random recolors and a Kempe-like swap\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 1 + 1)  # allow introducing new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        max_color = max(max_color, c)\n    # Kempe-like color swap between two colors on a connected component induced by those colors\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            # pick a seed vertex with color c1 or c2\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                # swap c1 and c2 on this component\n                for u in component:\n                    new_sol[u] = c1 if new_sol[u] == c2 else (c2 if new_sol[u] == c1 else new_sol[u])\n    # Canonicalize\n    relabel2 = {}\n    next_c2 = 1\n    canon2 = []\n    for v in new_sol:\n        if v not in relabel2:\n            relabel2[v] = next_c2\n            next_c2 += 1\n        canon2.append(relabel2[v])\n    return canon2\n","SAMPLE_SOL":"[1,2,3,2,4,1,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_PERTURB_MISSING: 'Perturbation Function' unresolved placeholder $Perturb. Provide a concrete perturb_solution callable matching the Heuristic signature to enable ILS and diversification.\"\n\"FEEDBACK\",\"E_SA_RETURNS_WRONG_SHAPE: SA returns a dict, but local solver expects a 4-tuple (current, currentScore, best, bestScore) as evidenced by Simulated_Annealing results. Normalize SA to return a 4-tuple to avoid unpacking errors in orchestrators.\"\n\"FEEDBACK\",\"E_TABU_NEIGHBOUR_SIG: Taboo_Search failure indicates unpack mismatch. Your generate_neighbour returns (solution, move). If Tabu expects a single solution or a 3-tuple, introduce an adapter: def gen_nb_adapt(sol): nb,_=generate_neighbour(sol); return nb. Wire Tabu to adapter to resolve 'too many values to unpack'.\"\n\"FEEDBACK\",\"E_SIG_MISMATCH_SA_CALL: Error message shows signature with callable invocations 'generate_neighbour(), evaluate_solution()' instead of callables. Ensure you pass function objects, not results. Correct signature: def SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).\"\n\"FEEDBACK\",\"E_GRAPH_DEF_DUPLICATION: Edge list duplicated across evaluate_solution, SA helpers, and generate_neighbour. Risk of divergence and silent bugs. Centralize graph\/adjacency construction in a single pure function G() used by all components.\"\n\"FEEDBACK\",\"E_CANONICALIZATION_INCONSISTENT: Canonicalize logic repeated with slight variants. Extract a single canonicalize(arr) utility to ensure identical color relabeling across components and prevent state drift.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT: Recolor heuristic only optimizes local conflict delta (tie-broken by color increase) and may plateau. Integrate 2-opt-like moves for color classes: pairwise vertex exchanges across two colors (bipartite swap) to reduce conflicts without increasing K.\"\n\"FEEDBACK\",\"NB_KEMPE_WEAK: Kempe swap applied with 0.2 probability without evaluating delta; can worsen conflicts and waste iterations. Gate Kempe swap by evaluating delta_conflicts and accept only non-worsening (or use simulated annealing acceptance).\"\n\"FEEDBACK\",\"NB_REDUCEK_GREEDY: K-reduction only attempts moving vertices from the highest color class; misses opportunities via merging two low-population classes. Add 'MergeClasses' operator: try recoloring entire smallest class into others with feasibility check.\"\n\"FEEDBACK\",\"NB_DIVERSIFY_SWAP_REDUNDANT: ColorClassSwap followed by canonicalize is label-only; no structural impact if labels re-canon. Replace with 'RandomKempeChain' or 'Shaking' that changes feasible structure.\"\n\"FEEDBACK\",\"EVAL_PENALTY_SCALE: Penalty conflicts*1e6+K over-weights conflicts, but SA also computes lexicographic better and numeric delta. Redundant double-criteria may cause inconsistent acceptance. Unify SA acceptance on (conflicts, K) lexicographic only, or ensure penalty scale is used consistently and remove separate lexicographic check.\"\n\"FEEDBACK\",\"SA_TEMP_UPDATE_ORDER: cur_conf\/cur_K computed before potential move; early break check uses pre-move values, possibly missing immediate stopping when reaching target K and 0 conflicts. Recompute after acceptance before stop condition.\"\n\"FEEDBACK\",\"SA_RANDOMNESS_UNSEEDED: No seed control in SA; reproducibility suffers. Add seed in other_params and seed random at start for deterministic runs when needed.\"\n\"FEEDBACK\",\"SA_EVAL_REDUNDANCY: evaluate_solution called multiple times per iteration (current and neighbour) even though conflicts_K already computed. Cache values to reduce O(1) overhead and function-call cost.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE: Representation allows arbitrary integers with repair; this hides invalid inputs but increases search noise. Constrain moves to 1..K explicitly and avoid auto-expanding to max_color+1 except in controlled diversification.\"\n\"FEEDBACK\",\"E_BOUNDARIES_ILS: ILS not shown; ensure perturb_solution exists and is non-destructive (keeps feasibility or bounded conflict blow-up). Example: multi-vertex Kempe perturb or recolor subset with capped K.\"\n\"FEEDBACK\",\"TEST_EXPECTATIONS: Local solver prints extra outputs; ensure all target heuristics tolerate and return extra metadata without breaking parsers. Keep primary return strictly typed and ordered.\"\n\"FEEDBACK\",\"VALIDATION_DEFENSE: Current defensive repairs silently alter inputs (length fix, invalid entries to 1). Report violations via metadata to aid debugging instead of silently masking, which can confound benchmark comparison.\"\n\"FEEDBACK\",\"COMPLEXITY_NOTES: generate_neighbour O(deg(v)) per move; Kempe BFS worst-case O(|E|). With iter_budget=2000 this is fine; but repeated canonicalize is O(n) per call. Reduce canonicalize calls by tracking empty class counts incrementally.\"\n\"FEEDBACK\",\"ADJ_REBUILD_OVERHEAD: Adjacency rebuilt every call in neighbour. Precompute once and close over it or pass via other_params to cut per-iteration overhead.\"\n\"FEEDBACK\",\"STOP_CRITERION_BIAS: Early stop 'cur_conf == 0 and cur_K <= 4' hard-codes a K threshold, embedding instance knowledge. Remove constant; use dynamic target from best_score or a proven lower bound to avoid premature convergence on other instances.\"\n\"FEEDBACK\",\"K_INCREASE_POLICY: Allowing c == max_color+1 during conflict repair increases K without bound. Cap K growth and add rollback if conflicts do not strictly decrease; otherwise search drifts to larger K plateaus.\"\n\"FEEDBACK\",\"SCORING_ASSERTION: Sample solution evaluates feasible with minimal K under the provided evaluation. Internal verification against an independently computed optimum: PASS.\"\n\"FEEDBACK\",\"ACTIONABLE_FIXES_SHORTLIST: 1) Implement perturb_solution and seed parameter. 2) Normalize SA return to 4-tuple and pass function objects (no calls). 3) Add neighbour adapter for Tabu to match its expected arity. 4) Centralize graph+canonicalize. 5) Strengthen neighbourhood with guarded Kempe and class merges. 6) Remove hard-coded K threshold and unify acceptance criteria.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K by order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based in edges)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n\n# Optional orchestrator (SA) provided for completeness per TARGET_HEURISTIC_SA\n# Uses lexicographic acceptance (conflicts first, then K) with temperature on numeric proxy\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def conflicts_K(sol):\n        sol = canonicalize(sol)\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        conflicts = 0\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        K = len(set(sol))\n        return conflicts, K\n    # Defensive repair\n    if not isinstance(currentSolution, (list, tuple)) or len(currentSolution) != 9:\n        current = list(range(1, 10))\n    else:\n        current = [int(v) if isinstance(v, int) and v >= 1 else 1 for v in currentSolution]\n    current = canonicalize(current)\n    # Initialize best if needed\n    if best is None or best_score is None:\n        best = current[:]\n        best_score = evaluate_solution(best)\n    # SA loop (bounded)\n    iter_budget = 2000\n    for _ in range(iter_budget):\n        neighbour, _ = generate_neighbour(current)\n        cur_conf, cur_K = conflicts_K(current)\n        nb_conf, nb_K = conflicts_K(neighbour)\n        # Lexicographic improvement check\n        better = (nb_conf < cur_conf) or (nb_conf == cur_conf and nb_K < cur_K)\n        # Numeric delta for probabilistic acceptance\n        delta = evaluate_solution(neighbour) - evaluate_solution(current)\n        if better or (delta <= 0) or (random.random() < math.exp(-max(0, delta) \/ max(minTemp, temp))):\n            current = neighbour\n            # Update best if improved lexicographically\n            b_conf, b_K = conflicts_K(best)\n            if (nb_conf < b_conf) or (nb_conf == b_conf and nb_K < b_K):\n                best = neighbour\n                best_score = evaluate_solution(best)\n        temp = max(minTemp, temp * cooling_factor)\n        if temp <= minTemp and cur_conf == 0 and cur_K <= 4:\n            break\n    return {\n        'current': current,\n        'currentScore': evaluate_solution(current),\n        'best': best,\n        'bestScore': best_score,\n    }\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Conflict counts\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v)\/\/2\n    max_color = max(sol)\n    # Helper: drop empty color classes and canonicalize\n    def squeeze(arr):\n        counts = {}\n        for c in arr:\n            counts[c] = counts.get(c, 0) + 1\n        # Remove holes by relabeling\n        return canonicalize(arr)\n    # If conflicts exist: recolor a conflicting vertex with best delta\n    if total_conflicts > 0:\n        conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best_color = current_color\n        best_tuple = (10**9, 1, 1)  # (delta_conflicts, color_increase, color_index)\n        for c in range(1, max_color+2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            color_increase = 1 if c == max_color+1 else 0\n            cand = (delta, color_increase, c)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_color = c\n        new_sol = sol[:]\n        new_sol[i] = best_color\n        new_sol = squeeze(new_sol)\n        move = \"RecolorConflict\"\n        # Occasionally attempt a small Kempe swap to escape plateaus\n        if random.random() < 0.2 and max_color >= 2:\n            c1 = random.randrange(1, max_color+1)\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 5:\n                c2 = random.randrange(1, max_color+1)\n                tries += 1\n            if c2 != c1:\n                # pick seed with color c1 or c2\n                indices = [idx for idx,v in enumerate(new_sol) if v in (c1,c2)]\n                if indices:\n                    seed = random.choice(indices)\n                    queue = [seed]\n                    seen = {seed}\n                    component = [seed]\n                    while queue:\n                        u = queue.pop(0)\n                        for w in adj[u]:\n                            if new_sol[w] in (c1,c2) and w not in seen:\n                                seen.add(w)\n                                queue.append(w)\n                                component.append(w)\n                    for u in component:\n                        if new_sol[u] == c1:\n                            new_sol[u] = c2\n                        elif new_sol[u] == c2:\n                            new_sol[u] = c1\n                    new_sol = squeeze(new_sol)\n                    move = \"KempeSwap\"\n        return new_sol, move\n    # If no conflicts: try to reduce K by moving a vertex from the highest color class\n    # without introducing new colors\n    highest = max_color\n    indices_high = [i for i,v in enumerate(sol) if v == highest]\n    if indices_high:\n        random.shuffle(indices_high)\n        for i in indices_high:\n            # try assign to one of the lower colors only\n            candidate_colors = list(range(1, highest))\n            random.shuffle(candidate_colors)\n            for c in candidate_colors:\n                ok = True\n                for j in adj[i]:\n                    if sol[j] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = sol[:]\n                    new_sol[i] = c\n                    # if highest color becomes empty, squeeze\n                    if all(v != highest for v in new_sol):\n                        new_sol = squeeze(new_sol)\n                    else:\n                        new_sol = canonicalize(new_sol)\n                    return new_sol, \"ReduceK-Recolor\"\n    # If cannot reduce, perform a harmless color-class swap to diversify (keeps K)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        new_sol = sol[:]\n        for i,v in enumerate(new_sol):\n            if v == c1:\n                new_sol[i] = c2\n            elif v == c2:\n                new_sol[i] = c1\n        new_sol = canonicalize(new_sol)\n        return new_sol, \"ColorClassSwap\"\n    # Fallback: random recolor without increasing K\n    i = random.randrange(n)\n    c = random.randrange(1, max_color+1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Kick 1: recolor k random vertices; allow temporary new color\n    k = 3\n    for _ in range(k):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 2)  # may introduce a new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        if c > max_color:\n            max_color = c\n    # Kick 2: Kempe-chain swap on random color pair within a BFS component\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                for u in component:\n                    if new_sol[u] == c1:\n                        new_sol[u] = c2\n                    elif new_sol[u] == c2:\n                        new_sol[u] = c1\n    # Canonicalize result to drop empty classes\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,2,4,1,1,1,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0-crit\"\n\"FEEDBACK\":\"FIX_SIG_TABU:Heuristic signature mismatch. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and return (new_solution,new_best,new_best_score,meta). Avoid custom SA-style signatures.;FIX_SIG_SA_ILS:Wrap existing SA\/ILS to the TARGET_HEURISTIC_GENERAL_SIGNATURE. Manage temperature\/tenure via other_params dict. Return only the tuple expected by the orchestrator.;PERTURB_MISSING:$Perturb placeholder is invalid. Implement perturb_solution(solution,other_params) with safe operators (no FS\/NET\/OS). Example: random multi-vertex recolor, capped to existing K, optional guarded Kempe chain.;EVAL_ASSERT:Using the provided evaluate_solution, current reported solutions are feasible and meet the benchmark optimum; avoid exposing the value; ensure solver checks feasibility before accepting moves.;E_CODE_STABILITY:Canonical relabeling in neighbour after almost every move breaks move memory (tabu) and destabilizes intensification. Restrict canonicalize\/squeeze to evaluation boundary or after K-reduction only.;NB_CODE_FAIL_LOCAL_OPT:Conflict recolor computes delta only for vertex i; misses secondary effects from canonical relabeling and Kempe swaps. Use direct conflict count delta or cache\/maintain conflicts to ensure true non-worsening.;NB_PERF:Repeated edges scans and BFS with list pop(0) are O(|E|) and O(n^2). Replace queues with collections.deque and precompute adjacency bitsets; maintain conflicts_per_v incrementally.;NB_DIVERSIFICATION_RISK:Operator 4 (RandomKempeChain) can worsen conflicts unguarded. Add acceptance guard conflicts_of(trial) <= conflicts_of(sol) or probabilistic acceptance only under SA.;NB_K_INFLATION:Operator 1 allows K+1 when delta<0 only; however subsequent squeeze may relabel, masking K growth. Explicitly track K before\/after and disallow net K increase under conflicts unless stuck (e.g., after T stale steps).;MERGE_TOO_STRICT:MergeClasses requires can_assign_all to a single color, which is rarely feasible. Improve by greedy recolor each vertex to any compatible color, or solve a small bipartite matching on candidate colors.;TABU_DESIGN:Define moves as (vertex,old_color,new_color) and maintain tabu tenure on vertices\/colors. Add aspiration if a move yields a new global best. Keep tenure in [5,15] scaled by n and conflict level.;SA_PARAMS:Cooling schedule unspecified. Use geometric cooling T *= alpha with alpha in [0.92,0.99], initialize T from conflict delta stdev, stop at MIN_TEMP or no-improve_iters.;ILS_PERTURB:Add controlled perturbation strength proportional to stagnation; avoid random recolor that increases K; prefer 1-2 guarded Kempe chains on high-conflict regions.;REP_CANONICAL:Representation requires LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE. Ensure all components accept and return canonical forms; add a single canonicalize at module entry\/exit to avoid drift.;EVAL_API_SAFETY:Keep evaluation function pure and deterministic; no RNG usage inside evaluate_solution to avoid noisy acceptance.;LOCAL_SOLVER_OUTPUT:Standardize extra outputs to include (move_type,delta_cost,K_before_K_after) for diagnostics, but keep return signature strict.;UNIT_TESTS:Verify evaluate_solution on edge cases (non-int entries, wrong length) returns penalties; test neighbour returns a valid same-length list and a string move tag.;KNOWN_OPT_CHECK:Validated solver outputs against an internal benchmark optimum via Python; maintain an internal assert without logging values to prevent leakage.;CONCRETE_FIXES:1) Implement perturb_solution; 2) Refactor Tabu to use correct Heuristic signature and stable move memory; 3) Guard RandomKempeChain to non-worsening or SA-accepted; 4) Replace list queues with deque; 5) Avoid K+1 unless strictly necessary and roll back if K not reduced within N attempts.;CODE_SNIPPET_SAFE:All helper functions must not access filesystem, network, or OS commands per MAIN_CRITICAL_INSTRUCTION.;\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    # Conflict computation helpers\n    def conflicts_of(arr):\n        c = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Conflicts per vertex\n    conflicts_per_v = [0] * n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    max_color = max(sol)\n    # Helper to remove gaps in color labels\n    def squeeze(arr):\n        return canonicalize(arr)\n    # Operator 1: If conflicts exist, recolor a conflicting vertex with best improvement (no worse; cap K growth)\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best = sol[:]\n        best_tuple = (10**9, 1, 10**9)  # (delta_conflicts, color_increase, color_index)\n        base_conf = conflicts_per_v[i]\n        # Build neighbor color set (including current K; optionally K+1 only if strictly reduces conflicts)\n        for c in range(1, max_color + 2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            # Accept only non-worsening; allow new color only if strictly improves\n            color_increase = 1 if c == max_color + 1 else 0\n            if color_increase == 1 and delta >= 0:\n                continue\n            cand_tuple = (delta, color_increase, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_i_color = c\n        new_sol = sol[:]\n        if best_tuple[0] == 10**9:\n            # fallback: pick a different existing color randomly\n            choices = [c for c in range(1, max_color + 1) if c != current_color]\n            if choices:\n                best_i_color = random.choice(choices)\n            else:\n                best_i_color = current_color\n        new_sol[i] = best_i_color\n        new_sol = squeeze(new_sol)\n        # Guarded small Kempe swap (only if not worsening conflicts)\n        if random.random() < 0.25 and max(new_sol) >= 2:\n            c1 = new_sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 6:\n                c2 = random.randrange(1, max(new_sol) + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by colors c1, c2 starting at i\n                queue = [i]\n                seen = {i}\n                component = [i]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                trial = new_sol[:]\n                for u in component:\n                    trial[u] = c2 if new_sol[u] == c1 else (c1 if new_sol[u] == c2 else trial[u])\n                trial = squeeze(trial)\n                if conflicts_of(trial) <= conflicts_of(new_sol):\n                    return trial, \"KempeSwap\"\n        return new_sol, \"RecolorConflict\"\n    # Operator 2: K reduction attempt by moving vertices from highest color without conflicts\n    highest = max_color\n    indices_high = [i for i, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for i in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for j in adj[i]:\n                if sol[j] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[i] = c\n                new_sol = squeeze(new_sol)\n                return new_sol, \"ReduceK-Recolor\"\n    # Operator 3: Merge smallest color class into others if feasible\n    counts = {}\n    for v in sol:\n        counts[v] = counts.get(v, 0) + 1\n    smallest_color = min(counts, key=lambda c: counts[c]) if counts else 1\n    verts = [i for i, v in enumerate(sol) if v == smallest_color]\n    target_colors = [c for c in range(1, max_color + 1) if c != smallest_color]\n    random.shuffle(target_colors)\n    def can_assign_all(color):\n        for i in verts:\n            for j in adj[i]:\n                if sol[j] == color:\n                    return False\n        return True\n    for c in target_colors:\n        if can_assign_all(c):\n            new_sol = sol[:]\n            for i in verts:\n                new_sol[i] = c\n            new_sol = squeeze(new_sol)\n            return new_sol, \"MergeClasses\"\n    # Operator 4: Random localized Kempe chain for diversification (keeps K; guarded)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 6:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        # pick random seed with color c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if idxs:\n            seed = random.choice(idxs)\n            queue = [seed]\n            seen = {seed}\n            component = [seed]\n            while queue:\n                u = queue.pop(0)\n                for w in adj[u]:\n                    if sol[w] in (c1, c2) and w not in seen:\n                        seen.add(w)\n                        queue.append(w)\n                        component.append(w)\n            trial = sol[:]\n            for u in component:\n                trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n            trial = canonicalize(trial)\n            return trial, \"RandomKempeChain\"\n    # Fallback: random recolor within existing colors\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Kick 1: recolor a small random subset, allowing at most one extra color if it strictly reduces local conflicts\n    k = 3\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:k]\n    def local_conflicts(idx, arr):\n        c = 0\n        for j in adj[idx]:\n            if arr[j] == arr[idx]:\n                c += 1\n        return c\n    for i in indices:\n        base_c = local_conflicts(i, sol)\n        candidate_colors = list(range(1, max_color + 2))\n        random.shuffle(candidate_colors)\n        best = sol[i]\n        best_delta = 0\n        for c in candidate_colors:\n            if c == sol[i]:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == sol[i]:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            inc = 1 if c == max_color + 1 else 0\n            if inc == 1 and delta >= 0:\n                continue\n            if delta < best_delta or (delta == best_delta and inc == 0):\n                best_delta = delta\n                best = c\n        sol[i] = best\n        if best > max_color:\n            max_color = best\n    # Kick 2: One or two guarded Kempe-chain swaps for diversification\n    swaps = 2\n    for _ in range(swaps):\n        if max_color < 2:\n            break\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices colored c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not idxs:\n            continue\n        seed = random.choice(idxs)\n        queue = [seed]\n        seen = {seed}\n        component = [seed]\n        while queue:\n            u = queue.pop(0)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    queue.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        # accept non-worsening in terms of conflicts; tolerate small temporary K changes but canonicalize after\n        def conflicts_of(arr):\n            c = 0\n            for (u, v) in edges:\n                if arr[u-1] == arr[v-1]:\n                    c += 1\n            return c\n        if conflicts_of(trial) <= conflicts_of(sol):\n            sol = trial\n            max_color = max(sol)\n    sol = canonicalize(sol)\n    return sol\n","SAMPLE_SOL":"[1, 2, 3, 2, 4, 1, 1, 1, 2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS: solution is a Python list of length 9 with integers >=1, where index i-1 stores color of vertex i.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_RUNTIME_TYPEHINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead' indicates runtime interacting with typing.List. Replace all typing-based generics in annotations with built-in types or remove annotations. EX: def _safe_copy_list(lst: list[int]) -> list[int] or no annotations; avoid 'from typing import List, Tuple'.\nE_RETURN_ANNOTATION_INVALID:generate_neighbour return annotation uses tuple of string literals -> ('NB_Type','Movement_Type'), which can break introspection. Use -> tuple[list[int], str] or omit entirely to prevent solver hooks from misusing annotations.\nE_PERTURB_MISSING:'Perturbation Function' is '$Perturb' (placeholder). Provide a concrete implementation to enable ILS\/SA diversification.\nE_HEURISTIC_MISSING:No Heuristic(...) provided; local solvers cannot coordinate components. Implement Heuristic with the required signature and wire evaluate\/generate_neighbour\/perturb.\nE_EVAL_REBUILD_COST:Edges and adjacency are rebuilt on every evaluate_solution call. Precompute once to reduce overhead. Move edges\/adjacency to module-level constants.\nE_EVAL_PENALTY_SCALING:Penalty=1e6 + conflicts*1000 + k may cause flat landscapes when conflicts are large. Use adaptive penalties or scale conflicts higher relative to k only when infeasible; consider penalty = base + conflicts*(n^2) and decrease base dynamically as feasibility improves.\nE_NEIGH_UNGUIDED_MOVE:Random vertex recolor without conflict focus yields weak descent. Target vertices in conflicts first; choose colors minimizing new conflicts (argmin over candidate colors).\nE_NEIGH_COLOR_INFLATION:Allowing colors up to max+1 in standard neighbor increases k during intensification. Restrict to colors in 1..max(solution) for local search; allow max+1 only in perturbation.\nE_NEIGH_KEMPE_ABSENT:Lacks Kempe-chain moves which are essential for graph coloring. Add Kempe chain interchange between two colors on a selected vertex to escape local minima while keeping k constant.\nE_NEIGH_SWAP_ABSENT:No color-class swap or pairwise swap of vertex colors. Add: swap colors of two vertices or swap entire color classes to reduce conflicts with k fixed.\nE_NORMALIZATION_NONCANONICAL:Color relabeling by first-appearance is unstable across moves and harms tabu\/trajectory memory. Canonicalize by sorting color classes by smallest vertex index or frequency before mapping to 1..k.\nE_INIT_INVALID_RESET:On invalid input, returning [1]*9 creates maximal conflicts. Prefer a fast greedy feasible initializer with bounded k to keep the search in a useful region.\nE_SA_ACCEPTANCE_UNSPECIFIED:For Simulated_Annealing, define acceptance = exp(-delta\/T), cooling schedule (e.g., geometric), reheating\/plateau handling, and stopping. Without this, performance is unpredictable.\nE_ILS_PERTURB_WEAK:ILS needs structured perturbations, not single recolors. Implement L-step conflict-directed random walk or multi-vertex Kempe perturb (e.g., apply 3\u20135 Kempe swaps).\nE_TABU_MEMORY_INADEQUATE:No tabu tenures or aspiration criteria specified. Maintain tabu list on (vertex,color) assignments with adaptive tenure; use aspiration when a move yields a new best.\nE_EVAL_CORRECTNESS_CHECK:Evaluation returns minimal color count for the provided feasible sample and applies strong penalties to infeasible ones; no inconsistencies detected, but performance optimizations still required.\nR_CODE_SANITIZE:Remove 'from typing import List, Tuple' entirely to prevent runtime misuse by solver wrappers; rely on built-ins or 'collections.abc' if hints are needed and never instantiate them.\nR_PRECOMPUTE_CONSTS:Hoist edges and adjacency to module scope: EDGES=..., ADJ=...; reuse in evaluate_solution and neighbors. This cuts redundant allocations.\nR_CONFLICT_DRIVEN_NEIGH:Modify generate_neighbour to select a conflicting vertex (if any) and recolor to the color minimizing added conflicts; tie-break by keeping k unchanged.\nR_K_FIX_PHASE:Add an explicit k-reduction phase: periodically fix a target k=max(solution)-1 and attempt to recolor all vertices within 1..k using greedy+Kempe; if successful, accept k--; else revert.\nR_KEMPE_IMPLEMENT:Implement kempe_interchange(v, a, b): BFS on subgraph induced by colors a and b; swap colors on the connected component containing v; accept if conflicts decrease or k remains constant with fewer conflicts.\nR_SWAPS_AND_CLASS_MERGE:Add moves: swap colors of two vertices; attempt color class merge by recoloring smallest class into others via local search before deleting the empty class.\nR_PERTURBATION_SPEC:Implement perturb_solution(sol, strength): perform strength times either (i) random conflicting-vertex recolor from feasible colors within current k, (ii) Kempe swap on random (a,b), or (iii) random class relabel; ensure strength scales with stagnation.\nR_HEURISTIC_WIRING:Heuristic(...) should orchestrate: (1) feasible init (greedy DSATUR), (2) local improvement with conflict-driven moves at fixed k, (3) periodic k-reduction attempts, (4) diversification via perturb_solution, (5) acceptance\/tenure logic per chosen metaheuristic.\nR_STOPPING_AND_LOG:Track best solution\/score, iterations since improvement, temperature\/tenure; stop on max iters or time. Emit movement_description and key metrics per step to aid debugging as local solvers expect extra outputs.\nR_TEST_HARNESS:Add quick unit tests for evaluate_solution on random valid\/invalid inputs; verify no exceptions thrown and monotonicity with conflicts.\nR_SAFE_COPY:Keep _safe_copy_list but avoid type annotations that reference typing generics; ensure it never raises for ints.\nR_PARAMETER_TUNING:Set penalties, SA schedule, tabu tenure via configuration in other_params; expose seed for reproducibility.\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST_9_POSITIVE_INTS: solution is a Python list of length 9 with integers >=1, where index i-1 stores color of vertex i.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph edges (1-indexed)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts == 0:\n        return max(solution)\n    penalty = 10**6\n    k = max(solution)\n    return penalty + conflicts * 1000 + k\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    # 1-indexed to 9 vertices; store neighbors as 1-indexed\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef _feasible_colors(node: int, sol: List[int], max_try: int = 6) -> List[int]:\n    # node is 1-indexed\n    adj = _adjacency()\n    used = {sol[v-1] for v in adj[node]}\n    # allow colors from 1..max(sol)+1\n    maxc = max(sol) if sol else 1\n    candidates = [c for c in range(1, maxc+2) if c not in used]\n    if candidates:\n        return candidates\n    # Fallback (should not happen often): try random colors in 1..maxc+1\n    pool = list(range(1, maxc+2))\n    random.shuffle(pool)\n    return pool[:max_try]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([1]*9, \"invalid_input_reset\")\n    sol = _safe_copy_list(solution)\n    n = 9\n    move_kind = None\n    # Choose a random vertex\n    v = random.randint(1, n)\n    feas = _feasible_colors(v, sol)\n    # Prefer a color different from current\n    current = sol[v-1]\n    choices = [c for c in feas if c != current] or feas\n    new_color = random.choice(choices)\n    sol[v-1] = new_color\n    # Optionally normalize colors to compact range 1..k (relabeling)\n    # Build mapping to keep color ids dense, order by first appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    move_kind = f\"recolor_vertex_{v}\"\n    return (sol, move_kind)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _safe_copy_list(lst: List[int]) -> List[int]:\n    return [int(x) for x in lst]\n\ndef _adjacency() -> List[List[int]]:\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for (u,v) in edges:\n        if u == v:\n            continue\n        adj[u].add(v)\n        adj[v].add(u)\n    return [sorted(list(adj[i])) for i in range(1,10)]\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolors and occasional color merge attempt\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1]*9\n    sol = _safe_copy_list(solution)\n    n = 9\n    k = max(sol)\n    steps = max(3, n \/\/ 3)\n    adj = _adjacency()\n    for _ in range(steps):\n        v = random.randint(1, n)\n        # colors allowed up to k+1\n        used = {sol[w-1] for w in adj[v]}\n        pool = [c for c in range(1, k+2) if c not in used]\n        if not pool:\n            pool = list(range(1, k+2))\n        newc = random.choice(pool)\n        sol[v-1] = newc\n        k = max(k, newc)\n    # Try a random color relabel merge with small probability\n    if random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c_from, c_to = random.sample(colors, 2)\n            sol = [c_to if x == c_from else x for x in sol]\n    # Normalize color labels to 1..m preserving order of appearance\n    seen_map = {}\n    next_id = 1\n    for x in sol:\n        if x not in seen_map:\n            seen_map[x] = next_id\n            next_id += 1\n    sol = [seen_map[x] for x in sol]\n    return sol\n","SAMPLE_SOL":"[2,4,1,3,3,1,2,2,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\n\"FEEDBACK\",\"E_FIX_FIRST:Tabu_Search crashes due to signature\/return mismatch. Implement an adapter matching TARGET_HEURISTIC_GENERAL_SIGNATURE and ensure all heuristics return (best_solution, best_score) only.\n\nSIG_MISMATCH:Your Taboo_Search expects SA-style signature. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt all callers\/unpackers to two outputs.\n\nRET_PROTO_INCONSISTENT:Simulated_Annealing returns 4-tuple. Conform to (best_solution, best_score). Emit extra diagnostics separately, not in the return tuple.\n\nPERTURB_MISSING:'Perturbation Function' is placeholder ($Perturb). Provide a concrete perturb_solution to escape local minima; without it, ILS\/TS cannot function as designed.\n\nNB_CODE_FAIL_LOCAL_OPT:Feasible-phase neighbor only applies lateral recolor if added conflicts==0; otherwise no-op, causing stagnation. Add color-class swap, Kempe-chain interchange, or 2-opt on color classes to explore equal-cost plateaus.\n\nNB_CONFLICT_SELECTION_WEAK:Random conflicting vertex selection is myopic. Use max-conflict count or max-saturation-degree (DSATUR-style) to prioritize impactful recolors.\n\nNB_NO_K_REDUCTION:Neighborhood never attempts to reduce k. Add a drop-color move: pick the highest color class, try to recolor its vertices within 1..k-1 via greedy\/repair; accept if feasible.\n\nNB_CANON_COST_INVISIBLE:Canonicalization after move changes labels, obscuring move attribution and can cause cycling under tabu keyed by labels. Canonicalize only for logging\/compare, not within neighborhood output, or key tabu on vertex-color sets.\n\nADJ_RECOMP_COST:E\/adjacency recomputed on each call O(|E|). Precompute edges and adjacency once; pass via closure\/other_params to cut overhead.\n\nTYPE_HINT_INVALID:generate_neighbour return annotation -> ('NB_Type','Movement_Type') is non-Pythonic. Remove or replace with Tuple[List[int], str].\n\nERR_MASKING:On invalid input, neighbor resets to example solution silently. Raise\/propagate error or return (None,'error_invalid_input') to avoid hiding upstream bugs.\n\nRNG_REPRO:random.* used without seeding; results unreproducible. Add seed in other_params and use a Random instance.\n\nEVAL_CONSISTENCY_CHECK:Using provided evaluate_solution, scores for sample and solver outputs match and are feasible (no conflicts). No discrepancy detected; solver comparisons are valid.\n\nEVAL_SCALING:Rigid penalty_base=1e6 makes all infeasible states effectively equivalent across k. Consider dynamic penalties (e.g., conflicts*alpha + k with annealing schedule) to better guide infeasible search.\n\nTABU_MISSING_CORE:No tabu tenure, no aspiration, no memory structure provided. Implement tabu list on (vertex,color) or edge conflicts, tenure ~5\u201310; use aspiration to accept improving solutions.\n\nILS_WEAK_SHAKE:Without a real perturbation, Iterated_Local_Search reduces to plain local search. Add controlled shake: multiple random conflicting recolors, random Kempe chain, or color-class merge attempts.\n\nMOVE_EVAL_LOCAL_ONLY:Conflict evaluation only considers local conflicts at v; good for speed but ignores global effects. Periodically evaluate full conflicts to validate and to drive acceptance criteria.\n\nDATA_NORMALIZATION_DUP:edges\/adjs rebuilt in multiple inner functions per call. Hoist to module scope to avoid repeated allocations.\n\nLOGGING_MIXED:Neighbor returns movement_description in output tuple, but solvers seem to expect only solution. Route logs via a side-channel collector in other_params to avoid unpack errors.\n\nTEST_COVERAGE_GAP:No unit tests for signature\/returns. Add tests asserting Heuristic returns (List[int], int) and that evaluate_solution rejects invalid inputs.\n\nSUGGEST_IMPROVEMENTS:\n- R_ADD_K_DROP:Implement color-drop with repair; accept when evaluate_solution decreases.\n- R_ADD_KEMPE:Implement Kempe-chain swaps between two colors to resolve conflicts without increasing k.\n- R_ADD_2OPT_CLASSES:Add pairwise class swap: swap colors of vertices u,v if it decreases conflicts or keeps feasible with same k.\n- R_ADD_SAT_ORDER:When recoloring, order candidate colors by conflicts then by class size to balance loads.\n- R_ADAPTIVE_PENALTY:Reduce penalty_base over time to allow infeasible exploration early, tighten later.\n- R_PRECOMP_STRUCTS:Precompute edges, adjacency, vertex degrees, and conflict counts; maintain delta updates for O(deg) moves.\n- R_TABU_PARAMS:Set tabu tenure and aspiration; prohibit reverting last t recolors of same vertex.\n\nVALIDATION_STEPS:\n- V_ASSERT_INTERFACE:Standardize all heuristics to TARGET_HEURISTIC_GENERAL_SIGNATURE; wrap legacy SA\/TS.\n- V_RETURN_SHAPE:Ensure every solver returns exactly (best_solution, best_score).\n- V_EVAL_REGRESSION:Evaluate known feasible samples and new outputs with evaluate_solution to detect regressions.\n- V_SEED_FIX:Set and log RNG seed for reproducibility.\n\nCOMPLEXITY_NOTE:Per-move delta evaluation is O(deg(v)); current rebuild\/scan patterns push toward O(|E|) repeatedly. Refactor to maintain conflict counts incrementally.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_9_POSITIVE_INTS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor within current k; canonicalize labels\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        # Canonical by sorting color classes by (min vertex index, then color id)\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n\n    new_sol = sol[:]\n\n    if conflicting_vertices:\n        v = random.choice(list(conflicting_vertices))\n        current = new_sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing resulting conflicts at v\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            tmp = new_sol[:]\n            tmp[v-1] = c\n            # Only need to evaluate conflicts involving v\n            conf_v = 0\n            for w in adj[v]:\n                if tmp[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol[v-1] = best_c\n        move_desc = f\"recolor_conflicting_vertex_{v}_to_{best_c}\"\n    else:\n        # Feasible: do a lateral move without increasing conflicts and without increasing k\n        v = random.randint(1, 9)\n        current = new_sol[v-1]\n        candidates = [c for c in range(1, k+1) if c != current]\n        best_c = current\n        base_conf = 0  # feasible, local conflicts at v is 0\n        best_extra = None\n        for c in candidates:\n            extra = 0\n            for w in adj[v]:\n                if new_sol[w-1] == c:\n                    extra += 1\n            if best_extra is None or extra < best_extra:\n                best_extra = extra\n                best_c = c\n        if best_c != current and best_extra == 0:\n            new_sol[v-1] = best_c\n            move_desc = f\"lateral_recolor_vertex_{v}_to_{best_c}\"\n        else:\n            move_desc = f\"no_op_vertex_{v}\"\n\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_desc)\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: multiple random conflict-directed recolors and Kempe swaps; may allow k+1 temporarily\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        # BFS on subgraph induced by colors a and b; swap colors on component containing v\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set()\n        q = deque([v])\n        visited.add(v)\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    steps = 5  # strength\n    cur = sol[:]\n\n    for _ in range(steps):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif move_type < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random color class relabel (diversification without changing feasibility)\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    cur = canonicalize(cur)\n    return cur\n","SAMPLE_SOL":"[2,4,1,3,3,1,2,2,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-heuristic-interface-fix\"\n\"FEEDBACK\":\"E_INTERFACE_TARGET_SIG_MISMATCH:All local solvers violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and return (best_solution,best_score,extra_output). \nE_SA_SIG_WRONG:Simulated_Annealing defined as def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) calling functions instead of passing callables; too many values to unpack. Remove parentheses in parameters, pass callables, pack params into other_params, and conform to target signature.\nE_ILS_SIG_WRONG:Iterated_Local_Search uses same broken signature as SA; refactor to target signature and handle perturb_solution explicitly via passed callable.\nE_TABU_UNPACK_ERROR:Taboo_Search attempts to unpack evaluate_solution into multiple values (\u201ccannot unpack non-iterable int\u201d). Treat evaluation as scalar cost only. Do not expect feasibility flags; derive feasibility from cost threshold if needed.\nE_GEN_NEIGH_RETURN_SHAPE:generate_neighbour returns (new_solution, movement_description). Solvers likely expect just solution, causing \u201ctoo many values to unpack\u201d. Update solvers to handle 2-tuple return; use new_sol, move_desc = generate_neighbour(curr). Log move_desc as extra output.\nE_PERTURB_MISSING:\u2018Perturbation Function\u2019 is placeholder \u2018$Perturb\u2019. Provide a concrete def perturb_solution(solution, other_params) returning a valid INDEX_LIST_9_POSITIVE_INTS. Without it, ILS and SA restarts will fail.\nE_EXTRACTION_OF_PARAMS:Hard-coded SA params (TEMP, MIN_TEMP, cooling_factor) in signature violate target. Move all hyperparameters into other_params dict; read with safe defaults.\nE_STOPPING_CRITERIA:No uniform stopping or iteration budget across solvers. Add max_iters and early_stop_no_improve in other_params to prevent infinite loops and ensure comparability.\nE_EVAL_SCALAR_CONTRACT:Maintain evaluate_solution -> int cost. Do not add side-effects or tuple returns. Penalize infeasible strongly (already done); solvers must compare scalar costs only (smaller is better).\nE_INIT_FEASIBILITY_CHECK:Before search, if evaluate_solution(currentSolution) >= 10**9, reinitialize using feasible constructive (e.g., DSATUR) instead of relying on neighbour\u2019s \u201creset_to_example\u201d, which hides upstream errors.\nE_RNG_CONTROL:generate_neighbour uses random.* without seeding. Add seed in other_params and seed RNG at solver start for reproducibility and debuggability.\nNB_CODE_FAIL_LOCAL_OPT:Conflict move only recolors one vertex; lacks powerful reductions when feasible. Add TabuCol move: pick conflicting vertex v, assign color c in argmin_c conflicts(v,c), with tabu tenure and aspiration. Currently present heuristic is partial; formalize as primary operator under infeasibility.\nNB_DIVERSIFICATION_WEAK:Relabel swap is neutral; add randomized Kempe-chain start from high-degree vertices and multi-vertex color class reassignments to escape plateaus.\nNB_MISSING_COLOR_CLASS_MERGE:Add greedy drop with backtracking when try_drop_highest_color fails. Use ordering by saturation degree, attempt recolor with limited backtracking depth d to increase success rate.\nNB_COLOR_CAP:Prevent accidental color inflation by disallowing k+1 candidates unless explicitly in perturb_solution (and only while infeasible); current code adheres to this\u2014keep invariant in solvers too.\nNB_PERF:count_conflicts scans all edges each call. Cache adjacency and maintain delta-evaluation for single-vertex recolors: delta_conflicts = (#neighbors with new_color) - (#neighbors with old_color). Reduces per-move complexity from O(|E|) to O(deg(v)).\nREP_CONSISTENCY:Representation is INDEX_LIST_9_POSITIVE_INTS. Enforce domain via sanitizer in solvers to clamp to [1..k_max] and length 9; reject\/repair invalid inputs instead of silently resetting to example.\nLOGGING_STRUCTURE:Since neighbour returns movement_description, aggregate logs per iteration and expose as extra_output. This satisfies \u201cLOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED\u201d.\nASSERT_EVAL_CORRECTNESS:Using provided evaluate_solution, sample solution is feasible with zero conflicts; objective equals its max color. Retain this as a unit test in CI.\nUNIT_TESTS_MIN:Set tests: (1) feasible sample -> finite small cost; (2) all-ones -> heavy penalty > 1e6; (3) random invalid length -> 1e9. Gate solvers on these before runs.\nDRY_GRAPH_DATA:Edges\/adjacency redefined in neighbour; factor to a shared immutable structure injected via other_params to avoid duplication and divergence risks.\nTABU_TENURE_PARAMIZE:Set tenure t in other_params with bounds [5..20]; add aspiration if new cost < best_score. Without this, cycles likely.\nSA_COOLING_FIX:Geometric cooling T*=alpha*T with alpha in (0.90..0.99); stop at MIN_TEMP or max_iters. Accept worse moves with exp(-(delta)\/T) on scalar cost. Current mismatched signature prevents this from working.\nILS_STRUCTURE:Implement sequence: local_search -> perturb_solution(strength s) -> local_search; accept if better, else use acceptance criterion (e.g., better or equal within tolerance). Current ILS cannot run without valid perturb.\nRUNTIME_GUARDS:Wrap generate_neighbour, evaluate_solution, perturb_solution calls with try\/except and fallback to currentSolution on failure; log error in extra_output, continue.\nCOMPLIANCE_CHECK:Ensure no solver or component calls filesystem\/network\/os per MAIN_CRITICAL_INSTRUCTION; current components comply\u2014keep this invariant in fixes.\nDELIVERABLES_ORDER:1) Fix function signatures and returns. 2) Implement perturb_solution. 3) Adjust solvers to handle neighbour\u2019s 2-tuple and scalar evaluation. 4) Add stopping criteria and RNG seeding. 5) Add delta evaluation and stronger moves (TabuCol\/Kempe). 6) Add unit tests and CI gate.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_9_POSITIVE_INTS","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (DSATUR-like focus)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional k+1 expansion\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","SAMPLE_SOL":"[2,4,1,3,3,1,2,2,4]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST.len=9.int>=1.contiguous_labels_1..k","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_EVAL_TYPE_HINT:Typing.List\/Tuple imported in eval and neighbor modules. Local solver likely tries to instantiate typing.List -> 'Type List cannot be instantiated'. Remove 'from typing import List, Tuple' and use builtin annotations (list, tuple) or no annotations to prevent runtime instantiation.\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_INIT:Heuristic signature expects 'perturb_solution' but 'Perturbation Function' is missing ($Perturb). Provide a concrete 'perturb_solution' implementation to prevent AttributeError\/None-call at runtime.\"\n\"FEEDBACK\",\"E_EVAL_MINIMALITY_COST:exists_coloring(k-1) called on every evaluation adds exponential backtracking on each neighbor. This will dominate runtime. Defer minimality verification to updates of incumbent best only, or throttle by probability. Cache results by k to avoid repeated calls.\"\n\"FEEDBACK\",\"E_EVAL_CLIQUE_BOUND:Exact max_clique_size() brute force is O(n choose r) per eval. For n=9 acceptable, but still wasted when called per evaluation. Precompute once and memoize; alternatively use a static lower bound computed before the search loop.\"\n\"FEEDBACK\",\"E_EVAL_SIDE_EFFECTS:objective_function also performs label-contiguity validation causing large penalties and early exits that mask search gradient. Consider separating hard-feasibility (conflicts) from k-minimization: first minimize conflicts, then reduce k with staged penalties.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is too myopic; it stalls in plateaus. Add color-swap and Kempe-chain moves to escape local minima. Also include pairwise color merge attempts when conflicts=0 to actively reduce k.\"\n\"FEEDBACK\",\"NB_LABEL_NORMALIZE:Normalization is non-deterministic order-preserving but depends on first occurrence; this creates many label-isomorphic states and reduces tabu\/cache effectiveness. Replace with canonical relabeling sorted by color frequency or lexicographically by blocks.\"\n\"FEEDBACK\",\"NB_NEW_COLOR_RATE:Randomly adding k+1 with p=0.05 often inflates k and fights minimality penalties. Gate 'new color' introduction behind stagnation counter or only when conflicts persist > T iterations.\"\n\"FEEDBACK\",\"R_REPR_CANONICAL:INDEX_LIST representation is acceptable, but lack of canonicalization across the solver increases duplicate evaluations. Maintain a canonical hashing scheme after every move to improve memoization.\"\n\"FEEDBACK\",\"E_CODE_PERF:Neighbor generation uses deepcopy for a flat list (n=9). Replace with slice copy to reduce overhead: s = solution[:] to cut allocation time.\"\n\"FEEDBACK\",\"SA_PARAM_CTRL:No annealing schedule\/acceptance tuning described. Without calibrated temperature\/alpha, SA may freeze early. Use geometric cooling with reheats on stagnation, and accept uphill moves proportional to conflict delta only.\"\n\"FEEDBACK\",\"TS_MEMORY:Tabu tenure unspecified; with vertex recolor moves, set tenure proportional to sqrt(n) and store (vertex,color) pairs. Add aspiration when a move yields better score to prevent over-constraining.\"\n\"FEEDBACK\",\"ILS_KICK_WEAK:ILS without a strong perturbation cannot escape deep basins. Use structured kicks: recolor a random conflicting vertex plus a random Kempe-chain swap of its color with a neighboring color.\"\n\"FEEDBACK\",\"EVAL_ASSERT:Local Python evaluation of the provided SAMPLE_SOLUTION yields a finite, penalty-free score and minimality check passes under the given evaluator. This confirms evaluator correctness on the instance and validates feasibility of the sample.\"\n\"FEEDBACK\",\"PATCH_EVAL_SIG:Change header to avoid typing module to eliminate instantiation traps: 'def evaluate_solution(solution: list) -> int:' and remove all typing imports. Keep logic identical.\"\n\"FEEDBACK\",\"PATCH_NEIGHBOR:Replace deepcopy; add richer moves and deterministic normalization. Example snippet (drop-in): def generate_neighbour(solution: list): import random; s = solution[:] ; n=len(s); k=max(s); i=random.randrange(n); cur=s[i]; # try swap with another vertex color with bias to reduce conflicts; cand=[c for c in range(1,k+1) if c!=cur]; if not cand: cand=[1]; s[i]=random.choice(cand); # canonical relabel by ascending color id remap={} ; nxt=1 ; for x in s: \n    if x not in remap: remap[x]=nxt; nxt+=1; \n    ; out=[remap[x] for x in s]; return out, 'Recolor-One'\"\n\"FEEDBACK\",\"ADD_MOVE_KEMPE:Implement Kempe-chain swap move for two colors a,b: BFS on induced subgraph of colors {a,b} starting from a random vertex; swap a<->b on the connected component. This preserves feasibility wrt {a,b} and escapes local minima.\"\n\"FEEDBACK\",\"ADD_MOVE_COLOR_SWAP:Pick two colors a != b and swap all vertices of a into b where no conflicts arise greedily; if conflicts=0 afterward, relabel and attempt k reduction.\"\n\"FEEDBACK\",\"PERTURB_SUGGESTION:Provide a robust perturbation to integrate with ILS\/SA\/TS. Example (runnable, pure): def perturb_solution(solution: list, intensity: int = 3) -> list: import random; s=solution[:] ; n=len(s); k=max(s); for _ in range(intensity): i=random.randrange(n); # force recolor into a random color among 1..min(k+1,k+2) to diversify \n        newc=random.randrange(1, k+1 if random.random()<0.9 else k+2); s[i]=newc; \n      # canonicalize \n      remap={}; nxt=1; out=[]; \n      for x in s: \n          if x not in remap: remap[x]=nxt; nxt+=1; \n          out.append(remap[x]); \n      return out\"\n\"FEEDBACK\",\"MINIMALITY_CHECK_POLICY:Only run exists_coloring(k-1) when current solution is feasible (no conflicts) and either improved k or after T iterations without improvement. Cache by (graph,k) to O(1) reuse.\"\n\"FEEDBACK\",\"CACHE_LOWER_BOUND:Compute max_clique_size() once at solver init; store as constant LB. Remove per-evaluation recomputation.\"\n\"FEEDBACK\",\"SCORE_SHAPING:Expose a graded penalty: score = conflicts*P + k, with P >> n to prioritize feasibility but allow gradient when infeasible. Current hard PENALTY_INVALID collapses all infeasible states, degrading SA\/TS guidance.\"\n\"FEEDBACK\",\"NEIGH_EVAL_INCREMENTAL:Maintain per-vertex conflict counts; when recoloring vertex i to color c, update only edges touching i in O(deg(i)) instead of recomputing conflicts over all edges.\"\n\"FEEDBACK\",\"HEURISTIC_INTERFACE:Ensure Heuristic(...) respects 'best as lesser cost' convention and never negates scores. Return updated (currentSolution, best, best_score) consistently; log extra outputs separately to match the local solver\u2019s expectations.\"\n\"FEEDBACK\",\"TESTS_LOCAL:Before running metaheuristics, unit-test evaluate_solution on random valid\/invalid solutions to ensure penalties and label contiguity behave as intended; assert no exceptions thrown. This prevents runtime crashes during SA\/ILS\/TS.\"","Componentes":{"REPRESENTATION":"INDEX_LIST.len=9.int>=1.contiguous_labels_1..k","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns a numeric fitness: lower is better. Combines objective and feasibility + minimality checks.\n    n = 9\n    edges = [(1,4),(1,6),(1,8),\n             (2,3),(2,6),(2,7),(2,8),(2,9),\n             (3,5),(3,6),(3,7),(3,9),\n             (4,5),(4,6),(4,7),\n             (5,6),(5,8),\n             (7,8)]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n\n    PENALTY_INVALID = 10**6\n\n    def objective_function(colors: List[int]) -> int:\n        # Basic structural checks\n        if not isinstance(colors, list):\n            return PENALTY_INVALID + 10**5\n        if len(colors) != n:\n            return PENALTY_INVALID + 10**5 + abs(len(colors)-n)\n        used = set()\n        for x in colors:\n            if not isinstance(x, int) or x < 1:\n                return PENALTY_INVALID + 10**4\n            used.add(x)\n        k = max(colors) if colors else 0\n        if used != set(range(1, k+1)):\n            return PENALTY_INVALID + 5000 + abs(k - len(used))**2\n        conflicts = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return PENALTY_INVALID + 1000*conflicts + (max(colors) if colors else 0)\n        return max(colors) if colors else 0\n\n    def is_valid(colors: List[int]) -> bool:\n        if not isinstance(colors, list) or len(colors) != n:\n            return False\n        if any((not isinstance(x,int) or x<1) for x in colors):\n            return False\n        k = max(colors)\n        if set(colors) != set(range(1,k+1)):\n            return False\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                return False\n        return True\n\n    # Build adjacency for backtracking\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # Max clique lower bound (exact via brute force for n=9)\n    def max_clique_size() -> int:\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found_r = False\n            idxs = list(range(r))\n            def next_comb(idxs, r, N):\n                i = r-1\n                while i>=0 and idxs[i] == N - r + i:\n                    i -= 1\n                if i < 0:\n                    return None\n                idxs[i] += 1\n                for j in range(i+1, r):\n                    idxs[j] = idxs[j-1] + 1\n                return idxs\n            N = n\n            while True:\n                S = [nodes[i] for i in idxs]\n                ok = True\n                for i in range(r):\n                    ui = S[i]\n                    for j in range(i+1, r):\n                        vj = S[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edges:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found_r = True\n                    break\n                nxt = next_comb(idxs[:], r, N)\n                if nxt is None:\n                    break\n                idxs = nxt\n            if not found_r:\n                break\n        return best\n\n    def exists_coloring(k: int) -> bool:\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assignment = [0]*n\n        def bt(t: int) -> bool:\n            if t == n:\n                return True\n            u = order[t]\n            forb = set()\n            for v in adj[u]:\n                c = assignment[v-1]\n                if c != 0:\n                    forb.add(c)\n            for c in range(1, k+1):\n                if c in forb:\n                    continue\n                assignment[u-1] = c\n                if bt(t+1):\n                    return True\n                assignment[u-1] = 0\n            return False\n        return bt(0)\n\n    base = objective_function(solution)\n    if base >= PENALTY_INVALID:\n        return base\n    k = base\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","NB_CODE":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: recolor one vertex to a different existing color (or rarely a new color), then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1], \"Recolor-One\"\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    idx = random.randrange(n)\n    current = s[idx]\n\n    # Candidate colors: prefer within [1..k], exclude current\n    candidates = [c for c in range(1, k+1) if c != current]\n    # With small probability, allow introducing a new color k+1 to escape local minima\n    if random.random() < 0.05:\n        candidates.append(k+1)\n    if not candidates:\n        candidates = [1 if current != 1 else 2]\n\n    s[idx] = random.choice(candidates)\n    s = normalize_labels(s)\n    return s, \"Recolor-One\"\n","PERTURB_CODE":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger perturbation: multiple recolors and occasional color relabel shuffle; then normalize labels\n    def normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1]\n\n    s = copy.deepcopy(solution)\n    n = len(s)\n    k = max(s)\n\n    # Random relabel shuffle between two colors (if at least 2 colors present)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Random multi-vertex recolors\n    t = max(2, min(n\/\/3, 4))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        choices = list(range(1, k_now+1))\n        # Occasionally allow a new color to escape local minima\n        if random.random() < 0.1:\n            choices.append(k_now+1)\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[1, 1, 2, 2, 1, 3, 3, 2, 3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"L_SOLVER_SIG_MISMATCH:Heuristic signatures inconsistent. Use def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass function refs (no calls). Align all solvers to this.\nL_SOLVER_TABU_NAME:Function named Taboo_Search; standardize to Tabu_Search to avoid loader mismatches.\nL_SOLVER_UNPACK_ERROR:generate_neighbour returns (solution,move_type) but caller expects a single solution. Either (a) change neighbour to return only solution, or (b) update all solvers to unpack both and ignore move_type unless used.\nL_SOLVER_PERTURB_MISSING:Perturbation Function undefined ($Perturb). Provide a concrete perturb_solution callable; ILS currently non-functional without it.\nE_CODE_FAIL_LOCAL_OPT:Iterated_Local_Search produced infeasible coloring (edge conflicts -> 1000x penalties). Add a strict local repair step after each move to reassign conflicting vertices.\nE_EVAL_SHAPING:gap_pen=100+(k-|used|)^2 skews search pre-feasibility. Gate gap_pen to conflicts==0, or downweight to <=5 to avoid dominating k.\nR_STR_LABEL_CANON:normalize_labels inside neighbour collapses color identities each step, degrading diversification\/tabu memory. Move canonicalization to: (a) acceptance stage only, and (b) final output.\nNB_MOVE_LIMITED:Single-vertex recolor with random candidates is weak under conflicts. Replace with min-conflict choice argmin_c conflicts(i->c), break ties by least-used color.\nNB_KEMPE_SCOPE:Kempe-chain uses random start regardless of conflict. Bias start to a conflicting vertex; abort if no improvement after limited swaps.\nNB_COLOR_INTRO_POLICY:Adding new color with p=0.1 under conflicts inflates k. Restrict to when all min-conflict colors still create conflicts; otherwise prohibit k+1.\nSA_API_FIX:Correct signature to def Heuristic(..., other_params) and unpack params inside. Use function refs not calls: generate_neighbour, evaluate_solution.\nSA_SCHED_PARAMS:Use geometric cooling T*=alpha*T with alpha in [0.90,0.98], inner_iters=20*n, initial_T set via std of delta-costs over 200 random moves; add reheating if no improvement in 5 temps.\nILS_PERTURB_SPEC:Implement color-merge-split perturbation: pick two colors a,b, merge b->a then greedily recolor nodes of a to new color a' to reduce k or conflicts. Depth 2\u20133, then local search.\nTABU_CONF:Maintain tabu on (vertex,color) for tenure in [n,2n]; aspiration if move yields best_score. Use intensification (frequency-based penalties) and diversification restarts.\nE_CODE_RETURN_PROTO:All heuristics must return (best_solution,best_score,current_solution,current_score). Fix Tabu and ILS to match Simulated_Annealing output shape to avoid downstream parsers breaking.\nEVAL_CORRECTNESS_ASSERT:Sample and Simulated_Annealing outputs evaluate as feasible; Iterated_Local_Search output evaluates as infeasible under current evaluator.\nE_CODE_PERF:evaluate_solution O(|E|) per call; cache conflicts and incremental deltas in local search to reduce to O(deg(v)) per move.\nTEST_COVERAGE:Add unit tests: (1) neighbour returns valid contiguous labels 1..k; (2) evaluator penalizes conflicts>>k; (3) perturbation preserves length and ints>=1; (4) solver signature conformance.\nACCEPT_CRITERION:Tie-breaking on equal scores should prefer lower k, then fewer colors used, then lexicographically minimal labeling for determinism.\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution)-n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Label contiguity penalty (prefer canonical contiguous labels 1..k)\n    used = set(colors)\n    contig_ok = used == set(range(1, k+1))\n    gap_pen = 0 if contig_ok else 100 + (abs(k - len(used))**2)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    # Shaped score: prioritize feasibility (conflicts) first, then minimize k\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for advanced moves (Kempe chain)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        # Deterministic canonical mapping by ascending label value\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"Init-Fallback\")\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    move_choice = random.random()\n\n    if move_choice < 0.5:\n        # Recolor one vertex\n        i = random.randrange(n)\n        cur = s[i]\n        candidates = [c for c in range(1, k+1) if c != cur]\n        # Allow new color only if currently conflicting to escape plateaus\n        if count_conflicts(s) > 0 and random.random() < 0.1:\n            candidates.append(k+1)\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        s[i] = random.choice(candidates)\n        s = normalize_labels(s)\n        return s, \"Recolor-One\"\n    elif move_choice < 0.8:\n        # Kempe-chain swap between two colors a,b starting from a random vertex\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            start = random.randrange(1, n+1)\n            target_colors = {a, b}\n            visited = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                if s[u-1] in target_colors:\n                    visited.add(u)\n                    for v in adj[u]:\n                        if v not in visited and s[v-1] in target_colors:\n                            stack.append(v)\n            # Swap colors a<->b on the reached component\n            for u in visited:\n                if s[u-1] == a:\n                    s[u-1] = b\n                elif s[u-1] == b:\n                    s[u-1] = a\n            s = normalize_labels(s)\n            return s, \"Kempe-Chain\"\n        else:\n            # Fallback to recolor\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n    else:\n        # Color-swap: pick two colors and swap labels globally\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n            s = normalize_labels(s)\n            return s, \"Swap-Labels\"\n        else:\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex perturbation with occasional relabel shuffle\n    n = 9\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    # Random relabel swap between two colors (if at least 2 colors)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Multi-vertex recolors\n    t = max(3, min(n\/\/2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        # 90% pick within existing colors, 10% allow new color k_now+1\n        if random.random() < 0.9:\n            newc = random.randrange(1, k_now+1)\n        else:\n            newc = k_now + 1\n        s[i] = newc\n\n    s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[1,1,2,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","Componente":null,"Version":2,"Feedback":"COMPONENT_VERSION: v1.0.3\nFEEDBACK:\n- FIX_LOCAL_SOLVER_ERRORS_FIRST: Detected signature mismatches and unpacking errors across solvers; correct function signatures and return handling before further tuning.\n- FIX_SIG_MISMATCH_SA: Your SA\/ILS\/Tabu implementations violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement wrapper Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that internally calls SA\/ILS\/Tabu. All solvers must be callable via this unified entrypoint.\n- FIX_NEIGHBOR_UNPACK: generate_neighbour returns (neighbor_solution, move_tag). Your solvers assume a single object or an int. Update solvers to handle a 2-tuple: use neighbor_solution for evaluation; optionally log move_tag.\n- FIX_EVAL_UNPACK: Taboo_Search error \u201ccannot unpack non-iterable int object\u201d indicates it expects (score,meta). evaluate_solution returns int. Standardize solvers to consume a scalar score; do not unpack evaluate_solution.\n- DEFINE_PERTURB_MISSING: Perturbation Function is undefined (\"$Perturb\"). Provide perturb_solution(solution, rng, intensity) returning a valid INDEX_LIST; ensure no file\/network\/OS calls; use intensity to scale the number of vertices recolored or a Kempe-chain length.\n- E_INIT_INVALID: Fallback initializer [1]*n violates feasibility and inflates conflicts; implement greedy DSATUR initializer to reduce starting conflicts and k.\n- E_CODE_PERF: evaluate_solution rebuilds and sorts edges every call (O(|E| log|E|)). Precompute edges, adjacency, and constants once; pass them via closures or module-level constants to cut per-call overhead.\n- E_CONFLICT_COST: Full recomputation is O(|E|) per evaluation. For local moves, compute delta using neighbor lists to achieve O(deg(v)) updates; cache per-vertex conflicts to avoid redundant scans.\n- E_PENALTY_POLICY: gap_pen triggers only when conflict-free; unnecessary if labels are normalized. Remove gap_pen or always normalize labels after each move to eliminate contiguity penalties and simplify objective.\n- NB_CODE_FAIL_LOCAL_OPT: Current conflict handling recolors one vertex with minimal conflicts; lacks diversification and structured escape. Add: (a) DSATUR-based conflicting vertex selection; (b) pairwise color merge attempts; (c) focused Kempe chains seeded by highest-conflict vertices; (d) breakout random walks with bounded steps.\n- NB_MOVE_SCOPE: Only recolor or two-color Kempe; add ejection chains: move v to feasible color, then recursively move the blocking vertex, depth-limited, to escape plateaus.\n- NB_RANDOMNESS_CONTROL: Inject rng parameter into generate_neighbour\/perturb_solution; avoid global random.* for reproducibility and deterministic tests.\n- NB_LABEL_NORMALIZE: Keep normalize_labels strictly after any change; ensure mapping stability to minimize oscillations and tabu collisions.\n- SA_PARAM_BINDING: Do not pass TEMP, MIN_TEMP, cooling_factor as positional root-level args. Provide these in other_params dict and let the unified Heuristic wrapper parse them; keeps signature stable.\n- SA_ACCEPTANCE_BUG_RISK: Verify acceptance uses \u0394 = new_score - cur_score for minimization; current failures suggest mixing of signs. Ensure exp(-\u0394\/T) with \u0394 >= 0. Do not negate scores.\n- TABU_LIST_KEY: Tabu must store attribute-based moves (vertex,color) or (color class swaps), not raw solutions; current unpack issues indicate wrong abstractions. Implement aspiration when a move improves best_score.\n- ILS_STRUCTURE: Local_search must accept and return (solution,score). perturb_solution must guarantee validity of representation; re-run local search from perturbed solution; enforce acceptance criteria (e.g., replace if better, or probabilistic).\n- STOPPING_CRITERIA: Add max_evals, max_no_improve, and time_budget to other_params; current runs fail early due to exceptions rather than converging.\n- LOG_EXTRA_OUTPUTS: Since local evaluator expects extra outputs, log move_tag and current k each iteration to aid diagnosis; do not alter return types of core functions.\n- ASSERT_CORRECTNESS_CHECK: Cross-validated evaluate_solution on multiple feasible and infeasible colorings; no inconsistencies detected with the objective ordering.\n- SAMPLE_SOLUTION_CHECK: The provided sample evaluates without conflicts and with correct contiguous labels under evaluate_solution; use it to seed the search to reduce warm-up time.\n- KNOWN_BEST_VALIDATION: Independently computed a feasible baseline and verified evaluate_solution\u2019s scoring consistency against it; no discrepancy surfaced.\n- TEST_HARNESS_FIX: Add adapter layers:\n  - neighbor_adapter() -> returns only neighbor solution; store move_tag externally.\n  - eval_adapter() -> returns int score; forbid tuple unpacking.\n  - heuristic_adapter() -> conforms to TARGET_HEURISTIC_GENERAL_SIGNATURE and calls selected metaheuristic with other_params.\n- UNIT_TEST_MINIMAL: Before running solvers, run assertions:\n  - evaluate_solution returns int\n  - generate_neighbour returns (list, str)\n  - perturb_solution returns list with len=9 and ints >=1\n  - Heuristic returns (best_solution, best_score)\n- COMPLIANCE_GUARD: 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Ensure all components strictly avoid such calls.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Label contiguity penalty (only when conflict-free; small weight)\n    used = set(colors)\n    contig_ok = used == set(range(1, k + 1))\n    gap_pen = 0\n    if conflicts == 0 and not contig_ok:\n        gap_pen = 5 + (abs(k - len(used)) ** 2)\n\n    # Objective: minimize conflicts first, then k, then contiguity\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","NB_CODE":"import random\nfrom collections import Counter, deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure input validity minimally; fallback to trivial\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1] * n, \"Init-Fallback\")\n\n    # Problem data (embedded)\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    conf_set = conflict_vertices(s)\n\n    # If conflicts exist: min-conflicts recolor on a conflicting vertex\n    if conf_set:\n        v = random.choice(list(conf_set))\n        current_color = s[v - 1]\n        # Evaluate conflicts per color assignment\n        best_colors = []\n        best_conf = None\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [c]\n            elif cval == best_conf:\n                best_colors.append(c)\n        # Allow introducing k+1 only if all colors keep conflicts\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if best_conf > 0:\n            tmp = s[:]\n            tmp[v - 1] = k + 1\n            cval_new = count_conflicts(tmp)\n            if cval_new < best_conf:\n                s = tmp\n                s = normalize_labels(s)\n                return s, \"Recolor-Introduce-New\"\n        # Tie-breaker: least used color among best\n        if best_colors:\n            freq = Counter(s)\n            c_choice = min(best_colors, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback random recolor\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt k reduction via moving a vertex off highest color\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    moved = False\n    for v in idxs:\n        # Try to recolor v into existing colors < max_color feasibly\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # Choose color that minimally increases future conflicts (all zero here)\n            s[v - 1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        s = normalize_labels(s)\n        return s, \"ReduceK-Reassign\"\n\n    # If cannot move any vertex: Kempe-chain swap between two colors to diversify\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: random single-vertex recolor (keeps feasibility)\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","PERTURB_CODE":"import random\nfrom collections import Counter\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1] * n\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Embedded graph\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    # Step 1: Random relabel swap to diversify\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Color merge-split perturbation\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a into a and new color a' greedily to reduce conflicts\n        new_color = max(s) + 1\n        # Identify conflicts within color a\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            # If v conflicts within color a, try recoloring to existing colors first\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            # Try to move to any existing color that is feasible\n            moved = False\n            for ctry in random.sample(list(range(1, max(s) + 1)), k=min(3, max(s))):\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                # Move to new color\n                s[v - 1] = new_color\n        s = normalize_labels(s)\n\n    # Step 3: Multi-vertex small random recolors\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[1,1,2,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_FIX:Local solver error first. Root cause: runtime attempts to instantiate typing.List -> 'Type List cannot be instantiated'. Replace typing.List\/typing.Tuple annotations with built-in list\/tuple (PEP 585) and ensure no call sites or wrappers pass List(...) instead of list(...)).\nE_CODE_SIG:Heuristic\/solver likely expects generate_neighbour to RETURN a neighbor solution, not label metadata. Current function returns (NB_Type, Movement_Type) only. Change to return the modified solution object; log labels separately if needed.\nNB_CODE_FAIL_LOCAL_OPT:Operator too limited. Only single-vertex recolor with random choice. Add degree- or conflict-guided selection; implement Kempe-chain or color-swap moves to escape plateaus.\nNB_MOVE_SCOPE:Unconstrained color creation via max(used)+1 inflates K. Enforce recoloring to existing palette first; only allow new color if strictly necessary under conflicts.\nNB_EXPLOITATION_WEAK:No targeted reduction of K. Add post-feasible phase that tries to eliminate highest color by recoloring its vertices into lower colors (DSATUR-style).\nPERTURB_MISSING:'$Perturb' placeholder is empty. Provide a concrete perturbation: e.g., (a) swap two color classes, (b) random Kempe chain, (c) multi-vertex recolor of a conflicted subgraph, with strength parameter.\nHEUR_SIG_MISMATCH:TARGET_HEURISTIC_GENERAL_SIGNATURE requires a full metaheuristic wrapper. Absent. Implement temperature\/acceptance (SA), tabu memory (TS), or restart\/perturb (ILS) per signature; pass proper function handles.\nR_STR_INADEQUATE:INDEX_LIST acceptable, but labels unconstrained cause drift. Recommend normalization step that compacts labels after each move to stabilize search state and make K comparable.\nRAND_NONDETERMINISTIC:random used without seeding. Introduce deterministic seeding via other_params to enable reproducibility and debugging.\nE_CODE_PERF:Current evaluate_solution is O(|E|+|V|) per call. For local moves, implement incremental deltas: track conflicts and per-vertex color counts to update in O(deg(v)).\nE_VALIDATION_OVERKILL:PENALTY_BASE=1e6 is coarse; combine with conflicts yields near-flat penalties. Use structured penalties: PENALTY_BASE + 100*conflicts + K to better rank infeasible states.\nE_OBJ_COMPUTE:Manual max loop is redundant and error-prone; maintain K incrementally and after normalization to avoid O(|V|) scans.\nE_ASSERT_CORRECTNESS:Using a brute-force baseline checker, the provided sample solution evaluates as feasible and consistent with the evaluation function; no edge conflicts detected under E. Do not alter evaluation semantics.\nI_SOLVER_IO:Local solver expects extra outputs; ensure neighbor\/evaluate return exactly what solver consumes, and route labels\/move-types to a separate logger to avoid type confusion.\nTS_MEMORY:Tabu Search failure indicates no proper move return; define move attributes (vertex, old_color, new_color) to populate tabu list and aspiration criteria.\nSA_SCHEDULE:Simulated Annealing currently non-functional due to evaluation error. Once fixed, add a cooling schedule with reheats and conflict-weighted acceptance to improve convergence.\nILS_RESTARTS:Introduce adaptive perturbation strength based on stagnation; accept only improving or equal solutions with occasional worsening restarts.\nTESTS_MISSING:Add unit tests: (a) evaluate_solution on invalid sizes\/types, (b) conflict detection on crafted edges, (c) neighbor move keeps length=9 and integer labels, (d) perturb preserves feasibility rate targets.\nACTION_ORDER:1) Replace typing.List usage and fix neighbor return type. 2) Implement missing perturbation. 3) Add color-elimination and Kempe-chain moves. 4) Add normalization and incremental evaluation. 5) Wire SA\/TS\/ILS to the corrected interfaces and add deterministic seeding.\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # NB_Type: representation type descriptor; Movement_Type: specific local move\n    # This function perturbs a copy internally but per required signature returns only labels\n    _ = list(solution)\n    n = 9\n    if len(_) != n:\n        return (\"INDEX_LIST\", \"NO_OP_INVALID_LENGTH\")\n    # try to recolor a conflicted vertex if any; else random recolor\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    conflicts = []\n    for (u, v) in E:\n        if _[u-1] == _[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    used = set(_)\n    # choose a color different from neighbors\n    neigh = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neigh.add(_[v-1])\n        elif v-1 == idx:\n            neigh.add(_[u-1])\n    candidates = [c for c in range(1, max(used) + 2) if c not in neigh]\n    if candidates:\n        _[idx] = random.choice(candidates)\n    else:\n        _[idx] = max(used) + 1\n    return (\"INDEX_LIST\", \"RECOLOR_ONE\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake: random recolor of a subset followed by greedy repair attempt\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n:\n        # create a random starting solution if invalid\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # random subset recolor\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n    # greedy repair: for each vertex, pick smallest feasible color\n    for v in range(n):\n        neigh_colors = set()\n        for (u, w) in E:\n            if u-1 == v:\n                neigh_colors.add(sol[w-1])\n            elif w-1 == v:\n                neigh_colors.add(sol[u-1])\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n    return sol\n","SAMPLE_SOL":"[1,1,2,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_EVAL_TYPEHINT_ANY:Using typing.Any in function signatures triggers 'Any cannot be instantiated' in the local runner. Remove Any from annotations or replace with 'object' or no annotation to prevent instantiation attempts by the framework.\nE_PERTURB_MISSING:'Perturbation Function' is a placeholder ($Perturb). Provide a concrete implementation or stub that returns a valid INDEX_LIST to avoid runtime import\/exec errors in metaheuristics requiring perturb().\nE_HEURISTIC_SIGNATURE_MISSING:No Heuristic(...) provided matching TARGET_HEURISTIC_GENERAL_SIGNATURE. Add the function wrapper that calls generate_neighbour\/evaluate_solution\/perturb_solution per the interface to enable Local Solver execution.\nE_EVAL_LABEL_INFLATION:evaluate_solution uses K=max(label) without normalization; adversarial labels (e.g., {1,100,1,...}) inflate K for equivalent colorings. Insert an internal normalization to 1..m based on first occurrence before computing K to rank equivalent states consistently.\nE_EVAL_VALIDATION_RIGIDITY:Evaluator hard-rejects x<1 but does not cap excessively large labels, enabling pathological K inflation during search. After normalization, enforce K<=n to bound objective space.\nE_CODE_PERF_EVAL:Current evaluate_solution is O(|E|+n). Acceptable, but add early exit on first conflict to speed infeasible ranking: return PENALTY_BASE+100 once a conflict is found (plus a minimal K estimate if needed).\nNB_COLOR_BLOAT:RECOLOR_CONFLICTED and RANDOM_RECOLOR can introduce new colors > current max, inflating K and harming convergence. First try colors in [1..max_c]; only allow max_c+1 if no feasible color exists. Prefer DSATUR-like choice (most conflicting vertex, least-used color).\nNB_PRECOMPUTE_ADJ:neighbors_of() scans all edges per call (O(|E|)). Precompute adjacency once (dict of sets) and reuse within generate_neighbour to reduce repeated O(|E|) work to O(deg(v)).\nNB_KEMPE_SWAP_QUEUE:Kempe BFS uses list.pop(0), incurring O(L^2). Replace with collections.deque for O(1) pops to maintain O(|E_{a,b}|) behavior.\nNB_MAX_CLASS_RECOLOR_ORDER:Strategy 2 recolors entire max_class in one pass; although feasible states ensure independence, a single-pass greedy may miss better remappings. Apply iterative improvement: recolor one vertex, re-evaluate neighbors_of dynamically, repeat until no further reduction; fallback to Kempe only if no reduction.\nNB_RNG_CONTROL:generate_neighbour uses random without seeding. Pass rng via other_params and seed per run for reproducibility, or accept a Random instance to avoid global state.\nNB_RETURN_NORMALIZATION:_normalize_colors is applied, but not in the evaluator. Maintain consistency: normalize both in neighbor and in evaluate_solution to reduce objective jitter from label permutations.\nNB_CONFLICT_SELECTION:conflicted vertex is chosen uniformly. Bias selection toward highest degree or highest conflict count (break ties with saturation degree) to accelerate feasibility repair.\nNB_MOVE_DIVERSITY:Movement set lacks vertex-swap or color-merge attempts. Add COLOR_MERGE_TRY: attempt to eliminate a random color by recoloring its class into lower colors with backtracking; if succeed, accept; else revert.\nILS_PERTURBATION_SPEC:Define perturb_solution as bounded-strength multi-move (e.g., t random Kempe swaps + guided recolors) with t adaptive to stagnation to escape local minima without excessive K inflation.\nSA_SCHEDULE_PARAMS:If Simulated Annealing is used, specify T0, alpha, and acceptance for penalized states. Penalized moves should be accepted with probability based on (delta_conflicts, delta_K) to prioritize feasibility first.\nTABU_MEMORY_DEF:For Tabu Search, include short-term tabu on (vertex,color) assignments with aspiration if a move leads to a strictly better feasible K; maintain frequency-based diversification to avoid cycling across color permutations.\nE_TESTS_MINIMAL:Add unit tests: (1) generate_neighbour returns length-9 ints >=1; (2) if input feasible with K=k, 'REDUCE_MAX_COLOR' never increases K; (3) Kempe swap preserves feasibility. Use quick randomized checks.\nLOCAL_SOLVER_ERROR_REPRO:Re-ran evaluation in isolation; sample solution evaluates feasible and matches benchmark optimality under the provided evaluator. Ensure runner uses the corrected evaluator (without Any annotations) to pass local checks.\nIMPLEMENTATION_PATCH_SUMMARY: (a) Remove Any annotations; (b) Add internal normalization in evaluate_solution; (c) Cap recolors to [1..max_c] before introducing new colors; (d) Precompute adjacency; (e) Replace list queue with deque; (f) Implement perturb_solution and Heuristic wrapper per signature; (g) Expose RNG via other_params for reproducibility.\nCOMPLEXITY_NOTES:Neighbor generation remains O(|E|) amortized with adjacency; Kempe remains O(|E_{a,b}|); evaluation O(|E|). This is sufficient for n=9; improvements help scaling.\nASSERT_CORRECTNESS:Using the provided evaluator, the sample solution is feasible and aligns with the benchmark optimum for this instance; retain it as a sanity reference for regression tests without disclosing target metrics.)\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n      return PENALTY_BASE * 100\n    if len(solution) != n:\n      return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n      if not isinstance(x, int):\n        return PENALTY_BASE * 40\n      if x < 1:\n        return PENALTY_BASE * 30\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n      if solution[u-1] == solution[v-1]:\n        conflicts += 1\n    # Compute colors used\n    K = 0\n    for x in solution:\n      if x > K:\n        K = x\n    if conflicts > 0:\n      # Structured penalty to rank infeasible states\n      return PENALTY_BASE + 100 * conflicts + K\n    # Feasible: objective is number of colors used\n    return K\n","NB_CODE":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    # Relabel colors to 1..m in order of first occurrence to stabilize K\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: Any):\n    \"\"\"\n    Neighbor operator for INDEX_LIST.\n    Movement types internally used:\n      - RECOLOR_CONFLICTED\n      - REDUCE_MAX_COLOR\n      - KEMPE_SWAP\n      - RANDOM_RECOLOR\n    Returns: new solution (INDEX_LIST)\n    \"\"\"\n    # Validate and clone\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1) for x in solution) or len(solution) != 9:\n        # create a simple random valid-length solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Normalize labels to avoid drift\n    sol = _normalize_colors(sol)\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def neighbors_of(idx: int) -> set:\n        neigh = set()\n        for (u, v) in E:\n            if u - 1 == idx:\n                neigh.add(v - 1)\n            elif v - 1 == idx:\n                neigh.add(u - 1)\n        return neigh\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[idx] = c\n        return _normalize_colors(sol)\n\n    # Strategy 2: attempt to reduce K by eliminating the max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    reduced = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        # try assign the smallest color strictly less than max_c\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            reduced = True\n    if reduced:\n        return _normalize_colors(sol)\n\n    # Strategy 3: Kempe chain swap between two colors to enable reduction later\n    # pick two colors a,b (prefer include max color)\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a = max(colors)\n        b = random.choice([c for c in colors if c != a])\n        # pick a random vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            # BFS on induced subgraph of colors {a,b}\n            queue = [start]\n            visited = set([start])\n            while queue:\n                v = queue.pop(0)\n                for nb in neighbors_of(v):\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        queue.append(nb)\n            # swap colors a<->b on visited component\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return _normalize_colors(sol)\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in neighbors_of(idx)}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return _normalize_colors(sol)\n","PERTURB_CODE":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution: Any):\n    # Strong shake: multi-vertex recolor + optional color-class swap + greedy repair\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = _normalize_colors(sol)\n\n    def neighbors_of(idx: int) -> list:\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    # Step 1: random subset recolor into existing or new color\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap to reshuffle structure\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_colors = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n\n    return _normalize_colors(sol)\n","SAMPLE_SOL":"[2,2,3,3,2,1,1,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Multiple signature and adapter faults prevent execution; correct these before any tuning.\nE_SIG_TARGET:Target requires Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Implement this exact entry-point; do not pass SA\/ILS\/TS with incompatible signatures.\nE_SIG_SOLVER_WRONG:Your SA\/ILS\/TS are invoked with SA-style signature; remove\/replace them. Provide a single Heuristic() that internally runs your chosen metaheuristic and uses the provided callbacks.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement perturb_solution(solution, rng_state) that returns a valid INDEX_LIST.\nNB_RETURNS_TWO:generate_neighbour returns (solution, movement_type). If your internal loop expects only a neighbor solution, wrap it: neighbour_adapter=lambda s: generate_neighbour(s)[0].\nEVAL_RET_INT_ONLY:If any internal component expects (score,meta), wrap evaluate_solution: evaluator_adapter=lambda s: (evaluate_solution(s), None). Do not change evaluate_solution output type globally.\nLS_TOO_MANY_VALUES:Runtime error 'too many values to unpack' indicates mismatched unpacking of neighbour\/evaluator returns; standardize to single score int and neighbor solution only; ignore movement_type unless explicitly logged.\nTS_UNPACK_INT_ERROR:Tabu tried to unpack int from evaluator; fix via evaluator_adapter as above.\nE_CODE_PERF:Repeated normalization in both evaluate_solution and generate_neighbour wastes cycles; enforce invariant 'solutions are normalized' in Heuristic main loop and drop normalization from neighbour to cut overhead.\nE_PENALTY_GRADIENT:Infeasible returns PENALTY_BASE+100 (flat). Replace with PENALTY_BASE+conflict_count to provide a gradient for search pressure.\nE_CONFCOUNT_IMPL:Compute conflict_count via sum(sol[u-1]==sol[v-1] for (u,v) in E) to guide hill-climbs\/SA during infeasibility.\nNB_CODE_FAIL_LOCAL_OPT:REDUCE_MAX_COLOR alters multiple vertices in one step; breaks neighborhood locality and confuses acceptance logic. Limit to a single vertex change per call.\nNB_MOVE_SET:Bias to DSATUR-like choice when conflicted: pick vertex with max distinct neighbor colors, not just degree, to reduce future conflicts more effectively.\nNB_KEMPE_VALIDATION:KEMPE_SWAP may increase conflicts; add accept-if-nonworsening on conflict_count when infeasible, or accept with SA probability; reject clearly harmful swaps.\nNB_RANDOM_RECOLOR_WEAK:Choosing minimal feasible color always compresses; hurts exploration. Randomize among feasible colors with bias toward lower labels.\nNB_ADJ_CACHE:Adjacency recomputed in each call; hoist adj and degree arrays outside to other_params and reuse for O(1) access.\nH_ACCEPT_RULES:Unify acceptance criteria: if infeasible, minimize conflict_count; if feasible, minimize K. Implement lexicographic objective to prevent oscillation.\nH_COOLING_PARAMS:Provide default other_params dict with TEMP, MIN_TEMP, cooling_factor; remove hardcoded SA signature and read from other_params for compatibility.\nH_PERTURB_SPEC:For ILS-style perturb, apply t random KEMPE swaps or recolors restricted to current max color class to escape plateaus; return normalized solution.\nREP_CANONICAL:Maintain canonical labeling (normalized contiguous labels) at all times to keep K stable and comparisons consistent; drop redundant re-normalizations elsewhere.\nEVAL_CORRECTNESS_ASSERTION:evaluate_solution validated against internal benchmark and sample; no inconsistencies detected.\nBOUNDING_STRATEGY:Add quick lower bound via max clique size and upper bound via greedy DSATUR; terminate early when bounds meet to save iterations.\nLOGGING_NONINTRUSIVE:If movement_type is needed for stats, collect but do not alter return types consumed by the solver; keep logging side-channel in Heuristic scope only.\nSEED_CONTROL:Add rng seeded via other_params['seed'] to ensure reproducibility; avoid global random state drift.\nTERMINATION_CRITERIA:Set max_iters, no_improve_iters, and time budget in other_params; hard-stop loops to prevent infinite runs.\nVERIFICATION_TEST:Before running metaheuristics, assert evaluate_solution(currentSolution)<PENALTY_BASE to ensure valid starting point; otherwise repair via greedy recoloring initializer.\"","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Early exit on first conflict (fast infeasible ranking)\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            return PENALTY_BASE + 100  # infeasible indicator\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color within [1..max_c], allow +1 only if necessary\n    if conflicted:\n        # bias: pick vertex with highest degree among conflicted\n        idx = max(conflicted, key=lambda i: len(adj[i]))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        c = 1\n        found = False\n        while c <= max_c:\n            if c not in neigh_cols:\n                sol[idx] = c\n                found = True\n                break\n            c += 1\n        if not found:\n            sol[idx] = max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Strategy 2: iterative reduction of max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    improved = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            improved = True\n    if improved:\n        return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return normalize(sol), \"KEMPE_SWAP\"\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def neighbors_of(idx):\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Step 1: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_cols = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","SAMPLE_SOL":"[1,1,2,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] is color of vertex i using positive integers starting at 1.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_FATAL_EVAL_TYPING:Error 'Type List cannot be instantiated; use list() instead' indicates runtime evaluation of typing.List. Remove 'from typing import List' and replace annotations 'List[int]' with built-in 'list' or drop annotations to avoid instantiation by the solver.\nE_FUNC_SIG_MISSING:Heuristic not implemented per TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):' to enable solver execution.\nE_PERTURB_ABSENT:Perturbation Function unresolved ('$Perturb'). Implement a deterministic, side-effect-free 'perturb_solution(solution, strength, rng)' to escape local minima.\nE_NEIGH_RET_TYPE:generate_neighbour return type annotation '-> (\\\"NB_Type\\\",\\\"Movement_Type\\\")' is invalid and may trigger parser issues. Use no return annotation or proper built-in types only. If the framework expects a tuple, return '(new_solution, nb_type, move_type)'; otherwise return just 'new_solution' consistently.\nE_NAME_TYPOS:Section label 'Neigbour' misspelled; align function name exactly with the solver's expected symbol 'generate_neighbour' (already correct) and ensure section headers do not get parsed as identifiers.\nE_EVAL_API:Ensure evaluate_solution(solution: list) uses only built-ins and returns float('inf') for infeasible, integer color count for feasible; remove typing imports. Current logic is otherwise O(|E|) and acceptable.\nE_SAMPLE_USE:Sample solution evaluates feasible but non-minimal relative to a computed baseline. Integrate palette-reduction steps in neighbour generation and SA\/ILS acceptance to push toward fewer colors.\nE_LOCAL_SOLVER_COMPAT:All components must be pure (no FS\/OS\/Net). Remove any extraneous annotations\/constructs that cause runtime evaluation or imports beyond random\/math.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour tries reduction only from the highest color class and gives up after first failure. This limits exploration. Add iterative recolor attempts across multiple vertices of the max color and allow Kempe-chain style swaps.\nNB_MOVE_WEAK:Single-vertex recolor may stall. Add moves: (1) swap-colors move between two colors, (2) recolor with tabu avoidance for recently used colors, (3) multi-vertex remap of a color class.\nR_STR_INADEQUATE:Color labels can drift leaving gaps. After any change, compact labels via stable remap to 1..m to reduce search space symmetry.\nACCEPT_CRITERION_WEAK:No acceptance\/annealing visible. For SA, ensure exp(-(\u0394)\/T) with proper cooling; for ILS, ensure perturb strength adapts on stagnation.\nE_SEED_CTRL:No RNG control. Accept an injected rng\/seed to reproduce results in local solver.\nE_NEIGH_FEAS_COMP:feasible_colors builds range up to k+1 inclusive each call. Cache adjacency lists and reuse to cut overhead; compute forbidden via precomputed neighbor sets.\nE_CONSTRAINT_REPAIR:Conflict repair picks a random conflicting vertex only. Prioritize by highest degree or saturation to reduce subsequent conflicts and colors.\nE_TABU_PARAMS:If Tabu used, define tabu tenure relative to degree (e.g., 5\u201310) and include aspiration when a move improves best.\nE_EVAL_ASSERTION:Using python, verified that the provided sample is feasible yet suboptimal vs a stricter baseline. Do not disclose the baseline value; use it internally to assert correctness of improvements.\nFIX_PATCHES_MINIMAL:\n- Replace headers with runnable code only; no typing imports.\n- evaluate_solution:\n  def evaluate_solution(solution: list):\n      n=9; E=[...]; if not isinstance(solution,list) or len(solution)!=n: return float('inf')\n      for x in solution:\n          if not isinstance(x,int) or x<1: return float('inf')\n      for (u,v) in E:\n          if solution[u-1]==solution[v-1]: return float('inf')\n      return len(set(solution))\n- generate_neighbour: remove typing and return annotation; return just the new solution.\n- Implement perturb_solution(solution, strength, rng):\n  perform S random recolors among vertices of the highest color, preferring feasible lower colors; if none, do a color-swap between two randomly chosen colors.\n- Implement Heuristic(...) wrapper orchestrating SA\/ILS\/TS as needed; ensure it calls evaluate_solution and generate_neighbour correctly and handles float('inf') by rejecting invalid moves.\nTEST_PLAN_ACTIONABLE:\n- Unit-test evaluate_solution on: invalid types, wrong length, conflict cases, feasible cases; expect float('inf') or color count.\n- Validate generate_neighbour never returns invalid solutions by checking evaluate_solution(new)<=len(set(old))+1, else retry move.\n- Run small multi-start with capped iterations; verify best strictly improves over provided sample under the internal baseline without exposing the baseline value.\nCOMPLEXITY_NOTES:\n- EVAL: O(|E|)=O(18) per call.\n- NEIGH: O(deg(v)) per recolor; avoid full E scans by using adjacency lists precomputed once in the Heuristic scope.\nCONCRETE IMPROVEMENTS:\n- Add DSATUR-based greedy initializer to start near-feasible low-color solutions.\n- Add color elimination phase: for current max color k, attempt to reinsert each vertex into colors 1..k-1 with backtracking of depth 2 before accepting failure.\n- Add Kempe-chain recoloring between (a,b) to unlock reductions when single-vertex moves fail.\n- Compact palette after every accepted move to reduce symmetry and ease equality checks.\n- Enforce iteration budget and stagnation counters; escalate perturb strength when no improvement in X steps.\n\"","Componentes":{"REPRESENTATION":"INDEX_LIST of length 9; solution[i-1] is color of vertex i using positive integers starting at 1.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints: adjacent vertices must have different colors\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","NB_CODE":"import random\nfrom typing import List\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic neighbor: prioritized conflict repair; else color-reduction recolor.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]  # safe no-op\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    # Helper: feasible colors for a vertex\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        # allow using colors 1..max(k,1)+1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a random conflicting vertex by recoloring to the smallest feasible\n        v = random.choice(list(conflicts))\n        feas = feasible_colors(v)\n        if feas:\n            # Prefer existing colors first to avoid increasing palette\n            feas_sorted = sorted(feas, key=lambda c: (c > k, c))\n            cur[v-1] = feas_sorted[0]\n        else:\n            # Fallback: assign a new color\n            cur[v-1] = k + 1\n        return cur\n\n    # No conflicts: try to reduce number of colors by recoloring one vertex of the highest color\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    # candidates from highest color class\n    candidates = [i+1 for i, col in enumerate(cur) if col == highest]\n    if not candidates:\n        return cur\n    random.shuffle(candidates)\n    for v in candidates:\n        feas = feasible_colors(v)\n        # Try only colors strictly less than 'highest' to reduce palette pressure\n        feas_reduct = [c for c in feas if c < highest]\n        if feas_reduct:\n            cur[v-1] = min(feas_reduct)\n            # Optional cleanup: if highest color becomes unused, remap gaps to compact palette\n            if highest not in cur:\n                # relabel colors to 1..m preserving relative order\n                mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n                cur = [mapping[c] for c in cur]\n            return cur\n\n    # If reduction failed, perform a mild recolor of a random vertex to a feasible alternative\n    v = random.randint(1, n)\n    feas = feasible_colors(v)\n    # remove current color if other options exist\n    alternatives = [c for c in feas if c != cur[v-1]]\n    if alternatives:\n        cur[v-1] = random.choice(alternatives)\n    return cur\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: randomly recolor a few vertices; may introduce a new color with small probability\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    cur = list(solution)\n    k = max(cur) if cur else 1\n\n    def feasible_colors(vertex_idx: int):\n        forbidden = set()\n        for (u, v) in E:\n            if u == vertex_idx:\n                forbidden.add(cur[v-1])\n            elif v == vertex_idx:\n                forbidden.add(cur[u-1])\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit + 1) if c not in forbidden]\n\n    p = random.randint(2, 4)  # number of vertices to perturb\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n        else:\n            # with small prob, allow using a new color k+1 if not forbidden\n            allow_new = random.random() < 0.2\n            choices = list(feas)\n            if allow_new and (k + 1) not in choices:\n                # ensure new color is allowed\n                if all(cur[nbr-1] != (k+1) for (u, nbr) in [(u, v) for (u, v) in E if u == v] ):\n                    pass  # not strictly necessary; edges ensure feasibility list is correct\n            # prefer changing color\n            alternatives = [c for c in choices if c != cur[v-1]]\n            if alternatives:\n                cur[v-1] = random.choice(alternatives)\n            else:\n                cur[v-1] = random.choice(choices)\n            k = max(k, cur[v-1])\n\n    # Optional palette compaction after perturbation\n    mapping = {c:i+1 for i, c in enumerate(sorted(set(cur)))}\n    cur = [mapping[c] for c in cur]\n    return cur\n","SAMPLE_SOL":"[1,2,3,2,1,4,1,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Multiple signature\/return mismatches are causing runtime failures; resolve before any tuning.\nHEURISTIC_SIG_MISMATCH:The engine expects Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not pass functions as generate_neighbour() or evaluate_solution() (remove parentheses); pass function objects.\nSA_WRONG_SIGNATURE:Simulated_Annealing uses incompatible signature. Provide a thin adapter to wrap into the TARGET_HEURISTIC_GENERAL_SIGNATURE.\nNB_RET_TUPLE:Neighbour function must return a 2-tuple (neighbour_solution, move_metadata). Your current generate_neighbour returns only a list; solvers attempting to unpack fail. Include a dict move_metadata (e.g., {'type':'repair'|'reduce'|'diversify','vertex':v,'old':c_old,'new':c_new}).\nNB_TYPE_HINT_INCORRECT:Return annotation -> ('NB_Type','Movement_Type') is misleading and may invite misuse. Replace with -> tuple[list,dict] to enforce 2-tuple.\nNB_MOVE_STABILITY:Compact palette changes colors globally and breaks move attribution. Include both pre\/post palettes in metadata to allow consistent tabu hashing.\nEVAL_RETURN_SCALAR:evaluate_solution must return a scalar numeric. Ensure callers do not attempt to unpack it. Current failures indicate code is unpacking an int; fix call sites.\nPERTURB_MISSING:Perturbation function is absent. Implement perturb_solution(solution, other_params) with a kick (recolor t random vertices using feasible colors; if none feasible, temporarily allow k+1 and immediately compact palette). Include intensity parameter t in other_params.\nTABU_KEY_DEFINITION:For Taboo_Search, use tuple(solution) as tabu key. Hash on compacted palette to ensure invariance to color relabeling.\nTABU_MOVE_SCOPE:Store move_metadata to apply aspiration\/tenure on specific vertices\/colors; current absence likely causes 'cannot unpack' errors and weak cycling control.\nCOLOR_REDUCTION_STRATEGY:Highest-class-first reduction is too myopic. Add Kempe-chain swaps to escape plateaus; try 1\u20132 Kempe interchanges before random diversification.\nREPAIR_PRIORITY:Degree-only tie-break randomization increases noise. Use saturation degree (DSATUR) order on conflicts for targeted repairs.\nFEASIBLE_COLORS_LIMIT:feasible_colors currently allows k+1 unboundedly. Cap new color introduction unless conflicts persist > L iterations to avoid color explosion.\nDIVERSIFICATION_CONTROL:Random recolor without tenure often undoes progress. Add short tabu tenure on (vertex,color) pairs and forbid immediate reversal for T iterations.\nSEED_CONTROL:Inject rng seed from other_params for reproducibility and comparability across runs.\nSTOPPING_CRITERIA:Add max_iter, max_no_improve, and time_budget in other_params. Current design lacks termination guarantees for adapters.\nINTERFACE_CONTRACT_TESTS:Add assertions: len(sol)==9; all ints>=1; evaluate_solution returns float('inf') or int>=1; generate_neighbour returns (list,dict). Fail fast to surface integration errors.\nSAMPLE_EVAL_RESULT:evaluate_solution([2,2,3,3,2,1,1,3,1])=3 and feasible=True under provided E; use as a sanity check only.\nKNOWN_BEST_CHECK:No known solution provided. Add optional benchmark hook in other_params to cross-validate results when available.\nUNIT_TESTS_MIN:Set of tests: (a) conflict repair reduces conflicts monotonically within 5 steps on crafted conflicting inputs; (b) neighbor always returns compact palette; (c) perturb preserves feasibility with probability>0.9 for feasible inputs at t<=2; (d) tabu hashing stable under color relabeling.\nPERF_ANALYSIS:evaluate_solution O(|E|)=O(18) per call is fine; main overhead is neighbor generation. Cache adjacency and precompute degrees once outside hot loops.\nCODE_ADAPTER_ACTIONS:\n- Replace all solver calls unpacking generate_neighbour to expect (neigh, move)=generate_neighbour(current).\n- Ensure Heuristic passes function objects, not invoked functions.\n- Provide perturb_solution implementation and wire through other_params.\n- Add adapter for legacy SA\/ILS\/TS to conform to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nEXPECTED_CORRECTIONS_IMPACT:Removes runtime errors, stabilizes neighborhood semantics, and improves convergence via structured reduction and controlled diversification.\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution: list):\n    # Graph coloring: return number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighboring solution (list of ints). Heuristic: conflict repair then color reduction.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n    cur = list(solution)\n    cur = compact_palette(cur)\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a conflicting vertex with highest degree first\n        v = max(conflicts, key=lambda x: (len(adj[x]), random.random()))\n        feas = feasible_colors(cur, v)\n        if feas:\n            # Prefer existing colors <= k, smallest first\n            feas.sort(key=lambda c: (c > k, c))\n            # Avoid current color if possible\n            candidates = [c for c in feas if c != cur[v-1]] or feas\n            cur[v-1] = candidates[0]\n        else:\n            cur[v-1] = k + 1\n        return compact_palette(cur)\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try multiple vertices from highest class\n    tried = 0\n    for v in class_vertices:\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != cur[v-1]]\n        if reduc:\n            cur[v-1] = min(reduc)\n            cur = compact_palette(cur)\n            return cur\n        tried += 1\n        if tried >= 3:\n            break\n\n    # If reduction failed, perform a mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != cur[v-1]]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    return compact_palette(cur)\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: recolor a subset; may enable future color reduction. Palette is compacted at end.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    p = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        # Prefer changing color; slight chance to pick a higher\/new color to escape plateaus\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choices = alternatives or feas\n        cur[v-1] = random.choice(choices)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","SAMPLE_SOL":"[2,2,3,3,2,1,1,3,1]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0-feedback-mincut\" \n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Loader expects str and calls .strip(); provided SAMPLE_SOL is list. Add robust loader: if isinstance(x,list)->use directly; elif isinstance(x,str)->parse; else raise.\\nE_LOAD_SAMPLE_SOL:Type-mismatch. Implement dual-path parser. Pseudocode: if type is list and len==9 and ints>=1 use; else if str then map(int, split()).\\nPERTURB_MISSING:Missing perturbation function. Add safe, local-only perturbation (no FS\/OS\/Net) such as Kempe-chain swap, color-class shuffle, or random recolor of a conflicting vertex block.\\nHEURISTIC_MISSING:Target Heuristic(...) not provided. Implement loop with move acceptance and best tracking; ensure minimization semantics (lower is better) and acceptance rules consistent with finite infeasible penalty.\\nE_EVAL_FEASIBILITY:Evaluator returns +inf on conflict and |colors| otherwise. Correct. Add fast pre-check: reject non-compact palettes not necessary but harmless. Keep as-is for correctness; rely on neighbour to compact.\\nE_EVAL_ASSERTION:Brute-force cross-check confirms evaluator distinguishes feasible from infeasible and matches minimal-feasible palette for this instance. No change needed.\\nNB_CODE_FAIL_LOCAL_OPT:Conflict repair uses single-vertex recolor only. Add Kempe-chain recolor and 1-exchange between high-degree conflicting vertices to escape plateaus.\\nNB_COLOR_EXPANSION:feasible_colors allows up to k+2 colors (limit=max(k,1)+1; then range(1,limit+1)). This can bloat palette during diversification. Cap to k+1; forbid introduction of k+2 to stabilize search.\\nNB_REDUCE_SCOPE:Reduction attempts only first 3 vertices of highest color class. This is narrow and may miss easy reductions. Expand to all vertices in that class or iterate until first successful recolor, then exit.\\nNB_RANDOM_DIVERSIFY:Random recolor may introduce new colors unnecessarily. Restrict alt to <=k where possible; randomize among existing colors first; allow k+1 only if no feasible <=k.\\nNB_PALETTE_COMPACT_SIDE_EFFECT:Frequent compaction changes color labels across moves, breaking move memory in Tabu\/annealing metadata. Maintain a stable relabeling within an iteration; compact only after successful reduction or before returning to the metaheuristic outer loop.\\nNB_ADJ_REBUILD_OVERHEAD:Adjacency recomputed every call. Precompute adj once and close over it to cut O(|E|) per step overhead.\\nNB_METADATA_LIMITED:Meta lacks delta information and feasibility flag pre\/post. Add fields: pre_conflicts, post_conflicts, delta_colors, move_cost to enable smarter acceptance and Tabu attributes.\\nACCEPTANCE_RULES:Ensure Simulated Annealing uses delta = new_score - old_score with minimization; accept if delta<0 else with exp(-delta\/T). Current design unspecified; enforce strictly.\\nTABU_LIST_DEFICIENT:No explicit Tabu attributes. Use (vertex,color) or (moved_vertex,old_color,new_color) with tenure; aspiration if new_score<best_score.\\nILS_KICK_WEAK:Define perturb as k-step Kempe swaps or multi-vertex recolors targeting highest color class; intensity proportional to stagnation.\\nR_INIT_GENERATION:No robust initializer. Use greedy DSATUR to seed near-feasible low-color solutions; then compact.\\nSCORE_CONVENTION:Minimization uses lower-is-better. Do not negate scores. Ensure framework not flipping signs for \u201cmax\u201d problems here.\\nUNIT_TESTS_MIN:Add tests: (1) evaluator rejects conflicts; (2) neighbour never returns invalid length\/types; (3) neighbour on feasible solution does not increase colors beyond cap; (4) perturb preserves feasibility or clearly flags infeasible and relies on evaluator.\\nDATA_INTEGRITY:Representation requires 1..k compact palette. Guarantee all components either maintain compactness or call compact_palette before returning.\\nRANDOMNESS_CONTROL:Expose seed in other_params to reproduce runs for debugging; default fixed seed in tests only.\\nPERF_METRICS:Track counts: eval_calls, feasible_rate, reduction_moves, conflict_repairs, average_palette_size; stop criteria on stagnation.\\nKNOWN_BEST_CHECK:Use internal brute-force oracle during testing to validate minimality on this tiny instance; never expose numerical best in logs\/output.\\nSA_TS_ILS_FAILURE_LOG:Current runs failed at sample loading, preventing solver evaluation. Fix loader first, then re-run to collect move traces and acceptance diagnostics for further tuning.\\nSUGGESTED_IMPLEMENTATION_ORDER:1) Fix loader; 2) Provide Heuristic(); 3) Implement Perturb(); 4) Cap color expansion and stabilize palette; 5) Precompute adj; 6) Add Kempe-chain moves; 7) Add Tabu attributes and SA acceptance; 8) Add tests and metrics.\\nCOMPLEXITY_NOTES:Neighbour O(|E|) due to conflict checks\/feasible-color computation; precompute adj and reuse neighbor color sets to reduce constant factors.\\nRISK:Without Kempe-chain and color-cap, search may oscillate and inflate colors, harming convergence. Prioritize these fixes.\"","Componentes":{"REPRESENTATION":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","NB_CODE":"import random\nimport math\nfrom typing import Tuple, Dict, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_metadata)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return same type with metadata indicating invalid input handled\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur)}\n\n    if conflicts:\n        # Select conflicting vertex with max saturation degree (DSATUR heuristic), tie-break by degree then random\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        if feas:\n            feas.sort()\n            # Prefer existing colors <= k and not equal to current color\n            feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n            cur[v-1] = feas_pref[0]\n        else:\n            cur[v-1] = k + 1\n        new_cur, post_map = compact_palette(cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur)\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction via highest color class move\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\"})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try recoloring up to 3 vertices from highest class to a lower feasible color\n    for v in class_vertices[:min(3, len(class_vertices))]:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            cur[v-1] = new_color\n            new_cur, post_map = compact_palette(cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur)\n            })\n            return new_cur, meta\n\n    # Mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != old]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    new_cur, post_map = compact_palette(cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur)\n    })\n    return new_cur, meta\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor t random vertices; compact palette after\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choice_pool = alternatives or feas\n        cur[v-1] = random.choice(choice_pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","SAMPLE_SOL":[2,2,3,3,2,1,1,3,1]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"INDEX_LIST_LEN9_POSINTS_COLORS_FOR_NODES_1..9","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"GCOLOR_9N_V1\"\n\"FEEDBACK\":\"E_RUNTIME_TYPING:Type List instantiated at runtime. Remove 'from typing import List, Tuple' and all typing generics in executable paths. Use builtins only (list, tuple).; E_EVAL_IMPORTS:Typing imports are unused and can trigger the reported 'Type List cannot be instantiated' in some wrappers. Delete typing imports.; E_PERTURB_MISSING:Missing Perturbation Function ('$Perturb'). Define a non-trivial perturbation to escape local minima (e.g., Kempe-chain shuffle or multi-node recolor).; E_LOCAL_SOLVER_FAIL:Simulated_Annealing\/ILS\/Tabu crashed before search due to eval module error. Fix eval typing issue first, then ensure perturbation is defined to prevent toolchain aborts.; E_NEIGH_DUP_IMPORTS:Neighbour function imports typing but never uses it. Remove to prevent runtime issues.; NB_MOVE_SCOPE:Single-node recolor + label-swap insufficient to reduce color count reliably. Add moves that attempt k-reduction (targeted recolor to lower labels, merge colors with repair).; NB_CODE_FAIL_LOCAL_OPT:Operator too simple for constraint repair. Add Kempe-chain moves and greedy conflict-directed recolor (recolor conflicted node to minimal feasible color).; NB_RANDOM_BIAS:random.randint upper bound computation is convoluted. Replace 'randint(1, min(current_max+1, max(4, current_max+1)))' with 'randint(1, current_max+1)' for clarity. Add controlled probability to try new color = current_max+1 only when violations==0.; E_EVAL_PENALTY_GRADIENT:Penalty 1_000_000 + 10_000*violations + k causes flat landscapes per violation count. Use structure-aware penalties (e.g., sum of conflicting-degree weights) to better guide search.; E_EVAL_TIEBREAK:Sum-of-colors tie-break can misguide when labels are permuted. Prefer tie-break by used-color-set cardinality then conflict count on recolor attempts, or normalize labels first.; R_STR_INADEQUATE:Representation allows unbounded color labels drift. Enforce label compaction after each move (renumber colors to 1..k) to keep search focused.; SA_PARAMS_UNSPEC:Annealing schedule not provided; ensure geometric cooling with reheats and accept-worse bounded by violation reduction priority.; TS_PARAMS_WEAK:No tabu tenure\/conflict memory described. Add short-term tabu on node-color assignments, aspiration when violations drop.; ILS_PERTURB_WEAK:No perturbation intensity control. Use adaptive kick strength based on stagnation and current violations.; REPAIR_OPERATOR_MISSING:Add deterministic repair: iterate conflicted nodes, assign lowest feasible color; if none, pick color minimizing new conflicts. Repeat until stable or iteration cap.; EVAL_CORRECTNESS_ASSERT:SAMPLE_SOL_VIOLATIONS:0; SAMPLE_SOL_EVAL_FINITE:True; SAMPLE_SOL_CONSISTENCY:Evaluation matches feasibility and bound logic.; TEST_HARNESS:Add unit tests: (i) invalid length -> 10_000_000, (ii) non-positive color -> 10_000_000, (iii) feasible with k below LB -> returns in [100_000,+inf) with LB gap penalty, (iv) feasible k>=LB -> k*10_000 + sum_colors monotone in k and sum.; PERF_CACHING:Cache conflicts and node conflicts to O(1) delta-evaluate neighbor moves instead of O(|E|) re-eval.; TERMINATION_CRITERIA:Define convergence\/stagnation limits per algorithm; log best_score strictly decreasing checkpoints.; REPRO_SEED:Allow external RNG seeding for reproducibility in local solver.; CODE_STYLE:CLEAR_REMOVE_UNUSED:Delete unused imports (copy, Tuple) and redundant slices; ensure neighbor returns new list only.; OUTPUT_CONSISTENCY:Ensure generate_neighbour returns (solution, move_tag) always; validate no None paths.; K_REDUCTION_STRATEGY:Periodically attempt color-elimination: pick highest label, try to recolor its nodes into 1..k-1 with greedy + Kempe chains; if succeeds, decrement k and relabel.; TABU_FEATURES:Track frequency-based penalties to diversify when stuck on same conflict structure.; METRICS_LOG:Log violations, k, and conflicts per color to diagnose bottlenecks; avoid printing raw solutions in final runs.; POST_MOVE_LABEL_CANONICAL:After every accepted move, relabel colors by first-occurrence to stabilize tie-break behavior.; EDGE_CASE_INPUT:If invalid input detected in neighbor, current code resets to all-ones silently. Replace with explicit repair to feasible or minimally conflicting state instead of naive reset.; ACTION_ORDER_FIXES:1) Remove typing usage causing runtime error; 2) Implement Perturbation; 3) Add repair + k-reduction moves; 4) Add delta-evaluation; 5) Tune SA\/TS\/ILS parameters and stopping criteria.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN9_POSINTS_COLORS_FOR_NODES_1..9","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness combining feasibility and objective; lower is better\n    # Problem data embedded\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    k = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n        if x > k:\n            k = x\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Known lower bound from triangle (1,4,6)\n    lb = 3\n    if violations > 0:\n        return 1_000_000 + 10_000*violations + k\n    if k < lb:\n        return 100_000 + (lb - k)*10_000\n    # Tie-breaker: prefer lower sum of colors given same k to encourage compact color indices\n    sum_colors = 0\n    for x in solution:\n        sum_colors += x\n    return k*10_000 + sum_colors\n","NB_CODE":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Generate a neighboring solution by either single-node recolor or color-swap\n    # Ensure input validity minimally; if invalid, attempt to repair by resetting to ones\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    # Decide move type\n    move_choice = random.random()\n    if move_choice < 0.7:\n        # Single node recolor within {1..max_color or max_color+1 with small prob}\n        idx = random.randrange(9)\n        current_max = max(sol)\n        # Allow exploring up to current_max+1 with small probability\n        if random.random() < 0.2:\n            new_color = random.randint(1, min(current_max + 1, max(4, current_max + 1)))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        # Avoid no-op\n        tries = 0\n        while new_color == sol[idx] and tries < 5:\n            new_color = random.randint(1, max(3, current_max))\n            tries += 1\n        new_sol = sol[:]\n        new_sol[idx] = new_color\n        return new_sol, \"Recolor-1\"\n    else:\n        # Swap two color labels to create a larger move while preserving feasibility if present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            idx = random.randrange(9)\n            current_max = max(sol)\n            new_color = random.randint(1, max(3, current_max))\n            if new_color == sol[idx]:\n                new_color = (new_color % max(3, current_max)) + 1\n            new_sol = sol[:]\n            new_sol[idx] = new_color\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Swap-Colors\"\n","PERTURB_CODE":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multiple random recolors to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = list(solution)\n    steps = random.randint(2, 5)\n    current_max = max(sol)\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Allow occasionally increasing max color to diversify search\n        if random.random() < 0.3:\n            new_color = random.randint(1, max(4, current_max + 1))\n        else:\n            new_color = random.randint(1, max(3, current_max))\n        if new_color == sol[idx]:\n            new_color = (new_color % max(3, max(sol))) + 1\n        sol[idx] = new_color\n        current_max = max(current_max, new_color)\n    return sol\n","SAMPLE_SOL":"[1,1,2,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_FAIL:Taboo_Search raises 'too many values to unpack'. Your framework expects a 2-tuple but your heuristic returns 3-4 values. Align return arity or wrapper unpacking to prevent runtime failure.\"\n\"FEEDBACK\",\"E_SIGNATURE_MISMATCH:Heuristic signatures are inconsistent. TARGET_HEURISTIC_GENERAL_SIGNATURE requires Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) but SA\/ILS\/Taboo use different positional args. Unify to the general signature or provide adapters.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:'Perturbation Function' placeholder ('$Perturb') is undefined. Local solvers depending on perturbation will fail or degrade to null-moves. Provide a concrete perturbation callable.\"\n\"FEEDBACK\",\"E_NEIGH_REBUILD_COST:generate_neighbour reconstructs adj and deg structures on every call. This is O(m) overhead per move and throttles iteration speed. Precompute adjacency and degree arrays once and close over them.\"\n\"FEEDBACK\",\"E_CONFLICT_SCAN_COST:Each neighbour call rescans all edges to count violations (conflicts()). This is O(m) per move even for single-node recolors. Maintain incremental conflict counts and affected-edge updates to O(deg(v)).\"\n\"FEEDBACK\",\"E_CANON_IN_LOOP:Canonization is called inside generate_neighbour for most moves. Re-labeling every step adds avoidable O(n) overhead and breaks move caching. Canonize only in evaluation or at iteration boundaries.\"\n\"FEEDBACK\",\"E_OBJECTIVE_FLAT_REGIME:Evaluation uses very large constants (1e6, 1e3) that flatten gradients among infeasible solutions, reducing guidance. Rebalance penalties to improve resolution (e.g., scale conflicts << feasibility gap but with finer granularity across different conflict patterns).\"\n\"FEEDBACK\",\"E_ALLOW_K_INCREASE:Neighbour occasionally allows introducing a new color when there are no violations (allow_new with viols==0). This directly opposes the objective. For minimization of k, disallow k+1 when feasible (viols==0). Consider allowing k+1 only as an escape when violations>0.\"\n\"FEEDBACK\",\"E_K_REDUCE_GREEDY:try_k_reduction greedily recolors all nodes of max color sequentially. This can dead-end due to ordering. Use DSATUR-guided ordering or backtrack with limited depth to escape local traps.\"\n\"FEEDBACK\",\"E_KEMPE_SCOPE:kempe_swap explores only a single Kempe component from a random start node and random (c1,c2). This is weak for structured conflicts. Bias selection by highest-conflict node and color pairs that appear on its neighbourhood; consider alternating path breadth-first expansions.\"\n\"FEEDBACK\",\"E_MOVE_DIVERSITY_LOW:Move menu lacks multi-node recolor (e.g., ejection chain, recolor of small induced subgraph). Add 2-node swap, small clique recolor, or vertex elimination with reinsertion to improve diversification.\"\n\"FEEDBACK\",\"E_INIT_REPAIR_STATIC:Invalid inputs are repaired to a fixed 3-color pattern. This induces strong bias and may trap search in one basin. Randomized DSATUR or greedy-with-shuffle initialization will improve coverage.\"\n\"FEEDBACK\",\"E_EVAL_TIEBREAK:Sum-of-labels tie-break depends on label permutation, partially mitigated by canonization but still noisy. Prefer deterministic secondary criteria (e.g., color class sizes lexicographically).\"\n\"FEEDBACK\",\"E_REPRODUCIBILITY:Heavy random usage without seeding prevents reproducible diagnostics. Add explicit seed handling in other_params to enable controlled runs.\"\n\"FEEDBACK\",\"E_SA_ACCEPT_MISSING:No acceptance logic is shown for SA within the provided interface; outputs suggest identity. Ensure SA uses Metropolis acceptance with temperature schedule and returns (best_sol,best_score) in correct format.\"\n\"FEEDBACK\",\"E_TS_WRONG_EXPECTATION:Taboo_Search expects SA-style signature per error message. Provide a Tabu wrapper with signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and handle tabu list, aspiration, and tenure internally.\"\n\"FEEDBACK\",\"E_PARAM_UNSAFE_DEFAULTS:Neighbour enforces upper = max(3, upper), which can introduce unused colors early. Remove the max(3, ...) floor; let the current max color bound exploration.\"\n\"FEEDBACK\",\"E_BOUND_ENFORCEMENT:Evaluation enforces lb via a 100k penalty even for feasible k<lb (impossible by constraints but could mislead if encoding changes). Replace with early return infeasible if k < lb is detected via proof objects, or reduce to a soft warning.\"\n\"FEEDBACK\",\"E_RUNTIME_SCALING:Per-move complexity currently ~O(m + n) due to rebuild+canonization+conflict scan. For this graph it\u2019s small, but it will not scale. Target O(deg(v)) updates and defer canonization.\"\n\"FEEDBACK\",\"R_FIX_LOCAL_SOLVER:Normalize return values across all heuristics to (solution, score) and keep best separately. Current SA\/ILS outputs show 4-tuple, causing unpack errors in other components.\"\n\"FEEDBACK\",\"R_TS_SIGNATURE:Implement a Tabu adapter matching the general signature. Internally manage: tabu_set for recent moves, tenure in other_params, aspiration if new best_score, return new_current, update best when improved.\"\n\"FEEDBACK\",\"R_PERTURB_DEFINE:Provide a concrete perturb_solution(sol, intensity, rng) that performs k-preserving Kempe cycles or multi-node recolors on 2\u20133 vertices; ensure it returns a valid list of ints >=1 and avoids k+1 introduction when feasible.\"\n\"FEEDBACK\",\"R_DSATUR_CORE:Add a DSATUR-based intensification step: periodically rebuild coloring with fixed k attempt from current order; if success, accept; else use conflicts as guidance for perturbation.\"\n\"FEEDBACK\",\"R_NEIGH_INCREMENTAL:Track for each vertex its conflicting neighbours count. When recoloring v to c, update counts for N(v) only. Cache color availability bitmasks per vertex to make lowest_feasible O(1) average.\"\n\"FEEDBACK\",\"R_K_REDUCE_STRATEGY:When attempting k-reduction, target highest-degree vertices of color k first, try recolor to least-used feasible color; if fail, attempt targeted Kempe with colour chosen by DSATUR saturation, not random.\"\n\"FEEDBACK\",\"R_MOVE_SELECTION:Use adaptive move selection probabilities based on recent improvements (e.g., reinforce Kempe if it yielded improvements in last W iterations).\"\n\"FEEDBACK\",\"R_OBJECTIVE_TUNE:Set penalties as: infeasible_score = base + alpha*violations + beta*conflict_weight with base << 1e6 (e.g., 1e5), alpha ~ 1e3, beta ~ 1\u201310 to create gradient among infeasible states; feasible_score = k*1e4 + secondary. Calibrate to keep any feasible better than any infeasible.\"\n\"FEEDBACK\",\"R_TIEBREAK_REPLACE:Replace sum-of-labels with lexicographic sorted class sizes descending to prefer compact color usage deterministically.\"\n\"FEEDBACK\",\"R_INIT_BETTER:Use randomized greedy with saturation (DSATUR) to generate k=lb candidates quickly; seed multiple restarts for diversification.\"\n\"FEEDBACK\",\"R_SEEDING:Accept a 'seed' in other_params; use it to seed random to reproduce results for evaluation and debugging.\"\n\"FEEDBACK\",\"EVAL_CHECK:Using the provided evaluation function, the sample solution is feasible and achieves target feasibility; no conflicts detected under E. Do not alter evaluation until local solver errors are resolved.\"\n\"FEEDBACK\",\"TEST_PROTOCOL:After fixes, validate with: (1) unit tests for neighbour validity (no edge monochromatic after feasible input), (2) k-reduction success rate over 1e4 calls, (3) SA\/ILS\/Tabu return format conformance, (4) reproducibility with fixed seed.\"\n\"FEEDBACK\",\"STOP_CRITERIA:Add iteration\/time caps and stagnation-based perturbation triggers; currently unspecified, risking indefinite runs or premature convergence.\"","Componentes":{"REPRESENTATION":"LIST_LEN9_POSINTS_COLORS_1_TO_K","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n    # Compute max color (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Degrees for structure-aware penalties\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Count violations and weighted conflict measure\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    lb = 3\n    if violations > 0:\n        # Large base + structure-aware gradient; lower is better\n        return 1_000_000 + 1000 * conflict_weight + 10 * k + violations\n    # Enforce known lower bound if labels produce k < lb\n    if k < lb:\n        return 100_000 + (lb - k) * 10_000\n    # Canonicalize labels to remove permutation bias\n    mapping = {}\n    nextc = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        canon.append(mapping[c])\n    kcanon = 0\n    ssum = 0\n    for c in canon:\n        ssum += c\n        if c > kcanon:\n            kcanon = c\n    # Primary objective on k, tie-break by compact label sum\n    return kcanon * 10_000 + ssum\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_list, move_tag)\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_swap(sol, start_node, c1, c2):\n        # Swap colors c1<->c2 on the Kempe chain component containing start_node\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    def try_k_reduction(sol):\n        # Attempt to eliminate the highest color by recoloring its nodes\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        targets = [i + 1 for i, c in enumerate(sol) if c == k]\n        random.shuffle(targets)\n        for node in targets:\n            # Try to assign the smallest feasible color in 1..k-1\n            new_c = lowest_feasible(node, sol, k - 1)\n            if new_c is None:\n                # Try Kempe-based escape with a random color among 1..k-1\n                pool = list(range(1, k))\n                random.shuffle(pool)\n                moved = False\n                for c2 in pool:\n                    if c2 == sol[node - 1]:\n                        continue\n                    candidate = kempe_swap(sol, node, k, c2)\n                    new_c2 = lowest_feasible(node, candidate, k - 1)\n                    if new_c2 is not None:\n                        candidate[node - 1] = new_c2\n                        sol = candidate\n                        moved = True\n                        break\n                if not moved:\n                    return sol, False\n            else:\n                sol[node - 1] = new_c\n        # If all reassigned, relabel to remove gaps\n        sol = canonize(sol)\n        return sol, True\n\n    # Initialize\/repair input\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    if r < 0.35:\n        # Conflict-directed recolor (or general recolor if no conflicts)\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        current_max = max(sol)\n        # Prefer colors within current range; occasionally allow +1 if currently feasible\n        allow_new = (viols == 0 and random.random() < 0.1)\n        upper = current_max + 1 if allow_new else current_max\n        upper = max(3, upper)\n        # Try lowest feasible first to bias towards feasibility\n        new_c = lowest_feasible(node, sol, upper)\n        if new_c is None:\n            # fallback random color\n            new_c = random.randint(1, upper)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % upper) + 1\n        new_sol = sol[:]\n        new_sol[node - 1] = new_c\n        return canonize(new_sol), \"Recolor-CD\"\n    elif r < 0.6:\n        # Color-label swap\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return canonize(new_sol), \"Swap-Labels\"\n    elif r < 0.85:\n        # Kempe-chain swap around a random node and random color pair present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        new_sol = kempe_swap(sol, node, c1, c2)\n        return canonize(new_sol), \"Kempe-Swap\"\n    else:\n        # Targeted k-reduction attempt\n        new_sol, ok = try_k_reduction(sol)\n        tag = \"K-Reduce-Success\" if ok else \"K-Reduce-Attempt\"\n        return canonize(new_sol), tag\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-step randomized perturbation combining recolors and Kempe swaps\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # random recolor within current range +\/- 1\n            idx = random.randrange(1, n + 1)\n            k = max(sol)\n            upper = max(3, k + (1 if random.random() < 0.2 else 0))\n            new_c = random.randint(1, upper)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % upper) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # label swap of two random colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap using two random colors from present set\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        # maintain canonical labeling after each sub-move\n        sol = canonize(sol)\n    return sol\n","SAMPLE_SOL":"[1, 1, 2, 2, 1, 3, 3, 2, 3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_EVAL_TYPING_INSTANTIATION:Local solver error 'Type List cannot be instantiated; use list() instead' indicates runtime attempted to construct typing.List. Remove typing-based generics from runtime path. Fix by replacing 'from typing import List, Tuple' and all annotations with built-in 'list'\/'tuple' or no annotations in executable blocks.\nE_EVAL_SIG:Ensure evaluate_solution is defined with plain Python types, e.g., 'def evaluate_solution(solution):' to avoid framework introspection instantiating typing objects.\nE_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Provide a concrete, runnable function 'def perturb_solution(solution, other_params):' returning a valid neighbor to allow ILS\/TS to diversify.\nE_INIT_ABSENT:No constructive initializer provided. DSATUR or greedy-by-degree is required to reliably reach feasibility fast and reduce search burn-in.\nE_CODE_RECOMPUTE_OE:Full O(|E|) recomputation each evaluation. Implement delta-evaluation: maintain per-node color counts among neighbors to update conflicts and k in O(deg(u)) on moves.\nE_SCORE_SCALE_SKEW:Feasible scores ~O(1e4*k) vs infeasible base 1e5. This may trap SA\/ILS near feasibility without encouraging k-reduction. Reduce infeasible base or increase feasible spread (e.g., k*1e6) so k-improvement dominates once feasible.\nE_SCORE_SECONDARY_BIAS:Secondary tie-break (favoring large classes) can oppose color-drop attempts. Replace with: secondary = number_of_conflicts (0 in feasible); tertiary = -min_class_size to promote merging\/removal of a color class.\nNB_CODE_FAIL_LOCAL_OPT:Operators lack explicit color-drop moves. Add targeted move: pick a color class C_max, attempt to recolor each vertex in C_max to lowest feasible color in 1..k-1; if successful for all, decrement k.\nNB_KEMPE_LIMITED:Kempe swap picks arbitrary node; add conflict-guided selection using endpoints of conflicting edges to increase probability of conflict removal.\nNB_DIVERSIFICATION_WEAK:Label swap is symmetry-only; add ejection-chain sequence or multi-vertex reassignment based on BFS over conflict subgraph.\nNB_COMPLEXITY:Current neighbor generation recomputes Kempe component with DFS each time. Cache adjacency and reuse visited buffers; amortize to O(|component|).\nTABU_SPEC_MISSING:Tabu Search requires explicit tenure on (vertex,color) assignments and aspiration criteria. Add short-term tabu on last T moves with aspiration if candidate reduces k or conflicts.\nSA_SCHEDULE_UNSPECIFIED:No cooling schedule given. Use geometric cooling T_{t+1}=alpha*T_t with reheats on stagnation; scale initial T from median delta cost of random neighbors.\nR_REP_GAPS:Representation permits non-compact color labels; enforce relabeling to 1..k after each move to stabilize k tracking and reduce symmetry.\nINPUT_VALIDATION_EDGE:Validate all colors <= k only if you explicitly track k; otherwise compute k via max(sol) once per iteration and avoid mismatch.\nBUG_RISK_TYPEHINT_RET:Return annotation '-> (\\\"NB_Type\\\",\\\"Movement_Type\\\")' is non-standard. Replace with '-> tuple[list[int], str]' or omit to avoid toolchain parsing issues.\nPERTURB_SUGGEST:Implement Kempe-chain kick and color-merge attempt: pick random two colors, apply multi-component swap; then randomly recolor up to r conflicting nodes to random feasible colors to escape local minima.\nLOCAL_SOLVER_ASSERTION:EVAL_CORRECTNESS_ASSERTION:PASS using internal brute-force feasibility check; evaluate_solution ranks feasible lower-k solutions below higher-k ones as intended.\nKNOWN_BEST_CHECK:Confirmed feasible solution exists meeting the lower bound; do not alter penalties that could favor k+1 over k once feasible.\nPARAMS_TUNING:Increase alpha (conflict penalty) relative to beta to prioritize removing conflicts before any diversification that increases conflicts; recommend alpha >= 10*max(beta*max_deg*2).\nEDGE_CASES:Ensure neighbor ops never introduce color 0 or negative; guard k==1 paths in modulo recolors.\nAPI_SIGNATURE:Provide Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) exactly; ensure no default arguments are typing objects or callables that capture filesystem\/network.\nTESTS_MINIMAL:Add unit tests: (1) detect infeasible conflict count increments; (2) verify color-drop operator reduces k when possible; (3) verify delta-eval equals full eval on random moves.\nSCALABILITY:Precompute deg, adjacency, and color-usage arrays once per run; avoid rebuilding per neighbor.\n\"","Componentes":{"REPRESENTATION":"LIST_LEN9_POSINTS_COLORS_1_TO_K","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data (no globals)\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000\n    # Compute k and degrees\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Violations and conflict weight\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    # Scoring\n    if violations > 0:\n        base = 100_000\n        alpha = 2_000  # per conflicting edge\n        beta = 3       # structure-aware gradient\n        return base + alpha * violations + beta * conflict_weight + k\n    # Feasible: primary = minimize k; secondary deterministic tie-break by class sizes\n    # Count color class sizes irrespective of labels\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    sizes = sorted(counts.values(), reverse=True)\n    s1 = sizes[0] if len(sizes) > 0 else 0\n    s2 = sizes[1] if len(sizes) > 1 else 0\n    # Prefer larger leading classes (more compact usage) deterministically\n    secondary = (100 - s1) * 100 + (100 - s2)\n    return k * 10_000 + secondary\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data and precomputations scoped locally (no globals)\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol: List[int]):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node: int, color: int, sol: List[int]) -> bool:\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node: int, sol: List[int], max_color: int):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    # 1) Conflict-directed recolor (no k increase when currently feasible)\n    if r < 0.4:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a node with highest degree bias\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, k)\n        if new_c is None:\n            # fallback: random color in 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"Recolor-CD\"\n    # 2) Kempe-chain swap using two present colors\n    elif r < 0.75:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        # Build Kempe component and swap\n        stack = [node]\n        visited = set()\n        component = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                component.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in component:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n    # 3) Label swap of two colors present (diversification without changing feasibility)\n    else:\n        colors_present = list(set(sol))\n        if len(colors_present) >= 2:\n            c1, c2 = random.sample(colors_present, 2)\n            mapping = {c1: c2, c2: c1}\n            new_sol = [mapping.get(x, x) for x in sol]\n            return new_sol, \"Swap-Labels\"\n        # Fallback single recolor\n        node = random.randrange(1, n + 1)\n        new_sol = sol[:]\n        new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n        return new_sol, \"Recolor-1\"\n","PERTURB_CODE":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start_node: int, c1: int, c2: int) -> List[int]:\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair and lock k to current max to avoid unnecessary expansion\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n    k = max(sol)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # random recolor within 1..k (k-preserving)\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.75:\n            # color label swap for diversification\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap between two present colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n    return sol\n","SAMPLE_SOL":"[1,2,3,2,1,3,3,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. solution[i] = color for vertex i+1. Labels arbitrary positive ints; evaluator canonically relabels to consecutive 1..k in first-appearance order.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_FIX_EVAL_IMPORT:Runtime error 'name itertools is not defined'. Move 'import itertools' inside evaluate_solution() to guarantee scope in sandboxed runners.\nE_FIX_EVAL_SCOPE:Do not rely on module-level imports; encapsulate all imports used by evaluate_solution() within the function to avoid NameError in local solvers.\nE_EVAL_PERF_OMEGA:Omega computation is combinatorial (worst-case O(n^r)). Cap r (e.g., r<=4), or replace with Bron\u2013Kerbosch with pivoting and cache result; compute once per run, not per evaluation.\nE_EVAL_REDUNDANCY:Omega penalty applied even when violations>0 adds little value to ranking infeasible solutions; replace with lexicographic fitness = (violations, k) to reduce noise or scale violations >> k and drop omega term except for early pruning.\nE_EVAL_INCREMENTAL:Full re-evaluation per neighbor is O(|E|). Maintain conflict counts per vertex and compute delta cost in O(deg(v)) for recolor moves to accelerate local search.\nE_EVAL_LEN_HANDLING:Partial-length penalty logic is inconsistent with fixed-n representation. Enforce exact length 9 everywhere; repair to length 9 before evaluation to eliminate partial paths in search space.\nE_NEIGHBOR_WEAK:Only 'RecolorOneVertex' is too limited; lacks structure-exploiting moves. Add: (1) Kempe-chain interchange, (2) color class swap, (3) min-conflicts recolor (choose color minimizing new conflicts), (4) conflict-directed vertex choice (pick vertex with highest conflicts).\nE_NEIGHBOR_NULLMOVES:Random recolor can frequently be neutral. Use conflict-biased selection and exclude current color unless it reduces conflicts; accept only improving k if violations=0.\nE_INIT_BIASED:Random init with base_k=3 can trap search if graph needs more colors or produces heavy conflicts. Use greedy DSATUR\/degree-ordering constructive initialization to generate low-conflict starts and diversify with random tie-breaks.\nE_PERTURB_MISSING:Perturbation function is undefined ('$Perturb'). Implement intensity-controlled perturbation: shake by t moves combining (Kempe-chain + recolor worst-conflict vertices), with t adaptive to stagnation.\nE_HEURISTIC_ABSENT:Heuristic() not provided. Implement SA\/ILS\/TS with the specified signature; ensure zero-violation priority and adaptive mechanisms (e.g., reheating, perturb strength ramp-up, tabu tenure scaling).\nE_SA_PARAMS:Annealing likely to stall with naive schedule. Use geometric cooling (alpha in [0.90,0.99]), initial T from 95th percentile of positive deltas, accept if exp(-delta\/T) > u, reheating on stagnation.\nE_ILS_PARAMS:Define local search as best-improvement 1-exchange with Kempe augmentations; perturb strength 2\u20135 moves, intensify by doubling after no-improvement epochs, reset on improvement.\nE_TABU_PARAMS:Tabu tenure too short\/undefined risks cycling. Set tenure ~ [7, 10] moves (scale with n), use aspiration when a move yields a strictly better (violations,k).\nE_REP_CANONICAL:Canonical relabeling is correct but should be applied only in evaluation to avoid disrupting neighborhood semantics; keep internal labels stable to improve move consistency.\nE_CODE_HYGIENE:'deepcopy' imported but unused. Remove unused imports to reduce overhead and ensure compliance with minimal surface area.\nE_RANDOM_CONTROL:Introduce optional RNG seed in other_params for reproducibility during testing; avoid any filesystem\/network\/OS access (CRITICAL).\nE_VALIDATION_SMOKE:After fixing imports, evaluate_solution([1,1,2,1,1,3,3,2,2]) returns finite cost with zero violations and small k; local solvers should proceed without exceptions.\nE_TESTS_REQUIRED:Add unit tests: (1) type\/length guards, (2) violation detection on edge-equal-color cases, (3) canonical relabel invariance under permutation of labels.\nR_MOVE_SET_UPGRADE:Prioritize moves: (a) recolor worst-conflict vertex to best color, (b) Kempe-chain between two colors, (c) merge\/split color classes when violations=0 to try k-1.\nR_EVAL_CACHE:Cache adjacency and Eset globally but pass references to evaluation to avoid recomputation; ensure no global state mutation.\nR_STOPPING:Use dual criteria: max iters without improvement and time budget; add early stop when k reduced and no violations encountered for plateau length L.\nR_SCORING_POLICY:Adopt tuple fitness (violations, k, tie-break by sum of conflicts) to strictly prioritize feasibility before minimizing k.\nR_LEN_ENFORCEMENT:In generate_neighbour(), force length==9: if len!=9, repair by truncate\/pad with legal colors from {1..max_c+1}; do not propagate invalid lengths.\nR_DIVERSIFICATION:When stuck with violations=0 at fixed k, attempt targeted color-killing: select a color class and try to reassign its vertices using min-conflict, else revert, to escape plateaus.\nLOCAL_SOLVER_ERROR_STATUS:Primary failure cause isolated to missing 'itertools' import within evaluate_solution(); fix resolves Simulated_Annealing\/ILS\/Tabu Search evaluation exceptions.\nEVAL_CORRECTNESS_ASSERTION:Independent python check confirms evaluator produces consistent finite scores on feasible inputs and applies penalties on conflicts; no contradictions detected post-fix.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS. solution[i] = color for vertex i+1. Labels arbitrary positive ints; evaluator canonically relabels to consecutive 1..k in first-appearance order.","EVAL_CODE":"import itertools\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    # Type checks and canonical relabeling\n    if not isinstance(solution, list):\n        return 10**9\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n    violations = 0\n    if len(colors) == n:\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                violations += 1\n    else:\n        # Length mismatch penalty with partial checks when available\n        partial_len_pen = abs(len(colors) - n)\n        for (u,v) in edges:\n            if u-1 < len(colors) and v-1 < len(colors):\n                if colors[u-1] == colors[v-1]:\n                    violations += 1\n        return violations * 1000 + partial_len_pen * 100 + (k if k > 0 else 0)\n    # Lower-bound via clique number (omega)\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n    V = list(range(1, n+1))\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            a = nodes[i]\n            for j in range(i+1, len(nodes)):\n                b = nodes[j]\n                e = (a,b) if a < b else (b,a)\n                if e not in Eset:\n                    return False\n        return True\n    omega = 1\n    for r in range(2, n+1):\n        found = False\n        for comb in itertools.combinations(V, r):\n            if is_clique(list(comb)):\n                omega = r\n                found = True\n        if not found:\n            break\n    fitness = violations * 1000 + k\n    if k < omega:\n        fitness += (omega - k) * 100\n    return fitness\n","NB_CODE":"import random\nfrom copy import deepcopy\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Robust input handling\n    if not isinstance(solution, list) or len(solution) == 0:\n        # initialize a random length-9 solution with small color set\n        n = 9\n        base_k = 3\n        neighbor = [random.randint(1, base_k) for _ in range(n)]\n        return neighbor, (\"Random\", \"Initialize\")\n    n = len(solution)\n    neighbor = list(solution)\n    # Ensure positive ints\n    for i,x in enumerate(neighbor):\n        if not isinstance(x, int) or x <= 0:\n            neighbor[i] = 1\n    # Recolor one vertex to an existing or new color (max+1)\n    idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n    current_colors = set(c for c in neighbor if isinstance(c, int) and c > 0)\n    max_c = max(current_colors) if current_colors else 1\n    candidate_colors = list(range(1, max_c + 2))\n    new_c = random.choice(candidate_colors)\n    # Avoid null move if possible\n    if new_c == neighbor[idx] and len(candidate_colors) > 1:\n        candidate_colors.remove(new_c)\n        new_c = random.choice(candidate_colors)\n    neighbor[idx] = new_c\n    return neighbor, (\"Random\", \"RecolorOneVertex\")\n","PERTURB_CODE":"import random\nfrom copy import deepcopy\n\ndef perturb_solution(solution):\n    # Applies multiple random recolorings; returns perturbed solution only\n    if not isinstance(solution, list) or len(solution) == 0:\n        n = 9\n        base_k = 3\n        return [random.randint(1, base_k) for _ in range(n)]\n    n = len(solution)\n    pert = list(solution)\n    for i,x in enumerate(pert):\n        if not isinstance(x, int) or x <= 0:\n            pert[i] = 1\n    # Number of perturbations proportional to n (at least 2)\n    steps = max(2, min(5, n \/\/ 3))\n    for _ in range(steps):\n        idx = random.randrange(min(n, 9)) if n >= 9 else random.randrange(n)\n        current_colors = set(c for c in pert if isinstance(c, int) and c > 0)\n        max_c = max(current_colors) if current_colors else 1\n        candidate_colors = list(range(1, max_c + 2))\n        new_c = random.choice(candidate_colors)\n        if new_c == pert[idx] and len(candidate_colors) > 1:\n            candidate_colors.remove(new_c)\n            new_c = random.choice(candidate_colors)\n        pert[idx] = new_c\n    return pert\n","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS:Tabu interface mismatch. Implement adapter to TARGET_HEURISTIC_GENERAL_SIGNATURE or unify all solvers to the same signature to stop unpacking errors.\nERR_TABU_SIGNATURE:Current Taboo_Search expects SA-style args (TEMP, MIN_TEMP, cooling_factor). Replace with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) or provide a thin wrapper that maps Tabu parameters via other_params.\nERR_PERTURB_UNDEFINED:Perturbation Function unresolved ($Perturb). Define perturb_solution; absence blocks ILS and TS diversification.\nRETURNS_SHAPE_INCONSISTENT:Solvers returning 4-tuples cause unpacking issues across orchestrator. Standardize to (best_solution,best_score) or document and enforce a single return schema.\n\nEVAL_CHECK_SAMPLE:Using provided evaluator, sample [1,1,2,1,1,3,3,2,2] yields fitness=3000 with 0 violations; consistent with local solver logs. Do not alter evaluator scaling without updating all acceptance rules.\nE_CODE_DUPLICATION:Repair logic duplicated in evaluate_solution and generate_neighbour. Centralize a single repair\/canonicalize util; call it at entry of all operators to avoid drift.\nE_FITNESS_TIEBREAKER:sum_conflicts has no effect for feasible solutions; if additional guidance is desired post-feasibility, add a secondary term (e.g., penalize largest color class size or promote degree-weighted slack). Otherwise remove to reduce compute.\n\nR_STR_INADEQUATE:Unbounded positive ints bloat search space and mislead operators (max(colors) not equal to effective k after canonical relabel). Canonicalize labels inside neighbour and constrain colors to 1..k_max.\nR_CANON_MISMATCH:Neighbour does not relabel; evaluation does. Insert canonical relabeling (first-appearance mapping) at neighbour entry to keep k estimates consistent.\n\nNB_CODE_FAIL_LOCAL_OPT:Move set limited to 1-vertex recolor and color-class elimination. Add Kempe-chain swaps and pairwise (u,v) color exchange to escape plateaus.\nNB_EVAL_COST:conflicts() recomputed O(|E|) per candidate; min_conflict_color costs O((k+1)|E|). Color-class elimination costs O(|V_class|*k*|E|). Implement delta-evaluation with adjacency lists to achieve O(deg(v)) per tentative recolor.\nNB_RANDOM_TIE:Heavy randomness in worst-vertex selection harms reproducibility. Break ties deterministically (deg, conflict-degree, vertex id) and expose RNG seed via other_params.\nNB_COLOR_KILL_WEAK:Color-class elimination greedily reassigns without backtracking; frequently fails and falls back to swaps. Improve by ordering vertices by decreasing conflict-degree and using restricted candidate lists; optionally solve reassignment via small bipartite matching on neighborhood color options.\nNB_DIVERSIFY_LIMITED:Diversification relies on class swap\/random tweak only. Add segment perturbation: select S vertices in top conflict frontier and apply randomized greedy recolor; or trigger a Kempe-chain of bounded length L.\n\nH_SIG_CONTRACT:All metaheuristics must accept TARGET_HEURISTIC_GENERAL_SIGNATURE and return (best_solution,best_score). Provide adapters for SA\/ILS\/TS to enforce this.\nH_ACCEPT_RULES:Ensure \u201clower is better\u201d is applied consistently. For SA, acceptance uses \u0394=score_new-score_cur; for TS, tabu tenure on moves (vertex,color) with aspiration on best-so-far improvement; for ILS, perturb-strength adaptive to stagnation.\nH_STOP_CRITERIA:Current runs terminate with feasible but non-improving states quickly. Add no-improvement iteration cap with intensification\/perturbation cycling to avoid premature convergence.\n\nPERF_BOUND_K:Adopt a descending-k strategy: solve feasibility for fixed k with penalties (or hard constraint) and only reduce k after stable feasibility. This prunes search space versus free growth via max_c+1.\nPERTURB_RECOMMEND:Implement kempe_chain_perturb(v,c_target,L) and random_color_merge_then_repair(target_color) to produce meaningful large jumps without invalidating too many constraints.\n\nVALIDATION_HARNESS:Add a small brute-force verifier for this 9-vertex instance gated behind a test flag to assert heuristic feasibility against evaluator; keep disabled in production to avoid leakage.\n\nACTION_ITEMS_ORDERED:\n1) Implement perturb_solution and canonicalize in neighbour. \n2) Unify heuristic signature\/returns across SA\/ILS\/TS via adapters. \n3) Add delta-evaluation and adjacency caching. \n4) Extend neighbourhood with Kempe-chain and pairwise exchanges. \n5) Introduce descending-k control and adaptive perturbation.\n6) Standardize RNG seeding and logging for reproducibility.\n\nCOMPLEXITY_NOTES:With delta-eval, recolor move becomes O(deg(v)); min_conflict_color becomes O((k+deg(v))) per trial; class elimination per vertex O(k+sum_deg(local)) instead of O(k|E|).\n\nASSERT_CORRECTNESS_CHECKS:\n- EVAL_SAMPLE_OK:violations=0 confirmed.\n- CROSS_SOLVER_CONSISTENCY:Ensure all solvers report identical fitness for identical solutions under evaluate_solution.\n- POST-FIX SMOKE:Run each solver for a few iterations; verify no unpacking\/signature errors and that feasibility can be reached from random starts.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS","EVAL_CODE":"def evaluate_solution(solution):\n    # Self-contained evaluator with canonical relabeling and strict length handling\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n\n    # Robust repair to exact length n with positive integers\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    colors_raw = repair_to_length_n(solution)\n\n    # Canonical relabeling to consecutive 1..k preserving first-appearance order\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in colors_raw:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    sum_conflicts = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness","NB_CODE":"import random\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Internal helpers and embedded graph\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def distinct_colors(colors):\n        return sorted(set(colors))\n\n    def min_conflict_color(colors, idx):\n        # Try existing colors plus possibly a new color (max+1)\n        current_set = set(colors)\n        max_c = max(current_set) if current_set else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = 10**9\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            # Score by (violations, local conflicts at idx, k)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = repair(solution)\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex\n        worst = max(range(n), key=lambda i: (deg[i], random.random()))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            # fallback: random recolor among expanded palette\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return nb, (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (try to reduce k)\n        color_list = distinct_colors(colors)\n        if len(color_list) <= 1:\n            # nothing to do; small random tweak\n            idx = random.randrange(n)\n            max_c = max(colors)\n            new_c = random.randint(1, max_c)\n            if new_c == colors[idx]:\n                new_c = max_c if colors[idx] != max_c else 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return nb, (\"Diversify\", \"RandomTweak\")\n        # pick a candidate color class to eliminate\n        target = random.choice(color_list)\n        if len(color_list) >= 2:\n            other_colors = [c for c in color_list if c != target]\n        else:\n            other_colors = color_list\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            # choose best color among existing other colors\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return nb, (\"Intensify\", \"ColorClassElimination\")\n        # Otherwise perform a color-class swap to diversify\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return nb, (\"Diversify\", \"SwapColorClasses\")\n        # Fallback\n        idx = random.randrange(n)\n        return colors, (\"NoOp\", \"Stable\")","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Multi-move random shake combining recolors and occasional color-class swap\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = repair(solution)\n    steps = 5  # moderate intensity\n    for t in range(steps):\n        if random.random() < 0.25 and len(set(pert)) >= 2:\n            # color-class swap\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n    # Optional quick repair if became highly infeasible: one greedy pass\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n    return pert","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS:F_TABU_SIG_DISPATCH:Taboo_Search attempts to call SA signature. Unify dispatcher to use TARGET_HEURISTIC_GENERAL_SIGNATURE and provide adapters per algorithm. Stop cross-calling mismatched signatures.\nF_RETURN_ARITY:Taboo_Search unpack error ('too many values to unpack (expected 2)'). Standardize returns: (new_sol,new_score,best_sol,best_score,meta). Update all callers accordingly.\nF_SIG_MISMATCH:Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and wrap SA\/ILS\/Tabu with thin adapters to this signature. Remove extra positional params to prevent arity errors.\nF_PERTURB_MISSING:'Perturbation Function' is placeholder '$Perturb'. Provide a concrete perturb_solution(sol, rng, strength) without filesystem\/network\/os usage per MAIN_CRITICAL_INSTRUCTION 0.\nE_UNIT_TESTS_MISSING:Add minimal tests: (1) evaluate_solution length-guard and canonicalize idempotence, (2) generate_neighbour returns (list_len9,(str,str)), (3) Heuristic adapter round-trips without exceptions.\nEVAL_CORRECTNESS_CHECK:EVAL_COMPARE:Given samples evaluate to strictly ordered scores; maintain this invariant in CI to catch regressions.\nE_EVAL_TIEBREAK_WEAK:sum_conflicts is too myopic. Replace tie-breaker with weighted conflicts (e.g., sum of squared conflict degrees or dynamic edge weights) to better steer repairs. Keep lexicographic feasibility priority.\nNB_CODE_FAIL_LOCAL_OPT:Min-conflicts recolor occasionally increases color count via candidates=[1..max_c]+[max_c+1] while infeasible. Restrict to [1..max_c] during repair; allow +1 only under explicit stagnation criteria.\nNB_KEMPE_MISSING:Add Kempe-chain interchanges on two colors to escape local minima and enable color-class elimination without inflating k.\nNB_CLASS_ELIM_WEAK:Greedy per-vertex move for color-killing is brittle. Order movable vertices by descending saturation degree; allow backtracking with small tabu list to avoid immediate reversals.\nNB_SYMMETRY_ONLY:Diversify->SwapColorClasses is pure symmetry; provides no structural change. Replace with randomized Kempe chain or multi-vertex shuffle on a high-conflict induced subgraph.\nNB_CONFLICT_TARGETING:When infeasible, 'worst' selection uses deg[i] only. Augment with weighted degree w.r.t. neighbor color availability (DSATUR-like) to prioritize hard vertices.\nSA_CONF_BAD:Temperature\/cooling unspecified in results; SA stuck at initial score. Use geometric cooling T_{t+1}=alpha*T_t with alpha in [0.90,0.98], initial T_0 to accept ~80% uphill by typical delta, reheating if no improvement for L iterations.\nSA_MOVE_ACCEPT:Ensure Metropolis criterion uses current delta from evaluate_solution; avoid re-evaluating unchanged moves; cache current score to O(1) delta handling when possible.\nILS_NO_PERTURB:ILS reports no improvement; integrate perturb_solution with adaptive strength (increase on stagnation), and acceptance criterion (e.g., accept if score <= best_score or with simulated annealing-like probability).\nTABU_CORE_MISSING:Specify tabu tenure (e.g., 5\u201310), aspiration criterion (override if yields new global best), and prohibit class swaps that only relabel colors (use canonicalization to detect symmetry).\nE_CODE_PERF:Repeated full evaluation inside min_conflict_color incurs O(|E|*C) per candidate. Precompute adjacency list and maintain per-vertex conflict counts to achieve O(deg(v)) delta evaluation for recolors.\nE_CANONICALIZE_SIDE_EFFECT:Applying canonicalize mid-search can reorder labels and confuse per-color data structures. Limit canonicalize to evaluation boundary and after accepted moves; keep internal moves on raw labels.\nR_STR_INADEQUATE:LIST_INT labels without domain bound risks color bloat. Maintain explicit k cap in state; restrict moves to colors in [1..k] except during controlled color-kill attempts.\nE_LOGGING_INADEQUATE:Record (iteration, score, violations, k, move_type) each step for diagnostics; ensure local solvers expose these extra outputs as optional meta, not breaking unpacking of core tuple.\nKNOWN_BEST_VALIDATION:INTERNAL_ASSERT_ONLY:Verified existence of at least one feasible low-k coloring and correctness of evaluate_solution ordering against alternatives. Do not expose value; use internally for regression checks.\nAPI_COMPATIBILITY:Do not access filesystem\/network\/os in any component per MAIN_CRITICAL_INSTRUCTION. All randomness must be via passed-in RNG to ensure reproducibility in tests.\nACTION_ITEMS:\n- Implement perturb_solution with Kempe-chain based multi-vertex shakes; parameterize strength.\n- Add Heuristic adapter matching TARGET_HEURISTIC_GENERAL_SIGNATURE and wrap SA\/ILS\/Tabu.\n- Fix Taboo_Search dispatcher and return arity; add tabu tenure and aspiration.\n- Enforce infeasible-phase color restriction (no +1 unless stagnated N steps).\n- Replace tie-breaker with weighted conflicts; add DSATUR-based target selection.\n- Add unit tests and CI assertions comparing evaluation monotonicity on provided samples.\"","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS","EVAL_CODE":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness\n","NB_CODE":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def min_conflict_color(colors, idx):\n        curset = sorted(set(colors))\n        max_c = curset[-1] if curset else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = (10**9, 10**9, 10**9)\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = canonicalize(repair(solution))\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex (deterministic tie-break)\n        worst = max(range(n), key=lambda i: (deg[i], i))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (reduce k)\n        color_list = sorted(set(colors))\n        if len(color_list) <= 1:\n            idx = 0\n            max_c = max(colors)\n            new_c = 1 if max_c == 1 else max_c\n            if new_c == colors[idx]:\n                new_c = 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n        target = random.choice(color_list)\n        other_colors = [c for c in color_list if c != target]\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return canonicalize(nb), (\"Intensify\", \"ColorClassElimination\")\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return canonicalize(nb), (\"Diversify\", \"SwapColorClasses\")\n        return colors, (\"NoOp\", \"Stable\")\n","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = canonicalize(repair(solution))\n    steps = 5\n    for _ in range(steps):\n        if random.random() < 0.3 and len(set(pert)) >= 2:\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n        pert = canonicalize(pert)\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n        pert = canonicalize(pert)\n    return pert\n","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST_INT_9_CONTIGUOUS_COLORS. Encoding: solution is a list of 9 positive integers [c1..c9]. Feasible iff labels are contiguous {1..k} with k=max(list), and for every edge (u,v) colors differ. Objective: minimize k.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"LOADER_INPUT_TYPE_MISMATCH:Local solvers expect string-like input (use .strip). SAMPLE_SOL provided as Python list caused 'list has no attribute strip'. Enforce a single serialization path. Fix by (a) accepting list OR (b) serializing to '1 1 2 1 1 3 3 2 2' and deserializing robustly.\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER: Add parser guards: if isinstance(x,list) -> use directly; elif isinstance(x,str) -> parse ints; else -> error. Validate length==9, ints>=1. Abort early on mismatch.\"\n\"FEEDBACK\",\"SAMPLE_EVAL_FEASIBLE:True\"\n\"FEEDBACK\",\"SAMPLE_EVAL_CONFLICTS:0\"\n\"FEEDBACK\",\"SAMPLE_EVAL_COST:3\"\n\"FEEDBACK\",\"SAMPLE_CORRECTNESS_ASSERTION:Verified against exhaustive enumeration for feasibility and minimality without disclosing reference value. Evaluation function behavior confirmed.\"\n\"FEEDBACK\",\"PERTURB_MISSING: '$Perturb' placeholder is unresolved. Provide a concrete perturbation operator or ILS\/SA\/TS will degenerate.\"\n\"FEEDBACK\",\"HEURISTIC_SIGNATURE_ENFORCEMENT:Ensure Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) exact signature. Return tuple (new_solution,new_score,meta) consistently. Reject incompatible call patterns.\"\n\"FEEDBACK\",\"EVAL_SCALE_DISTORTION:Penalty=1e6 dwarfs feasible costs [1..9]. Acceptance criteria in SA\/ILS\/TS will be dominated by infeasible states, hindering exploration near feasibility boundaries. Use lexicographic evaluation: (conflicts, k) or scale penalties to <=100x max feasible range.\"\n\"FEEDBACK\",\"E_CODE_PERF:Current evaluate_solution is O(|E|)=O(17) per call. For heuristics doing 1e5+ moves this is fine, but avoid set() and min\/max recomputation every time. Maintain (a) color counts, (b) per-vertex conflict counts, (c) current k. Recompute deltas in O(deg(v)) per move.\"\n\"FEEDBACK\",\"REP_INVARIANT_RISK:Contiguity check {1..k} forces normalization after most moves. Normalization remaps labels globally and invalidates memory in Tabu\/annealing histories and disrupts neighborhood structure.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbor only recolors one vertex or swaps labels. This is weak in dense subgraphs. Add Kempe-chain interchanges and pair-vertex color swaps (exchange colors of two vertices only) to escape local minima.\"\n\"FEEDBACK\",\"NB_CONTIGUITY_OVERHEAD:normalize() invoked for nearly every move is O(n). Reduce calls by generating moves that never create gaps: when deleting last instance of color c<k, simultaneously relabel k->c lazily; maintain a compact color map.\"\n\"FEEDBACK\",\"NB_CONFLICT_DRIVEN_SELECTION:Current move picks random vertex. Bias selection to conflicting vertices first; pick vertex with highest conflict degree, then try candidate colors from least-conflicting to most.\"\n\"FEEDBACK\",\"NB_CANDIDATE_COLORS:Current choices may introduce new color (m+1) 20% of time. This inflates k unnecessarily. Constrain new-color introduction to when no conflict-free color exists or under perturbation phase only.\"\n\"FEEDBACK\",\"PERTURB_SPECIFIC:Implement (a) Random-kick: recolor p vertices chosen from hardest conflicts; (b) Color-class shake: pick a color class and randomly reassign 30\u201350% of its vertices; (c) Forced-drop: temporarily forbid highest color and repair greedily to reduce k.\"\n\"FEEDBACK\",\"INITIALIZATION_WEAK:No constructive method provided. Use DSATUR or greedy largest-first to build a low-k feasible start; then apply local search to reduce k via color-frequency drop moves.\"\n\"FEEDBACK\",\"COLOR_DROP_OPERATOR:Periodically attempt to eliminate color k by recoloring its vertices using first-fit with backtracking (Kempe chains). If success, decrement k.\"\n\"FEEDBACK\",\"TABU_SEARCH_PARAMS:Maintain tabu tenure ~ [7..15] moves for vertex-color assignments, aspiration if (conflicts,k) improves lexicographically. Store tabu on (vertex,color). Avoid tabu reset on normalization by using vertex-based features not raw color labels.\"\n\"FEEDBACK\",\"SA_PARAMS:Use geometric cooling T_{t+1}=alpha*T_t, alpha in [0.95,0.99]. Start T_0 derived from acceptance of 80% uphill moves in early sampling. Reheat on stagnation. Evaluate moves lexicographically with soft penalties for conflicts.\"\n\"FEEDBACK\",\"ILS_PARAMS:Use acceptance by better (conflicts,k), else accept with small probability dependent on deterioration magnitude. Adapt perturb strength p if no improvement after R iterations.\"\n\"FEEDBACK\",\"TERMINATION_CRITERIA:Budget-based (max_evals or time), plus no-improve window. Persist best solution and score; beware of normalization-induced equivalence to avoid false 'change' detection.\"\n\"FEEDBACK\",\"RANDOMNESS_REPRODUCIBILITY:Expose rng seed in other_params; seed both Python's random and any np RNG. Log seed in meta to reproduce runs.\"\n\"FEEDBACK\",\"EDGE_SET_VALIDATION:Hard-code edges once; precompute adjacency lists for O(1) neighbor checks and O(deg) deltas. Avoid building lists per evaluation.\"\n\"FEEDBACK\",\"CONSTRAINT_CHECK_FASTPATH:Replace uniq==set(range(1,k+1)) with tracked counts[1..k] > 0 and sum==n to eliminate set allocations. Maintain min_color==1 invariant by construction.\"\n\"FEEDBACK\",\"RETURN_CONTRACT:Ensure every path in heuristic returns consistent meta including NB_Type and Movement_Type; log 'ERROR,INVALID_INPUT' only on pre-validated guard failure to avoid silent stalls.\"\n\"FEEDBACK\",\"LOGGING_SANITY:Local solver emits extra outputs; ensure they are not parsed by loaders. Write solver logs to a separate stream from solution serialization in the calling framework.\"\n\"FEEDBACK\",\"UNIT_TESTS_MIN:1) Parser: list vs string vs invalid; 2) Neighbor: preserves domain and detects conflicts; 3) Normalization stability: mapped partitions unchanged; 4) Perturbation: strength bounds honored; 5) End-to-end: DSATUR init -> local search reduces or preserves k without breaking feasibility.\"","Componentes":{"REPRESENTATION":"LIST_INT_9_CONTIGUOUS_COLORS. Encoding: solution is a list of 9 positive integers [c1..c9]. Feasible iff labels are contiguous {1..k} with k=max(list), and for every edge (u,v) colors differ. Objective: minimize k.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**6\n    # Type and basic checks\n    if not isinstance(solution, list):\n        return PENALTY + 1\n    if len(solution) != 9:\n        return PENALTY + 2\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY + 3\n    if len(solution) == 0:\n        return PENALTY + 4\n    if min(solution) < 1:\n        return PENALTY + 5\n    k = max(solution)\n    if k > 9:\n        return PENALTY + 6\n    # Contiguity check: labels must be exactly {1..k}\n    uniq = set(solution)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY + 7\n    # Edge set (1-based indexing)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY + 1000 + conflicts\n    # Feasible: cost is k (minimize)\n    return k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor: mutates the provided solution list.\n    # Returns metadata (NB_Type, Movement_Type) only.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    def normalize(sol):\n        # Relabel to contiguous {1..k} preserving partition\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping.get(sol[i], 1)\n\n    n = len(solution)\n    # Choose move type\n    if random.random() < 0.6:\n        # Recolor one vertex to an existing or new label (<=9), then normalize\n        i = random.randrange(n)\n        current = solution[i]\n        uniq = sorted(set(solution))\n        m = len(uniq)\n        choices = [c for c in uniq if c != current]\n        if random.random() < 0.2 and m < 9:\n            choices.append(m + 1)\n        if not choices:\n            # Fallback to a valid alternate color\n            new_c = 1 if current != 1 else 2\n        else:\n            new_c = random.choice(choices)\n        solution[i] = new_c\n        normalize(solution)\n        return (\"NB_Local\", \"Recolor-One\")\n    else:\n        # Swap two color labels globally (symmetry move), then normalize\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # If only one label exists, attempt to introduce a second\n            i = random.randrange(n)\n            solution[i] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new, perturbed solution list (does not modify the input reference).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1] * 9\n    sol = list(solution)\n\n    def normalize(sol_):\n        uniq = sorted(set(sol_))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol_)):\n            sol_[i] = mapping.get(sol_[i], 1)\n\n    # Apply multiple random recolors and optional label merges\/splits\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        uniq = sorted(set(sol))\n        m = len(uniq)\n        # Allow move within 1..min(m+1,9)\n        candidate = random.randint(1, min(m + 1, 9))\n        if candidate == sol[i] and m > 1:\n            pool = [c for c in range(1, m + 1) if c != sol[i]]\n            if not pool and m < 9:\n                pool = [m + 1]\n            if pool:\n                candidate = random.choice(pool)\n        sol[i] = candidate\n        normalize(sol)\n\n    # Occasionally merge two labels to encourage k-reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])  # avoid always merging into smallest\n        b = random.choice([x for x in uniq if x != a])\n        for idx in range(len(sol)):\n            if sol[idx] == a:\n                sol[idx] = b\n        normalize(sol)\n\n    return sol\n","SAMPLE_SOL":[1,1,2,1,1,3,3,2,2]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"E_EVAL_TYPING_LIST: Importing 'List' from typing is unnecessary and risks runtime misuse by the local solver (error: 'Type List cannot be instantiated'). Remove 'from typing import List' and any 'List' usage; use built-in 'list' and list[int] annotations only.\nE_PERTURB_MISSING: 'Perturbation Function' is a placeholder ('$Perturb'). Provide a concrete, pure function with no side effects beyond its return; ensure it adheres to MAIN_CRITICAL_INSTRUCTION.\nE_HEURISTIC_ABSENT: Required signature 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' not implemented. Add orchestrator implementing acceptance, iteration budget, and proper usage of components.\nE_SAMPLE_EVAL_PIPELINE: Local solver failed to evaluate sample due to typing misuse. After removing typing.List and ensuring parser accepts strings, verify sample evaluation returns a scalar.\nNB_CODE_FAIL_LOCAL_OPT: Conflict-driven move minimizes only conflicts_of_vertex(i); it ignores global delta in total conflicts. Replace with evaluation of total conflict delta or cached conflict counts to choose the move with maximal reduction in total conflicts.\nNB_OP_SET_TOO_NARROW: No explicit color-reduction move when conflicts=0. Add targeted k-reduction: attempt to recolor all vertices of the highest color into existing colors; if successful, drop that color class and normalize.\nNB_NORMALIZE_SIDE_EFFECTS: normalize() remaps labels after each move, which can mask whether a move actually reduced k or only permuted labels. Gate normalization: only apply after a move that changes the set of used labels; avoid normalizing after pure recolor if set(sol) unchanged.\nNB_SWAP_VERTICES_RANDOM: Pairwise swap-vertices-colors is weak for graph coloring and can increase conflicts arbitrarily. Replace with Kempe-chain interchanges or 2-color component swaps to preserve feasibility more often.\nNB_SYMMETRY_MOVE_REDUNDANT: Global label swap does not change the evaluation; spend probability mass on structurally meaningful moves (e.g., recolor most constrained vertex, greedy saturation for a subset).\nR_STR_INADEQUATE: Representation disallows using <=k with gaps (strict contiguity). While evaluation mandates contiguity, search will waste effort maintaining it. Maintain any labels in 1..k without contiguity during search; normalize only before evaluation to reduce disruptive remapping.\nE_CODE_PERF: conflicts_of_vertex recomputes adjacency checks repeatedly. Cache adjacency lists once, and cache per-vertex conflict counts; update incrementally in O(deg) per move.\nACCEPT_RULE_WEAK: No annealing\/ILS\/TS acceptance core is provided. Implement temperature-based or iteration-based acceptance; ensure decreasing temperature and reheating\/perturbation for ILS.\nPERTURB_WEAKNESS: Add structured perturbation: randomly select a small subset of vertices (e.g., 2\u20133) from the highest color class and attempt reassignment; or perform a bounded number of Kempe-chain flips.\nINIT_STRATEGY: No initializer specified. Add DSATUR or greedy with largest-degree ordering to start near-feasible low-k states.\nRANDOMNESS_INJECT: Expose rng seed\/state via other_params to ensure reproducibility and controlled experiments.\nEVAL_ASSERTION: Evaluated component against an independently computed optimum baseline; evaluation function\u2019s lexicographic objective and feasibility checks align with the baseline (no discrepancies found).\nCONCRETE_FIX_EVAL: Delete 'from typing import List' in both evaluation and neighbour modules; retain 'import re' only. Ensure parser returns list[int] and strictly enforces length=9, min>=1, contiguity set=={1..k}.\nCONCRETE_FIX_PERTURB: Implement:\ndef perturb_solution(sol, adj, max_k):\n    # Input: list[int], 0 side-effects on external state\n    import random\n    n=len(sol); k=max(sol)\n    verts=sorted(range(n), key=lambda i: (sol[i]==k, -len(adj[i])))[:3]\n    new=sol[:]\n    for i in verts:\n        best=new[i]; best_conf=10**9\n        for c in range(1, k+1):\n            if c==new[i]: continue\n            conf=sum(1 for j in adj[i] if new[j]==c)\n            if conf<best_conf:\n                best_conf=conf; best=c\n        new[i]=best\n    # normalize contiguity\n    uniq=sorted(set(new)); mp={c:i+1 for i,c in enumerate(uniq)}\n    return [mp[c] for c in new]\nCONCRETE_FIX_HEURISTIC: Provide orchestrator:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    import random\n    sol = currentSolution[:] if isinstance(currentSolution, list) else [int(x) for x in str(currentSolution).split()]\n    def normalize(s):\n        uniq=sorted(set(s)); mp={c:i+1 for i,c in enumerate(uniq)}\n        return [mp[c] for c in s]\n    sol=normalize(sol)\n    score=evaluate_solution(sol)\n    if best is None or score<best_score:\n        best, best_score = sol[:], score\n    iters=other_params.get('iters', 2000)\n    temp0=other_params.get('temp0', 1.0)\n    alpha=other_params.get('alpha', 0.995)\n    temp=temp0\n    for t in range(iters):\n        cand=sol[:]\n        nb_type, mv_type = generate_neighbour(cand)\n        cand_score=evaluate_solution(cand)\n        if cand_score<=score or random.random()<pow(2.718281828, -(cand_score-score)\/max(temp,1e-9)):\n            sol, score = cand, cand_score\n            if score<best_score:\n                best, best_score = sol[:], score\n        if t%200==0:\n            cand = perturb_solution(sol, other_params['adj'], other_params.get('max_k', 9))\n            cand_score=evaluate_solution(cand)\n            if cand_score<score:\n                sol, score = cand, cand_score\n        temp *= alpha\n    return best, best_score\nNB_IMPROVEMENT: Add k-reduction operator:\ndef try_reduce_k(sol, adj):\n    k=max(sol)\n    if k<=1: return sol\n    new=sol[:]\n    moved=True\n    while moved:\n        moved=False\n        target=k\n        idxs=[i for i,c in enumerate(new) if c==target]\n        for i in idxs:\n            for c in range(1,k):\n                if all(new[j]!=c for j in adj[i]):\n                    new[i]=c; moved=True; break\n        if all(c!=k for c in new):\n            # normalize and decrease k\n            uniq=sorted(set(new)); mp={c:i+1 for i,c in enumerate(uniq)}\n            new=[mp[c] for c in new]\n            k-=1\n        else:\n            break\n    return new\nTEST_PLAN: \n- Remove typing imports; re-run local solver to eliminate 'List()' instantiation error.\n- Validate evaluate_solution('1 1 2 1 1 3 3 2 2') returns a finite scalar.\n- Cross-check evaluation on random feasible colorings against an independently computed optimum baseline (no disclosure of value) to ensure no lexicographic anomalies.\n- Unit-test generate_neighbour for: invalid input path, conflict-driven recolor, symmetry swap, vertex swap, and idempotent normalization.\n- Add regression tests for k-reduction and perturbation not increasing conflicts unnecessarily.\"","Componentes":{"REPRESENTATION":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","EVAL_CODE":"import re\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost; lower is better. Lexicographic via cost = conflicts*20 + k.\n    # Robust parser: accepts list[int] or string of ints.\n    PENALTY_BASE = 1000\n    # Edge set with 1-based vertices\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    # Contiguity check {1..k}\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    # Cost: conflicts dominate; minimal k within zero-conflict region\n    return conflicts * 20 + k\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor on list[int]. If non-list provided, return error metadata.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    # Problem data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    # Compute current conflicts and conflicting vertices\n    conf_vertices = [i for i in range(n) if conflicts_of_vertex(solution, i) > 0]\n\n    move_roll = random.random()\n    if conf_vertices and move_roll < 0.8:\n        # Conflict-driven recolor of the most conflicting vertex\n        i = max(conf_vertices, key=lambda x: conflicts_of_vertex(solution, x))\n        current_k = max(solution)\n        # Candidate colors: 1..current_k, avoid introducing new color unless all fail\n        best_color = solution[i]\n        best_conf = 10**9\n        # Evaluate each candidate color (excluding current first)\n        candidates = list(range(1, current_k + 1))\n        if solution[i] in candidates:\n            candidates.remove(solution[i])\n        # Try existing colors\n        for c in candidates:\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n                if conf == 0:\n                    # Prefer zero-conflict immediately\n                    break\n            solution[i] = tmp\n        # If no improvement and still conflicts, optionally try introducing color current_k+1 (bounded by 9)\n        if best_conf > 0 and current_k < 9:\n            c = current_k + 1\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n            solution[i] = tmp\n        solution[i] = best_color\n        normalize(solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One\")\n    elif move_roll < 0.95:\n        # Symmetry move: swap two labels globally (if >=2 labels)\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # Introduce second label to escape uniform state\n            j = random.randrange(n)\n            solution[j] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n    else:\n        # Pairwise color exchange on two vertices (not a global swap)\n        i, j = random.sample(range(n), 2)\n        solution[i], solution[j] = solution[j], solution[i]\n        normalize(solution)\n        return (\"NB_Local\", \"Swap-Vertices-Colors\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution; accepts list[int] or string. Preserves type when possible.\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = [int(x) for x in sol.replace(',', ' ').split()]\n            return parts, 'str'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    # Problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1]*9\n    sol = list(sol)\n    normalize(sol)\n\n    # Determine vertices by conflict priority\n    conflict_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(9)]\n    conflict_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Random-kick on top p vertices\n    p = random.randint(2, 4)\n    targets = [i for i, _ in conflict_scores[:p]]\n    current_k = max(sol)\n    for i in targets:\n        # Try a random existing color different from current; 20% chance allow k+1 (<=9)\n        candidates = [c for c in range(1, current_k + 1) if c != sol[i]]\n        if random.random() < 0.2 and current_k < 9:\n            candidates.append(current_k + 1)\n        if candidates:\n            sol[i] = random.choice(candidates)\n    normalize(sol)\n\n    # Color-class shake: choose a color and reassign ~40% of its vertices\n    uniq = sorted(set(sol))\n    if uniq:\n        c = random.choice(uniq)\n        idxs = [i for i in range(9) if sol[i] == c]\n        if idxs:\n            m = max(1, int(0.4 * len(idxs)))\n            pick = random.sample(idxs, m)\n            current_k = max(sol)\n            for i in pick:\n                pool = [x for x in range(1, current_k + 1) if x != sol[i]]\n                if not pool and current_k < 9:\n                    pool = [current_k + 1]\n                if pool:\n                    sol[i] = random.choice(pool)\n    normalize(sol)\n\n    # Forced merge attempt with 50% chance to encourage k reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])\n        b = random.choice([x for x in uniq if x != a])\n        for i in range(9):\n            if sol[i] == a:\n                sol[i] = b\n        normalize(sol)\n\n    return to_type(sol, typ)\n","SAMPLE_SOL":"1 1 2 1 1 3 3 2 2"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\",\"FEEDBACK\":\"E_IMPORT_MISSING: evaluate_solution uses re but environment error shows re not imported at runtime. Inline-safe fix: define parse without regex or import locally inside function.\nE_IMPORT_FIX_CODE:def evaluate_solution(solution):\\n    edges=[(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\\n    PENALTY_BASE=1000\\n    def parse(sol):\\n        if isinstance(sol,list): return list(sol)\\n        if isinstance(sol,str):\\n            parts=sol.strip().split()\\n            try: return [int(x) for x in parts]\\n            except: return None\\n        return None\\n    sol=parse(solution)\\n    if sol is None: return PENALTY_BASE+1\\n    if len(sol)!=9: return PENALTY_BASE+2\\n    if any((not isinstance(x,int)) for x in sol): return PENALTY_BASE+3\\n    if min(sol)<1: return PENALTY_BASE+4\\n    k=max(sol)\\n    if k>9: return PENALTY_BASE+5\\n    uniq=set(sol)\\n    if uniq!=set(range(1,k+1)): return PENALTY_BASE+6\\n    conflicts=0\\n    for u,v in edges:\\n        if sol[u-1]==sol[v-1]: conflicts+=1\\n    return conflicts*20+k\nE_SIG_WRONG_SOLVER: Simulated_Annealing, Iterated_Local_Search, Taboo_Search used signatures with called arguments generate_neighbour() and evaluate_solution(). Must pass function references, not calls. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nFIX_SOLVER_SIGNATURE_CODE:def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    # implement metaheuristic here using function refs; do not call in signature\\n    return best,best_score\nE_TABU_NEIGHBOR_API_MISMATCH: generate_neighbour mutates solution in-place and returns two strings ('NB_Type','Movement_Type'); Tabu code likely expects a new solution (or different return shape). Standardize: return (new_solution, move_info) and avoid in-place side-effects inside neighborhoods used by Tabu.\nNB_API_FIX_CODE:def generate_neighbour(solution):\\n    sol=list(solution)  # work on a copy\\n    # ... apply move on sol ...\\n    move_info={\\\"nb\\\":\\\"NB_Local\\\",\\\"mv\\\":\\\"Conflict-Recolor-One-GlobalDelta\\\"}\\n    return sol,move_info\nNB_INPLACE_SIDE_EFFECT_RISK: Current in-place mutation combined with acceptance tests can corrupt incumbent and tabu memory. Enforce copy-on-write at neighborhood level or ensure solvers clone before applying moves.\nEVAL_COST_EFFICIENCY: total_conflicts recomputed O(|E|) per color trial; inner loops may do O(|E|*K) per step. Use incremental delta evaluation based on adjacency and per-color counts to O(deg(v)) per trial.\nDELTA_EVAL_SUGGESTION: Maintain for each vertex v a dict color->count among neighbors; update locally when recoloring a vertex; compute conflict delta as count[new_color]-count[old_color].\nNB_CODE_FAIL_LOCAL_OPT: Conflict selection picks max conflicts but ignores equal-delta degree-ties beyond degree. Add secondary criterion: prefer vertices in highest color class to accelerate k-reduction when feasible.\nNB_K_REDUCTION_FRAGILITY: try_reduce_k loops until no moves; may stall with partial evacuation of highest class, leaving k unchanged and wasting iterations. Add bounded attempts and fall back to Kempe or targeted vertex reassignment.\nNB_DIVERSIFICATION_LIMITED: kempe_chain_flip always swaps two random colors; lacks bias toward colors involving highest class. Recommend biased Kempe toward (highest_color, c<highest) pairs to promote k-reduction.\nPERTURB_MISSING: Placeholder $Perturb invalid. Provide concrete perturbation that preserves feasibility when possible and breaks stalemates otherwise.\nPERTURB_FIX_CODE:def perturb_solution(solution,adj,steps=3,rng=None):\\n    import random\\n    rng=rng or random\\n    sol=list(solution)\\n    for _ in range(steps):\\n        uniq=sorted(set(sol))\\n        if len(uniq)<2: break\\n        a,b=rng.sample(uniq,2)\\n        # biased: include highest color with prob .6\\n        if rng.random()<0.6:\\n            mx=max(uniq)\\n            if a!=mx and b!=mx: a,mx=b,mx; b=mx\\n        seed=rng.randrange(len(sol))\\n        # BFS on {a,b}\\n        seen=[False]*len(sol); stack=[seed]; seen[seed]=True\\n        while stack:\\n            u=stack.pop()\\n            for v in adj[u]:\\n                if not seen[v] and (sol[v]==a or sol[v]==b):\\n                    seen[v]=True; stack.append(v)\\n        for u,vis in enumerate(seen):\\n            if vis:\\n                sol[u]=a if sol[u]==b else b if sol[u]==a else sol[u]\\n    return sol\nR_DOMAIN_NORMALIZATION_GAP: Solvers must ensure contiguous labels after any move that removes a color class. Current normalization exists only in neighbor; add normalization utility and call it in solvers post-acceptance.\nNORMALIZE_CODE:def normalize_labels(sol):\\n    uniq=sorted(set(sol))\\n    mp={c:i+1 for i,c in enumerate(uniq)}\\n    return [mp[c] for c in sol]\nSA_FAIL_LOCAL: Error shows wrong function name\/signature repeated for multiple solvers. Implement distinct, compliant solvers using the generic signature and correct neighbor API.\nSA_IMPL_CODE:def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    import math, random\\n    sol=list(currentSolution)\\n    score=evaluate_solution(sol)\\n    T=other_params.get(\\\"TEMP\\\",1.0)\\n    T_min=other_params.get(\\\"MIN_TEMP\\\",1e-3)\\n    alpha=other_params.get(\\\"cooling_factor\\\",0.95)\\n    iters=other_params.get(\\\"iters_per_T\\\",50)\\n    while T>T_min:\\n        for _ in range(iters):\\n            cand,info=generate_neighbour(sol)\\n            cscore=evaluate_solution(cand)\\n            if cscore<=score or random.random()<math.exp((score-cscore)\/T):\\n                sol=cand; score=cscore\\n                if cscore<best_score:\\n                    best, best_score = sol, cscore\\n        T*=alpha\\n    return best, best_score\nTABU_IMPL_CODE:def Tabu(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    from collections import deque\\n    tenure=other_params.get(\\\"tenure\\\",7)\\n    max_it=other_params.get(\\\"max_it\\\",500)\\n    tabu=deque(maxlen=tenure)\\n    sol=list(currentSolution)\\n    score=evaluate_solution(sol)\\n    for _ in range(max_it):\\n        best_cand=None; best_cscore=float(\\\"inf\\\"); best_move=None\\n        # sample neighborhood\\n        for __ in range(other_params.get(\\\"nb_calls\\\",20)):\\n            cand,info=generate_neighbour(sol)\\n            move=(tuple(sol),tuple(cand))  # simple move signature\\n            if move in tabu: continue\\n            cscore=evaluate_solution(cand)\\n            if cscore<best_cscore:\\n                best_cand, best_cscore, best_move = cand, cscore, move\\n        if best_cand is None:\\n            sol=perturb_solution(sol,other_params[\\\"adj\\\"]) if \\\"adj\\\" in other_params else sol\\n            continue\\n        tabu.append(best_move)\\n        sol=best_cand; score=best_cscore\\n        if score<best_score:\\n            best, best_score = sol, score\\n    return best, best_score\nILS_IMPL_CODE:def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\\n    sol=list(currentSolution)\\n    score=evaluate_solution(sol)\\n    max_it=other_params.get(\\\"max_it\\\",1000)\\n    for _ in range(max_it):\\n        cand,info=generate_neighbour(sol)\\n        cscore=evaluate_solution(cand)\\n        if cscore<=score:\\n            sol,score=cand,cscore\\n            if cscore<best_score:\\n                best, best_score=sol,cscore\\n        else:\\n            sol=perturb_solution(sol,other_params[\\\"adj\\\"]) if \\\"adj\\\" in other_params else sol\\n    return best,best_score\nE_STOPPING_CRITERIA: Provide deterministic iteration budgets and temperature schedules; current logs show failures before any progress. Add max iterations\/time guards in params.\nRANDOMNESS_CONTROL: No rng control. Pass rng via other_params and use it uniformly for reproducibility when testing.\nEVAL_VALIDATION_CORRECTNESS: Using the provided evaluation function, internal verification confirms it correctly discriminates feasibility and penalizes conflicts\/invalid label sets; no change to scoring needed beyond import fix.\nNB_EDGE_CASES: generate_neighbour accepts k up to 9; ensure colors do not exceed bound under any acceptance policy to avoid unnecessary penalty transitions.\nK_BLOAT_RISK: Allowing k+1 during conflict resolution can inflate domain. Apply aspiration: only allow k+1 if it reduces conflicts strictly and revert after a bounded number of steps without improvement.\nLOCAL_SOLVER_OUTPUTS: Ensure solvers return both best solution (list[int] length 9 with contiguous labels) and best_score (scalar). Add optional move logs in a separate diagnostics object, not mixed into return tuple.\nKNOWN_BEST_ASSERT: Verified via independent search that evaluate_solution ranks an optimal feasible coloring as strictly better than nearby alternatives; solvers should target that regime without exposing its value.\nACTION_ITEMS_ORDERED: (1) Fix evaluate_solution import\/parse. (2) Standardize neighbor API to return (new_solution, move_info) without in-place side-effects. (3) Replace solver signatures with generic signature and adopt SA\/Tabu\/ILS implementations provided. (4) Implement perturb_solution per code. (5) Add normalize_labels calls post-acceptance. (6) Integrate delta evaluation to cut per-step cost. (7) Add reproducibility controls and stopping criteria.\"","Componentes":{"REPRESENTATION":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input: in-place operation on list[int] of length 9\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def try_reduce_k(sol):\n        # Greedy attempt to remove the highest color class entirely\n        k = max(sol)\n        if k <= 1:\n            return False\n        target = k\n        changed = False\n        moved_any = True\n        # Attempt multiple passes to relocate vertices of 'target'\n        while moved_any:\n            moved_any = False\n            idxs = [i for i, c in enumerate(sol) if c == target]\n            if not idxs:\n                break\n            for i in idxs:\n                for c in range(1, target):\n                    if all(sol[j] != c for j in adj[i]):\n                        sol[i] = c\n                        moved_any = True\n                        changed = True\n                        break\n        if all(c != target for c in sol):\n            before = set(sol)\n            normalize_if_labelset_changed(before, sol)\n            return True\n        return changed\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        ca = sol[seed]\n        cb = b if ca == a else a\n        # BFS on subgraph induced by colors {a,b}\n        seen = set()\n        stack = [seed]\n        seen.add(seed)\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        # swap a<->b on the component 'seen'\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Begin move selection\n    k = max(solution)\n    tot_conf = total_conflicts(solution)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor with global conflict delta evaluation\n        conf_scores = [(i, conflicts_of_vertex(solution, i)) for i in range(n)]\n        # pick a most conflicting vertex; tie-break by higher degree to be more impactful\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        i = max(cand_vertices, key=lambda x: len(adj[x]))\n        current_k = max(solution)\n        best_color = solution[i]\n        best_total = tot_conf\n        colors = list(range(1, current_k + 1))\n        if solution[i] in colors:\n            colors.remove(solution[i])\n        # allow k+1 occasionally to escape dead-ends\n        if current_k < 9:\n            colors.append(current_k + 1)\n        before_set = set(solution)\n        original = solution[i]\n        for c in colors:\n            solution[i] = c\n            cand_total = total_conflicts(solution)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n                if best_total == 0:\n                    # can't do better than zero conflicts\n                    pass\n        solution[i] = best_color\n        normalize_if_labelset_changed(before_set, solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try k-reduction often; otherwise perform Kempe chain to diversify while preserving feasibility\n        move_roll = random.random()\n        if move_roll < 0.7:\n            before_k = max(solution)\n            reduced = try_reduce_k(solution)\n            after_k = max(solution)\n            if reduced and after_k < before_k:\n                return (\"NB_K_Reduction\", \"Greedy-Merge-Highest-Color\")\n            # If not reduced, try to move one vertex from highest color to a feasible lower color\n            target = max(solution)\n            idxs = [i for i, c in enumerate(solution) if c == target]\n            random.shuffle(idxs)\n            for i in idxs:\n                for c in range(1, target):\n                    if all(solution[j] != c for j in adj[i]):\n                        before = set(solution)\n                        solution[i] = c\n                        normalize_if_labelset_changed(before, solution)\n                        return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n            # fall through to diversification if nothing applied\n        # Kempe-chain interchange (feasibility-preserving)\n        kempe_chain_flip(solution)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","PERTURB_CODE":"import random\nimport re\n\n\ndef perturb_solution(solution):\n    # Parse and preserve type\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums], 'str'\n        return [1] * 9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Kempe diversifications (2-3 times)\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n\n    # 2) Random-kick on top conflict vertices (if any conflicts exist)\n    confs = [conflicts_of_vertex(sol, i) for i in range(n)]\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: confs[i], reverse=True)\n    top_p = max(2, min(4, len(idxs)))\n    picks = idxs[:top_p]\n    k = max(sol)\n    for i in picks:\n        # choose a different color; 25% chance allow k+1 (<=9)\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.25 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Forced partial merge attempt of highest color to encourage k drop\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","SAMPLE_SOL":"1 1 2 1 1 3 3 2 2"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 (1-based colors, arbitrary labels). Example: [1,1,3,1,1,2,2,3,3].","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_FIX_PRIORITY:Local solver failing before search. Address runtime\/type errors before any heuristic tuning.\nE_EVAL_RUNTIME_ERROR:Error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing module types at runtime. Remove 'from typing import List, Tuple' imports from all executable code paths. Never call List() or Tuple(). Use built-ins for annotations (e.g., def f(x: list) -> int) or PEP585 (list[int]) only; avoid typing module entirely in runtime code.\nE_TYPE_HINTS_SHADOW:Audit for variables\/functions named 'List'\/'Tuple' shadowing typing types. Rename to avoid accidental instantiation by the framework\u2019s reflection layer.\nE_SIG_COMPAT:Heuristic signature is specified but missing implementation. Provide def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params): with deterministic defaults and no side effects beyond using provided callables.\nE_PERTURB_MISSING:'Perturbation Function' is a placeholder ($Perturb). Implement def perturb_solution(solution, intensity, rng): that performs structured diversification. Avoid filesystem\/network\/OS calls per constraints.\nE_EVAL_VALIDATION:Evaluation relies on domain check x>=1 only; negative and non-int are penalized but extremely large color labels are permitted. Add a soft cap to reduce search drift (e.g., if max_color > len(V), return 1e9 + overflow) or normalize labels in the neighbour to keep palette compact.\nE_EVAL_PERF:Evaluation recomputes conflicts O(|E|) each call. For iterative local moves, add a delta-evaluation layer within the heuristic to update cost in O(deg(v)) using adjacency lists; cache feasibility and color-class membership to reduce recomputation.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour can introduce a new color whenever no conflict-free color exists (palette fallback to max_color+1). This inflates k and harms convergence. Restrict to existing colors; allow new color only under explicit diversification (perturbation) or annealing schedules with acceptance criteria tied to conflict reduction.\nNB_MOVE_SET_WEAK:Only single-vertex recolor and random jitter are available. This is insufficient for color reduction. Add: (1) Kempe-chain swaps between two colors to resolve conflicts without increasing k; (2) Color-class merge attempts with repair (recolor small conflicting sets greedily); (3) Pairwise color relabeling to eliminate empty\/duplicate color classes; (4) Targeted 1-opt recolor using saturation degree (DSATUR-guided).\nNB_INEFF_REBUILD:Adjacency and conflicts are rebuilt on every neighbour call. Precompute adjacency once as a constant structure and pass it via other_params; avoid repeated list\/dict allocations in the hot path.\nNB_LABEL_NORMALIZATION_MISSING:Lack of normalization leads to label bloat and plateaus. After any recolor, compress labels to [1..k] preserving color classes; also periodically remap by color-class size to stabilize search.\nINIT_WEAK:No construction heuristic defined. Provide DSATUR or greedy largest-degree-first initialization to start near low-k feasible regions; this reduces reliance on conflict-phase search.\nE_RNG_CONTROL:Randomized moves without RNG injection\/seed hinder reproducibility and tuning. Thread a rng parameter (random.Random) through generate_neighbour and perturb_solution; avoid global random state.\nHEURISTIC_CTRL_PARAMS:No temperature\/tenure\/intensity control exposed. Add parameters: max_iters, no_improve_limit, temperature schedule (for SA), tabu tenure and aspiration (for TS), perturb intensity and acceptance (for ILS). Ensure they are read from other_params with safe defaults.\nACCEPTANCE_CRITERIA:Feasible vs infeasible costs differ by large constants (1e8 barriers). Acceptance should prioritize eliminating conflicts before k reduction. Enforce lexicographic objective within the heuristic: (conflicts, k), rather than relying purely on numeric magnitudes.\nTEST_REPRO_CASES:Create unit tests (in-memory) to assert: (1) evaluate_solution([1,1,3,1,1,2,2,3,3]) returns finite feasible score; (2) generate_neighbour preserves domain and length; (3) perturb_solution changes >=1 vertex and does not access I\/O. This isolates remaining runtime issues.\nKNOWN_BEST_ASSERTION:Used internal enumeration to validate evaluate_solution consistency against a verified optimal coloring. Do not expose its value; use it to assert that the evaluator orders solutions correctly and to validate heuristic reachability in smoke tests.\nSUGG_PERTURB_IMPLEMENTATION:Implement kempe_chain_perturb(solution, adj, steps, rng) that selects random vertex v and random color c, computes the (color(solution[v]), c)-Kempe component, and swaps colors within the component; repeat steps times. This preserves feasibility and explores alternative basins without increasing k.\nSUGG_COLOR_REDUCTION_PASS:Add periodic pass reduce_colors(solution, adj) that attempts to eliminate the highest label: greedily reassign its vertices to lower labels using DSATUR order; if conflict-free, drop the label. Run every T iterations or upon reaching feasibility.\nSUGG_DELTA_STRUCTS:Maintain: color_of[v], neighbors[v], color_class[c] sets, conflicts_count[v], and per-color forbidden counts for each v to enable O(1..deg) move checks. Update incrementally on each move.\nROBUSTNESS_INVALID_INPUT:Neighbour currently 'resets' to [1]*9 upon invalid input, which can create severe conflicts. Prefer returning the input unchanged with a flag or a safe greedy repair rather than escalating conflicts.\nANNOTATION_SANITY:Remove pseudo-return-type comment '-> (\"NB_Type\", \"Movement_Type\")'. If annotations are needed, use -> tuple[list,int] (PEP585) in Python 3.9+; otherwise omit to avoid parser\/tooling confusion.\nCOMPLEXITY_NOTES:EVAL O(|E|)=O(17) per call is cheap, but neighbour\u2019s current allocations dominate. Optimize allocations and avoid per-call shuffles where unnecessary; reuse pre-shuffled vertex orders or use deterministic heuristics during intensification.\nACTION_ITEMS:\n- Remove typing imports\/usages; ensure zero instantiation of typing types.\n- Implement perturb_solution (Kempe-chain + color-merge) and the Heuristic driver per required signature.\n- Precompute adjacency; add delta structures; normalize labels after moves.\n- Expand move set (Kempe swap, class merge, DSATUR-guided recolor).\n- Add RNG injection and acceptance\/parameter controls.\n- Add unit tests to assert evaluator behavior and neighbour invariants, using the verified optimal solution only for internal assertions.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 (1-based colors, arbitrary labels). Example: [1,1,3,1,1,2,2,3,3].","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain\/integrality\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial neighbour to remain robust\n        base = [1]*9\n        return (base, \"reset\")\n    n = 9\n    cur = solution[:]\n    # Graph definition\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency for quick checks\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n    max_color = max(cur) if cur else 1\n    # Strategy: if conflicts exist, target one endpoint; else diversify by recoloring a random vertex\n    if conflicts:\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        # Choose a color different from all neighbors; allow introducing a new color at most +1 of current max\n        neighbor_colors = {cur[w-1] for w in adj[target]}\n        palette = list(set(range(1, max_color+1)) - neighbor_colors)\n        if not palette:\n            palette = [max_color+1]\n        new_color = random.choice(palette)\n        cur[target-1] = new_color\n        return (cur, \"conflict_recolor\")\n    else:\n        # No conflicts: attempt to reduce colors by reassigning a vertex to an existing color if safe; otherwise jitter\n        order = list(range(1, n+1))\n        random.shuffle(order)\n        moved = False\n        for v in order:\n            old = cur[v-1]\n            # Try to map to a lower color label first\n            trial_colors = list(range(1, max_color+1))\n            random.shuffle(trial_colors)\n            for c in trial_colors:\n                if c == old:\n                    continue\n                ok = True\n                for w in adj[v]:\n                    if cur[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved:\n            # Mild jitter: recolor a random vertex to a random color in [1..max_color]\n            v = random.randint(1, n)\n            c = random.randint(1, max_color)\n            cur[v-1] = c\n        return (cur, \"feasible_relabel\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: probabilistically reassign a subset of vertices and optionally relabel colors\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Initialize random feasible-ish seed (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n    n = 9\n    s = solution[:]\n    # With some probability, apply a random permutation of color labels to escape symmetry\n    colors = sorted(set(s))\n    if colors:\n        if random.random() < 0.5:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[i] for i, c in enumerate(colors)}\n            s = [mapping[c] for c in s]\n    # Randomly pick m vertices (m in [2..4]) and reassign colors in [1..max_color+1]\n    max_color = max(s) if s else 1\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_color + 1)\n    return s\n","SAMPLE_SOL":"[1,1,3,1,1,2,2,3,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"0.1\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:Target heuristic signature mismatch. Required def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your Taboo_Search used SA-style signature; fix to conform and update all solvers to call the general signature.\"\n\"FEEDBACK\",\"E_TABU_UNPACK:generate_neighbour returns (neighbour, move_type) but Taboo_Search unpacks inconsistently (error: too many values to unpack). Standardize to exactly two returns and ensure the caller handles both.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation Function unresolved placeholder '$Perturb'. Provide a concrete perturb_solution(sol,other_params) that returns a valid list of length 9.\"\n\"FEEDBACK\",\"E_EVAL_CHECK:Using provided evaluation, SA best [1,1,2,1,1,3,3,2,2] scores 3 (feasible). ILS best [1,1,1,2,1,1,2,2,1] scores 1e8+8 (infeasible). Do not report infeasible solutions as best; wire evaluation into acceptance and logging.\"\n\"FEEDBACK\",\"E_CONSISTENCY_ASSERT:Add runtime guards: assert isinstance(sol,list) and evaluate_solution(sol)==best_score for reported best; reject any candidate with evaluate_solution>=1e8.\"\n\"FEEDBACK\",\"E_REPRODUCIBILITY:Randomness not controlled. Inject seed via other_params and set random.seed(seed) at heuristic entry for reproducible runs.\"\n\"FEEDBACK\",\"E_PERF_ADJ_BUILD:Adjacency rebuilt on every neighbour generation. Precompute once and pass via other_params to cut overhead.\"\n\"FEEDBACK\",\"NB_COLOR_DROP_WEAK:Color-drop attempts abort on first unmoved vertex; this is brittle. Use ordering by saturation degree, try backtracking\/repair for stuck vertices, or apply greedy recolor then normalize.\"\n\"FEEDBACK\",\"NB_CONFLICT_SELECTION:Conflict-directed recolor picks a random endpoint; bias by conflict-degree and choose the color minimizing incremental conflicts (tie-break by future saturation).\"\n\"FEEDBACK\",\"NB_KEMPE_LIMITED:Kempe swaps applied blindly can increase conflicts. Gate Kempe moves by simulated delta (apply, count_conflicts, accept only if non-worsening in conflict phase).\"\n\"FEEDBACK\",\"NB_NORMALIZE_NOISE:normalize_colors changes labels non-canonically, adding noise for tabu\/SA memory. Canonicalize by first-appearance order AND keep a stable permutation across steps or avoid relabel during neighbourhood unless dropping a color.\"\n\"FEEDBACK\",\"R_INIT_WEAK:No constructive initializer provided. Add DSATUR\/greedy-degree initialization to start near low-k feasible solutions.\"\n\"FEEDBACK\",\"E_ACCEPTANCE_POLICY:Local search acceptance not specified. For SA, ensure penalized infeasible scores (>=1e8) are always worse than any feasible; for ILS\/TS, forbid moves that keep\/increase conflict count unless diversification is explicitly triggered.\"\n\"FEEDBACK\",\"TS_TABU_LIST:No tabu attributes described. Track (vertex,color) assignments and color-class merges for a rolling horizon; aspiration criterion: accept tabu if it strictly improves k or reduces conflicts.\"\n\"FEEDBACK\",\"ILS_PERTURB_SCOPE:Perturbation should escape local minima without breaking feasibility excessively. Recommend multi-vertex Kempe-chain perturb or shuffle a color class; cap induced conflicts and immediately run a repair.\"\n\"FEEDBACK\",\"E_STOPPING:Define clear stopping: max_iters, no_improve_iters on both conflicts and k, and time cap; log both metrics.\"\n\"FEEDBACK\",\"M_LOWER_BOUNDING:Compute clique lower bound \u03c9(G) to avoid futile k-reduction attempts; if current k==\u03c9, switch to diversification instead of color-drop.\"\n\"FEEDBACK\",\"E_CODE_PERF:count_conflicts is O(|E|) each call; cache per-vertex conflict deltas and update incrementally on single-vertex recolors to get O(deg(v)).\"\n\"FEEDBACK\",\"V_OUTPUT_PROTOCOL:Always return (best_solution, best_score, last_solution, last_score, extra) from solvers to align with \u201cextra outputs expected\u201d; include move_type histograms for diagnosis.\"\n\"FEEDBACK\",\"R_DOMAIN_SAFEGUARD:Before any move, clamp to positive ints in 1..current_k; drop any drift beyond 9 to avoid 1e9 penalty.\"\n\"FEEDBACK\",\"TESTS_MINIMAL:Add unit tests: (1) neighbour preserves list length and domain, (2) conflict-reducing move never increases conflicts, (3) color-drop reduces k or proves impossible with witness vertex set.\"\n\"FEEDBACK\",\"ACTIONABLE_FIX_ORDER:1) Implement perturb_solution and fix heuristic signatures\/unpacking. 2) Enforce feasibility-aware acceptance and assertions. 3) Precompute adjacency and seed control. 4) Improve colour-drop with DSATUR repair and conflict-driven selection. 5) Add tabu attributes\/SA cooling and stopping. 6) Optimize conflict delta updates.\"\n\"FEEDBACK\",\"PY_VALIDATION:Evaluation verified via Python: SA best feasible (3); ILS claimed best is infeasible (penalized). Align solver reporting with evaluate_solution to prevent false positives.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = normalize_colors(solution[:])\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        target_color = sol[v-1]\n        if target_color not in (color_a, color_b):\n            return sol[:]\n        keep = set([color_a, color_b])\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting vertex, try best existing color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        best_sol = None\n        best_score = None\n        used_colors = list(range(1, k+1))\n        random.shuffle(used_colors)\n        for c in used_colors:\n            if c == cur[target-1]:\n                continue\n            if feasible_recolor(cur, target, c):\n                trial = cur[:]\n                trial[target-1] = c\n                sc = count_conflicts(trial)\n                if best_score is None or sc < best_score:\n                    best_score = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n        # If no direct recolor reduces conflicts, attempt a Kempe-chain swap between two existing colors\n        c_a = cur[target-1]\n        # Pick an alternative color present in the palette\n        alt_colors = [c for c in range(1, k+1) if c != c_a]\n        if not alt_colors:\n            return (cur, \"noop\")\n        c_b = random.choice(alt_colors)\n        swapped = kempe_swap(cur, target, c_a, c_b)\n        return (normalize_colors(swapped), \"kempe_swap_conflict\")\n    else:\n        # Feasible: try to reduce number of colors by eliminating the highest label\n        if k > 1:\n            target_color = k\n            vertices = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            random.shuffle(vertices)\n            reduced = cur[:]\n            success = True\n            for v in vertices:\n                # Try to move v to any lower color without conflicts\n                moved = False\n                palette = list(range(1, target_color))\n                random.shuffle(palette)\n                for c in palette:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (normalize_colors(reduced), \"color_drop\")\n        # If not reduced, apply a small Kempe swap to diversify keeping k constant\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        # choose a different color within current palette\n        choices = [c for c in range(1, k+1) if c != c_a]\n        if not choices:\n            return (cur, \"noop\")\n        c_b = random.choice(choices)\n        swapped = kempe_swap(cur, v, c_a, c_b)\n        swapped = normalize_colors(swapped)\n        return (swapped, \"kempe_swap_feasible\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = set([color_a, color_b])\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # With probability, relabel colors by a random permutation to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Perform several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        # choose a different existing color to swap with\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment of a few vertices to existing colors (no new colors)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        # Try up to 2 attempts to pick a different color within existing palette\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_TABU_SIG_MISMATCH:Taboo_Search caller expects 2 returns while heuristic emits 4. Standardize all heuristics to TARGET_HEURISTIC_GENERAL_SIGNATURE and unify return as (new_solution, new_score, best_solution, best_score, meta). Fix caller unpacking accordingly.\nE_HEURISTIC_SIG_INCONSISTENT:Simulated_Annealing signature in error log does not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass SA hyperparameters via other_params={TEMP,MIN_TEMP,cooling_factor}.\nE_PERTURB_MISSING:Perturbation Function unresolved ($Perturb). Implement perturb_solution with non-trivial diversification: e.g., random Kempe-chain swap, multi-vertex recolor of highest color class, or color merge-split to escape plateaus.\nE_EVAL_TIE_BREAK:Evaluation returns 1e8+conflicts or k. This creates large plateaus for equal-conflict states. Improve acceptance metric to 1e8*conflicts + k to guide towards fewer colors within same conflict level.\nE_ILS_INFEASIBLE:Iterated_Local_Search returned infeasible [1,2,2,2,2,1,1,2,1] with evaluate_solution=100000007 (7 conflicts). Add feasibility repair after each move or reject moves that do not reduce 1e8*conflicts. Integrate a deterministic repair pass using feasible_recolor and Kempe swaps.\nE_SA_VALIDATION_GAP:SA returned feasible [2,2,3,2,2,1,1,3,3] with evaluate_solution=3, but no feasibility assertion in loop. Add post-move assert\/evaluation guard and immediate repair on conflict > 0 to avoid wasting iterations on penalized states.\nE_COLOR_DRIFT:normalize_colors used only in color_drop. Add normalization upon acceptance of any feasible move to prevent label drift and reduce chance of exceeding soft cap (max_color>9 penalty).\nE_NB_COLOR_DROP_GREEDY:color_drop greedily relabels entire highest color class and aborts on first stuck vertex. Replace with backtracking local search on that class or order by least-constraining color; try multi-pass reassignment before failing.\nE_MOVE_DIVERSITY_LOW:Neighbourhood lacks targeted two-vertex recolor for conflict edges in feasible regime. Add: swap two vertices\u2019 colors across distinct classes if safe; try vertex pair exchange on same color classes to unlock color_drop.\nE_KEMPE_SELECTION:Kempe swap picks random alt color. Bias selection by neighbor color frequencies at worst_v to maximize probability of enabling recolor; also skip if Kempe component does not touch conflicting neighbors.\nE_ADJ_REBUILD_OVERHEAD:Adjacency and edges rebuilt on each neighbour call. Cache them once in other_params and close over references to cut O(|E|) redundant allocations.\nE_DELTA_EVAL_MISSING:count_conflicts scans all edges O(|E|). Maintain per-vertex conflict counts and update deltas only for affected edges in O(deg(v)) to accelerate high-iteration heuristics.\nE_INIT_WEAK:No constructive seeding. Add DSATUR or smallest-last greedy initialization to start from low k and near-feasible states, improving convergence speed.\nE_ACCEPTANCE_SCHEME:For SA, acceptance should compare composite score (1e8*conflicts + k). Calibrate TEMP to typical delta magnitudes; otherwise, temperature too small will freeze at high-penalty states.\nE_STOPPING_CRITERIA:Undefined. Add max_iters, max_no_improve, and time budget in other_params to avoid indefinite runs and to standardize comparisons across heuristics.\nE_LOGGING_INCONSISTENT:Local solver outputs 4-tuple for SA\/ILS, while Tabu expects 2. Define a common result schema dict: {best_solution,best_score,start_solution,start_score,meta}, and adapt all drivers to it.\nE_TEST_COVERAGE:No automated checks. Add unit tests: evaluate_solution on Sample, SA, ILS; assert feasibility for returned best and that score does not worsen across iterations.\nE_CONSTRAINT_ENFORCEMENT:ILS accepted infeasible state for best. Enforce best must always be the lowest-score feasible found; keep a separate current (possibly infeasible) vs best (feasible only) state to prevent regression.\nR_PERTURB_SPEC:Implement perturb_solution as: (a) t random Kempe swaps across top-2 frequent colors, (b) reassign a subset of vertices in highest color to random lower feasible colors, (c) shuffle color labels followed by normalization to break symmetry.\nR_NEIGHBOUR_SPEC:Add conflict-edge directed move: pick (u,v) with same color and recolor u to the least frequent feasible color in its neighborhood; if none, apply a small Kempe chain with that color and the least interfering alternative.\nR_INIT_SPEC:Construct initial solution via DSATUR ordering with tie-breaking on degree, then immediate normalization.\nR_PERF_SPEC:Precompute edges, adjacency, and degrees in other_params once; expose delta conflict update helpers; avoid Python-level random.shuffle on large palettes by sampling small subsets.\nR_META_TRACK:Track movement_type histogram and success rates; adaptively increase frequency of moves with highest success in reducing composite score; decrease those leading to no-ops.\nR_COLOR_DROP_ENHANCED:When color_drop fails, temporarily allow one-vertex spill to a new color, then apply sequence of Kempe swaps to re-pack and remove the spilled color, finally normalize.\nASSERTIONS_RESULTS:Sample evaluate_solution=3 (feasible). SA evaluate_solution=3 (feasible). ILS evaluate_solution=100000007 with 7 conflicts (infeasible). Integrate automated checks and repair to prevent infeasible \u2018best\u2019 outputs.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed recolor: choose most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_conflicts = count_conflicts(cur)\n        best_sol = None\n        best_conf = None\n        palette = list(range(1, max(k, 2)+1))  # ensure at least 2 to allow a move\n        random.shuffle(palette)\n        for c in palette:\n            if c == cur[worst_v-1]:\n                continue\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = count_conflicts(trial)\n                if sc <= current_conflicts and (best_conf is None or sc < best_conf):\n                    best_conf = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (best_sol, \"conflict_recolor\")\n        # Try a gated Kempe swap that does not increase conflicts\n        alt_colors = [c for c in range(1, k+1) if c != cur[worst_v-1]]\n        if alt_colors:\n            c_b = random.choice(alt_colors)\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if count_conflicts(swapped) <= current_conflicts:\n                return (swapped, \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            # Order by saturation degree (distinct neighbor colors desc)\n            def sat_deg(v):\n                return len({cur[w-1] for w in adj[v]})\n            verts.sort(key=sat_deg, reverse=True)\n            reduced = cur[:]\n            success = True\n            for v in verts:\n                # Try to move v to a lower color without conflicts\n                candidates = list(range(1, target_color))\n                random.shuffle(candidates)\n                moved = False\n                for c in candidates:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                reduced = normalize_colors(reduced)\n                return (reduced, \"color_drop\")\n        # If not reduced, diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (trial, \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if count_conflicts(swapped) == 0:\n                return (swapped, \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment within existing palette (may introduce few conflicts)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST length=9 of positive integers: solution[i] = color assigned to vertex i+1; colors are 1..k with k unrestricted (k inferred from max color in list).","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:Your heuristic signatures are invalid. Do not call functions in parameter lists. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\nH_SIG_MISMATCH:Simulated_Annealing\/Iterated_Local_Search\/Taboo_Search signature does not match def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Rename to Heuristic and fix parameters.\nH_PARAM_CALL_IN_SIGNATURE:Detected generate_neighbour() and evaluate_solution() being called in the function signature. Pass references (generate_neighbour, evaluate_solution), not calls.\nH_TYPING_TUPLE_RUNTIME:Error 'Type Tuple cannot be instantiated; use tuple() instead' implies runtime misuse of typing.Tuple (e.g., Tuple(...)). Replace with tuple(...) for construction and keep typing.Tuple only in annotations.\nNB_TYPEHINT_MISMATCH:generate_neighbour annotated -> Tuple[str,str] but returns 3 items (solution, NB_Type, Movement_Type). Fix to -> Tuple[list,str,str] and ensure all call sites expect a 3-tuple.\nPERTURB_MISSING:$Perturb placeholder is invalid. Provide a concrete perturbation callable perturb_solution(solution, rng, intensity) that returns a valid solution.\nE_EVAL_SANITY:evaluate_solution returns finite non-penalized for conflict-free inputs and large penalties when conflicts exist; basic behavior consistent.\nE_EVAL_COST_SHAPING:The cost for feasible solutions is used + max(0, used - chi), which flattens all optimal feasible solutions into identical scores and dilutes guidance near optimality. Prefer used or used + epsilon*imbalance to maintain gradient without computing chi every call.\nE_EVAL_PERF:Chromatic number computed via backtracking on every call is expensive. Cache chi once per instance (function static or closure) or compute once externally to avoid exponential overhead each evaluation.\nE_EVAL_REDUNDANCY:conflict_count in neighbor duplicates edge processing each time. Precompute adjacency\/edge list once and reuse to cut overhead.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to single-vertex recolor and random vertex swap; lacks structure-aware moves. Add Kempe-chain recolor, color-class swap, and color-merge moves for stronger local descent.\nNB_EXPLODES_COLORS:Allowing max_color+1 during recolor even when conflict-free increases color count unnecessarily. Restrict new-color introduction to conflict states and add a color-drop operator.\nNB_RENUMBER_MISSING:Lack of color compaction after moves leaves gaps that inflate used colors. Add a renumber step to reindex colors to 1..k after each move or periodically.\nNB_TARGETING_WEAK:Recolor picks a random vertex; low signal. Bias selection to conflicted\/high-degree vertices and evaluate candidate colors via local conflict delta with tie-breaking by minimal new color usage.\nNB_CLASS_MOVES_INADEQUATE:Swap of two vertex colors rarely improves class structure. Implement color-class swap (swap all vertices of colors a and b) and greedy recolor of small classes into others.\nINIT_STRATEGY_WEAK:No constructive initializer specified. Use DSATUR or greedy-by-degree to build a low-color starting solution to reduce search burn-in.\nPERTURB_SUGGEST:For ILS\/SA, implement intensity-controlled perturbation (e.g., apply t Kempe-chain moves plus one color-merge attempt, with t proportional to intensity) to escape deep local minima.\nTABU_SPEC_INCOMPLETE:If using Tabu, define move attributes (vertex,color or color-class pair), tabu tenure ~O(sqrt(n)), aspiration by improving cost, and maintain conflict-first aspiration.\nANNEALING_PARAMS:Cooling schedule unspecified\/misaligned. Use geometric cooling T*=alpha*T with alpha in [0.90,0.99], initialize T to match median positive delta, stop at MIN_TEMP or stall iterations.\nE_CONFLICT_DELTA_CACHE:Maintain per-vertex color frequency tables to compute delta conflicts in O(1) per candidate color rather than recomputing counts over edges.\nE_MOVE_ACCEPT:When conflict-free, switch objective to minimize used colors with acceptance rules that prefer color-reducing moves, and disallow any move that increases used unless followed by immediate consolidation.\nE_LOG_EXTRA:Neighborhood returns tags; ensure heuristic logs (NB_Type,Movement_Type) and acceptance decisions for analysis of operator efficacy.\nE_TESTS_MINIMAL:Add unit tests: (1) invalid length\/values return BIG; (2) conflicting solution penalized; (3) feasibility preserved after renumber; (4) neighbor returns 3-tuple and valid solution.\nACTIONABLE_FIX_SIG:Implement Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and inside call neigh_sol,nb_type,move_type=generate_neighbour(currentSolution); score=evaluate_solution(neigh_sol); use perturb_solution when stagnating.\nACTIONABLE_NB_IMPROVE:Add functions: color_compact(sol); kempe_chain_move(sol,v,color_target); color_merge(sol,a,b) if no conflicts; class_swap(sol,a,b); guided_recolor(sol,v) using neighbor color frequencies.\nACTIONABLE_PERTURB:perturb_solution(sol,rng,intensity): for _ in range(intensity): apply 1-2 kempe chains on random conflicted\/high-degree vertices; every few iterations attempt a color_merge; finalize with color_compact.\nACTIONABLE_CACHE:Inside evaluate_solution, cache chi in a function attribute (e.g., if not hasattr(evaluate_solution,'chi'): compute once and store) to avoid recomputation.\nE_VALIDATION_RUN:Sample solution evaluates as feasible and non-penalized under evaluate_solution; a deliberately conflicting solution yields a large penalty. This confirms penalty mechanics and neighbor feasibility expectations.\nRISK:Do not expose internal optimality values in logs\/feedback; only compare relative costs and feasibility status to prevent target leakage.\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9 of positive integers: solution[i] = color assigned to vertex i+1; colors are 1..k with k unrestricted (k inferred from max color in list).","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**4\n    # Basic checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed vertices)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Build adjacency\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Triangle check (lower bound omega)\n    omega = 2\n    for i in range(1, n+1):\n        for j in adj[i]:\n            if j <= i:\n                continue\n            for k in adj[i]:\n                if k <= j:\n                    continue\n                if j in adj[k]:\n                    omega = 3\n                    break\n            if omega == 3:\n                break\n        if omega == 3:\n            break\n    # Exact chromatic number via backtracking (n=9)\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: len(adj[v]), reverse=True)\n    colors = [0] * (n + 1)\n\n    def can_color(v, c):\n        for nb in adj[v]:\n            if colors[nb] == c:\n                return False\n        return True\n\n    def search_k(k, idx):\n        if idx == n:\n            return True\n        v = order[idx]\n        forbidden = set(colors[nb] for nb in adj[v] if colors[nb] != 0)\n        for c in range(1, k + 1):\n            if c not in forbidden and can_color(v, c):\n                colors[v] = c\n                if search_k(k, idx + 1):\n                    return True\n                colors[v] = 0\n        return False\n\n    def chromatic_number():\n        for k in range(omega, n + 1):\n            for i in range(1, n + 1):\n                colors[i] = 0\n            if search_k(k, 0):\n                return k\n        return n\n\n    chi = chromatic_number()\n    used = len(set(solution))\n    return used + max(0, used - chi)\n","NB_CODE":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> Tuple[str, str]:\n    \"\"\"\n    Returns a neighbor solution along with (NB_Type, Movement_Type) tags.\n    Output: (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    \"\"\"\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return the same solution if invalid; still provide tags\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    def conflict_count(sol):\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        es = set()\n        for (u,v) in edges:\n            a = u if u < v else v\n            b = v if u < v else u\n            es.add((a,b))\n        cnt = 0\n        for (u,v) in es:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    n = 9\n    cur = solution[:]\n    max_color = max(cur)\n\n    # Choose move type: recolor or swap\n    if random.random() < 0.6:\n        # Recolor one vertex to a color minimizing conflicts (tie-broken randomly)\n        v = random.randrange(n)\n        candidate_colors = list(range(1, max_color + 2))  # allow introducing a new color\n        random.shuffle(candidate_colors)\n        best_sol = None\n        best_conf = None\n        for c in candidate_colors:\n            if c == cur[v]:\n                continue\n            trial = cur[:]\n            trial[v] = c\n            conf = conflict_count(trial)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best_sol = trial\n        if best_sol is None:\n            best_sol = cur\n        return best_sol, \"NB_Recolor\", \"SingleVertex\"\n    else:\n        # Swap colors of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        nei = cur[:]\n        nei[i], nei[j] = nei[j], nei[i]\n        return nei, \"NB_Swap\", \"Pairwise\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n    n = 9\n    s = solution[:]\n    max_color = max(s)\n    # Apply a series of random recolors; allow expanding palette temporarily\n    steps = 3\n    for _ in range(steps):\n        v = random.randrange(n)\n        new_c = random.randint(1, max_color + 2)\n        s[v] = new_c\n        max_color = max(max_color, new_c)\n    # Optional palette contraction: relabel colors to a compact 1..k mapping\n    palette = sorted(set(s))\n    remap = {c: i + 1 for i, c in enumerate(palette)}\n    s = [remap[c] for c in s]\n    return s\n","SAMPLE_SOL":"[2,2,3,2,2,1,1,3,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_SOLVER_SIG_MISMATCH:Heuristic entrypoint does not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses on function arguments and conform to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"FEEDBACK\",\"E_SA_ILTS_TABU_SIGNATURE:Local solver expects two-value neighbor returns and proper function objects; your SA\/ILS\/Tabu signature shows callable parentheses and mismatched unpacking. Standardize to accept (neighbor, meta) from generate_neighbour and pass function objects, not invoked results.\"\n\"FEEDBACK\",\"E_NB_UNPACK:generate_neighbour returns 3 values (solution, NB_Type, Movement_Type) causing 'too many values to unpack'. Provide a thin adapter def generate_neighbour_2(sol): n, t, m = generate_neighbour(sol); return n, {'NB_Type':t,'Movement_Type':m} or alter solver to unpack 3 values.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation function is undefined ('$Perturb'). Implement def perturb_solution(solution, intensity, rng): return a diversified yet feasible-biased variant (e.g., random Kempe-chain swap + targeted recolor of d vertices).\"\n\"FEEDBACK\",\"E_EXTRA_OUTPUT_CHANNEL:Solver claims extra outputs expected yet rejects 3-tuple. Standardize meta to a single dict as second return to keep a 2-tuple and avoid unpack errors.\"\n\"FEEDBACK\",\"E_EVAL_VALIDATION:evaluate_solution scalar objective is consistent and monotone with feasibility; verified via brute-force cross-check that at least one feasible solution achieves the minimal objective under this evaluator.\"\n\"FEEDBACK\",\"E_EVAL_PENALTY_SCALE:Fixed penalties (1e7 + 1e5*conflicts) dwarf objective but provide coarse gradient. Replace with lexicographic scalar: score = CONFLICT_WEIGHT*conflicts + used_colors where CONFLICT_WEIGHT >= 100 to preserve priority while enabling finer discrimination.\"\n\"FEEDBACK\",\"E_EVAL_COST:O(|E|) per call; repeated full recomputation in neighborhoods is wasteful. Add incremental delta evaluation around changed vertices to cut to O(deg(v)) for single-vertex moves.\"\n\"FEEDBACK\",\"NB_COMPACT_PALETTE_SIDE_EFFECT:compact_palette inside neighbor perturbs color labels every move, breaking memory in Tabu\/SA state and complicating acceptance (two structurally identical solutions map to different labels across steps). Remove compaction from neighbor; compact only on accepted incumbent updates.\"\n\"FEEDBACK\",\"NB_MOVE_SELECTION_IMBALANCE:guided_recolor restricts candidates mostly to existing palette with low chance of introducing a new color; when infeasible this can stall. Use DSATUR-guided recolor for conflicted vertices and allow controlled introduction of a new color when all neighbor colors are present.\"\n\"FEEDBACK\",\"NB_KEMPE_CHAIN_SCOPE:Kempe chain seed is fully random and may produce null or harmful swaps. Bias c2 selection toward most conflicting neighbor color and compute chain strictly on induced subgraph of {c1,c2}; abort if local conflicts increase.\"\n\"FEEDBACK\",\"NB_COLOR_DROP_BIAS:color_drop may frequently return identity when early placement fails. Add multi-try with randomized vertex order and fallback to partial drop (move subset), else return a different neighbor to prevent no-op.\"\n\"FEEDBACK\",\"NB_REDUNDANT_CLASS_SWAP:class_swap is label-only and never changes feasibility\/used-colors; it wastes iterations. Either remove from stochastic menu or trigger only when a tabu mechanism needs label normalization.\"\n\"FEEDBACK\",\"R_PALETTE_GROWTH:Unbounded color creation in conflicts introduces palette bloat. Enforce max_color <= current_max+1 and prefer recolors over introducing new classes.\"\n\"FEEDBACK\",\"ACCEPTANCE_CRITERION:Annealing parameters (TEMP, MIN_TEMP, cooling_factor) unspecified and signature broken. Implement geometric cooling with calibrated initial T from objective deltas; ensure acceptance uses delta from evaluate_solution (post-fix).\"\n\"FEEDBACK\",\"TABU_MEMORY_KEY:If using Tabu, keying on raw color lists fails under palette relabeling; key using conflict set + color class partition signature to avoid false misses.\"\n\"FEEDBACK\",\"RESTART_POLICY:No perturbation or restart safeguards; add ILS-style kick after stagnation K iterations using perturb_solution with increasing intensity.\"\n\"FEEDBACK\",\"INIT_CONSISTENCY:The provided sample solution is feasible and evaluation returns the minimal objective; keep as a strong initializer for fair benchmarking. Do not compact palette after each neighbor when starting from this state.\"\n\"FEEDBACK\",\"TRACEABILITY:Record NB_Type and Movement_Type in the meta dict and through solver\u2019s logging hooks rather than altering return arity.\"\n\"FEEDBACK\",\"TESTS_MINIMAL:Set unit tests: (1) unpacking of generate_neighbour_2 returns 2-tuple; (2) perturb_solution returns valid 9-int list; (3) evaluate_solution strictly decreases or keeps conflicts non-increasing under accepted moves.\"\n\"FEEDBACK\",\"FIX_ORDER:1) Replace generate_neighbour with 2-tuple adapter. 2) Implement perturb_solution. 3) Correct heuristic signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE and remove callable parentheses. 4) Remove in-neighbor compact_palette and move to incumbent normalization. 5) Add incremental evaluation and tighten penalty scalar. 6) Prune class_swap or make conditional.\"\n\"FEEDBACK\",\"EXPECTED_IMPACT:Remedying signature\/unpack\/perturb issues restores solver execution; removing label compaction noise and adopting incremental deltas increases move efficiency and stability; Kempe\/DSATUR guidance improves infeasible-to-feasible convergence speed.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**5\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty dominates; add small tie breaker by used colors\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Feasible: minimize number of used colors\n    used = len(set(solution))\n    return used\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {NB_Recolor, NB_Kempe, NB_ClassSwap, NB_ColorDrop, NB_InvalidPassthrough}\n    Movement_Type in {SingleVertex, Chain, ClassPair, Palette, None}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    # Graph data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        # Pick conflicted vertex if any, else high-degree vertex\n        bad = conflict_vertices(sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            # Highest degree, tie-broken randomly\n            v = max(range(1, n+1), key=lambda u: (len(adj[u]), random.random()))\n        cur = sol[:]\n        max_color = max(cur)\n        # Candidate colors: existing palette only (avoid color explosion) unless conflicts exist\n        candidate_colors = list(sorted(set(cur)))\n        if bad and random.random() < 0.2:\n            candidate_colors.append(max_color + 1)\n        random.shuffle(candidate_colors)\n        best = cur\n        best_score = None\n        for c in candidate_colors:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Compute conflict delta locally\n            conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    conf += 1\n            # Add small tie-breaker to reduce colors\n            used = len(set(trial))\n            score = (conf, used, random.random())\n            if best_score is None or score < best_score:\n                best_score = score\n                best = trial\n        return compact_palette(best), \"NB_Recolor\", \"SingleVertex\"\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Pick target color different from c1; prefer neighbor colors\n        nb_colors = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_colors:\n            palette = sorted(set(cur))\n            if len(palette) == 1:\n                return cur, \"NB_Kempe\", \"Chain\"\n            nb_colors = [random.choice([c for c in palette if c != c1])]\n        c2 = random.choice(nb_colors)\n        # BFS to collect Kempe chain for colors {c1,c2}\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on the chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return compact_palette(cur), \"NB_Kempe\", \"Chain\"\n\n    def class_swap(sol):\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) < 2:\n            return cur, \"NB_ClassSwap\", \"ClassPair\"\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n        return compact_palette(cur), \"NB_ClassSwap\", \"ClassPair\"\n\n    def color_drop(sol):\n        # Try to eliminate a color by greedily recoloring its vertices\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, \"NB_ColorDrop\", \"Palette\"\n        target = random.choice(palette)\n        other = [c for c in palette if c != target]\n        random.shuffle(other)\n        ok = True\n        for v in [i+1 for i,c in enumerate(cur) if c == target]:\n            placed = False\n            random.shuffle(other)\n            for c in other:\n                conflict = False\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                ok = False\n                break\n        if ok:\n            return compact_palette(cur), \"NB_ColorDrop\", \"Palette\"\n        else:\n            return sol[:], \"NB_ColorDrop\", \"Palette\"\n\n    moves = []\n    # Prefer recolor\/Kempe when conflicts exist; else attempt color drop\n    if conflict_vertices(solution):\n        moves.extend([guided_recolor, kempe_chain_move])\n        if random.random() < 0.3:\n            moves.append(class_swap)\n    else:\n        moves.extend([color_drop, guided_recolor, kempe_chain_move, class_swap])\n    move = random.choice(moves)\n    neigh, nb_type, mv = move(solution)\n    return compact_palette(neigh), nb_type, mv\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def kempe(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    s = solution[:]\n    # Intensity: 2-5 Kempe chains and 1 class swap attempt; finalize with palette compaction\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        s = kempe(s)\n    # Class swap attempt\n    palette = sorted(set(s))\n    if len(palette) >= 2 and random.random() < 0.8:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n    s = compact_palette(s)\n    return s\n","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\": \"v0.1\"\n\"FEEDBACK\": \"FIX_LOCAL_SOLVER_ERRORS_FIRST:Taboo_Search driver miswired; SA signature used in Taboo context. Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE across all solvers and provide adapters. Root-cause: unpacking mismatch and heterogeneous call signatures.\nE_SIGNATURE_MISMATCH:Current SA\/ILS\/Tabu signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Implement perturb_solution callable; otherwise ILS\/SA acceptance can stall or crash on None.\nE_NB_API:generate_neighbour returns (neighbor, meta). Ensure all callers expect 2 outputs. If a framework expects only neighbor, add a thin adapter lambda s: generate_neighbour(s)[0].\nE_EVAL_CONST_RECOMP:Edges and weights rebuilt on each evaluate_solution call. Move edges adjacency and weight constants to outer scope to avoid O(|E|) re-init overhead per evaluation.\nE_SCALARIZATION_RISK:Fixed CONFLICT_WEIGHT=100 assumes |palette| <= 99 margin. If color count can exceed 99 due to label inflation, lexicographic dominance can break. Replace with tuple-return (conflicts, used) and a comparator or use BIG_MULTIPLIER >= 1+max_possible_colors.\nREP_COLOR_LABEL_INFLATION:Large labels in solutions (e.g., 27,32,37,38) cause unnecessary palette fragmentation. Add normalize_palette(solution): remap distinct colors to 1..k to stabilize search neighborhoods.\nNB_CODE_FAIL_LOCAL_OPT:Kempe chain palette selection may pick c2 with no improving swap; lacks accept-if-improves check. Add accept-if-better filter using evaluate_solution or local conflict delta; revert otherwise.\nNB_MOVE_BIAS:guided_recolor adds new color when neighbors occupy all alternatives; this increases palette and hurts objective. Restrict new color introduction only when conflicts remain post best recolor attempt.\nNB_DIVERSITY_LIMITED:No vertex-swap or pair-exchange operator. Add 2-vertex swap within same palette to escape plateaus; add multi-vertex Kempe cascade with bounded depth for diversification.\nR_STR_INADEQUATE:Pure index labeling without capacity to lock color classes leads to thrashing. Introduce color-class ordering and vertex ordering by saturation to stabilize recoloring.\nSA_PARAM_UNSAFE:Cooling\/temps unspecified; acceptance likely inconsistent. Use exponential cooling T_k = T0*alpha^k with alpha in [0.90,0.99] and iterations per T proportional to |V|.\nTABU_CONF_BAD:No tenure nor aspiration described. Set tabu tenure in [7, 10] moves, aspiration if a move yields strict best_score.\nILS_PERTURB_WEAK:No strong perturbation to escape deep basins. Implement perturb_solution as k Kempe-chain swaps + random recolor on q high-degree conflicted vertices; choose k,q based on stagnation length.\nLOCAL_SOLVER_EVAL_ASSERT:Using evaluate_solution with provided outputs yields: sample=[1,1,2,1,1,3,3,2,2] -> score=3, SA_sol=[9,9,3,9,12,11,5,8,3] -> score=6, ILS_sol=[38,38,32,38,38,37,37,27,32] -> score=4. All are conflict-free; SA\/ILS inflated palette vs sample. Indicates neighbor\/perturb introduces unnecessary new colors and lacks palette reduction pressure.\nCOLOR_DROP_FRAGILITY:color_drop aborts on first unplaceable vertex; early failure prevents partial success. Replace with greedy recolor with backtracking or sequence: sort target color class by decreasing degree, try all existing colors with conflict checks; if a vertex fails, keep successful reassignments and fallback to guided_recolor only for remaining vertices.\nCONFLICT_VERTEX_SELECTION:guided_recolor picks max saturation among conflicted but ignores conflict degree at v. Prioritize vertices by (#conflicts_at_v, saturation, degree) to target real violations first.\nE_INIT_HEURISTIC:No constructive initializer specified; random starts increase conflicts. Use DSATUR or Welsh-Powell for initialization to reduce initial conflicts and colors.\nE_NEIGH_EVAL_COST:guided_recolor recomputes len(set(trial)) per candidate (O(n)). Maintain palette count incrementally by tracking if replacing v removes last instance of its old color and\/or introduces a new color.\nE_ADJ_REBUILD:Adjacency rebuilt per neighbor call. Precompute adjacency once at module scope for O(1) reuse.\nE_STOPPING_CRITERIA:No stagnation or time-based stop noted. Add max_iter, max_no_improve, and early exit when conflicts=0 and no color drop possible.\nE_ACCEPTANCE_POLICY:No tie-breaking rules. Prefer moves that reduce conflicts; when equal, prefer moves minimizing used colors; when equal, prefer minimal change cardinality.\nE_ASSERTS:Add runtime asserts to ensure 1<=vertex<=9 and colors>0; add fast conflict delta evaluators for single-vertex recolor and 2-vertex swap.\nADAPTERS_REQUIRED:Provide wrappers:\n- neighbour_adapter(solution)->neighbor = generate_neighbour(solution)[0]\n- heuristic_adapter(...) to map framework-specific parameters to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nTESTS_REQUIRED:Add unit tests:\n- Evaluate no-conflict feasible solutions return <= current best.\n- Kempe swap non-worsening property validated or reverted.\n- color_drop reduces used colors or leaves unchanged with fallback.\nBENCH_VALIDATION:Cross-validate solutions by evaluate_solution; reject any move introducing conflict weight dominance. Avoid accepting palette-increasing moves when conflicts=0 unless a subsequent color-drop is scheduled.\nREPRODUCIBILITY:Randomness used without seeds; hard to debug. Add seed control in other_params for deterministic runs.\nCONCRETE_ACTIONS:\n- Implement perturb_solution: randomized k-step Kempe chains + selective recolor of top-m conflicted vertices, with k in [1,3], m in [1,3].\n- Add normalize_palette() after any palette-increasing move.\n- Precompute ADJ, EDGES, DEG, and cached neighbor color sets.\n- Replace CONFLICT_WEIGHT with tuple objective or set weight >= 1+max_colors_cap (e.g., 1000) and enforce cap.\n- Integrate DSATUR initialization.\n- Fix Tabu: store tabu list of (vertex,color) assignments with tenure; aspiration if best-improving.\n- Add color_drop_improved with degree-sorted reassignment and partial success retention.\nE_CODE_PERF:Current neighbor and evaluation O(|E|) per move; after caching and delta updates, target O(deg(v)) per recolor and O(size_chain) per Kempe.\nEVAL_WITH_KNOWN_BEST_ASSERTION:Evaluation confirms sample outperforms provided SA\/ILS outputs under current objective; local solvers not converging to minimal palette. Enforce stricter penalties for introducing new colors when conflicts=0 and increase frequency of color_drop moves until palette reduces.\"","Componentes":{"REPRESENTATION":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    # Weight >= 100 ensures any conflict worse than any color count decrease\n    CONFLICT_WEIGHT = 100\n    return conflicts * CONFLICT_WEIGHT + used","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a 2-tuple: (neighbor_solution, meta_dict)\n    meta_dict contains keys: {'NB_Type': str, 'Movement_Type': str}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def guided_recolor(sol):\n        # DSATUR-ish: pick a vertex (prefer conflicted; else highest saturation\/degree)\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Compute saturation (distinct neighbor colors)\n        def sat(u):\n            return len({cur[v-1] for v in adj[u]})\n        v = max(cand_vertices, key=lambda u: (sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        # Candidate colors: try existing colors first, then at most one new color\n        nb_cols = {cur[nb-1] for nb in adj[v]}\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        # Allow new color only if all neighbor colors block current palette\n        if len(nb_cols) >= len(used_palette) - (1 if cur[v-1] in used_palette else 0):\n            candidates.append(max(used_palette) + 1)\n        random.shuffle(candidates)\n        best = cur\n        best_key = None\n        for c in candidates:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Local conflict count at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if best_key is None or key < best_key:\n                best_key = key\n                best = trial\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        # Seed vertex prefers conflicted; else random\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Choose c2 among neighbor colors that currently conflict most with v\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        # bias to highest frequency\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        # Collect (c1,c2)-Kempe chain via DFS\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                # Check if assigning c to v creates conflict\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection: prioritize reducing conflicts; otherwise try to reduce colors\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Targeted recolor of 1-2 random vertices to diversify\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s","SAMPLE_SOL":"[1,1,2,1,1,3,3,2,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING length=9; solution = [a1,...,a9] with ai in {1,...,k}, k = max(solution); labels must be contiguous 1..k and each used at least once.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_EVAL_RUNTIME_ERROR:Local runner reports 'Type List cannot be instantiated'; remove 'from typing import List, Tuple' instantiations by switching all annotations to builtins 'list'\/'tuple' or enable 'from __future__ import annotations'. Avoid variable annotations like 'tmp: List[List[int]] = []' that some runtimes evaluate.\nE_PERTURB_MISSING:'Perturbation Function' is '$Perturb' (invalid). Provide a concrete 'perturb_solution' callable matching the signature and returning a valid neighbor solution.\nE_NB_SIGNATURE_MISMATCH:'generate_neighbour' return type annotated as 'Tuple[str, str]' but returns '((str,str), list)'. Align to a single, fixed format, e.g. return '(nb_type, move_type, neighbor_solution)' and update all callers.\nE_NB_API_CONTRACT:Neighbour returns metadata first and solution second without a structured container; enforce a dict-based metadata or a fixed 3-tuple to prevent unpacking errors across heuristics.\nE_EVAL_CONTRACT:Evaluation returns 'chi' only if provided 'k' equals optimum; otherwise returns 'PENALTY_BASE + |k - chi|'. This makes near-optimal feasible colorings indistinguishable from infeasible ones in magnitude. Use a composite score: 'score = 1e9*conflicts + 1e6*label_noncontiguity + k' to preserve gradient while still penalizing constraint violations.\nE_EVAL_EXPENSIVE_OMEGA:Clique bound via exhaustive combinations is exponential; replace with Bron\u2013Kerbosch with pivoting or a greedy clique heuristic to cut worst-case overhead. Cache adjacency and bounds across evaluations.\nE_EVAL_BACKTRACKING:Feasibility check uses naive BT on degree order; switch to DSATUR ordering inside BT to prune faster and reduce k-try iterations.\nE_LABELING_COST:Relabeling check recomputes missing\/extra with 'set' and list scan; replace with frequency array of size k to avoid extra list of 'x>k' (always zero by definition) and reduce overhead.\nE_STATE_VALIDATION:Basic check enforces contiguous labels; neighbour generator can transiently introduce k+1. Ensure relabeling occurs after all edits and before evaluation to avoid spurious penalties.\nE_SA_ILSTS_FAIL:All local solvers failed at evaluation stage (same typing error). Fix evaluation typing first; then re-run to isolate heuristic-level issues.\nE_SAMPLE_SOL_EVAL:Validated via python tool; sample passes feasibility and aligns with evaluator's optimality check. Do not alter sample; adjust infrastructure to run it.\nR_PERTURB_IMPLEMENT:Implement 'perturb_solution' as multi-vertex recolor with controlled amplitude: (a) shuffle a random subset S of vertices size ~Geom(p); (b) apply Kempe-chain swaps on randomly chosen color pairs; (c) relabel contiguous. Return both perturbed solution and metadata including amplitude.\nR_NB_OPERATORS:Add conflict-directed moves: (a) recolor a conflicted vertex to least-conflicting color; (b) swap colors between two vertices (color swap move); (c) Kempe-chain interchange; (d) color merge-split to reduce k. Keep 'relabel_contiguous' at the end.\nR_RANDOMNESS_CONTROL:Inject 'rng' object parameter into 'generate_neighbour' and 'perturb_solution' to enable reproducibility; do not use global 'random'.\nR_HEURISTIC_CONTRACT:Ensure 'Heuristic' uses 'best'\/'best_score' consistently with minimization (lower is better). Avoid returning None; always return a fully valid solution and score.\nR_STOPPING_CRITERIA:Add time\/iter\/plateau-based stopping; export diagnostics (acceptance rate, best_score trajectory) via metadata channel, not stdout.\nR_SCORING_NORMALIZATION:Return raw k for feasible solutions to preserve relative differences; for infeasible, return '1e9 + conflicts*1e6 + monochrome_edge_count*1e3 + label_gap_count' to enable progressive improvement.\nR_CACHE:Precompute adjacency, degree order, and optionally DSATUR data once and pass via 'other_params' to avoid recomputation in evaluation.\nR_TESTS:Unit-test evaluation and neighbor with edge cases: wrong length, non-contiguous labels, zero\/negative labels, conflicts injected, introduction\/removal of k+1, and ensure relabel post-condition holds.\nR_TYPE_HINTS_SAFE:Replace typing generics with builtins in annotations, or add 'from __future__ import annotations'. Do not use 'typing.List' in variable annotations to avoid runtime evaluation in strict runners.\nR_OUTPUT_SCHEMA:Standardize neighbour return to: '(op_type:str, move:str, solution:list[int])'. Update all heuristics to unpack accordingly and log via metadata only.\nR_LOCAL_SOLVER_COMPAT:Ensure no print\/log in evaluation; return integers only. Heuristic should handle penalties without crashing, explicitly checking for '>=1e6' as infeasible.\nASSERT_INTERNAL_CHECK:Used python tool to verify evaluator behavior on provided sample; alignment confirmed. Do not expose optimal value in logs or feedback.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORING length=9; solution = [a1,...,a9] with ai in {1,...,k}, k = max(solution); labels must be contiguous 1..k and each used at least once.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    PENALTY_BASE = 10**6\n\n    def basic_check(sol: List[int]) -> Tuple[bool, int]:\n        if not isinstance(sol, list):\n            return False, PENALTY_BASE + 10\n        if len(sol) != 9:\n            return False, PENALTY_BASE + 20 + abs(len(sol) - 9)\n        for x in sol:\n            if not isinstance(x, int):\n                return False, PENALTY_BASE + 30\n            if x <= 0:\n                return False, PENALTY_BASE + 40\n        k = max(sol)\n        labels = set(sol)\n        if labels != set(range(1, k + 1)):\n            missing = len(set(range(1, k + 1)) - labels)\n            extra = len([x for x in sol if x > k])\n            return False, PENALTY_BASE + 50 + 100 * missing + 1000 * extra\n        edges_local = [\n            (1,2),(1,7),(1,9),\n            (2,3),(2,6),(2,7),(2,8),\n            (3,4),\n            (4,6),(4,7),(4,8),(4,9),\n            (5,7),(5,8),(5,9),\n            (7,9),\n            (8,9)\n        ]\n        for (u, v) in edges_local:\n            if sol[u - 1] == sol[v - 1]:\n                return False, PENALTY_BASE + 60\n        return True, 0\n\n    ok, pen = basic_check(solution)\n    if not ok:\n        return pen\n\n    # Build graph\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),\n        (8,9)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n    adj = [set() for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Clique lower bound omega\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            ui = nodes[i]\n            for j in range(i + 1, len(nodes)):\n                vj = nodes[j]\n                if vj not in adj[ui]:\n                    return False\n        return True\n\n    omega = 1\n    idxs = list(range(n))\n\n    def combs(arr: List[int], r: int, start: int, cur: List[int], out: List[List[int]]):\n        if len(cur) == r:\n            out.append(cur[:])\n            return\n        for i in range(start, len(arr)):\n            cur.append(arr[i])\n            combs(arr, r, i + 1, cur, out)\n            cur.pop()\n\n    for r in range(2, n + 1):\n        tmp: List[List[int]] = []\n        combs(idxs, r, 0, [], tmp)\n        found = False\n        for nodes in tmp:\n            if is_clique(nodes):\n                omega = r\n                found = True\n        if not found and r > omega:\n            break\n\n    # Backtracking feasibility for given k\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda x: -deg[x])\n\n    def can_color(k: int) -> bool:\n        colors = [-1] * n\n\n        def bt(i: int) -> bool:\n            if i == n:\n                return True\n            u = order[i]\n            forbidden = {colors[v] for v in adj[u] if colors[v] != -1}\n            for c in range(k):\n                if c not in forbidden:\n                    colors[u] = c\n                    if bt(i + 1):\n                        return True\n                    colors[u] = -1\n            colors[u] = -1\n            return False\n\n        return bt(0)\n\n    chi = None\n    k_try = max(omega, 1)\n    while True:\n        if can_color(k_try):\n            chi = k_try\n            break\n        k_try += 1\n\n    k_given = max(solution)\n    if k_given == chi:\n        return chi\n    return PENALTY_BASE + abs(k_given - chi)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[str, str]:\n    # Work on a copy\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        # Ensure length; if invalid, reset to trivial feasible pattern (1..3 repeated)\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    # Single-vertex recolor neighbor\n    idx = random.randrange(9)\n    k = max(sol)\n    # Allow recolor to any in [1..k] or occasionally introduce k+1 to escape\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        # ensure different color\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n\n    # Relabel to maintain contiguity 1..k'\n    sol = relabel_contiguous(sol)\n\n    return (\"RandomSingleRecolor\", \"RecolorVertex\"), sol  # Note: returns (NB_Type, Movement_Type) as first element, neighbor solution as second\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    sol = list(solution)\n\n    def relabel_contiguous(sol_in: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    n = len(sol)\n    if n != 9:\n        sol = [((i % 3) + 1) for i in range(9)]\n\n    k = max(sol)\n\n    if random.random() < 0.5 and k >= 2:\n        # Swap two color labels globally\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        # Multi-vertex random recolors (2 to 4 vertices)\n        times = random.randint(2, 4)\n        for _ in range(times):\n            idx = random.randrange(9)\n            k = max(sol)\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                if choices:\n                    new_color = random.choice(choices)\n                else:\n                    new_color = sol[idx]\n            sol[idx] = new_color\n\n    sol = relabel_contiguous(sol)\n    return sol\n","SAMPLE_SOL":"[1,3,2,1,1,2,2,2,3]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\n- \"L_SOLVER_IO_SAMPLE_SOL_TYPE:Local solvers expect a string (uses .strip), but SAMPLE_SOL provided as list. Serialize as '1,3,2,1,1,2,2,2,3' or implement dual parsing (str->list, list passthrough) to prevent AttributeError.\"\n- \"L_SOLVER_MISSING_PERTURB:Perturbation Function is undefined ('$Perturb'). Provide a concrete perturbation to escape local minima (e.g., multi-vertex recolor, Kempe-chain shake, or partial randomized DSATUR restart).\"\n- \"L_SOLVER_MISSING_HEURISTIC_IMPL:Heuristic(...) body absent. Implement acceptance, iteration control, and termination; align with provided signature and ensure no side-effects beyond in-memory state.\"\n- \"E_EVAL_CROSSCHK:Evaluator correctness confirmed via internal search; returns finite feasible value on a valid solution and large penalties on infeasible inputs. No change needed for scoring semantics.\"\n- \"E_CODE_ROBUSTNESS:Hard fail on non-int or <=0 entries is correct but coarse. Add fast early exits for len!=9 and type mismatches before computing k\/freq to reduce wasted work.\"\n- \"E_CODE_GRADIENT:Penalty weights create steep cliffs; consider reducing label_gaps weight to 1e2 to allow smoother progress towards contiguity without dwarfing conflict reduction, if stagnation observed.\"\n- \"NB_CODE_FAIL_LOCAL_OPT:Uniform vertex choice ignores conflicts. Bias selection to conflicting vertices first; fallback to uniform only when no conflicts exist.\"\n- \"NB_CODE_UNNECESSARY_COLOR_BLOAT:Unconditional 20% chance to add k+1 inflates palette and triggers heavy penalties. Gate color addition to plateau conditions or only when conflicts persist after bounded recolor attempts.\"\n- \"NB_CODE_MOVESET_THIN:Single-vertex recolor is too weak. Add: (1) two-color swap on a vertex pair, (2) Kempe-chain swaps on two colors, (3) color-merge attempt followed by targeted repairs.\"\n- \"NB_CODE_CANONICALIZATION_CYCLING:Relabeling each move can cause search cycling and disrupt acceptance comparisons. Defer relabel_contiguous to: (a) evaluation time only, or (b) post-acceptance normalization.\"\n- \"NB_CODE_METADATA_MISMATCH:Function advertises 3-tuple (nb_type, move_type, neighbor), verify solver interface actually consumes metadata; otherwise return neighbor only to avoid unpack errors.\"\n- \"R_STR_INADEQUATE:Strict contiguous labels during search amplify penalties. Internally allow gaps, maintain 0-based colors, and normalize to 1..k only at evaluation\/recording to improve exploration.\"\n- \"SA_PARAM_UNSPECIFIED:No cooling\/iteration policy defined. Use geometric schedule T_{t+1}=alpha*T_t with alpha in [0.90,0.99], initial T from 95th percentile |\u0394|, and at least 20*n moves per temperature.\"\n- \"ILS_PERTURB_WEAK:Without a defined perturb, ILS will loop on local optima. Implement variable-strength perturbation proportional to stagnation duration (e.g., 2\u20135 Kempe-chain operations).\"\n- \"TS_MEMORY_UNDEFINED:Tabu list length and aspiration not specified. Set tenure \u2248 n to 2n, aspiration by best-so-far override, and forbid both vertex-color assignments and recent color-class swaps.\"\n- \"INIT_CONSTRUCTION_MISSING:Greedy seed improves convergence. Add DSATUR or largest-first greedy to generate a low-conflict initial coloring.\"\n- \"E_CODE_PERF:O(|E|) per evaluate call is fine, but frequent relabeling costs O(n). Remove relabeling in neighbor; normalize lazily to reduce overhead.\"\n- \"ACCEPTANCE_CRITERIA_INCONSISTENT:Ensure SA uses probabilistic acceptance; ILS accepts only improving local optima; TS accepts best admissible non-tabu (or tabu if aspiration) to prevent regressions.\"\n- \"TERMINATION_CRITERIA_WEAK:Define clear stops: time budget, iteration cap without improvement, or hitting target palette size to avoid unbounded runs.\"\n- \"VALIDATION_TESTS_MISSING:Add unit tests: (a) parser accepts str\/list, (b) evaluator flags conflicts\/label_gaps, (c) neighbor preserves length and positivity, (d) normalization yields contiguous labels.\"\n- \"RESULTS_REPRODUCIBILITY:Seed control absent. Add deterministic seeding path per run to enable regression testing across solvers.\"\n- \"EVAL_CONSISTENCY_ASSERT:Cross-validated evaluator against an internally computed baseline solution; evaluator returns a feasible finite score and penalizes invalids as designed.\"\n- \"FIX_ORDER:1) Fix SAMPLE_SOL parsing\/type. 2) Implement Perturbation and Heuristic scaffolding. 3) Replace neighbor with conflict-driven + richer moves, remove eager relabel. 4) Add robust init and parameters for each metaheuristic. 5) Add tests and seeding.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust, gradient-preserving evaluator for graph coloring on fixed 9-vertex graph\n    # Score semantics (minimize):\n    # - If feasible (no edge conflicts, labels contiguous 1..k): return k\n    # - If infeasible: 1e9 + conflicts*1e6 + label_gaps*1e3 + k\n    # This preserves gradient towards feasibility and then towards fewer colors.\n    BASE_PENALTY = 10**9\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + 10**7\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + 10**7 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + 10**7 + 1\n        if x <= 0:\n            return BASE_PENALTY + 10**7 + 2\n    k = max(solution)\n    # Contiguity check: labels must be exactly 1..k with each used\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            # Should not happen due to k = max(solution), keep safe\n            return BASE_PENALTY + 10**7 + 3\n    label_gaps = 0\n    for c in range(1, k + 1):\n        if freq[c] == 0:\n            label_gaps += 1\n    # Graph definition (0-based indices)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Count conflicts (monochromatic edges)\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    # Feasible: minimize k\n    return k\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a 3-tuple: (nb_type:str, move_type:str, neighbor_solution:list[int])\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    # Ensure proper base solution\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        # Fallback reasonable seed\n        sol = [1,3,2,1,1,2,2,2,3]\n    n = 9\n    idx = random.randrange(n)\n    k = max(1, max(sol))\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return (\"RandomSingleRecolor\", \"RecolorVertex\", sol)\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, multi-edit perturbation with optional global color swap\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        sol = [1,3,2,1,1,2,2,2,3]\n    k = max(1, max(sol))\n    if random.random() < 0.5 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        edits = random.randint(2, 4)\n        n = 9\n        for _ in range(edits):\n            idx = random.randrange(n)\n            k = max(1, max(sol))\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                new_color = random.choice(choices) if choices else sol[idx]\n            sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return sol\n","SAMPLE_SOL":[1,3,2,1,1,2,2,2,3]}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_SIG_HEURISTIC_MISMATCH:Target signature Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) not respected by local solvers. SA\/ILS\/TS expose def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) and call functions with parentheses. Standardize to target signature and pass function references (no parentheses). Encode SA\/ILS\/TS hyperparameters inside other_params.\nE_GEN_NEIGH_CALL_ARITY:Local solvers expect 2 return values but generate_neighbour returns 3 (nb_type, move_type, solution). Either (a) update solvers to unpack 3; or (b) change neighbor to return (solution, meta) or just solution and emit nb_type\/move_type via logging hook.\nE_PERTURB_MISSING:Perturbation Function unresolved ($Perturb). Provide a concrete perturb_solution(current,other_params) that preserves representation and does not break contiguity post-normalization.\nE_EVAL_LABEL_GAPS:Evaluator penalizes label gaps heavily; current neighborhood can create empty color classes with no post-move relabeling, causing artificial mega-penalties and stagnation. Add compress_labels(sol)->contiguous [1..k] after every move and in perturbation; or integrate normalization inside evaluate_solution before computing penalties.\nE_DUP_GRAPH_DEF:Edges are hard-coded in both evaluator and neighbor; risk of drift. Centralize a shared immutable EDGES0\/ADJ in one module passed to both to avoid inconsistency.\nE_NEIGH_ADJ_COST:Adjacency list rebuilt every call. Precompute once; reuse to cut per-move O(m) overhead. Also precompute color conflicts per vertex to allow O(deg) delta updates.\nE_MOVE_SET_LIMITED:Only single-vertex recolor and occasional class swap. This is weak for plateau-escape. Add Kempe-chain moves, color class merge\/split, and double-vertex swaps on conflicting endpoints to improve exploration.\nE_CONFLICT_VERTEX_PICK:Random conflict vertex choice is noisy. Use highest conflict count or tie-break by DSATUR (max saturation degree), then min-conflict color choice; this reduces evaluations and speeds convergence.\nE_COLOR_INTRO_POLICY:Randomly adding k+1 with p=0.1 can bloat k and trigger label gaps. Gate new-color introduction behind necessity: only when no feasible color in 1..k exists for selected vertex given current conflicts; otherwise forbid.\nE_INIT_BIAS:valid_or_seed returns fixed seed, harming diversification. Replace with randomized DSATUR\/greedy coloring with shuffled vertex order; or sample multiple seeds from other_params.\nE_SA_PARAM_INJECTION:SA signature leaks specific params, breaking general interface. Move TEMP, MIN_TEMP, cooling_factor to other_params and access internally; maintain uniform callsite.\nE_TABU_CONFIG:Tabu Search not defined; ensure tabu tenure adaptive to n and conflict dynamics. Maintain tabu on (vertex,color) assignments; aspiration when new best found. Accept 3-return neighbor or wrap to 2.\nE_ILS_PERTURB:ILS requires a non-trivial kick. Implement k-vertex Kempe-chain perturbation or color-class shuffle affecting 5\u201315% of vertices, followed by local descent.\nE_STOPPING_CRITERIA:Undefined. Add max_evals, max_iters_without_improve, and time budget in other_params; return last best deterministically.\nE_RANDOM_SEED_REPRO:No seed control. Accept rng in other_params or seed parameter to ensure reproducibility in tests.\nE_EVAL_SANITY_CHECK:Python check evaluate_solution([1,3,2,1,1,2,2,2,3]) returned finite non-penalized value; evaluator consistent on provided sample.\nE_CODE_STYLE_SAFETY:Ensure no filesystem\/network\/OS access in any component to satisfy MAIN_CRITICAL_INSTRUCTION.\nR_FIX_ORDER:1) Unify heuristic interface across SA\/ILS\/TS and neighbor return arity. 2) Implement perturb_solution. 3) Add compress_labels normalization after every move and perturbation. 4) Centralize graph data and precompute adjacency. 5) Upgrade move selection (DSATUR-driven, Kempe chains). 6) Add robust stopping and reproducibility controls.\nR_COMPRESS_LABELS_SNIPPET:def compress_labels(sol): mapping={}; nxt=1; out=[]; for x in sol: \n    if x not in mapping: mapping[x]=nxt; nxt+=1 \n    out.append(mapping[x]) \n    return out  # call after each neighbor\/perturb before evaluation.\nR_NEIGH_REFACTOR:Return only neighbor solution; move_type and nb_type can be computed lazily for logs. Or wrap: def generate_neighbour_wrapped(sol): nb_type, move_type, ns = generate_neighbour(sol); return ns, (nb_type, move_type).\nR_DELTA_EVAL:Maintain conflicts per vertex and color counts in neighborhoods to avoid full recomputation in acceptance checks; enables O(1)\u2013O(deg) incremental evaluation and faster inner loops.\nR_PARAMETER_DEFAULTS:Set other_params={'algo':'SA','TEMP':1.0,'MIN_TEMP':1e-3,'cooling':0.95,'max_evals':100000,'tabu_tenure':7,'kick_strength':3,'rng_seed':42} and gate behavior on algo for a single Heuristic entry point.\nR_ASSERTS:Before run, assert representation invariants post-normalization: len==9, ints>0, contiguous labels used at least once; fail-fast to avoid wasting iterations on penalized states.\"","Componentes":{"REPRESENTATION":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    k = max(solution)\n    # Contiguity check 1..k all used at least once\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            return BASE_PENALTY + STRUCT_PENALTY + 3\n    label_gaps = sum(1 for c in range(1, k + 1) if freq[c] == 0)\n    # Graph edges (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    return k\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (nb_type:str, move_type:str, neighbor_solution:list[int])\n    # Internal graph (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        # Feasible 3-color seed\n        return [1,3,2,1,1,2,2,2,3]\n    def compute_conflicts(sol):\n        cset = set()\n        for (u, v) in edges0:\n            if sol[u] == sol[v]:\n                cset.add(u); cset.add(v)\n        return cset\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    conflict_vertices = list(compute_conflicts(sol))\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    if random.random() < 0.2 and k >= 2:\n        # occasional color-class swap diversification\n        a, b = random.sample(range(1, k + 1), 2)\n        new_sol = [b if x == a else a if x == b else x for x in new_sol]\n        move_type = \"SwapColors({},{})\".format(a, b)\n        nb_type = \"ColorClassSwap\"\n    else:\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Try best existing color for v (greedy min local conflicts)\n        # Build adjacency list for quick conflict eval\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        current = new_sol[v]\n        best_color = current\n        best_conf = 10**9\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                # usually skip no-op\n                continue\n            tmpc = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmpc += 1\n            if tmpc < best_conf:\n                best_conf = tmpc\n                best_color = c\n                if best_conf == 0:\n                    break\n        # Consider adding a new color only if conflicts exist and it helps\n        if conflict_vertices and random.random() < 0.1:\n            best_color = k + 1\n        new_sol[v] = best_color\n    # Ensure positivity and length preserved\n    if len(new_sol) != n:\n        new_sol = valid_or_seed(None)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (nb_type, move_type, new_sol)\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation using Kempe-chain swaps and random recolors\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def kempe_chain_swap(sol, start_v, a, b):\n        # BFS over subgraph induced by colors a and b starting at start_v\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        target_colors = {a, b}\n        q = deque([start_v])\n        comp = set([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target_colors and u not in comp:\n                    comp.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            # random recolor a few vertices\n            edits = random.randint(1, 3)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n    # Sanity: ensure all entries valid\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","SAMPLE_SOL":"1,3,2,1,1,2,2,2,3"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9 of positive integers; solution[i] is color of vertex i+1.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix1\"\n\"FEEDBACK\",\"E_RUNTIME_TYPEHINT:Remove 'from typing import List' and all 'List[...]' annotations from runtime code. The local runner reports 'Type List cannot be instantiated'; environments that eval hints or misuse List() will break. Use built-ins or no annotations.|\nE_PERTURB_MISSING:'Perturbation Function' is '$Perturb' (non-code). Define a concrete function: def perturb_solution(sol, intensity, rng): return perturbed_sol. Without this, SA\/ILS\/TS fail at import.|\nE_NEIGHBOR_SIG_UNCERTAIN:Heuristic expects generate_neighbour to be callable consistently. Ensure it always returns a 3-tuple (neighbor, NB_Type, Movement_Type). Document and keep arity fixed to avoid unpack errors across solvers.|\nE_INIT_BAD_SEED:Malformed-solution fallback uses [1]*9 producing heavy penalties and hindering convergence. Replace with DSATUR\/greedy initializer producing a feasible low-color seed.|\nEVAL_CORRECTNESS_ASSERT:evaluate_solution(sample) returns feasible score and conflicts=0; matches an independently computed baseline optimum (value withheld). PASS.|\nE_CODE_PERF:Current evaluate_solution is O(|E|) per call (fine for n=9) but costly in local search loops. Implement delta evaluation to O(deg(v)) for single-vertex moves and O(#affected vertices) for palette swaps. Cache edge list and adjacency.|\nR_SYMMETRY:Color labels are arbitrary; lack of canonical relabeling increases search symmetry. After any move, relabel colors to a compact 1..k order by first-appearance to stabilize neighborhood and tabu checks.|\nNB_CODE_FAIL_LOCAL_OPT:Random recolor is uninformed; wastes evaluations. Add steepest-descent recolor: for a chosen vertex, assign the lowest feasible color minimizing conflicts; iterate until no improvement.|\nNB_MOVE_COVERAGE_WEAK:Only recolor\/swap\/highest-color reduce. Add (a) Kempe-chain swaps to escape plateaus, (b) vertex-pair color exchange when both remain feasible, (c) color-class elimination attempt (try to reassign all vertices of a color with backtracking\/time cap).|\nNB_GREEDY_REDUCE_RISK:Sequential reassignment in _reduce_palette can stall by picking the smallest candidate greedily. Use randomized tie-breaking plus retry loops; if reassignment fails, rollback atomically instead of leaving partial merges.|\nRNG_CONTROL:Replace global random with injected rng in all operators: def generate_neighbour(sol, rng), def perturb_solution(sol, intensity, rng). Ensures reproducibility and solver-level temperature\/seed control.|\nTABU_ATTR_KEY:When returning metadata, include a stable move signature (e.g., ('recolor', v, old, new) or ('swap_colors', a, b)) to support robust tabu hashing; current string-only tags are too coarse.|\nCONSTRAINT_DIRECTED:Prioritize vertices by DSAT (saturation degree) or conflict degree when selecting move targets to intensify toward feasibility or palette reduction; current uniform sampling dilutes progress.|\nPALETTE_BOUND:Track current k=|set(colors)| and forbid moves that introduce k+1 unless a diversification phase is active; current _valid_colors can introduce new colors too eagerly. Gate by phase or acceptance rule.|\nINIT_DSATUR:Provide build_initial_solution(graph) using DSATUR producing a low-color feasible solution; use as starting point for SA\/ILS\/TS instead of random fallbacks.|\nDELTA_STATE:Maintain (used_colors_count, conflicts_count, per-color vertex sets). Update incrementally after a move to enable fast acceptance tests and early rejection.|\nHEURISTIC_API_CONSISTENCY:Heuristic(...) must call evaluate_solution only on lists of length 9 with positive ints; add guards and a repair step to map invalid entries to nearest valid color in [1..k].|\nTESTS_MINIMAL:Add unit tests: (a) evaluate_solution on known feasible sample must return a feasible score; (b) 2-color assignment with an odd-cycle conflict must be penalized; (c) generate_neighbour must preserve list length\/types; (d) perturb_solution must change solution distributionally with adjustable intensity.|\nKNOWN_BEST_CHECK:Exhaustive search computed a baseline optimum (withheld) and a witness coloring; evaluate_solution agrees and neighbor operators can reach a feasible solution from random seeds. Keep this hidden in logs; do not expose in solver output.|\nSUGGESTED_PERTURB:def perturb_solution(sol, intensity, rng): apply t=intensity random Kempe-chain or vertex recolors biased toward high-degree\/conflict vertices; ensure no new colors are introduced during intensification phases.|\nAPI_RETURN_EXTRA:Return (neighbor, 'MoveTag', 'SubType', {'delta_conflicts':..., 'delta_k':..., 'move_key':...}) to aid annealing\/tabu; extra dict is ignored by simple runners but improves advanced ones.|\nLOGGING_MIN:Strip prints; return metadata via neighbor tuple. Uncontrolled stdout breaks automated evaluators.|\nCOMPAT_FIX_SUMMARY:1) Remove typing imports\/annotations at runtime. 2) Implement perturb_solution as specified. 3) Canonicalize palette after every move. 4) Add DSATUR initializer. 5) Inject rng across operators. 6) Add delta evaluation and richer neighborhoods.|\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9 of positive integers; solution[i] is color of vertex i+1.","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    if not isinstance(solution, list):\n        return 10000\n    n = 9\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\n\ndef _graph_edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _valid_colors_for_vertex(solution: List[int], v: int) -> List[int]:\n    # v is 1-based\n    n = 9\n    neighbor_colors = set()\n    for (u, w) in _graph_edges():\n        if u == v:\n            neighbor_colors.add(solution[w-1])\n        elif w == v:\n            neighbor_colors.add(solution[u-1])\n    used = set(solution)\n    # Try existing colors first, excluding neighbor colors\n    candidates = [c for c in used if c not in neighbor_colors]\n    if not candidates:\n        # introduce a new color if necessary\n        maxc = max(used) if used else 0\n        candidates = [maxc + 1]\n    return candidates\n\n\ndef _random_recolor(solution: List[int]) -> List[int]:\n    n = 9\n    idx = random.randrange(n)\n    v = idx + 1\n    candidates = _valid_colors_for_vertex(solution, v)\n    current = solution[idx]\n    # Prefer a different color if available\n    choices = [c for c in candidates if c != current] or candidates\n    new_color = random.choice(choices)\n    new_sol = solution[:]\n    new_sol[idx] = new_color\n    return new_sol\n\n\ndef _swap_colors(solution: List[int]) -> List[int]:\n    colors = list(set(solution))\n    if len(colors) < 2:\n        return _random_recolor(solution)\n    a, b = random.sample(colors, 2)\n    return [b if x == a else a if x == b else x for x in solution]\n\n\ndef _reduce_palette(solution: List[int]) -> List[int]:\n    # Attempt to reassign a color class to reduce number of colors\n    colors = sorted(set(solution))\n    if len(colors) <= 1:\n        return solution[:]\n    high = colors[-1]\n    candidates_vertices = [i for i, c in enumerate(solution) if c == high]\n    new_sol = solution[:]\n    for idx in candidates_vertices:\n        v = idx + 1\n        candidates = _valid_colors_for_vertex(new_sol, v)\n        # Prefer lower colors\n        candidates = sorted(candidates)\n        if candidates:\n            new_sol[idx] = candidates[0]\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-ish solution if malformed\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb = _random_recolor(sol)\n        return (nb, \"Recolor\", \"SingleVertex\")\n    elif move_pick < 0.8:\n        nb = _swap_colors(sol)\n        return (nb, \"SwapColors\", \"PaletteRelabel\")\n    else:\n        nb = _reduce_palette(sol)\n        return (nb, \"GreedyReduce\", \"ClassReassign\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\n\ndef _edges_for_perturb():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\n\ndef _feasible_recolor_seq(sol: List[int], steps: int) -> List[int]:\n    n = 9\n    for _ in range(steps):\n        i = random.randrange(n)\n        v = i + 1\n        neighbor_colors = set()\n        for (u, w) in _edges_for_perturb():\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        palette = list(set(sol))\n        if len(palette) < 1:\n            palette = [1]\n        # Ensure at least one option by allowing a new color if blocked\n        options = [c for c in palette if c not in neighbor_colors]\n        if not options:\n            options = [max(palette)+1]\n        # Prefer to change color\n        current = sol[i]\n        choices = [c for c in options if c != current] or options\n        sol[i] = random.choice(choices)\n    return sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors plus occasional palette relabel\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [1]*9\n    else:\n        sol = solution[:]\n    steps = max(3, len(sol)\/\/3)\n    sol = _feasible_recolor_seq(sol, steps)\n    # With probability 0.5, relabel two colors to diversify\n    if random.random() < 0.5 and len(set(sol)) >= 2:\n        a, b = random.sample(list(set(sol)), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_FIX_FIRST:Local solver interface is broken. Your heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove call parentheses in parameters and conform exactly to: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\nE_SIG_MISMATCH:Simulated_Annealing\/Iterated_Local_Search\/Taboo_Search define parameters as generate_neighbour() and evaluate_solution() (called in signature). This causes argument misbinding and downstream failures. Use function references, not calls, in the signature.\nE_MISSING_COMPONENT:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete perturb_solution callable; otherwise ILS\/TS cannot escape local minima nor meet interface.\nE_RUNTIME_BINDING:_edges() takes 0 positional arguments but 1 was given indicates argument shifting due to wrong heuristic signature. Fix signature to prevent helper names being bound incorrectly at runtime.\nE_API_CONTRACT:generate_neighbour returns (neighbor, NB_Type, Movement_Type). Ensure your Heuristic consumes and logs NB_Type\/Movement_Type as \u201cextra outputs are expected\u201d; but only uses neighbor for evaluation. Do not pass metadata back into generate_neighbour.\nE_PARAM_PACKING:Algorithm-specific params (TEMP, MIN_TEMP, cooling_factor, tabu_tenure, max_no_improve, etc.) must be provided via other_params dict; do not place them as positional parameters to preserve the general signature.\nE_STATE_RESET:Lack of initial solution handling in Heuristic will cause failures when currentSolution is invalid. Use DSATUR seed (already implemented) when evaluate_solution detects infeasible\/ill-formed inputs.\nE_EVAL_ASSERT:Evaluation function returns correct penalties and relative ranking consistent with an internally verified optimal solution; sample solution evaluates as feasible and minimal w.r.t. used colors under this graph. No disclosure of the optimal value per policy.\nNB_CODE_FAIL_LOCAL_OPT:_steepest_recolor greedily chooses one vertex and tries all colors; it plateaus easily and cannot reduce palette once conflicts are zero. Add explicit color-class elimination moves and targeted recolor of vertices in the highest color class.\nNB_SEARCH_SCOPE:Kempe chains implemented are unrestricted and may waste steps. Restrict to chains that touch the target highest color class to bias palette reduction, or adopt strategic oscillation between conflict-free and slightly infeasible states.\nR_STR_INADEQUATE:Representation lacks explicit color-class structure. Maintain per-color buckets and per-vertex conflict counts to enable O(1) updates and faster move evaluation.\nE_PERF_ADJ:_adjacency() and _edges() are recomputed on each call across helpers. Hoist to module-level constants or cache once to avoid O(|E|) reconstruction on every neighbor evaluation.\nE_MOVE_COST:Current neighbor evaluation recomputes conflicts from scratch O(|E|) per candidate color. Maintain delta-conflict bookkeeping using adjacency lists to achieve O(deg(v)) update per recolor.\nE_COLOR_CANON:_canonical_relabel called frequently; this is O(n). Restrict relabeling to acceptance steps, not during candidate generation, to reduce overhead and avoid disrupting tabu attributes.\nE_TABU_DEF:If you implement Tabu Search, you need explicit tabu attributes on (vertex,color) assignments and aspiration by best_score. Current components provide no tabu memory.\nE_ANNEALING_CTRL:For SA, implement Metropolis acceptance on delta = new_cost - cur_cost with temperature from other_params. Current design lacks acceptance and cooling hooks consistent with the general signature.\nE_ILS_KICK:Perturbation should be strength-controlled. Use kempe_chain_swap with a loop count and occasional random recolor of a high-color-class vertex; intensity passed via other_params, scaled by stagnation.\nE_SEED_CTRL:Nondeterminism unmanaged. Add seed parameter in other_params and seed RNG within Heuristic start to allow reproducibility in local solver.\nE_STOPPING:Define iteration budgets and early-stop criteria inside Heuristic via other_params (max_iters, max_no_improve). Current results show repeated signature crashes; even after fix, missing budgets risks unbounded loops.\nE_VALIDATION:Before main loop, assert evaluate_solution returns finite values; on infeasible states allow temporary conflicts only if using SA\/TS with penalties; otherwise enforce feasibility.\nS_FIX_SIGNATURE:Implement Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and inside do:\n- if currentSolution invalid: current = _dsatur_initial()\n- loop: nb, mt, ms = generate_neighbour(current); nb_score = evaluate_solution(nb); accept per method; maintain best\/best_score; log (mt,ms).\nS_PERTURB_IMPL:Define perturb_solution(current, intensity, rng) that performs t times: kempe_chain_swap + targeted recolor of a vertex in the highest color class with a feasible color; t from other_params.\nS_COLOR_ELIM:Add a large-neighborhood move: pick highest color h, try to reassign its vertices greedily using feasible colors from lower palette; if all reassigned, drop color h. Use queue with backtracking depth limit.\nS_DELTA_BOOKKEEP:Precompute adj, degree, and neighbor color counts per vertex. Maintain conflict counts to evaluate recolor delta in O(deg(v)) and update neighbor color sets incrementally.\nS_CACHE_GRAPH:Store EDGES and ADJ globally once and pass references to helpers to avoid repeated construction overhead.\nS_META_LOG:Return or record movement metadata per step to satisfy \u201cextra outputs expected,\u201d but ensure evaluation uses only the neighbor assignment.\nS_SANITY_TESTS:Add unit tests: (1) evaluate_solution detects malformed inputs; (2) generate_neighbour returns valid list of length 9 with positive ints; (3) perturb_solution preserves list shape and usually keeps or reduces palette on feasible inputs.\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","EVAL_CODE":"import random, math\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    # Heavy penalties for malformed or conflicting assignments\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","NB_CODE":"import random, math\n\n# Helper utilities fully local to avoid globals\n\ndef _edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adjacency():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canonical_relabel(sol):\n    # Relabel colors by first appearance to 1..k to reduce symmetry\n    mapping = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        out.append(mapping[c])\n    return out\n\ndef _is_conflict_free(sol):\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            return False\n    return True\n\ndef _used_colors(sol):\n    return sorted(set(sol))\n\ndef _dsatur_initial():\n    # DSATUR heuristic to build a low-color feasible solution\n    n = 9\n    adj = _adjacency()\n    colors = [0]*n\n    sat = [0]*n\n    uncolored = set(range(1,n+1))\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    while uncolored:\n        # pick vertex with max saturation, break ties by degree\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        forbid = neighbor_colors[v]\n        c = 1\n        while c in forbid:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canonical_relabel(colors)\n\ndef _valid_colors_for_vertex(sol, v, forbid_new_color=True):\n    # v is 1-based\n    adj = _adjacency()\n    neighbor_cols = set(sol[n-1] for n in adj[v])\n    used = set(sol)\n    candidates = [c for c in used if c not in neighbor_cols]\n    if not candidates and not forbid_new_color:\n        candidates = [max(used)+1]\n    return candidates\n\ndef _steepest_recolor(sol):\n    # Choose a vertex (prefer high conflicts \/ high degree) and assign best feasible color\n    n = 9\n    adj = _adjacency()\n    # conflict score per vertex\n    conf = [0]*n\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            conf[u-1] += 1\n            conf[v-1] += 1\n    # pick target\n    if any(conf):\n        v = max(range(1,n+1), key=lambda x: (conf[x-1], len(adj[x])))\n    else:\n        # intensification toward palette reduction: pick vertex in highest color class\n        colors = sorted(_used_colors(sol))\n        v = 1\n        if colors:\n            high = colors[-1]\n            # pick a vertex in the highest color class with largest degree\n            candidates = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(candidates, key=lambda x: len(adj[x]))\n    candidates = _valid_colors_for_vertex(sol, v, forbid_new_color=True)\n    if not candidates:\n        return sol[:]  # no move that avoids adding colors\n    # try to minimize conflicts and palette size\n    best = None\n    best_tuple = None\n    for c in sorted(candidates):\n        if c == sol[v-1]:\n            continue\n        trial = sol[:]\n        trial[v-1] = c\n        # score tuple: (conflicts, palette_size, color_value)\n        conflicts = 0\n        for u,w in _edges():\n            if trial[u-1] == trial[w-1]:\n                conflicts += 1\n        score = (conflicts, len(set(trial)), c)\n        if best is None or score < best_tuple:\n            best = trial\n            best_tuple = score\n    if best is None:\n        return sol[:]\n    return _canonical_relabel(best)\n\ndef _swap_palette(sol):\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    nb = [b if x == a else a if x == b else x for x in sol]\n    return _canonical_relabel(nb)\n\ndef _kempe_chain_swap(sol):\n    # Basic Kempe chain between two colors to escape plateaus\n    adj = _adjacency()\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    # pick start vertex with color a or b\n    candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n    if not candidates:\n        return sol[:]\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    pair = {a, b}\n    while stack:\n        v = stack.pop()\n        if v in target_set:\n            continue\n        target_set.add(v)\n        for w in adj[v]:\n            if sol[w-1] in pair:\n                stack.append(w)\n    nb = sol[:]\n    for v in target_set:\n        nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n    return _canonical_relabel(nb)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_initial()\n    else:\n        base = _canonical_relabel(solution)\n    r = random.random()\n    if r < 0.55:\n        nb = _steepest_recolor(base)\n        move_t, move_s = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = _kempe_chain_swap(base)\n        move_t, move_s = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = _swap_palette(base)\n        move_t, move_s = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, move_t, move_s)\n","PERTURB_CODE":"import random, math\n\ndef _edges_p():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adj_p():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges_p():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canon(sol):\n    m = {}\n    k = 1\n    out = []\n    for c in sol:\n        if c not in m:\n            m[c] = k\n            k += 1\n        out.append(m[c])\n    return out\n\ndef _dsatur_seed():\n    n = 9\n    adj = _adj_p()\n    colors = [0]*n\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    uncolored = set(range(1,n+1))\n    while uncolored:\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        c = 1\n        while c in neighbor_colors[v]:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canon(colors)\n\ndef _random_feasible_recolor(sol):\n    # recolor a random vertex without introducing a new color\n    adj = _adj_p()\n    n = 9\n    i = random.randrange(n)\n    v = i+1\n    neighbor_cols = set(sol[w-1] for w in adj[v])\n    palette = list(set(sol))\n    options = [c for c in palette if c not in neighbor_cols]\n    if not options:\n        return sol[:]\n    cur = sol[i]\n    choices = [c for c in options if c != cur] or options\n    nb = sol[:]\n    nb[i] = random.choice(choices)\n    return _canon(nb)\n\ndef _palette_merge_attempt(sol, retries=3):\n    # Try to eliminate highest color by reassigning its vertices greedily with randomized order\n    colors = sorted(set(sol))\n    if len(colors) <= 1:\n        return sol[:]\n    high = colors[-1]\n    vertices = [i for i,c in enumerate(sol) if c == high]\n    if not vertices:\n        return sol[:]\n    order = vertices[:]\n    random.shuffle(order)\n    nb = sol[:]\n    adj = _adj_p()\n    for idx in order:\n        v = idx+1\n        neighbor_cols = set(nb[w-1] for w in adj[v])\n        candidates = [c for c in colors if c != high and c not in neighbor_cols]\n        if not candidates:\n            return sol[:]  # abort merge\n        nb[idx] = random.choice(candidates)\n    return _canon(nb)\n\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification: sequence of feasible recolors, optional Kempe-like relabel, and palette merge attempts\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_seed()\n    else:\n        base = _canon(solution)\n    steps = max(3, len(base)\/\/2)\n    cur = base\n    for _ in range(steps):\n        cur = _random_feasible_recolor(cur)\n    # swap two colors with 0.5 probability\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = _canon([b if x==a else a if x==b else x for x in cur])\n    # attempt palette merge\n    if random.random() < 0.6:\n        cand = _palette_merge_attempt(cur)\n        cur = cand\n    return cur\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG_MISMATCH:Heuristic signature mismatch. Framework expects Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your SA\/ILS\/TS use def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) and invoke generate_neighbour() prematurely.\"\n\"E_LOCAL_SOLVER_UNPACK_ERR:Neighbour returns 3-tuple (nb, NB_Type, Movement_Type) but caller unpacks 2. Either return only nb or update caller to accept 3 and ignore metadata.\"\n\"E_PERTURB_MISSING:\u2018Perturbation Function\u2019 is placeholder $Perturb. Missing implementation breaks ILS\/TS\/SA restarts\/diversification.\"\n\"E_SOLVER_INTERFACE_INCONSISTENT:Temperature\/cooling parameters hard-coded into signature instead of passed via other_params dict. Violates target general signature and prevents reuse.\"\n\"E_SAMPLE_EVAL_CHECK:Sample solution evaluation feasible and minimality validated programmatically. Evaluation function alignment: PASS. Do not alter penalty scheme.\"\n\"E_NEIGHBOR_DEAD_CODE:valid_colors_for_vertex unused; remove to reduce maintenance and confusion.\"\n\"E_NEIGHBOR_CANON_OVERUSE:canon() called on every neighbor; unnecessary when palette already compact. Adds O(n) overhead per move.\"\n\"E_MOVE_SET_LIMITED:Recolor targets a single vertex; lacks color-elimination moves and vertex-swap moves; exploration narrow.\"\n\"E_KEMPE_START_SELECTION_WEAK:Random start over {a,b} subgraph can hit trivial chains; low impact on feasibility reduction.\"\n\"E_PALETTE_SWAP_NO_PROGRESS:Pure relabeling provides zero objective change; wastes iterations unless used only for normalization.\"\n\"E_EVAL_PERF:Conflicts recomputed O(|E|) each time; no incremental delta. For iterative methods this is avoidable.\"\n\"E_RANDOMNESS_SEEDING:No RNG seeding control; non-reproducible debugging\/benchmarks.\"\n\"R_FIX_SIG:Refactor SA\/ILS\/TS to exact signature Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); pass functions, not their calls. Pack parameters (TEMP,MIN_TEMP,cooling_factor,tabu_tenure,max_iters) inside other_params.\"\n\"R_UNPACK_ALIGN:Change generate_neighbour to return only neighbor solution OR update solvers to accept (nb, nb_type, mv_type) and ignore the last two. Example: nb_tuple = generate_neighbour(sol); nb = nb_tuple[0].\"\n\"R_IMPLEMENT_PERTURB:Provide perturb_solution(sol,other_params) that applies k-step Kempe kicks or random recolor of vertices incident to highest color class to escape local minima. Ensure returns a valid list.\"\n\"R_MOVE_COLOR_ELIM:Add targeted color-elimination move: pick highest color class H; for v in H, try reassignment to any feasible lower color. If all reassigned, drop H.\"\n\"R_MOVE_PAIR_SWAP:Add vertex-pair swap on conflict edges to break stalemates; evaluate via delta conflicts to avoid full recompute.\"\n\"R_KEMPE_IMPROVE:Bias Kempe start to vertices in highest color class or with max conflicts; prefer chains that touch conflicts to increase effectiveness.\"\n\"R_DISABLE_NOOP_RELABEL:Remove palette_swap from main neighborhood; restrict to canonicalization after improvements only.\"\n\"R_DELTA_EVAL:Maintain per-vertex color counts of neighbors; update conflicts and feasible-colors incrementally in O(deg(v)) per move. Avoid full O(|E|) scans.\"\n\"R_DSATUR_USAGE:Use dsatur_seed only at initialization or after perturb; avoid re-seeding on invalid input silently masking errors. Raise\/repair explicitly.\"\n\"R_CANON_CONDITIONAL:Apply canon() only after a color-elimination success or periodically; skip otherwise to save O(n).\"\n\"R_TUNING_SA:Adopt geometric cooling with reheats on stagnation; accept worse moves with exp(-\u0394\/T). Ensure T schedule via other_params and stop on stability.\"\n\"R_TUNING_TS:Set tabu tenure proportional to n (e.g., 5\u201310) with aspiration if new best found; tabu list on (vertex,color) assignments.\"\n\"R_TUNING_ILS:Use local search L (recolor_steepest+Kempe) then perturb with strength k increasing on stagnation; accept only if not worse.\"\n\"R_RNG_SEED:Expose seed in other_params for reproducibility.\"\n\"R_VALIDATION_TESTS:Add unit tests: neighbor returns list of len 9 positive ints; evaluate_solution minimality check vs reference enumerator.\"\n\"EVAL_CORRECTNESS_ASSERT:Independent search verifies feasibility and evaluation consistency for the provided sample; evaluator returns exact objective. No disclosure of target value per policy.\"","Componentes":{"REPRESENTATION":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","NB_CODE":"import math, random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Internal graph data and helpers\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def conflicts(sol):\n        cnt = 0\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def used_colors(sol):\n        return sorted(set(sol))\n\n    def valid_colors_for_vertex(sol, v):\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        return [c for c in set(sol) if c not in neighbor_cols]\n\n    def recolor_steepest(sol):\n        n = 9\n        conf = [0]*n\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n        if any(conf):\n            v = max(range(1,n+1), key=lambda x: (conf[x-1], len(ADJ[x])))\n        else:\n            cols = used_colors(sol)\n            high = cols[-1] if cols else 1\n            cand = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (conflicts(sol), len(set(sol)), sol[v-1])\n        for c in sorted(set(sol)):\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (conflicts(trial), len(set(trial)), c)\n            if key < best_key:\n                best = trial\n                best_key = key\n        return canon(best)\n\n    def kempe_chain_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        start_candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not start_candidates:\n            return sol[:]\n        start = random.choice(start_candidates)\n        stack = [start]\n        seen = set()\n        pair = {a,b}\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in pair and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return canon(nb)\n\n    def palette_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        return canon([b if x==a else a if x==b else x for x in sol])\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    base = canon(solution) if sol_ok else dsatur_seed()\n\n    r = random.random()\n    if r < 0.55:\n        nb = recolor_steepest(base)\n        mt, ms = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = kempe_chain_swap(base)\n        mt, ms = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = palette_swap(base)\n        mt, ms = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, mt, ms)\n","PERTURB_CODE":"import math, random\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification preserving feasibility when possible\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def random_feasible_recolor(sol):\n        n = 9\n        i = random.randrange(n)\n        v = i+1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return canon(nb)\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        vertices = [i for i,c in enumerate(sol) if c == high]\n        if not vertices:\n            return sol[:]\n        order = vertices[:]\n        random.shuffle(order)\n        nb = sol[:]\n        for idx in order:\n            v = idx+1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    cur = canon(solution) if sol_ok else dsatur_seed()\n\n    steps = max(3, len(cur)\/\/2)\n    for _ in range(steps):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = canon([b if x==a else a if x==b else x for x in cur])\n    if random.random() < 0.6:\n        cur = palette_merge_attempt(cur)\n    return cur\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS: solution is a list of 9 positive integers [c1,..,c9], where ci is the color (room ID) of vertex i. Labels are arbitrary; evaluation compacts labels internally.","Componente":null,"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_TYPE_ANNOT:Type List cannot be instantiated; remove typing.List annotations from runtime context. Replace 'from typing import List' and all 'List[...]' annotations with built-in 'list' or remove annotations to avoid frameworks attempting List(). \nE_EVAL_CALL_FAIL:Local solver fails evaluating SAMPLE_SOL due to typing misuse; FIX_LOCAL_SOLVER by stripping typing imports and annotations across evaluate_solution\/_compact_labels\/generate_neighbour\/Heuristic. \nE_EVAL_EARLY_EXIT:Evaluation iterates all edges even after first violation despite penalty dominance. Implement early return once violations>0 while preserving colors_used: return 1000000+colors_used immediately. \nE_EVAL_PENALTY_SCALE:Fixed 1e6 penalty flattens landscape; consider lexicographic objective (violations first, then colors) to avoid tuning sensitivity and to improve accept\/reject logic. \nNB_CODE_FAIL_LOCAL_OPT:SWAP_COLORS is a pure label permutation; it never changes feasibility nor objective under current evaluation. Remove or replace with structural moves (Kempe-chain swap, pair recolor, color-merge attempts). \nNB_SCOPE_LIMITED:RECOLOR allows introducing a new color up to max_col+1, inflating K and harming exploitation. Bias candidate colors toward existing feasible colors; attempt no-new-color recolor first, then allow new color only if stuck. \nNB_LACKS_CONSTRAINT_AWARENESS:No check prevents conflicting recolors; add feasibility-aware recolor (only assign colors not present in neighbors) for intensification, and keep current stochastic recolor for diversification. \nNB_POST_MOVE_NORMALIZE:Return value not re-compacted after edits; ensure compacting labels before returning to reduce symmetry (always apply _compact_labels at return). \nPERTURB_MISSING:Perturbation Function is undefined ('$Perturb'); provide a concrete implementation (e.g., random Kempe-chain, multi-vertex kick, or random merge-then-repair) to escape local minima. \nHEURISTIC_MISSING:Target signature specified but no Heuristic provided; implement SA\/ILS\/TS wrapper matching 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)'. \nINIT_STRATEGY_WEAK:No constructive initializer; add DSATUR\/greedy coloring to start near low-K solutions, then apply local search. \nR_LABEL_SYMMETRY:Representation suffers from high label symmetry; enforce canonical relabeling after every move and at evaluation boundaries to stabilize search features. \nE_GRAPH_DATA_DUP:Edge (7,9) appears twice logically via list end; ensure unique edges to avoid accidental double counting if code changes. \nE_COMP_COST:Mapping rebuild performed twice (evaluate and neighbour). Cache or reuse compacted solution where possible to reduce overhead in tight loops. \nLOCAL_EVAL_CHECK:Using python tool, SAMPLE_SOL evaluated with cost=3; random neighbours produced both feasible (cost=3) and infeasible (>=1000003) confirming penalty structure; remove typing to resolve local solver crash. \nACTION_ITEMS:1) Remove typing imports\/annotations. 2) Add early-exit in evaluate. 3) Replace SWAP_COLORS with Kempe-chain\/merge moves and feasibility-aware recolor. 4) Implement Perturb and Heuristic per signature. 5) Add DSATUR initializer. 6) Canonicalize labels on return. 7) Consider lexicographic objective for robustness.\"","Componentes":{"REPRESENTATION":"LIST9_POSINTS: solution is a list of 9 positive integers [c1,..,c9], where ci is the color (room ID) of vertex i. Labels are arbitrary; evaluation compacts labels internally.","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and length\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Compact colors to consecutive integers starting at 1\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    violations = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            violations += 1\n    colors_used = len(mapping)\n    return violations*1000000 + colors_used\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"RECOLOR\",\"SWAP_COLORS\"}; Movement_Type describes granularity\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    sol = _compact_labels(solution)\n    n = len(sol)\n    max_col = max(sol)\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # RECOLOR 1 vertex to an existing or new color (at most max_col+1)\n        i = random.randrange(n)\n        # candidate colors: 1..max_col (+ maybe new color)\n        candidates = list(range(1, max_col+2))\n        candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        return sol, \"RECOLOR\", \"1-change\"\n    else:\n        # SWAP_COLORS: pick two distinct color labels present and swap them\n        colors_present = list(sorted(set(sol)))\n        if len(colors_present) < 2:\n            # fallback to recolor\n            i = random.randrange(n)\n            candidates = list(range(1, max_col+2))\n            candidates.remove(sol[i])\n            sol[i] = random.choice(candidates)\n            return sol, \"RECOLOR\", \"1-change\"\n        a, b = random.sample(colors_present, 2)\n        for idx in range(n):\n            if sol[idx] == a:\n                sol[idx] = b\n            elif sol[idx] == b:\n                sol[idx] = a\n        return sol, \"SWAP_COLORS\", \"label-swap\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: recolor k random vertices; k in {2,3,4}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = solution[:]\n    # compact labels first to normalize\n    mapping = {}\n    next_color = 1\n    for i, x in enumerate(sol):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        sol[i] = mapping[x]\n    n = len(sol)\n    max_col = max(sol)\n    k = random.choice([2,3,4])\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # allow assignment among 1..max_col+1\n        new_cands = list(range(1, max_col+2))\n        if sol[i] in new_cands:\n            new_cands.remove(sol[i])\n        sol[i] = random.choice(new_cands)\n    return sol\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Componente":null,"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIG:Invalid heuristic signatures use function calls in parameter list. Correct to def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor).\"\n\"E_LOCAL_SOLVER_UNPACK_NB:Local solvers expect 2-tuple from generate_neighbour but neighbor returns 3 values. Standardize to 2-tuple or add adapter that discards NB_Type\/Movement_Type.\"\n\"E_LOCAL_SOLVER_EVAL_UNPACK:Tabu implementation attempts to unpack evaluate_solution result. Standardize evaluate_solution to return a scalar cost or add adapter to map scalar->(cost, feasible\/conflicts=0).\"\n\"E_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide a concrete implementation to enable ILS\/SA escape.\"\n\"FIX_ADAPTERS:Introduce thin wrappers: nb_adapter(sol)->(new_sol, move_tag) extracting first element; eval_adapter(sol)->cost ensuring scalar; perturb_impl(sol)->legal diversified shake.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks targeted conflict resolution for infeasible states. Add conflict-driven recolor (choose conflicted vertex, assign least-conflicting color) and DSATUR-guided single-vertex recolor.\"\n\"NB_CODE_INEFFICIENCY:_merge_colors_move recomputes adjacency per vertex in reverse pass. Cache adj once to cut redundant work.\"\n\"NB_DIVERSIFICATION_WEAK:Kempe chain start selection uniform; low probability to hit bottlenecks. Bias start toward high-degree or high-conflict vertices.\"\n\"E_EVAL_OBJECTIVE_TIEBREAK:Penalty returns 1e6+colors; coarse gradient near feasibility. For solvers needing richer signal, use wrapper evaluating (conflicts, colors) lexicographically and mapping to scalar safely.\"\n\"R_LABEL_SYMMETRY:Label symmetry persists despite compaction; moves can drift across equivalent labelings. Enforce canonical relabel after every neighbor\/perturb to stabilize search landscape (already partly done; ensure solvers call it consistently).\"\n\"SA_PARAM_WEAK:No default schedule provided. Set TEMP=10.0, MIN_TEMP=1e-3, cooling_factor=0.95, inner_iters proportional to |V| for stable convergence.\"\n\"TABU_PARAM_WEAK:No tabu tenure strategy. Use tenure in [7,10], aspiration by best-so-far cost, and forbid reversing last move class (recolor\/merge component) for tenure steps.\"\n\"ILS_PERTURB_INADEQUATE:No long-jump defined. Implement k-step Kempe component swaps and color-merge attempts followed by greedy repair; set k\u22483\u20135.\"\n\"INPUT_VALIDATION_GAP:generate_neighbour returns ('INVALID','NOOP') without recovery path. Add repair-on-invalid to project inputs into feasible domain.\"\n\"RESTART_POLICY_MISSING:Solvers risk stagnation. Add capped-iteration restarts with randomized seed colors and record-best retention.\"\n\"EVAL_ASSERT_SAMPLE:SampleSolution=[1,2,3,1,1,3,3,3,2] -> evaluate_solution=3 (feasible). Use this to unit-test solver wiring.\"\n\"UNIT_TESTS_REQUIRED:Add smoke tests: (a) neighbor returns 2-tuple via adapter; (b) evaluate_adapter returns scalar; (c) SA\/ILS\/Tabu improve or maintain cost over 100 iterations on sample.\"\n\"CONCRETE_FIX_NB:Replace public generate_neighbour with two-arity return or publish nb_adapter: def nb_adapter(sol): ns,_,_=generate_neighbour(sol); return ns,'MOVE'.\"\n\"CONCRETE_FIX_EVAL:Publish eval_adapter: def eval_adapter(sol): return evaluate_solution(sol). Ensure all solvers call eval_adapter only.\"\n\"CONCRETE_FIX_PERTURB:Implement: with p=0.5 apply Kempe on random color pair component; else attempt color-merge then greedy recolor conflicted vertices; always canonicalize.\"\n\"LOGGING_MINIMAL:Record (iter, cost, conflicts_proxy, move_class) only. Avoid verbose strings in tight loops for performance.\"\n\"E_CODE_PERF:Avoid repeated _adjacency() construction inside loops; precompute once per run and pass as other_params.\"\n\"ABlation_PLAN:Verify impact per operator: disable MERGE\/KEMPE\/RECOLOR individually and compare median cost over 20 runs to identify deadweight.\"\n\"STOP_CRITERIA:Use no-improvement window and temperature threshold\/tenure saturation; stop early when color count unchanged for T iterations after feasibility achieved.\"\n\"SCALING_NOTE:For small n=9, prioritize exactness in local moves over heavy randomness; reduce acceptance\/perturb intensity to prevent oscillation.\"","Componentes":{"REPRESENTATION":"LIST9_POSINTS","EVAL_CODE":"import random\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Early exit on first violation; penalty dominates\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            return 1000000 + colors_used\n    return colors_used\n","NB_CODE":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    adj = _adjacency()\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR\", \"feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR\", \"new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR\", \"conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    adj = _adjacency()\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP\", \"kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    target_set.add(start)\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE\", \"component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol):\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    adj = _adjacency()\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # If not feasible, try the reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in _adjacency()[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","PERTURB_CODE":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        # build component in {a,b}\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Componente":null,"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\n\"FEEDBACK\",\"E_LOCAL_SOLVER_ERROR:Type List cannot be instantiated; use list() instead indicates runtime tried to instantiate typing.List. Replace all annotations List[...] and Tuple[...] with built-in list[...] and tuple[...], or quote annotations ('list[int]') to avoid typing at runtime. Remove from typing imports entirely to prevent symbol collisions.\nE_EVAL_INSTANTIATION_BUG_RISK:Avoid any List()\/Tuple() calls; grep and ensure zero instantiations of typing types. If annotations must be kept, add from __future__ import annotations to defer evaluation.\nEVAL_CODE_LOC:Evaluate function currently safe when run in isolation; error is environment-induced. Prioritize removing typing imports to unblock local solvers (SA\/ILS\/Tabu).\nPERTURB_MISSING:Perturbation Function is undefined ($Perturb). Provide a concrete perturbation operator (e.g., multi-vertex conflict-driven recolor and random color relabel shuffle) returning (new_solution, move_tag). Missing component halts all metaheuristics.\nHEURISTIC_MISSING:Heuristic(...) not provided. Implement the core loop respecting signature, including acceptance criterion, best tracking, stopping conditions, and use of generate_neighbour\/evaluate_solution\/perturb_solution. Without it, all solvers will fail.\nE_EVAL_PERF:O(|E|+n) per call; edges and n are redefined each invocation. Hoist edges, n, and adjacency to module scope to cut constant overhead; preallocate and reuse immutable structures.\nE_EVAL_OBJECTIVE_SCALING:1000 multiplier is arbitrary. Ensure it exceeds any plausible colors_used range to maintain lex order; with n=9 current 1000 is safe. Document this invariant and guard with assert to prevent future regression.\nNB_CODE_FAIL_LOCAL_OPT:_adjacency() rebuilt on every neighbor call. Hoist to a module-level constant; reuse to reduce overhead in tight loops.\nNB_MOVE_SELECTION_WEAK:Vertex i chosen uniformly ignores conflicts. Bias selection toward conflicting vertices first; fallback to random only when conflict-free to accelerate descent.\nNB_RECOLOR_DIVERSIFICATION:Adding new color with p=0.2 can bloat palette early. Gate by current conflicts>0, or cap max colors at current_best_colors+1. Reduce p adaptively when conflicts==0.\nNB_KEMPE_TARGETING:Colors (a,b) sampled uniformly; low impact when no conflicts on their cut. Sample (a,b) from colors present on conflict edges\u2019 endpoints to increase effectiveness.\nNB_MERGE_INADEQUATE:Single random pair test is weak. Iterate over color pairs sorted by inter-class edge count; try merge if no conflicts, else skip. Optionally attempt partial merge with repair.\nNB_STATE_COPY_SAFETY:_recolor_move\/_kempe\/_merge compact and mutate; ensure returning a fresh list independent of input to avoid aliasing across solvers\u2019 caches.\nR_STR_INADEQUATE:Color labels are canonicalized multiple times across components. Canonicalize once at solver entry and maintain canonicality after each move to cut redundant work.\nSA_PARAM_CONTROL:Expose temperature, cooling, and reheating via other_params; add deterministic seeding for reproducibility in local runs.\nTABU_LIST_SCOPE:Include both vertex-color assignments and color-swaps in tabu attributes; clear on perturb to avoid over-constraining.\nILS_PERTURB_STRENGTH:Set perturb sweep size proportional to number of conflicts (e.g., ceil(alpha*conflict_vertices)) to escape shallow basins.\nE_EVAL_CORRECTNESS:Validated against exact search using python; evaluate_solution correctly enforces lexicographic minimization and identifies feasible minima. Do not alter objective without revalidating.\nTEST_COVERAGE:Add unit tests: (a) invalid lengths\/types return inf; (b) conflict introduction increases score by >=1000; (c) relabeling invariance; (d) neighbor moves preserve domain and improve feasibility on conflict-heavy states.\nLOGGING_EXPECTED:Ensure generate_neighbour returns informative move_tag; propagate and aggregate move frequencies in heuristic extra outputs for diagnostics.\nCOMPUTATION_BOUNDS:Set iteration\/time caps in Heuristic and emit final status plus last move_tag histogram to meet 'evaluation extra outputs expected' requirement.\"","Componentes":{"REPRESENTATION":"LIST9_POSINTS","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then colors\n    return conflicts * 1000.0 + float(colors_used)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR|conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set([start])\n    stack = [start]\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE|component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Try reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol, adj)\n\n# Public API\n# Must return (new_solution, move_tag) as 2-tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    adj = _adjacency()\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution, adj)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution, adj)\n    else:\n        return _merge_colors_move(solution, adj)\n","PERTURB_CODE":"import random\nfrom typing import List\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","SAMPLE_SOL":"[1,2,3,1,1,3,3,3,2]"}}
