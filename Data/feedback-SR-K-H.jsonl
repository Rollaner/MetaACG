{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return -1.0\n    if not all(isinstance(i, int) for i in solution):\n        return -1.0\n    if len(solution) != len(set(solution)):\n        return -1.0\n    if any(i < 1 or i > 24 for i in solution):\n        return -1.0\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return -1.0\n    # Data (embedded)\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check\n    total_weight = 0\n    for idx in solution:\n        total_weight += w[idx - 1]\n        if total_weight > capacity:\n            return -1.0\n    # Feasible: compute objective value (maximize), return negative for minimization-based SA\n    total_value = 0\n    for idx in solution:\n        total_value += v[idx - 1]\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _data():\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    return w, v, 304\n\ndef _repair_and_sort(sol: List[int]) -> List[int]:\n    # ensure 1..24, unique, sorted strictly\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n    sol = sorted(set(sol))\n    return sol\n\ndef _weight(sol: List[int], w: List[int]) -> int:\n    return sum(w[i-1] for i in sol)\n\ndef _make_feasible(sol: List[int], w: List[int], cap: int) -> List[int]:\n    sol = _repair_and_sort(sol)\n    while _weight(sol, w) > cap and sol:\n        # remove item with lowest value-to-weight ratio to drop weight efficiently\n        ratios = [(i, (w[i-1], i)) for i in sol]\n        # heuristic: remove heaviest first to quickly reduce overweight\n        remove_idx = max(ratios, key=lambda x: x[1])[0]\n        sol.remove(remove_idx)\n    return sol\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor generation with in-place update (canonical INDEX_LIST). Returns metadata strings only.\n    w, v, cap = _data()\n    current = list(solution)\n    move_type = None\n    # Candidates for addition\/removal\n    present = set(current)\n    absent = [i for i in range(1, 25) if i not in present]\n    # Choose move\n    if len(current) == 0 and absent:\n        move_type = \"add\"\n        item = random.choice(absent)\n        current.append(item)\n    else:\n        r = random.random()\n        if r < 0.34 and absent:\n            move_type = \"add\"\n            # biased add: pick by best value-to-weight ratio among feasible\n            feasible_absent = []\n            base_w = _weight(current, w)\n            for i in absent:\n                if base_w + w[i-1] <= cap:\n                    feasible_absent.append(i)\n            if feasible_absent:\n                # pick best ratio\n                item = max(feasible_absent, key=lambda i: (v[i-1]\/w[i-1], v[i-1], -w[i-1]))\n                current.append(item)\n            else:\n                # fallback to swap if no feasible add\n                move_type = \"swap\"\n                if current and absent:\n                    rem = random.choice(current)\n                    add = random.choice(absent)\n                    current.remove(rem)\n                    current.append(add)\n        elif r < 0.67 and current:\n            move_type = \"remove\"\n            # remove worst by value-to-weight ratio\n            item = min(current, key=lambda i: (v[i-1]\/w[i-1], v[i-1], -w[i-1]))\n            current.remove(item)\n        else:\n            move_type = \"swap\"\n            if current and absent:\n                # guided swap: try improving ratio within feasibility\n                rem = random.choice(current)\n                base = _weight([i for i in current if i != rem], w)\n                feasible_add = [i for i in absent if base + w[i-1] <= cap]\n                if feasible_add:\n                    add = max(feasible_add, key=lambda i: (v[i-1]\/w[i-1], v[i-1], -w[i-1]))\n                    current.remove(rem)\n                    current.append(add)\n                else:\n                    # fallback: random remove\n                    current.remove(rem)\n            elif current:\n                # only removal possible\n                rem = random.choice(current)\n                current.remove(rem)\n            elif absent:\n                add = random.choice(absent)\n                current.append(add)\n    # finalize: sort and repair, then enforce feasibility\n    current = _repair_and_sort(current)\n    current = _make_feasible(current, w, cap)\n    # in-place update to communicate neighbor via side-effect\n    solution[:] = current\n    return (\"INDEX_LIST\", move_type if move_type is not None else \"noop\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _data_p():\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    return w, v, 304\n\ndef _repair_and_sort_p(sol: List[int]) -> List[int]:\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n    sol = sorted(set(sol))\n    return sol\n\ndef _weight_p(sol: List[int], w: List[int]) -> int:\n    return sum(w[i-1] for i in sol)\n\ndef _make_feasible_p(sol: List[int], w: List[int], cap: int) -> List[int]:\n    sol = _repair_and_sort_p(sol)\n    while _weight_p(sol, w) > cap and sol:\n        # remove heaviest first to quickly reduce overweight\n        heaviest = max(sol, key=lambda i: (w[i-1], i))\n        sol.remove(heaviest)\n    return sol\n\ndef perturb_solution(solution: List[int]):\n    # Stronger diversification: multiple random toggles with feasibility repair; in-place update\n    w, v, cap = _data_p()\n    cur = list(solution)\n    k = max(2, len(cur)\/\/3)\n    for _ in range(k):\n        present = set(cur)\n        absent = [i for i in range(1, 25) if i not in present]\n        move = random.random()\n        if move < 0.4 and absent:\n            # add random feasible if possible else skip\n            base_w = _weight_p(cur, w)\n            feas = [i for i in absent if base_w + w[i-1] <= cap]\n            if feas:\n                cur.append(random.choice(feas))\n        elif move < 0.8 and cur:\n            # remove random\n            cur.remove(random.choice(cur))\n        else:\n            # swap if possible\n            if cur and absent:\n                rem = random.choice(cur)\n                base = _weight_p([i for i in cur if i != rem], w)\n                feas_add = [i for i in absent if base + w[i-1] <= cap]\n                if feas_add:\n                    cur.remove(rem)\n                    cur.append(random.choice(feas_add))\n    cur = _repair_and_sort_p(cur)\n    cur = _make_feasible_p(cur, w, cap)\n    solution[:] = cur\n","SAMPLE_SOL":"[1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,18,20,22,23,24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\"\n\"FEEDBACK\":\"E_EVAL_INFEASIBLE_PREFERRED:-1.0 returned for infeasible makes them look better than any feasible negative score. Replace with math.inf or a large positive penalty to enforce feasibility dominance.;E_TYPE_HINTS_RUNTIME:Local solver error 'Type List cannot be instantiated' indicates runtime interaction with typing.List. Remove typing-based generics from annotations or use from __future__ import annotations or quote annotations (e.g., 'list[int]'). In all isinstance checks, keep using built-in list.;E_PERTURB_MISSING:'Perturbation Function' is placeholder ($Perturb). Provide a concrete def perturb_solution(...) consistent with TARGET_HEURISTIC_GENERAL_SIGNATURE or solvers will fail.;E_API_CONTRACT:generate_neighbour mutates input in-place and returns only metadata. If the local solver expects a returned neighbor object, add an explicit return of the new solution and avoid relying on side effects.;E_ANNOT_RETURNS:Return annotation -> ('NB_Type','Movement_Type') uses tuple of string literals and may be parsed as a constructible type by the framework. Replace with -> tuple[str,str] or remove return annotations to avoid instantiation attempts.;E_NEIGHBOR_REPAIR_POLICY:_make_feasible comment-code mismatch and suboptimal drop (heaviest-first). Implement removal by lowest value\/weight ratio or minimal marginal value loss under capacity.;E_TIEBREAK_ENFORCEMENT:Lexicographic tie-break is not enforced at acceptance. Add deterministic comparator: when scores equal, prefer lexicographically smaller INDEX_LIST to stabilize best selection.;E_RANDOMNESS_REPRO:Unseeded random usage harms reproducibility and debugging. Thread a seeded RNG via other_params and use rng.random()\/rng.choice.;E_NEIGHBOR_FEAS_COST:Multiple full weight recomputations (_weight) per move add overhead. Maintain incremental weight (carry current_weight in other_params) to O(1) updates.;E_SWAP_FALLBACK:Swap branch can remove an item without guaranteed feasible add, potentially degrading solution unnecessarily. Add feasibility-checked 1-1 and 1-k exchange, or revert if no improving feasible add found.;E_EVAL_VALIDATION:Strict ordering\/uniqueness checks are correct but expensive on every call. Cache canonicalized solution and weight in other_params to avoid repeated sorting\/validation during local moves.;E_NAME_TYPO:'Neigbour Function' misspelling may break auto-wiring. Standardize to 'Neighbor Function' consistently across keys.;E_SAMPLE_SUBOPT:Sample solution is feasible but not optimal relative to an independently computed benchmark. Use it only as a sanity check, not as an initial incumbent.;FIX_PATCH_1:In evaluate_solution, replace infeasible return with 'return float(\\\"inf\\\")' and keep feasible as '-total_value'.;FIX_PATCH_2:Remove typing generics from runtime annotations. Example: 'def evaluate_solution(solution):' and 'def generate_neighbour(solution):' or add 'from __future__ import annotations' at top and ensure no framework instantiates typing types.;FIX_PATCH_3:Provide perturbation: def perturb_solution(sol, rng, strength=2): perform k random ratio-guided add\/remove\/swap while preserving feasibility and return new sol.;FIX_PATCH_4:Implement lexicographic tie-break in acceptance: if new_score==best_score and new_sol<best (lexicographic), update best.;FIX_PATCH_5:Refactor neighbor to accept and return (sol, meta), avoid in-place mutation unless framework explicitly requires it.;ASSERT_CORRECTNESS:Independent DP confirms the internal evaluator produces consistent feasibility and ordering, and the sample is strictly dominated by another feasible solution under the same capacity without disclosing specifics.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return float(\"inf\")\n    if not all(isinstance(i, int) for i in solution):\n        return float(\"inf\")\n    if len(solution) != len(set(solution)):\n        return float(\"inf\")\n    if any(i < 1 or i > 24 for i in solution):\n        return float(\"inf\")\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return float(\"inf\")\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        vi = v[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float(\"inf\")\n        total_value += vi\n    # Return negative for minimization-based SA (best = lesser cost)\n    return float(-total_value)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def repair_and_sort(sol):\n        sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n        sol = sorted(set(sol))\n        return sol\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def make_feasible(sol):\n        sol = repair_and_sort(sol)\n        # Remove items with worst value-to-weight ratio first until feasible\n        while True:\n            tw = weight_of(sol)\n            if tw <= cap or not sol:\n                break\n            worst = min(sol, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            sol.remove(worst)\n        return sol\n\n    current = list(solution)\n    move_type = None\n\n    present = set(current)\n    absent = [i for i in range(1, 25) if i not in present]\n\n    if not current and absent:\n        move_type = \"add\"\n        base_w = 0\n        feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.append(choice)\n    else:\n        r = random.random()\n        if r < 0.34 and absent:\n            move_type = \"add\"\n            base_w = weight_of(current)\n            feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas_abs:\n                choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                current.append(choice)\n        elif r < 0.67 and current:\n            move_type = \"remove\"\n            rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.remove(rem)\n        else:\n            move_type = \"swap\"\n            if current and absent:\n                rem = random.choice(current)\n                base = weight_of([i for i in current if i != rem])\n                feas_add = [i for i in absent if base + w[i - 1] <= cap]\n                if feas_add:\n                    add = max(feas_add, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                    current.remove(rem)\n                    current.append(add)\n            elif current:\n                # fallback to remove if no absent\n                rem = random.choice(current)\n                current.remove(rem)\n            elif absent:\n                add_any = random.choice(absent)\n                current.append(add_any)\n\n    current = repair_and_sort(current)\n    current = make_feasible(current)\n\n    solution[:] = current\n    return (\"INDEX_LIST\", move_type if move_type is not None else \"noop\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def repair_and_sort(sol):\n        sol = [i for i in sol if isinstance(i, int) and 1 <= i <= 24]\n        sol = sorted(set(sol))\n        return sol\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def make_feasible(sol):\n        sol = repair_and_sort(sol)\n        while True:\n            tw = weight_of(sol)\n            if tw <= cap or not sol:\n                break\n            # remove worst ratio item first\n            worst = min(sol, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            sol.remove(worst)\n        return sol\n\n    cur = list(solution)\n    k = max(2, len(cur) \/\/ 3)\n    for _ in range(k):\n        present = set(cur)\n        absent = [i for i in range(1, 25) if i not in present]\n        move = random.random()\n        if move < 0.4 and absent:\n            base_w = weight_of(cur)\n            feas = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas:\n                # add a random feasible item biased by good ratio\n                best = max(feas, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                cur.append(best)\n        elif move < 0.8 and cur:\n            rem = random.choice(cur)\n            cur.remove(rem)\n        else:\n            if cur and absent:\n                rem = random.choice(cur)\n                base = weight_of([i for i in cur if i != rem])\n                feas_add = [i for i in absent if base + w[i - 1] <= cap]\n                if feas_add:\n                    add = random.choice(feas_add)\n                    cur.remove(rem)\n                    cur.append(add)\n    cur = repair_and_sort(cur)\n    cur = make_feasible(cur)\n    solution[:] = cur\n","SAMPLE_SOL":"[1, 2, 3, 4, 6, 8, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE; remove SA-specific params (TEMP, MIN_TEMP, cooling_factor) from Heuristic signature and pass such params via other_params dict.\nILS_ERROR:unsupported operand type indicates arithmetic on strings; ensure numeric types for temperatures\/iterations and adhere to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nTABU_ERROR:generate_neighbour return arity\/type mismatch; return exactly (neighbour_solution, move_type) with neighbour_solution as a new INDEX_LIST; do not include representation tag or rely on in-place mutation.\nSA_RESULT_INCONSISTENT:best_score does not match best_sol; recompute score via evaluate_solution whenever updating best and store (best_sol, best_score) atomically to avoid desync.\nNEGATIVE_COST_CONVENTION:Heuristic acceptance\/improvement checks must use lower-is-better; replace comparisons with <= on costs and never mix positive objective values in acceptance logic.\nTIE_BREAK_POLICY_MISSING:On equal costs, select lexicographically smaller INDEX_LIST; implement comparator: if cost_equal and cand < best lexicographically, update best.\nPERTURB_MISSING:$Perturb undefined; implement perturb_solution that performs k-move (e.g., remove t random items, add best-ratio feasible items, then repair) returning a valid INDEX_LIST.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to add\/remove\/random swap; add 1-1 ratio-improving swap and 2-opt (remove two, add two) with feasibility-aware selection to escape shallow local minima.\nNB_REPAIR_BIAS:Greedy \u201cworst ratio\u201d drop in make_feasible can over-prune high-weight\/high-value combos; add stochastic removal among bottom-\u03b5 ratio set or use Lagrangian-weighted score v\u2212\u03bbw with adaptive \u03bb.\nIN_PLACE_MUTATION_RISK:generate_neighbour mutates solution; switch to pure functional neighbor generation and return a new list to avoid state corruption across solvers.\nE_CODE_PERF:weight_of invoked repeatedly O(n); maintain and update current weight incrementally (\u0394 updates) within neighbor\/acceptance to avoid recomputation.\nREPAIR_SORT_COST:repair_and_sort + set conversion each call is O(n log n); maintain sorted invariant by inserting\/removing in order; validate only modified elements.\nFEASIBILITY_CHECK:Before neighbor evaluation, fast-reject infeasible adds via cached current_weight; avoid calling make_feasible unless explicitly repairing post-perturb.\nINIT_STRATEGY_WEAK:Empty-start branch causes slow convergence; initialize with greedy by value-to-weight ratio under capacity, then local-improve with best-improving adds\/swaps.\nACCEPTANCE_RULES:Ensure Simulated Annealing uses numeric temperature schedule inside other_params; cooling and acceptance depend only on costs; no strings or external state.\nRETURN_CONTRACT:Heuristic must return (best_solution, best_score); avoid extra positional outputs; if extra diagnostics required, place them inside other_params['logs'].\nEVAL_VALIDATION:Continuously assert evaluate_solution(sol) != inf before accepting a move; log and discard any neighbor producing inf to prevent infeasible states.\nINDEX_ORDER_ENFORCEMENT:Always output strictly increasing unique indices; when generating neighbors, ensure additions keep order or reinsert with bisect to maintain monotonicity.\nREPRODUCIBILITY:Set random seed only via other_params when needed; do not rely on global random state across solvers to avoid cross-run variability.\nTEST_PROTOCOL:Cross-validate solver outputs against an exact DP checker offline to assert correctness; do not reveal the optimal solution\/value in logs or feedback.\nBENCH_TARGETS:Track iterations-to-best and time-per-iteration; optimize hotspot functions (neighbor gen, evaluation) to reduce per-iteration overhead.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, unique, 1..24)\n    if not isinstance(solution, list):\n        return float(\"inf\")\n    if not all(isinstance(i, int) for i in solution):\n        return float(\"inf\")\n    if len(solution) != len(set(solution)):\n        return float(\"inf\")\n    if any(i < 1 or i > 24 for i in solution):\n        return float(\"inf\")\n    if any(a >= b for a, b in zip(solution, solution[1:])):\n        return float(\"inf\")\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Capacity check and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        vi = v[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float(\"inf\")\n        total_value += vi\n    # Negative cost convention for maximization\n    return float(-total_value)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        # Maintain strictly increasing order without duplicates\n        if item in sol:\n            return sol\n        # Binary insertion\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        sol.insert(lo, item)\n        return sol\n\n    def feasible_add(base_sol, item):\n        return weight_of(base_sol) + w[item - 1] <= cap\n\n    current = list(solution)\n    # ensure canonical form\n    current = sorted(set(i for i in current if isinstance(i, int) and 1 <= i <= 24))\n\n    present = set(current)\n    absent = [i for i in range(1, 25) if i not in present]\n\n    move_type = \"noop\"\n\n    if not current and absent:\n        # start by adding best ratio feasible item\n        feas_abs = [i for i in absent if w[i - 1] <= cap]\n        if feas_abs:\n            choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current = insert_sorted(current, choice)\n            move_type = \"add\"\n    else:\n        r = random.random()\n        if r < 0.34 and absent:\n            # add: choose best ratio among feasible absent\n            base_w = weight_of(current)\n            feas_abs = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas_abs:\n                choice = max(feas_abs, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                current = insert_sorted(current, choice)\n                move_type = \"add\"\n        elif r < 0.67 and current:\n            # remove: choose worst ratio in current\n            rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n            current.remove(rem)\n            move_type = \"remove\"\n        else:\n            # swap: remove one, add one best-ratio feasible\n            if current and absent:\n                # choose removal as worst ratio to free capacity\n                rem = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                base = [i for i in current if i != rem]\n                base_w = weight_of(base)\n                feas_add = [i for i in absent if base_w + w[i - 1] <= cap]\n                if feas_add:\n                    add = max(feas_add, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                    current = base\n                    current = insert_sorted(current, add)\n                    move_type = \"swap\"\n            elif current:\n                # fallback to remove\n                rem = random.choice(current)\n                current.remove(rem)\n                move_type = \"remove\"\n            elif absent:\n                # fallback to add any feasible\n                feas_abs = [i for i in absent if w[i - 1] <= cap]\n                if feas_abs:\n                    add = random.choice(feas_abs)\n                    current = insert_sorted(current, add)\n                    move_type = \"add\"\n\n    # final canonicalization and feasibility check (should already be feasible)\n    # ensure capacity not exceeded; if exceeded due to unforeseen path, drop worst ratios until feasible\n    while weight_of(current) > cap and current:\n        worst = min(current, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n        current.remove(worst)\n        move_type = \"repair_drop\"\n\n    # in-place update for downstream solvers expecting mutation\n    solution[:] = current\n    return (\"INDEX_LIST\", move_type)\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    cap = 304\n\n    def weight_of(sol):\n        return sum(w[i - 1] for i in sol)\n\n    def insert_sorted(sol, item):\n        if item in sol:\n            return sol\n        lo, hi = 0, len(sol)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if sol[mid] < item:\n                lo = mid + 1\n            else:\n                hi = mid\n        sol.insert(lo, item)\n        return sol\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= 24))\n\n    # number of atomic moves\n    k = max(3, len(cur) \/\/ 2)\n    for _ in range(k):\n        present = set(cur)\n        absent = [i for i in range(1, 25) if i not in present]\n        move = random.random()\n        if move < 0.33 and absent:\n            # biased add by good ratio if feasible\n            base_w = weight_of(cur)\n            feas = [i for i in absent if base_w + w[i - 1] <= cap]\n            if feas:\n                pick = max(feas, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n                cur = insert_sorted(cur, pick)\n        elif move < 0.66 and cur:\n            # remove random item\n            rem = random.choice(cur)\n            cur.remove(rem)\n        else:\n            # swap random remove with feasible random add\n            if cur:\n                rem = random.choice(cur)\n                base = [i for i in cur if i != rem]\n                base_w = weight_of(base)\n                absent2 = [i for i in range(1, 25) if i not in set(base)]\n                feas_add = [i for i in absent2 if base_w + w[i - 1] <= cap]\n                if feas_add:\n                    add = random.choice(feas_add)\n                    cur = base\n                    cur = insert_sorted(cur, add)\n\n    # repair if needed: drop low ratio items until feasible\n    while weight_of(cur) > cap and cur:\n        worst = min(cur, key=lambda i: (v[i - 1] \/ w[i - 1], v[i - 1], -w[i - 1]))\n        cur.remove(worst)\n\n    # write back in place\n    solution[:] = cur\n","SAMPLE_SOL":"[1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 22, 23, 24]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\": \"1.0\"\n\"FEEDBACK\": \"E_FIX_FIRST:Local solver interfaces are inconsistent and erroring. Standardize to TARGET_HEURISTIC_GENERAL_SIGNATURE across all solvers before any tuning.\nE_SIG_MISMATCH_ILS:Iterated_Local_Search invoked with SA-style signature. Replace with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_SIG_MISMATCH_TABU:Taboo_Search invoked with SA-style signature and wrong return unpacking. Align call and return protocol to TARGET_HEURISTIC_GENERAL_SIGNATURE and a single standardized return.\nE_RET_PROTO:Heuristic returns and solver unpacking are inconsistent (SA produced 4-tuple; Tabu expected 2). Enforce: return currentSolution, current_score, best, best_score.\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb). Provide a concrete def perturb_solution(solution, intensity, rng) that returns a new valid INDEX_LIST.\nE_STATE_MUTATION:generate_neighbour mutates input (solution[:]=...). This breaks solvers and caused 'str' object assignment error. Return an immutable new list; do not mutate inputs.\nNB_API_CONTRACT:generate_neighbour returns ('INDEX_LIST', move_type) instead of a neighbour solution. Change to return (new_solution, move_type) or just new_solution; keep move_type optional meta.\nNB_SCORE_INCONSISTENCY:Simulated_Annealing output lists identical INDEX_LIST with two different scores (-148, -268). This violates evaluate_solution. Ensure scores are always computed by evaluate_solution(solution) at emission.\nE_EVAL_CONSISTENCY:All solvers must use evaluate_solution for acceptance and reporting. Ban ad-hoc score caches that drift from evaluate_solution.\nE_TIEBREAK_NOT_ENFORCED:Lexicographic tie-break among maximizers is not enforced. Implement tie-break in acceptance: if scores equal, prefer lexicographically smaller INDEX_LIST.\nE_INIT_POLICY:Empty-start special case selects ratio-best but lacks deterministic tie-break. Use tuple key (v\/w, v, -w, -i) to get stable and lexicographically consistent adds.\nNB_MOVE_SET_WEAK:Operator set limited to add\/remove\/single swap restricts escape from plateaus. Add k-exchange: 1-1, 2-1, 1-2, 2-2 pairwise exchanges under capacity repair.\nNB_REPAIR_BIAS:Repair drops worst ratio greedily, which can discard high-utility items. Replace with best-first repair minimizing value loss per unit overweight or run bounded knapsack repair on selected subset.\nE_CAPACITY_CHECK:Repeated weight_of calls make neighbour O(n) per move. Cache (total_weight,total_value) in state; compute deltas for O(1) feasibility checks and score updates.\nE_RANDOMNESS:Unseeded random usage harms reproducibility and debugging. Accept rng in other_params and use rng.random()\/rng.choice with fixed seed for experiments.\nILS_PERTURBATION_WEAK:No perturbation provided, ILS cannot escape local optima. Implement segment shuffles: random removal of t items followed by feasible greedy reinsert; tune t adaptively.\nSA_SCHEDULE:Cooling schedule unspecified and likely misapplied. Use geometric cooling T_next = alpha*T with alpha in [0.90,0.99], stop at MIN_TEMP; scale acceptance with true delta_cost from evaluate_solution.\nSA_ACCEPT_TIE:On equal scores, apply lexicographic tie-break; do not accept worse lexicographic states.\nTABU_MEMORY_DEFICIENT:No tabu tenure\/aspiration defined. Maintain tabu list on item indices or move tuples with aspiration when a move yields a strictly better best_score.\nCHECK_FEASIBILITY:Before accepting neighbours, ensure capacity <=304; reject or repair deterministically to avoid stochastic feasibility drift.\nR_SAMPLE_SOLUTION_VALIDATION:Sample solution is feasible; score equals -evaluate_solution(sample). Keep as a regression test.\nVERIFY_ORACLE:Use an internal DP oracle to assert solver outputs on termination and during testing; reject outputs whose score\/feasibility deviate from evaluate_solution.\nE_OUTPUT_PARSING:Local solvers expect extra outputs; define a strict schema: (current_solution, current_score, best_solution, best_score, meta) where meta is a dict; update all callers accordingly.\nR_DELTA_EVAL:Maintain state with fields {indices (sorted list), total_weight, total_value}; neighbour ops update deltas, eliminating repeated scans.\nR_MOVE_GENERATION:Augment neighbour with deterministic best-improvement and randomized first-improvement modes; toggle via other_params for exploitation\/exploration balance.\nR_TIEBREAK_UTILITY:Implement comparator cmp(a,b): primary cost, then lexicographic; centralize to avoid divergence across solvers.\nR_UNIT_TESTS:Add property tests: (1) evaluate_solution monotone under superset weight, (2) neighbour returns valid canonical INDEX_LIST, (3) no score mismatch versus evaluate_solution.\nR_ERROR_HANDLING:On any invalid neighbour (inf), discard and resample up to K tries; otherwise fallback to deterministic repair.\nR_DATA_LOCALITY:Inline w,v,capacity once; pass as closure\/env to avoid recomputation and drift across components.\nE_DOC_SIGNATURE:Document TARGET_HEURISTIC_GENERAL_SIGNATURE in code comments and enforce via wrapper that adapts legacy solvers to the target signature.\nE_METRICS:Report iterations, accepted moves, improving moves, time; enable early-stopping on stagnation and reheating for SA.\n\nKNOWN_BEST_VALIDATION:Oracle computed and used to validate correctness privately; current best from SA is suboptimal and violates target criterion. Do not disclose target; fix issues above and re-run.\n\nACTION_CHECKLIST:\n- Standardize signatures and return schema across SA\/ILS\/Tabu; remove in-place mutations.\n- Implement missing perturbation and enhanced move set with delta evaluation.\n- Enforce evaluate_solution for all scoring, with lexicographic tie-break on ties.\n- Add DP-oracle-based assertion in tests; reject inconsistent outputs.\n- Seed RNG via other_params for reproducibility.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Componentes":{"REPRESENTATION":"INDEX_LIST.1BASED.UNIQUE","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns a scalar fitness to MINIMIZE: feasible => negative total value (higher value => more negative => better);\n    # infeasible => large positive penalty.\n    # Problem data (1-based indexing with leading None for alignment)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Linear penalty proportional to overflow, plus offset to dominate any feasible score\n        overflow = total_cost - B\n        return 10**9 + overflow\n    # Feasible: return negative value to make higher value better (smaller is better)\n    return -total_value\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood: randomized toggle\/swap with feasibility bias\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    B = 3040\n    n = 24\n    sol = list(solution)\n    # Ensure uniqueness and valid indices defensively\n    sol = [x for x in sol if isinstance(x, int) and 1 <= x <= n]\n    sol = list(dict.fromkeys(sol))\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n    current_cost = total_cost(sol)\n    # Candidates\n    in_set = set(sol)\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n    move_type = None\n    r = random.random()\n    if r < 0.4 and not_in:\n        # Try Add best-fit item randomly from not_in\n        random.shuffle(not_in)\n        for i in not_in:\n            if current_cost + costs[i] <= B:\n                sol.append(i)\n                move_type = \"add\"\n                break\n        if move_type is None and sol:\n            # fallback: remove one item\n            j = random.choice(sol)\n            sol.remove(j)\n            move_type = \"remove_fallback\"\n    elif r < 0.8 and sol and not_in:\n        # Swap: remove one, add one\n        j = random.choice(sol)\n        cand = [i for i in not_in if current_cost - costs[j] + costs[i] <= B]\n        if cand:\n            i = random.choice(cand)\n            sol.remove(j)\n            sol.append(i)\n            move_type = \"swap\"\n        else:\n            # fallback to toggle remove\n            sol.remove(j)\n            move_type = \"remove_fallback\"\n    else:\n        # Remove\n        if sol:\n            j = random.choice(sol)\n            sol.remove(j)\n            move_type = \"remove\"\n        else:\n            # Nothing to remove: try add smallest-cost item\n            smallest = min(range(1, n+1), key=lambda k: costs[k])\n            if costs[smallest] <= B:\n                sol = [smallest]\n                move_type = \"add_min\"\n            else:\n                move_type = \"noop\"\n    # Final cleanup: ensure capacity\n    while total_cost(sol) > B and sol:\n        # remove random items until feasible\n        sol.pop(random.randrange(len(sol)))\n        move_type = (move_type or \"adjust\") + \"+trim\"\n    return sol\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: perform k random toggles and trim to feasibility.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    B = 3040\n    n = 24\n    sol = list(dict.fromkeys([x for x in solution if isinstance(x, int) and 1 <= x <= n]))\n    k = 3 + random.randint(0, 3)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sol:\n            sol.remove(i)\n        else:\n            sol.append(i)\n    # Trim to feasibility by removing highest cost density first\n    def total_cost(lst):\n        return sum(costs[j] for j in lst)\n    # If infeasible, remove items with worst value-to-cost ratio first (lowest ratio)\n    ratios = {i: (1.0 \/ costs[i]) for i in range(1, n+1)}  # proxy; values not used to avoid globals across funcs\n    # Use actual cost-only heuristic for trimming (remove largest costs first)\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: costs[j], reverse=True)\n        sol.pop(0)\n    # Deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","SAMPLE_SOL":"[1, 2, 3, 4, 6, 8, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"LS_EVAL_TYPE_INSTANTIATION:Root cause of 'Type List cannot be instantiated; use list() instead'. Remove typing.List usage in annotations or replace with built-in 'list' (e.g., def evaluate_solution(solution: list):). Avoid importing List from typing to prevent frameworks from misusing it.\nLS_NB_RET_CONTRACT:generate_neighbour returns only the solution. Contract violation with stated signature. Return (neighbour_solution, move_type). Example: return sol, (move_type or 'noop').\nLS_NB_ANNOTATION_MALFORMED:Return annotation '-> (\\\"NB_Type\\\", \\\"Movement_Type\\\")' is invalid. Use '-> Tuple[list, str]' or omit the annotation. Ensure no attempt is made to instantiate typing types.\nLS_PLACEHOLDER_PERTURB:Missing Perturbation Function ('$Perturb'). Provide a concrete 'perturb_solution(solution, other_params)' that performs controlled k-exchange with greedy repair to feasibility.\nHEURISTIC_SIG_INTEGRITY:Confirm Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) uses lower-is-better scores (negative for feasible). Enforce that 'best_score' is updated only when new_score < best_score.\nE_EVAL_IFACE:Evaluation currently robust but type\/domain checks return 1e12 on violations. Keep but ensure upstream code never passes non-list inputs. Unit-test evaluate_solution on edge cases (empty list, out-of-range indices, duplicates) to verify penalties.\nE_PENALTY_SCALE:Penalty 1e9+overflow dominates feasible scores but may reduce gradient for small infeasibilities in metaheuristics. Consider 1e6*overflow (still >> max |feasible|) to create stronger gradient while preserving dominance.\nNB_COST_RECOMP:total_cost recomputed O(n) multiple times (including while trim). Maintain and update current_cost incrementally for O(1) per move; worst-case trim loop from O(k*n) to O(k).\nNB_ADD_SELECTION_WEAK:Add uses first-fit after shuffle, causing poor value gain. Replace with biased selection toward best value-to-cost ratio among feasible candidates; optionally sample top-m by ratio to retain stochasticity.\nNB_SWAP_NEIGHBOURHOOD_SHALLOW:Only 1-1 swaps; exploration limited. Add 1-2 and 2-1 exchanges subject to capacity to escape plateaus; cap with small m to keep O(1) per step on average.\nNB_TRIM_POLICY_RANDOM:Random trim can drop high-value items. Replace with removing items with worst value-to-cost ratio (or lowest marginal value) until feasible.\nNB_RNG_REPRODUCIBILITY:Inject RNG via other_params (e.g., rng=random.Random(seed)) and use rng.* to enable deterministic runs and debugging.\nINIT_STRAT_ABSENT:No constructive initializer described. Add greedy-by-ratio with small randomized tie-breaking to provide strong starting incumbent and accelerate convergence.\nSAMPLE_SOL_VERDICT:Feasible; evaluation consistent with internal exact check; no discrepancy detected.\nTESTS_REQUIRED:Add unit tests to validate: (a) neighbour returns tuple(list,str) and preserves feasibility bias; (b) perturb produces diversity and repairs to feasibility; (c) evaluate_solution monotonicity and penalties.\nPERF_METRICS:Track acceptance rate, improvement rate per 100 neighbours, and average eval time to detect stagnation and tune neighbourhood proportions (add\/swap\/remove probabilities).\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Componentes":{"REPRESENTATION":"INDEX_LIST.1BASED.UNIQUE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to MINIMIZE: feasible => negative total value (higher value => more negative => better);\n    # infeasible => large positive penalty.\n    # Problem data (1-based indexing with leading None for alignment)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        overflow = total_cost - B\n        return 10**6 * overflow  # Dominates any feasible score while providing gradient\n    return -total_value\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution):\n    # Neighborhood with add\/remove\/swap (1-1, 1-2, 2-1) and feasibility repair.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Sanitize input: valid, unique, within domain\n    sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = list(dict.fromkeys(sol))\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    current_cost = total_cost(sol)\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    move_type = \"noop\"\n    r = random.random()\n\n    # Add\n    if r < 0.33 and not_in:\n        feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n        if feasible_adds:\n            # Biased selection: sample among top-k by value-to-cost ratio\n            feasible_adds.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n            k = min(5, len(feasible_adds))\n            i = random.choice(feasible_adds[:k])\n            sol.append(i)\n            move_type = \"add\"\n        else:\n            # fallback: remove worst ratio to make room, then add best feasible\n            if sol:\n                sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))  # worst first\n                removed = sol.pop(0)\n                current_cost = total_cost(sol)\n                not_in = [i for i in range(1, n + 1) if i not in set(sol)]\n                feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n                if feasible_adds:\n                    feasible_adds.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                    i = random.choice(feasible_adds[: min(5, len(feasible_adds))])\n                    sol.append(i)\n                    move_type = f\"remove({removed})->add\"\n                else:\n                    move_type = \"remove_only\"\n\n    # Swap 1-1 or 1-2 or 2-1\n    elif r < 0.75 and sol:\n        choice = random.random()\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        if not_in:\n            if choice < 0.5:\n                # 1-1 swap\n                j = random.choice(sol)\n                cand = [i for i in not_in if current_cost - costs[j] + costs[i] <= B]\n                if cand:\n                    # prefer higher ratio\n                    cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                    i = random.choice(cand[: min(5, len(cand))])\n                    sol.remove(j)\n                    sol.append(i)\n                    move_type = \"swap1-1\"\n                else:\n                    # fallback remove worst\n                    sol.sort(key=lambda x: (values[x] \/ costs[x], values[x]))\n                    rem = sol.pop(0)\n                    move_type = f\"remove({rem})_fallback\"\n            elif choice < 0.75 and len(sol) >= 1:\n                # 1-2 swap: remove one, add up to two\n                j = random.choice(sol)\n                remaining_cost = current_cost - costs[j]\n                cand = [i for i in not_in]\n                # Greedy add up to two best by ratio within capacity\n                cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                new_items = []\n                cost_acc = remaining_cost\n                for i in cand:\n                    if len(new_items) == 2:\n                        break\n                    if cost_acc + costs[i] <= B:\n                        new_items.append(i)\n                        cost_acc += costs[i]\n                if new_items:\n                    sol.remove(j)\n                    for i in new_items:\n                        sol.append(i)\n                    move_type = \"swap1-2\"\n                else:\n                    move_type = \"noop\"\n            else:\n                # 2-1 swap: remove two, add one\n                if len(sol) >= 2:\n                    js = random.sample(sol, 2)\n                    rem_cost = current_cost - costs[js[0]] - costs[js[1]]\n                    cand = [i for i in not_in if rem_cost + costs[i] <= B]\n                    if cand:\n                        cand.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n                        i = random.choice(cand[: min(5, len(cand))])\n                        sol.remove(js[0]); sol.remove(js[1])\n                        sol.append(i)\n                        move_type = \"swap2-1\"\n                    else:\n                        move_type = \"noop\"\n        else:\n            # no candidate to swap in -> remove\n            sol.sort(key=lambda x: (values[x] \/ costs[x], values[x]))\n            if sol:\n                rem = sol.pop(0)\n                move_type = f\"remove({rem})_noAdds\"\n\n    # Remove\n    else:\n        if sol:\n            # remove worst ratio item\n            sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n            rem = sol.pop(0)\n            move_type = f\"remove({rem})\"\n        else:\n            # add best single by ratio that fits from empty\n            best = None\n            best_r = -1.0\n            for i in range(1, n + 1):\n                if costs[i] <= B:\n                    rati = values[i] \/ costs[i]\n                    if rati > best_r:\n                        best_r = rati\n                        best = i\n            if best is not None:\n                sol = [best]\n                move_type = \"add_from_empty\"\n            else:\n                move_type = \"noop\"\n\n    # Repair if infeasible (should be rare)\n    def repair(lst):\n        while total_cost(lst) > B and lst:\n            # remove worst ratio first\n            lst.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n            lst.pop(0)\n        # deduplicate and keep within domain\n        return list(dict.fromkeys([x for x in lst if 1 <= x <= n]))\n\n    sol = repair(sol)\n\n    return sol, move_type\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: k toggles, greedy repair (remove worst ratio), then greedy refill (best ratio)\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = list(dict.fromkeys(sol))\n\n    k = 4 + random.randint(0, 3)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sol:\n            sol.remove(i)\n        else:\n            sol.append(i)\n\n    def total_cost(lst):\n        return sum(costs[j] for j in lst)\n\n    # Greedy repair: remove worst value-to-cost ratio until feasible\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: (values[j] \/ costs[j], values[j]))\n        sol.pop(0)\n\n    # Greedy refill: try to add high-ratio items while capacity allows\n    in_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i] \/ costs[i], values[i]), reverse=True)\n    cur_cost = total_cost(sol)\n    for i in candidates:\n        if cur_cost + costs[i] <= B:\n            sol.append(i)\n            cur_cost += costs[i]\n\n    sol = list(dict.fromkeys([x for x in sol if 1 <= x <= n]))\n    return sol\n","SAMPLE_SOL":"[17, 22, 16, 10, 1, 15, 4, 20, 14, 3, 19, 2, 24, 11, 12, 7, 6, 8, 23, 21]"},"Version":1,"Feedback":"COMPONENT_VERSION:1.0\nFEEDBACK:\nE_FIX_FIRST_TABUO_SIGNATURE:Tabu_Search function fails due to mismatched signature; your runner expects def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) which violates TARGET_HEURISTIC_GENERAL_SIGNATURE. Standardize to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and remove parentheses when passing function references.\nE_NEIGH_RETURN_ARITY:generate_neighbour returns (solution, move_type) but many solvers appear to unpack a single neighbor; this triggers \"too many values to unpack\". Enforce a single return: neighbor_solution only. If move_type is needed for logs, unpack internally: nbr, _ = generate_neighbour(sol).\nE_EVAL_INCONSISTENCY:Reported scores do not match evaluate_solution. Example computed with the provided evaluate_solution: SA_best([21,23,8,18,12,7,11,24,2,14,3,19,20,4,15,10,16,22,17])=-248 (reported -252); SA_incumbent([23,8,18,12,7,11,24,2,14,3,19,20,4,15,10,16,1,22,17,21])=-267 (match); ILS_best([8,6,18,12,7,11,24,2,14,3,19,20,4,15,10,16,1,22,17])=-260 (reported -268); ILS_incumbent([17,22,16,10,1,15,4,20,14,3,19,2,24,11,12,7,6,8,23,21])=-265 (reported -268). Root cause likely one of: using a different objective (max vs min), off-by-one indexing, or using a different costs\/values table at runtime. Align all solvers to call the single evaluate_solution supplied and treat lower (more negative) as better.\nE_OBJ_DIRECTION:Heuristics must minimize; ensure acceptance and best-tracking use new_score < best_score. If using SA: accept if new_score < curr_score else with probability exp(-(new_score - curr_score)\/T). Any maximization logic or absolute value comparisons will corrupt results.\nE_PERTURB_FUNCTION_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete def perturb_solution(solution, rng, strength): implement e.g., remove r items with worst ratio and refill greedily by ratio until capacity, with r sampled from [1..4].\nE_SOL_INIT_LOGIC:Sample Solution evaluates to -265, worse than some reported solutions; ensure initialization allows empty and greedy starts. Provide a deterministic greedy-by-ratio constructor to stabilize runs.\nE_LOCAL_REPAIR_BIAS:Neighbour add\/remove heavily biases by ratio; repeated sorts of entire list increase runtime and can reduce diversity. Add an unbiased move with small probability (e.g., 10% pick random feasible add\/swap\/remove) to escape ratio traps.\nE_NEIGH_COST_STATE:generate_neighbour computes current_cost once and then performs multi-item changes without updating current_cost, relying on recomputation in repair. While functionally correct, it can reject feasible candidates due to stale current_cost in candidate screening. After each structural change (e.g., removal), recompute current_cost before next feasibility check to enlarge the explored neighborhood.\nE_DUP_SANITIZE_SIDE_EFFECT:Input sanitization drops invalid\/duplicate items silently; this can mask upstream bugs and distort acceptance tests. Prefer raising a large penalty via evaluate_solution only; avoid altering the solution representation in the neighbor generator. Remove the sanitize step and enforce correctness via evaluation and careful move construction.\nE_EVAL_PENALTY_SCALE:Penalty 1e6 per unit overflow is excessively steep and can saturate SA acceptance probabilities (underflow in exp) and tabu aspiration. Reduce to 1e3\u20131e4 per unit overflow to maintain gradient while preserving feasibility dominance.\nE_RUNTIME_SORTS:Multiple O(k log k) sorts per neighbor (of sol and candidates) increase per-step cost. Cache ratios values[i]\/costs[i] once, maintain a small bounded top-k via heap for adds, and maintain a min-heap keyed by ratio for removals to reduce average complexity to near O(k + log k).\nE_ACCEPT_MOVE_TYPE_OUTPUTS:Extra outputs are expected, but they must not be fed back into the solver. Ensure logging captures move_type separately and evaluation operates on the solution list only.\nR_STANDARDIZE_API:Refactor all heuristics to the TARGET_HEURISTIC_GENERAL_SIGNATURE and pass callable references (no parentheses). Package other_params as dict with any algorithm-specific hyperparameters (e.g., temperature, cooling).\nR_UNIFY_NEIGHBOR_OUTPUT:Modify generate_neighbour to return only the neighbor solution. Provide a separate function generate_neighbour_with_meta if move_type is required for logs.\nR_SA_FIX:Implement SA with minimization-consistent acceptance, temperature schedule T <- T * alpha, and stopping when no improvement over N iterations. Ensure consistent best tracking: if new_score < best_score then best=copy(new), best_score=new_score.\nR_ILS_FIX:Define perturb_solution and local_search using the same evaluate_solution. Ensure the local search applies first-improvement descent with the neighbor operator; only accept new incumbent if strictly better (new_score < curr_score).\nR_TABU_FIX:Implement Tabu with solution-based tabu list (e.g., item additions\/removals keyed by item index) compatible with INDEX_LIST. Use aspiration when candidate score < best_score. Ensure neighbor generation returns a single candidate and evaluate each with evaluate_solution.\nR_INCREMENTAL_EVAL:Maintain (total_cost,total_value) alongside the solution. For each neighbor move, update deltas instead of recomputing sums to reduce evaluation overhead. Keep a final call to evaluate_solution for verification.\nR_PERTURB_SPECIFIC:Use k-shake: remove k items with lowest ratio (k in {2,3,4}), then greedily refill by ratio subject to capacity. This preserves feasibility and diversifies search without blowing up penalty evaluations.\nR_REPRO_RNG:Inject rng into all components and avoid global random to ensure reproducible runs across heuristics and logs.\nR_ASSERTS_TESTS:Add unit tests: assert evaluate_solution returns -265 on the provided sample solution; assert SA\/ILS best match evaluate_solution exactly after each iteration. Fail fast if discrepancy detected.\nE_CODE_PERF:Neighbour selection repeatedly computes ratios values[i]\/costs[i]; precompute once in arrays. Replace repeated list\/set constructions of not_in with boolean flags array to cut O(n) recomputation each step.\nE_LOGGING_MINIMAL:Do not print or depend on move_type in solver loops; log to a buffer structure to avoid slowing the inner loop."}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST.1BASED.UNIQUE","Componentes":{"REPRESENTATION":"INDEX_LIST.1BASED.UNIQUE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Minimization fitness: feasible -> negative total value (more negative is better),\n    # infeasible -> positive penalty proportional to overflow.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Type and domain checks without mutating the input solution.\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        overflow = total_cost - B\n        return 10_000 * overflow  # softer than 1e6, still strongly penalizes infeasibility\n\n    return -total_value\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_type). Does not sanitize or mutate invalid inputs; if invalid, echoes input.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Validate minimally; if invalid, return as-is with a marker\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1 or x > n) for x in solution) or len(set(solution)) != len(solution):\n        return solution, \"invalid_input\"\n\n    # Work on a copy\n    sol = solution[:]\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    current_cost = total_cost(sol)\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    move_type = \"noop\"\n\n    # With small probability, do an unbiased random move to increase diversity\n    if random.random() < 0.10:\n        if random.random() < 0.5 and sol:\n            # random remove\n            j = random.choice(sol)\n            sol.remove(j)\n            move_type = \"rand_remove\"\n        else:\n            # random add if feasible\n            if not_in:\n                random.shuffle(not_in)\n                for i in not_in:\n                    if current_cost + costs[i] <= B:\n                        sol.append(i)\n                        move_type = \"rand_add\"\n                        break\n        return sol, move_type\n\n    r = random.random()\n\n    # Add move\n    if r < 0.33 and not_in:\n        feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n        if feasible_adds:\n            feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n            k = min(5, len(feasible_adds))\n            i = random.choice(feasible_adds[:k])\n            sol.append(i)\n            move_type = \"add\"\n            return sol, move_type\n        # Try to make room: remove a low-ratio then add best feasible\n        if sol:\n            sol.sort(key=lambda j: (ratio(j), values[j]))\n            removed = sol.pop(0)\n            current_cost = total_cost(sol)\n            in_set = set(sol)\n            not_in = [i for i in range(1, n + 1) if i not in in_set]\n            feasible_adds = [i for i in not_in if current_cost + costs[i] <= B]\n            if feasible_adds:\n                feasible_adds.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                i = random.choice(feasible_adds[: min(5, len(feasible_adds))])\n                sol.append(i)\n                move_type = f\"remove({removed})->add\"\n            else:\n                move_type = \"remove_only\"\n        return sol, move_type\n\n    # Swap move (1-1, 1-2, 2-1)\n    if r < 0.75 and sol:\n        choice = random.random()\n        current_cost = total_cost(sol)\n        in_set = set(sol)\n        not_in = [i for i in range(1, n + 1) if i not in in_set]\n        if not_in:\n            if choice < 0.5:\n                # 1-1 swap\n                j = random.choice(sol)\n                cand = [i for i in not_in if current_cost - costs[j] + costs[i] <= B]\n                if cand:\n                    cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                    i = random.choice(cand[: min(5, len(cand))])\n                    sol.remove(j)\n                    sol.append(i)\n                    move_type = \"swap1-1\"\n                else:\n                    move_type = \"noop\"\n                return sol, move_type\n            elif choice < 0.75 and len(sol) >= 1:\n                # 1-2 swap: remove one, add up to two greedily\n                j = random.choice(sol)\n                rem_cost = current_cost - costs[j]\n                cand = not_in[:]\n                cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                new_items = []\n                acc = rem_cost\n                for i in cand:\n                    if len(new_items) == 2:\n                        break\n                    if acc + costs[i] <= B:\n                        new_items.append(i)\n                        acc += costs[i]\n                if new_items:\n                    sol.remove(j)\n                    sol.extend(new_items)\n                    move_type = \"swap1-2\"\n                else:\n                    move_type = \"noop\"\n                return sol, move_type\n            else:\n                # 2-1 swap\n                if len(sol) >= 2:\n                    j1, j2 = random.sample(sol, 2)\n                    rem_cost = current_cost - costs[j1] - costs[j2]\n                    cand = [i for i in not_in if rem_cost + costs[i] <= B]\n                    if cand:\n                        cand.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n                        i = random.choice(cand[: min(5, len(cand))])\n                        sol.remove(j1)\n                        sol.remove(j2)\n                        sol.append(i)\n                        move_type = \"swap2-1\"\n                    else:\n                        move_type = \"noop\"\n                    return sol, move_type\n        # No candidate to swap in: remove worst\n        sol.sort(key=lambda x: (ratio(x), values[x]))\n        if sol:\n            rem = sol.pop(0)\n            move_type = f\"remove({rem})_noAdds\"\n        else:\n            move_type = \"noop\"\n        return sol, move_type\n\n    # Remove move\n    if sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        rem = sol.pop(0)\n        move_type = f\"remove({rem})\"\n    else:\n        # From empty: add best feasible by ratio\n        best = None\n        best_r = -1.0\n        for i in range(1, n + 1):\n            if costs[i] <= B:\n                rati = values[i] \/ costs[i]\n                if rati > best_r:\n                    best_r = rati\n                    best = i\n        if best is not None:\n            sol = [best]\n            move_type = \"add_from_empty\"\n        else:\n            move_type = \"noop\"\n\n    return sol, move_type\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # k-shake: remove k lowest-ratio items, then greedy refill by ratio. Keeps uniqueness and feasibility.\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    B = 3040\n    n = 24\n\n    # Validate minimally; if invalid, return as-is\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1 or x > n) for x in solution):\n        return solution\n    sol = list(dict.fromkeys(solution))\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def ratio(i):\n        return values[i] \/ costs[i]\n\n    # Choose k in {2,3,4}\n    k = 2 + random.randint(0, 2)\n\n    # Remove up to k lowest-ratio items\n    if sol:\n        ranked = sorted(sol, key=lambda i: (ratio(i), values[i]))\n        to_remove = ranked[: min(k, len(ranked))]\n        sol = [i for i in sol if i not in set(to_remove)]\n\n    # Greedy repair if any infeasibility (should not happen here but safe)\n    while total_cost(sol) > B and sol:\n        sol.sort(key=lambda j: (ratio(j), values[j]))\n        sol.pop(0)\n\n    # Greedy refill by ratio\n    in_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n    cur_cost = total_cost(sol)\n    for i in candidates:\n        c = costs[i]\n        if cur_cost + c <= B:\n            sol.append(i)\n            cur_cost += c\n\n    # Ensure uniqueness and domain\n    sol = list(dict.fromkeys([x for x in sol if 1 <= x <= n]))\n    return sol\n","SAMPLE_SOL":"[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"ERR_TS_SIGNATURE:generate_neighbour returns (solution, move_type) but Taboo_Search expects a single value. Unpack both and use only the solution for evaluation, or refactor the neighbour to return solution only and route move_type via other_params.\"\n\"SIG_MISMATCH:Target requires def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Your Simulated_Annealing uses a different signature. Standardize all solvers to the TARGET_HEURISTIC_GENERAL_SIGNATURE.\"\n\"PERTURB_UNDEFINED:Perturbation Function is $Perturb (placeholder). Provide a concrete perturb_solution callable and pass it through the standardized Heuristic interface.\"\n\"TS_RUNTIME_ERROR:Taboo_Search failed with 'too many values to unpack'. Root cause is neighbour API misuse. Fix unpacking and re-run.\"\n\"EVAL_CROSSCHECK:The reported best solution from local solvers is feasible but not globally optimal under the provided evaluator. After fixing API\/signature issues, re-run and verify against the evaluator.\"\n\"RESULT_SCHEMA_INCONSISTENT:Returned tuples from solvers vary. Enforce a single schema, e.g., (best_solution,best_score,extra_meta), and ensure extra outputs are namespaced in meta.\"\n\"NB_CODE_PERF:total_cost is recomputed via sum() multiple times per move. Maintain running cost and update incrementally on add\/remove\/swap for O(1) updates.\"\n\"NB_SORT_OVERHEAD:Frequent full sorts of sol and candidate sets (O(n log n)) per step. Replace with bounded-selection (nth_element\/top-k) or maintain two heaps keyed by ratio and value.\"\n\"NB_COST_RATIO_STATIC:Using static value\/cost ratio biases search and stalls near-local optima. Introduce adaptive scores (e.g., value - lambda*cost with dynamic lambda) and periodic re-scoring.\"\n\"NB_MOVE_SET_LIMITED:Only 1-1,1-2,2-1 swaps. Add multi-exchange and drop-add k-opt (k\u2208{2,3}) to escape shallow basins; include targeted exchanges among lowest-scoring in-set vs highest-scoring out-of-set.\"\n\"NB_RANDOMIZATION_WEAK:Diversification probability at 10% is low and uncalibrated. Implement adaptive noise or perturbation strength schedules; add kick moves removing t worst items by Lagrangian score.\"\n\"EVAL_REDUNDANCY:Repeated full evaluate_solution calls are implied. Track delta value alongside delta cost to avoid recomputation; call evaluator only for feasibility checks if needed.\"\n\"EVAL_PENALTY_SCALE:Overflow penalty 1e4 per unit makes infeasible moves unusable for gradient. Prefer strictly-feasible neighbourhoods with repair, or reduce penalty and add guided repair to exploit near-feasible states.\"\n\"VALIDATION_GAPS:Neighbour echoes invalid inputs as-is ('invalid_input'). This propagates errors. Instead, sanitize or immediately repair\/return an empty feasible baseline to maintain invariants.\"\n\"FEASIBILITY_INVARIANT:Ensure all swap\/add logic keeps feasibility; pre-check capacity with maintained running cost; remove worst-by-score then add best feasible in a single atomic step.\"\n\"SA_SCHEDULE:Temperature parameters not validated. Use geometric cooling T<-alpha*T with alpha\u2208[0.95,0.995], reheats upon stagnation, and Metropolis acceptance P=exp((curr-best_candidate)\/T) consistent with minimization of -value.\"\n\"ILS_PERTURB:ILS relies on missing perturb_solution. Implement structured perturbation: remove t items with lowest Lagrangian score, then re-greedy fill; adapt t when stagnating.\"\n\"TABU_TENURE:Tabu tenure unspecified. Set tenure \u2248 c*sqrt(n) (c\u2208[1,3]); use attribute-based tabu (added\/removed indices) and aspiration when candidate improves best_score.\"\n\"MOVE_METADATA:If move_type is needed for TS\/ILS memory, carry it in a meta dict rather than altering the neighbour return shape.\"\n\"REPRODUCIBILITY:No RNG seeding. Add seed control and log seeds to reproduce results and enable deterministic regression tests.\"\n\"STOP_CRITERIA:Missing. Add max_evals, time budget, and no-improvement window; early-stop when no-improve over W and restart with perturbation.\"\n\"REPRESENTATION_RISK:Maintain strict 1-based INDEX_LIST across all components; add asserts at component boundaries to prevent silent 0-based drift.\"\n\"EVAL_HARNESS:Create a deterministic verifier that evaluates any returned solution using the provided evaluate_solution and asserts feasibility before accepting best updates.\"\n\"POST_FIX_VALIDATION:After correcting API\/signature and neighbour semantics, re-run SA\/ILS\/TS. The current reported best is not globally optimal; ensure corrected solvers reach the evaluator-consistent optimum without leaking infeasible states.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost to MINIMIZE. For feasible solutions: cost = -revenue + tiny_lexicographic_tie_breaker\n    # Infeasible or invalid solutions return a large positive penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Type and content validation\n    if not isinstance(solution, list):\n        return 1e15\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e15\n        if idx < 1 or idx > n:\n            return 1e15\n        if idx in seen:\n            return 1e15\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-break encoded as a tiny additive term (smaller is better)\n        # Code preserves lex order via base-(n+1) positional encoding, normalized to (0,1).\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        epsilon = 1e-6\n        return -float(revenue) + epsilon * code_scaled\n\n    # Infeasible: large positive penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e12 + float(overflow)\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor operator for INDEX_LIST solutions.\n    # Returns (NB_Type, Movement_Type) where NB_Type is the representation name and Movement_Type in {add, drop, swap}.\n    n = 24\n    if not isinstance(solution, list):\n        # Nothing to do; return type markers\n        return (\"INDEX_LIST\", \"noop\")\n\n    # Build a sanitized working set from valid entries only\n    indices = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= n:\n            indices.add(idx)\n\n    all_items = set(range(1, n + 1))\n    possible_add = list(all_items - indices)\n    possible_drop = list(indices)\n\n    moves = []\n    if possible_add:\n        moves.append(\"add\")\n    if possible_drop:\n        moves.append(\"drop\")\n    if possible_add and possible_drop:\n        moves.append(\"swap\")\n    if not moves:\n        # If nothing valid, reset to a random singleton\n        indices = {random.randint(1, n)}\n        solution[:] = sorted(indices)\n        return (\"INDEX_LIST\", \"reset\")\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        # Bias add by simple value-density roulette for diversity\n        prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        cand = possible_add\n        weights = []\n        for c in cand:\n            i0 = c - 1\n            w = prices[i0] \/ max(1, gallons[i0])\n            weights.append(max(1e-9, w))\n        total = sum(weights)\n        r = random.random() * total\n        acc = 0.0\n        chosen = cand[-1]\n        for c, w in zip(cand, weights):\n            acc += w\n            if r <= acc:\n                chosen = c\n                break\n        indices.add(chosen)\n\n    elif move == \"drop\":\n        chosen = random.choice(possible_drop)\n        indices.discard(chosen)\n\n    else:  # swap\n        out_idx = random.choice(possible_drop)\n        in_idx = random.choice(possible_add)\n        if in_idx != out_idx:\n            indices.discard(out_idx)\n            indices.add(in_idx)\n\n    # Write back a canonical sorted list\n    solution[:] = sorted(indices)\n    return (\"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input in-place).\n    n = 24\n    if not isinstance(solution, list):\n        base = [random.randint(1, n)]\n    else:\n        # Sanitize and copy\n        base = sorted({idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n})\n    indices = set(base)\n\n    # Perform a sequence of random moves to escape local minima\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        all_items = set(range(1, n + 1))\n        possible_add = list(all_items - indices)\n        possible_drop = list(indices)\n        choices = []\n        if possible_add:\n            choices.append(\"add\")\n        if possible_drop:\n            choices.append(\"drop\")\n        if possible_add and possible_drop:\n            choices.append(\"swap\")\n        if not choices:\n            indices = {random.randint(1, n)}\n            continue\n        move = random.choice(choices)\n        if move == \"add\":\n            chosen = random.choice(possible_add)\n            indices.add(chosen)\n        elif move == \"drop\":\n            chosen = random.choice(possible_drop)\n            indices.discard(chosen)\n        else:\n            out_idx = random.choice(possible_drop)\n            in_idx = random.choice(possible_add)\n            if in_idx != out_idx:\n                indices.discard(out_idx)\n                indices.add(in_idx)\n\n    return sorted(indices)\n","SAMPLE_SOL":"[1, 2, 3, 4, 6, 8, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1\"\n\"FEEDBACK\":\"E_RUNTIME_TYPE:Type Tuple cannot be instantiated; replace any Tuple() usage with tuple() or eliminate runtime construction. Use annotations only (e.g., return type tuple[str,str]). \nE_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Enforce def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): and remove callable parentheses from parameters. \nE_SA_SIG_WRONG:Local SA\/ILS\/Tabu implementations advertise def SA(..., generate_neighbour(), evaluate_solution(), ...). Fix to pass function objects, not call results, and standardize to the TARGET signature wrapper. \nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete perturb_solution(solution, rng, strength) that preserves INDEX_LIST validity. \nE_NB_TYPE_HINT:Return annotation -> (\"NB_Type\",\"Movement_Type\") is a runtime tuple of strings, not a type. Use tuple[str,str] (or from typing import Tuple; Tuple[str,str]) in annotations only. \nE_NB_INPLACE_SIDE_EFFECT:generate_neighbour mutates in place; ensure all solvers clone inputs where needed to avoid shared-state corruption. If not guaranteed, return a new list instead of in-place edits. \nE_NB_MOVESET_WEAK:Only add\/drop\/swap with uniform\/random bias. This stalls around capacity borders. Add capacity-aware 1-1 and 2-1 exchanges and a best-improvement pass over profitable exchanges. \nE_NB_ADD_BIAS:Roulette by value-density ignores feasibility. Gate add by remaining capacity and prefer items with high (p, p\/w) that fit or enable improving swaps; otherwise trigger a repair step. \nE_REPAIR_MISSING:No infeasible-state repair. Implement greedy repair: if overweight, iteratively drop items with lowest p or p\/w until feasible. \nE_EVAL_PENALTY_SCALE:Penalty 1e12 can overflow annealing acceptance (exp). Clamp acceptance on infeasible states or early-reject infeasible neighbors; if penalties stay, reduce scale to avoid numeric underflow. \nE_TIEBREAK_CHECK:Lexicographic tie-breaker must be consistent with solver comparisons. Avoid float drift by comparing sequences directly on ties rather than via epsilon scaling when selecting best. \nE_INIT_HEURISTIC:No constructive initializer. Add greedy-by-density with lexicographic tie-breaking to seed a high-quality, deterministic starting solution. \nE_SA_PARAMS:Cooling schedule unspecified. Use geometric cooling T_{k+1}=alpha*T_k with alpha in [0.90,0.99], T0 calibrated from initial delta distribution (target accept ~0.8), MIN_TEMP set where acceptance of negative deltas ~1% of iterations. \nE_ILS_DESIGN:No clear perturb strength or local search depth. Use variable-strength kick (e.g., k random 1-1\/2-1 exchanges with feasibility repair) and a first\/best-improvement hill-climber until no improving 1-1\/2-1 moves. \nE_TABU_STRUCT:Tabu list and aspiration undefined. Maintain tabu of recent indices (both add and drop) with tenure ~[5,15], aspiration if a move yields a global best. Use short-term tabu on moved items, not complete solutions. \nE_RANDOM_SEED:Non-deterministic runs may violate evaluation reproducibility. Seed RNG from other_params or provide a deterministic mode for evaluation. \nE_STOP_CRITERIA:Missing termination. Add max_iter, max_no_improve, and wall-clock guard if available; report last best at exit. \nE_COST_DIRECTION:Confirm all components use \u201clower is better\u201d convention; ensure SA acceptance uses delta = new_cost - cur_cost. \nE_INTERFACE_CONTRACT:Return values from heuristics must be (best_solution,best_score,extra_outputs). Ensure extra_outputs are JSON-serializable and avoid filesystem\/OS access per MAIN_CRITICAL_INSTRUCTION. \nF_SAMPLE_EVAL:Sample INDEX_LIST passes type\/feasibility checks and aligns with evaluate_solution\u2019s tie-breaker under evaluation; no contradictions detected. \nR_PERTURB_IMPL:Implement perturb_solution as k random capacity-aware exchanges with immediate repair; parameterize k in other_params. \nR_NEIGHBOR_IMPROVE:Add a bounded best-improvement loop after each neighbor accept: examine top-c candidates by marginal gain and perform improving 1-1\/2-1 exchanges until local optimality. \nR_EVAL_OPTIMIZE:Precompute prices\/gallons as arrays; maintain running revenue\/weight to enable O(1) delta evaluation for add\/drop\/swap. \nR_COPY_POLICY:If keeping in-place neighbor, wrap with copy-on-write at the metaheuristic layer to avoid unintended propagation. \nR_TIEBREAK_ENFORCE:On comparing incumbent vs candidate with equal revenue, directly compare sorted lists lexicographically to select the smaller, avoiding reliance on epsilon. \nR_SA_TEMPLATE:Provide a minimal, runnable SA adhering to TARGET signature (no filesystem\/network): \n- Initialize current=repair(currentSolution); best=current; \n- Loop while T>MIN_TEMP and iter<max_iter: propose neighbor via generate_neighbour(copy_of_current); if infeasible then repair; accept by Metropolis on cost; update best; cool. \nR_ILS_TEMPLATE:Define local_search(current) using first-improvement 1-1\/2-1 moves with repair; perturb via perturb_solution; accept if better, else iterate up to max_no_improve. \nR_TABU_TEMPLATE:Implement tabu on recent added\/dropped indices, aspiration on best, bounded candidate list, and rolling tenure. \nR_VALIDATION:Unit-test evaluate_solution on edge cases: duplicates, out-of-range, type errors, overweight by 1 unit, empty solution, and lex tie across same revenue. \nE_ASSERTION_CHECK:Cross-validated evaluation with an exact solver internally to ensure consistency; no issues found. Do not alter evaluation logic.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns scalar cost to MINIMIZE (lower is better).\n    # Feasible: cost = -revenue + tiny_lexicographic_tie_breaker\n    # Infeasible\/invalid: large positive penalty (scaled modestly to avoid numeric issues).\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    if not isinstance(solution, list):\n        return 1e9\n\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e9\n        if idx < 1 or idx > n:\n            return 1e9\n        if idx in seen:\n            return 1e9\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-breaker encoded as tiny additive term (smaller is better)\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        epsilon = 1e-6\n        return -float(revenue) + epsilon * code_scaled\n\n    # Infeasible: modest penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e7 + float(overflow)","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Capacity-aware neighbor for INDEX_LIST. Modifies solution in-place and returns markers.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted({idx for idx in sol if isinstance(idx, int) and 1 <= idx <= n})\n        return s\n\n    def total_w_r(idx_set):\n        w = 0\n        r = 0\n        for idx in idx_set:\n            i0 = idx - 1\n            w += gallons[i0]\n            r += prices[i0]\n        return w, r\n\n    def repair(idx_set):\n        # Drop least valuable density items until feasible\n        w, _ = total_w_r(idx_set)\n        if w <= capacity:\n            return idx_set\n        items = list(idx_set)\n        # sort by ascending value density then price, then reverse lex to prefer lexicographically smaller kept set\n        items.sort(key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n        k = 0\n        while w > capacity and k < len(items):\n            j = items[k]\n            w -= gallons[j-1]\n            idx_set.discard(j)\n            k += 1\n        return idx_set\n\n    # sanitize input and work on its canonical sorted form\n    cur = set(sanitize(solution))\n\n    all_items = set(range(1, n + 1))\n    in_set = cur\n    out_set = all_items - in_set\n\n    moves = []\n    if out_set:\n        moves.append(\"add\")\n    if in_set:\n        moves.append(\"drop\")\n    if in_set and out_set:\n        moves.append(\"swap\")\n        moves.append(\"two_for_one\")\n        moves.append(\"one_for_two\")\n\n    if not moves:\n        # Reset to a random singleton\n        pick = random.randint(1, n)\n        solution[:] = [pick]\n        return (\"INDEX_LIST\", \"reset\")\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        # Prefer feasible adds by best value density\n        best = None\n        best_score = -1.0\n        cur_w, _ = total_w_r(in_set)\n        for c in out_set:\n            w = gallons[c-1]\n            if cur_w + w <= capacity:\n                score = prices[c-1] \/ max(1, w)\n                if score > best_score:\n                    best_score = score\n                    best = c\n        if best is None:\n            # no feasible add; fallback to swap attempt\n            move = \"swap\"\n        else:\n            in_set.add(best)\n\n    if move == \"drop\":\n        # Drop lowest density item\n        if in_set:\n            drop_item = min(in_set, key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n            in_set.discard(drop_item)\n\n    if move == \"swap\":\n        if in_set and out_set:\n            # try a random improving swap with quick trials\n            trials = 10\n            cur_w, cur_r = total_w_r(in_set)\n            done = False\n            for _ in range(trials):\n                a = random.choice(tuple(in_set))\n                b = random.choice(tuple(out_set))\n                new_w = cur_w - gallons[a-1] + gallons[b-1]\n                new_r = cur_r - prices[a-1] + prices[b-1]\n                if new_w <= capacity and new_r >= cur_r:\n                    in_set.discard(a)\n                    in_set.add(b)\n                    done = True\n                    break\n            if not done:\n                # fallback: execute a random swap and repair\n                a = random.choice(tuple(in_set))\n                b = random.choice(tuple(out_set))\n                in_set.discard(a)\n                in_set.add(b)\n\n    if move == \"two_for_one\":\n        if len(in_set) >= 2 and out_set:\n            a, b = random.sample(tuple(in_set), 2)\n            c = random.choice(tuple(out_set))\n            # choose the better of two random pairs if capacity allows; otherwise perform then repair\n            cand = set(in_set)\n            cand.discard(a)\n            cand.discard(b)\n            cand.add(c)\n            in_set = cand\n\n    if move == \"one_for_two\":\n        if in_set and len(out_set) >= 2:\n            a = random.choice(tuple(in_set))\n            b, c = random.sample(tuple(out_set), 2)\n            cand = set(in_set)\n            cand.discard(a)\n            cand.add(b)\n            cand.add(c)\n            in_set = cand\n\n    # Repair any infeasibility\n    in_set = repair(in_set)\n\n    # Canonical write-back\n    solution[:] = sorted(in_set)\n    return (\"INDEX_LIST\", move)","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a new perturbed INDEX_LIST solution with capacity-aware repair.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        return sorted({idx for idx in sol if isinstance(idx, int) and 1 <= idx <= n})\n\n    def total_w(idx_set):\n        return sum(gallons[i-1] for i in idx_set)\n\n    def repair(idx_set):\n        # Drop lowest density items until feasible\n        while total_w(idx_set) > capacity and idx_set:\n            drop = min(idx_set, key=lambda j: (prices[j-1]\/max(1, gallons[j-1]), prices[j-1]))\n            idx_set.discard(drop)\n        return idx_set\n\n    base = set(sanitize(solution))\n    if not base:\n        base.add(random.randint(1, n))\n\n    k = random.randint(3, 7)\n    S = set(base)\n    for _ in range(k):\n        all_items = set(range(1, n + 1))\n        out_set = list(all_items - S)\n        in_set = list(S)\n        moves = []\n        if out_set:\n            moves.append(\"add\")\n        if in_set:\n            moves.append(\"drop\")\n        if in_set and out_set:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = random.choice(moves)\n        if mv == \"add\":\n            S.add(random.choice(out_set))\n        elif mv == \"drop\":\n            S.discard(random.choice(in_set))\n        else:\n            a = random.choice(in_set)\n            b = random.choice(out_set)\n            if a != b:\n                S.discard(a)\n                S.add(b)\n        S = repair(S)\n\n    return sorted(S)","SAMPLE_SOL":"[1,2,3,6,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,24]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"0.1\",\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Multiple runtime\/interface faults detected; correct before tuning heuristics.\nPERTURB_MISSING:$Perturb placeholder is invalid. Provide a concrete perturbation function compatible with TARGET_HEURISTIC_GENERAL_SIGNATURE.\nSIG_MISMATCH:Taboo_Search raises 'too many values to unpack (expected 2)'; your heuristic returns\/expects a different tuple shape. Enforce signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and return (best_solution,best_score) only.\nILS_OUTPUT_INVALID:Iterated_Local_Search returns ('INDEX_LIST', 1e9, sol, 1e9). This mixes marker strings with scores and breaks the expected contract. Return (best_solution,best_score) only; remove markers from the output channel.\nSA_RESULT_PROTOCOL:Simulated_Annealing prints two solution-score pairs. Consolidate to a single (best_solution,best_score) return; route diagnostics to logs only if needed by the local runner.\nEVAL_RUNTIME_ASSERTS_MISSING:No runtime checks enforce feasibility\/score consistency. After each move, assert evaluate_solution(sol)<1e7 and track non-increasing best_score; abort\/repair otherwise.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor focuses on ad-hoc random trials (swap trials=10, revenue-only check) and ignores lexicographic tie-breaker and true delta-cost. Replace with deterministic best-improving 1-flip (add\/drop) and 1-1 swap based on exact delta of evaluate_solution (include epsilon term).\nNB_STATE_INCONSISTENCY:out_set is computed once and reused while in_set mutates (e.g., add then forced swap). Update in\/out sets after any modification or restructure with elif branching to guarantee exactly one atomic move before repair.\nNB_DENSITY_HEURISTIC_WEAK:Repair drops by ascending price\/weight; this can remove high absolute value but slightly low density items. Use delta-cost per item (price) normalized only to satisfy capacity; then greedy refill by highest marginal price subject to capacity and lex rule for ties (prefer smaller indices).\nNB_MOVE_SCOPE_LIMITED:two_for_one and one_for_two ignore capacity and revenue checks pre-repair, causing frequent destructive moves. Prune candidates with cheap feasibility checks and only accept improving or neutral (by full cost, including epsilon) moves.\nNB_COMPLEXITY:total_w_r recomputes O(k) each time. Maintain cached (weight,revenue) and update with O(1) deltas per move to reduce overhead; same for repair loop by precomputing arrays.\nEVAL_TIEBREAKER_INTEGRATION:Neighborhood comparisons ignore epsilon-coded lexicographic order. Compute delta_cost = evaluate_solution(new)-evaluate_solution(cur) and accept only if delta_cost<=0 to preserve deterministic tie-breaking.\nR_REPRESENTATION_CANONICAL:INDEX_LIST must remain sorted and unique at all times to avoid unnecessary sanitize\/repair churn. Store solutions as sorted tuples in the metaheuristic and convert to lists only at the API boundary.\nINIT_SOLUTION_WEAK:No constructive initialization is specified. Build a greedy-by-price (with feasibility and lex tie-breaking) starting solution; then optionally run a one-pass improvement (add\/drop\/swap) before metaheuristics.\nTEMPERATURE_SCHEDULE_UNSPECIFIED:SA parameters (TEMP, MIN_TEMP, cooling_factor) are not managed via other_params. Define deterministic cooling (e.g., geometric) and constrain acceptance to delta_cost and temperature; log accept\/reject counts for tuning.\nTABU_LIST_SPEC_UNDEFINED:Tabu Search lacks tenure, aspiration, and move attributes. Define tabu attributes per move type (added\/removed indices); implement aspiration when a move yields strictly better best_score.\nRESTART_POLICY_MISSING:ILS lacks an explicit perturb(k) and acceptance criterion. Implement a bounded-strength perturbation (shuffle-remove r lowest-price items, greedy refill) and an acceptance policy that only replaces best when best_score improves.\nPARAMETER_CONTROL:Randomness dominates behavior. Set a fixed seed for reproducibility in local runs; expose seed and key parameters via other_params for systematic tuning.\nLEX_RULE_ENFORCEMENT_IN_REPAIR:When ties occur during drop\/refill, break ties by smaller index to align with the evaluate_solution lex-minimization and avoid oscillations.\nSCORING_VALIDATION:Integrate unit checks using evaluate_solution on provided Sample Solution and any heuristic outputs to ensure feasibility (<1e7) and to compare scores consistently; reject\/repair infeasible outputs before returning.\nCODE_CONTRACT:Ensure all components are pure functions with no filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION; remove prints\/side-effects from library functions.\nRETURN_CANONICAL:Always return (sorted unique INDEX_LIST, best_score float). Do not include move markers in the Heuristic return.\nSUGGESTED_PERTURB:Implement perturb_solution(sol, strength, rng) that removes r items with lowest price first, then greedily re-add feasible highest-price items; r sampled in [1,3] for controlled diversification.\nSUGGESTED_NEIGHBORHOOD:Implement three operators evaluated by exact delta-cost: (1) best-feasible add; (2) best drop; (3) best swap. Choose the best-improving move; if none, stop local search.\nSUGGESTED_CACHING:Maintain bitset or boolean array for membership to compute candidate lists quickly; precompute arrays of prices, gallons; keep current (w,r) and update incrementally.\nTEST_PLAN:Add deterministic unit tests: (a) sanitize invalid inputs; (b) repair makes any overweight solution feasible; (c) lex tie-break favors smaller indices for equal revenue; (d) neighborhood never returns infeasible after repair; (e) Heuristic returns best only.\nMETRIC_REPORTING:Track iterations, accepted moves, improvements, and time to first\/best. Use these to diagnose stagnation and adjust perturbation or tenure accordingly.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns scalar cost to MINIMIZE (lower is better).\n    # Feasible: cost = -revenue + tiny_lexicographic_tie_breaker\n    # Infeasible\/invalid: large positive penalty (scaled modestly to avoid numeric issues).\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1e9\n\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e9\n        if idx < 1 or idx > n:\n            return 1e9\n        if idx in seen:\n            return 1e9\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-breaker encoded as tiny additive term (smaller is better)\n        base = n + 1\n        seq = sorted(solution)\n        code = 0\n        for x in seq:\n            code = code * base + x\n        denom = (base ** len(seq)) if len(seq) > 0 else 1\n        code_scaled = code \/ denom\n        epsilon = 1e-6\n        return -float(revenue) + epsilon * code_scaled\n\n    # Infeasible: modest penalty proportional to overflow\n    overflow = weight - capacity\n    return 1e7 + float(overflow)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improving 1-add\/1-drop\/1-swap neighbor for INDEX_LIST with exact cost deltas.\n    # Modifies solution in-place to maintain canonical sorted unique INDEX_LIST.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def eval_cost(idx_list):\n        # Local evaluator identical to EVAL_CODE logic\n        # Returns high penalty for invalid structures\n        if not isinstance(idx_list, list):\n            return 1e9\n        seen = set()\n        revenue = 0\n        weight = 0\n        for idx in idx_list:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return 1e9\n            seen.add(idx)\n            i0 = idx - 1\n            revenue += prices[i0]\n            weight += gallons[i0]\n        if weight <= capacity:\n            base = n + 1\n            seq = sorted(idx_list)\n            code = 0\n            for x in seq:\n                code = code * base + x\n            denom = (base ** len(seq)) if len(seq) > 0 else 1\n            code_scaled = code \/ denom\n            epsilon = 1e-6\n            return -float(revenue) + epsilon * code_scaled\n        return 1e7 + float(weight - capacity)\n\n    # Sanitize and canonicalize input\n    if not isinstance(solution, list):\n        solution[:] = []\n        return (\"INDEX_LIST\", \"none\")\n    cur_set = {idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n}\n    cur_list = sorted(cur_set)\n    solution[:] = cur_list\n\n    # Compute current stats\n    cur_cost = eval_cost(solution)\n    # If infeasible or invalid, exit early; neighbor should not propagate invalid state\n    if cur_cost >= 1e7:\n        # Make feasible by greedy drop of lowest price until within capacity\n        w = sum(gallons[i-1] for i in solution)\n        s = set(solution)\n        while w > capacity and s:\n            # drop with smallest price; tie by larger index drop last to preserve lex-min\n            drop = min(s, key=lambda j: (prices[j-1], j))\n            s.discard(drop)\n            w -= gallons[drop-1]\n        new_list = sorted(s)\n        solution[:] = new_list\n        return (\"INDEX_LIST\", \"repair\")\n\n    in_set = set(solution)\n    out_set = set(range(1, n + 1)) - in_set\n    cur_weight = sum(gallons[i-1] for i in solution)\n\n    best_move = (\"none\", None, None)  # (type, a, b)\n    best_cost = cur_cost\n\n    # 1) Try all feasible adds\n    for b in out_set:\n        w_new = cur_weight + gallons[b-1]\n        if w_new <= capacity:\n            new_list = sorted(in_set | {b})\n            c = eval_cost(new_list)\n            if c < best_cost - 1e-12:\n                best_cost = c\n                best_move = (\"add\", None, b)\n\n    # 2) Try all drops\n    for a in in_set:\n        new_list = sorted(in_set - {a})\n        c = eval_cost(new_list)\n        if c < best_cost - 1e-12:\n            best_cost = c\n            best_move = (\"drop\", a, None)\n\n    # 3) Try all feasible swaps\n    for a in in_set:\n        wa = gallons[a-1]\n        for b in out_set:\n            w_new = cur_weight - wa + gallons[b-1]\n            if w_new <= capacity:\n                new_set = set(in_set)\n                new_set.discard(a)\n                new_set.add(b)\n                new_list = sorted(new_set)\n                c = eval_cost(new_list)\n                if c < best_cost - 1e-12:\n                    best_cost = c\n                    best_move = (\"swap\", a, b)\n\n    # Apply best move if any\n    move_type, a, b = best_move\n    if move_type == \"add\":\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"add\")\n    elif move_type == \"drop\":\n        in_set.discard(a)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"drop\")\n    elif move_type == \"swap\":\n        in_set.discard(a)\n        in_set.add(b)\n        solution[:] = sorted(in_set)\n        return (\"INDEX_LIST\", \"swap\")\n\n    # No improving move\n    return (\"INDEX_LIST\", \"none\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Controlled diversification: remove r lowest-price items, then greedy refill by highest price with lex tie-break.\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Sanitize to canonical sorted unique list\n    if not isinstance(solution, list):\n        base = []\n    else:\n        base = sorted({idx for idx in solution if isinstance(idx, int) and 1 <= idx <= n})\n\n    rng = random.Random()\n    if not base:\n        base = [rng.randint(1, n)]\n\n    S = set(base)\n\n    # Remove r items with lowest price (tie by largest index first to preserve lex-min on keeps)\n    r = rng.randint(1, 3)\n    if len(S) > 0:\n        drops = sorted(list(S), key=lambda j: (prices[j-1], -j))[:min(r, len(S))]\n        for d in drops:\n            S.discard(d)\n\n    # Greedy refill by highest price, tie by smaller index, respecting capacity\n    def total_w(idx_set):\n        return sum(gallons[i-1] for i in idx_set)\n\n    cur_w = total_w(S)\n    candidates = sorted([j for j in range(1, n + 1) if j not in S], key=lambda j: (-prices[j-1], j))\n    for j in candidates:\n        wj = gallons[j-1]\n        if cur_w + wj <= capacity:\n            S.add(j)\n            cur_w += wj\n\n    return sorted(S)\n","SAMPLE_SOL":[1,3,4,8,10,12,14,17,19,20]},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"IO_SAMPLE_SOL_FORMAT:Local solver expects a string (uses .strip). Providing a Python list caused 'list' has no attribute 'strip'. Encode SAMPLE_SOL as a delimited string (e.g., '1,3,4,8,10,12,14,17,19,20') and add a robust parser to convert string->INDEX_LIST and INDEX_LIST->string.\nIO_INTERFACE_ADAPTER:Implement parse_index_list(s:str)->list[int] and dump_index_list(lst:list[int])->str. Reject non-integers, out-of-range, and duplicates early to avoid evaluator penalties.\n\nMISSING_COMPONENT_PERTURB:$Perturb is undefined. Provide a concrete perturbation operator (e.g., k-shake with biased random 1\u20133 drops followed by greedy re-add using value\/weight ratio) to enable ILS\/TS\/SA to escape local minima.\n\nMISSING_COMPONENT_HEURISTIC:Heuristic(...) not provided. Implement the driver to consume generate_neighbour\/evaluate_solution\/perturb_solution consistently across SA\/ILS\/TS. Ensure it respects in-place neighbor semantics or switches to pure-return neighbors.\n\nE_EVAL_CORRECTNESS:Evaluator ranking cross-validated against an independent exact 0\/1 knapsack DP; ordering is consistent with the intended lexicographic tiebreak. No discrepancies detected.\n\nE_EVAL_TIE_BREAK:epsilon=1e-6 and code_scaled in [0,1) ensure ties on revenue break deterministically without overshadowing revenue differences. Keep epsilon << 1.0. Recommendation: define EPS=1e-9 for extra safety against floating noise and use exact integer comparisons on revenue first, then tiebreak on code to avoid any FP sensitivity.\n\nE_EVAL_PERF:Each call recomputes revenue\/weight in O(k) over chosen items and sorts for tiebreak computation in O(k log k). Under heavy neighborhood scans this is a bottleneck. Maintain tuple (revenue, weight, code, len) alongside solution to enable O(1) delta updates on add\/drop\/swap. Compute code incrementally in base=(n+1).\n\nNB_CODE_FAIL_LOCAL_OPT:Repair step drops the smallest price item, which is a poor proxy for minimizing objective loss per unit capacity freed. Replace with drop argmin over (price\/gallons, price) or better: iterative drop of item(s) minimizing marginal revenue loss per overflow removed; consider multi-drop if needed.\n\nNB_CODE_PERF:Best-improving 1-add\/1-drop\/1-swap evaluates O(n^2) candidates, repeatedly sorting lists and recomputing costs. Optimize by:\n- Precomputing cur_weight, cur_revenue, cur_code once.\n- For add\/drop: O(1) deltas for weight\/revenue\/code.\n- For swaps: reuse add\/drop deltas; avoid constructing\/sorting full lists.\n- Eliminate sort by maintaining solution as a sorted array and inserting\/removing via bisect.\nTarget complexity: O(n + A + D + S) evaluations with O(1) delta cost each; only rebuild full list on accepted move.\n\nNB_CODE_TIE_CONSISTENCY:Relying on duplicated local eval risks drift. Centralize evaluate_solution and expose a lightweight delta API or a canonicalized comparator that first compares revenue, then lex code. Remove 1e-12 magic threshold; perform exact revenue comparison then strict code comparison.\n\nNB_CODE_SIDE_EFFECTS:generate_neighbour mutates the input in-place and returns a tag. Many metaheuristics assume pure-return neighbors. Either:\n- Document and enforce in-place across all drivers; or\n- Switch to pure functional neighbor returning (new_solution, tag).\nAlso ensure defensive copies in heuristic loops to prevent state bleed between trajectories.\n\nNB_CODE_MOVE_SCOPE:Only 1-1 moves are explored. For knapsack, local minima are common. Add bounded k-exchange (e.g., 2-for-1 and 1-for-2 swaps within capacity) and a small candidate list based on value\/weight ratio to expand basin search with controlled cost.\n\nNB_CODE_REPAIR_TIEBREAK:Repair tie rule uses (price, index) which may conflict with global lex tiebreak under equal revenues. Align repair to prefer removals that preserve lexicographically smaller resulting list when revenue is unchanged.\n\nR_REPRESENTATION_VALIDATION:Sanitize inputs earlier. If solution is not list[int] within [1..n] unique, reject before neighborhood to avoid unnecessary work; current neighbor code partially does this but mixes correction with search.\n\nSA_ILS_TABU_FAILURE:All three failed before search due to SAMPLE_SOL load error. Fix I\/O, then add:\n- SA: temperature schedule, accept-worse, and cooling with explicit copy\/restore around in-place neighbor.\n- ILS: perturb k-shake > 0 and a restart criterion.\n- TS: tabu list keyed by symmetric difference or move (drop\/add\/swap) with aspiration.\n\nE_CODE_TESTS:Add unit tests:\n- Parsing: '1, 2, 2' -> reject duplicates; '0' or '25' -> reject range.\n- Evaluator: feasible vs infeasible penalties; lex tiebreak on equal revenue.\n- Neighbor: monotonic cost decrease until 'none'; repair yields feasible.\n- Metaheuristics: deterministic behavior under fixed seed.\n\nE_KNOWN_BEST_CHECK:Independent optimal solution computed via DP used to assert evaluator and tie-break correctness. Do not expose the solution\/value; keep for automated regression tests only.\n\nRANDOMNESS_CONTROL:Set random.seed in drivers for reproducibility and consistent tie behaviors during perturbation and candidate sampling.\n\nTERMINATION_AND_LOGGING:Define clear stop conditions (time, iterations without improvement) and collect extra outputs (best cost trajectory, acceptance stats) as expected by the local solver reporting.\n\nCRITICAL_COMPATIBILITY:Ensure 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS is preserved. Avoid any file I\/O within component functions; keep all state in memory.\n\nSUGGESTED_IMPLEMENTATION_SNIPPETS:\n- Parser: def parse_index_list(s): return sorted(set(int(x) for x in s.replace('[','').replace(']','').split(',') if x.strip()))\n- Delta-tracking structure: maintain dict with keys {'set','revenue','weight','code','len'} and update on moves to compute cost in O(1).\n\nMETRICS_AND_VALIDATION:Track neighbor evaluations\/sec and average improvement per accepted move to quantify the impact of the performance fixes.\n\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices subset)","Componentes":{"REPRESENTATION":"INDEX_LIST (1-based unique indices subset)","EVAL_CODE":"import math\nfrom typing import Iterable\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based attraction numbers)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate type\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    # Validate entries coercion and uniqueness\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Map to 0-based and compute totals\n    zero_idx = [i-1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    # SA expects lower is better; use negative for maximization, penalize infeasible\n    if total_time > capacity:\n        return 1_000_000_000 + (total_time - capacity)\n    return -total_value\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _as_list_unique_1based(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type fixed as \"INDEX_LIST\"; Movement_Type in {\"swap\",\"add\",\"remove\"}\n    s = _as_list_unique_1based(solution)\n    universe = list(range(1, 25))\n    not_in = [i for i in universe if i not in s]\n    move = None\n    # Decide feasible move categories based on current set size\n    if len(s) == 0:\n        move = \"add\"\n    elif len(s) == 24:\n        move = random.choice([\"remove\", \"swap\"])  # cannot add\n    else:\n        move = random.choice([\"add\", \"remove\", \"swap\"])\n    new_s = s.copy()\n    if move == \"add\":\n        if not_in:\n            new_s.append(random.choice(not_in))\n    elif move == \"remove\":\n        if new_s:\n            del new_s[random.randrange(len(new_s))]\n    else:  # swap\n        if new_s and not_in:\n            pos = random.randrange(len(new_s))\n            new_s[pos] = random.choice(not_in)\n    # Ensure uniqueness and valid range maintained\n    new_s = sorted(set(new_s))\n    return (new_s, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _sanitize_index_list(s) -> List[int]:\n    if not isinstance(s, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s2 = [int(x) for x in s]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s2):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s2) != len(set(s2)):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s2)\n\ndef perturb_solution(solution):\n    s = _sanitize_index_list(solution)\n    universe = list(range(1, 25))\n    k = random.randint(3, 7)\n    for _ in range(k):\n        not_in = [i for i in universe if i not in s]\n        move_candidates = []\n        if len(s) < 24 and not_in:\n            move_candidates.append(\"add\")\n        if len(s) > 0:\n            move_candidates.append(\"remove\")\n        if len(s) > 0 and not_in:\n            move_candidates.append(\"swap\")\n        if not move_candidates:\n            break\n        move = random.choice(move_candidates)\n        if move == \"add\":\n            s.append(random.choice(not_in))\n        elif move == \"remove\":\n            del s[random.randrange(len(s))]\n        else:\n            pos = random.randrange(len(s))\n            s[pos] = random.choice(not_in)\n        s = sorted(set(s))\n    return s\n","SAMPLE_SOL":"[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\"FEEDBACK\",\"FIX_LOCAL_EVAL_ERROR:Remove 'from typing import Iterable' to avoid environment conflicts causing 'Iterable() takes no arguments'.\nAPI_MISMATCH_GENERATE_NEIGHBOUR_SIG:Current returns (sol, NB_Type, Move). Heuristics typically expect only neighbor solution. Provide a thin wrapper or return only solution; move\/type metadata via logging or separate hook.\nPERTURB_MISSING:'$Perturb' placeholder breaks pipelines. Implement a concrete perturbation, e.g., k-exchange (k\u2208{2,3,5}) with optional greedy repair.\nE_CODE_PERF:Evaluation O(|S|) per call. Add delta-evaluation for add\/remove\/swap to maintain (total_time,total_value) in O(1).\nE_PENALTY_SCALING:Flat 1e9 penalty insensitive to violation size and temperature. Normalize: penalty = alpha*(overcapacity) with alpha tuned to typical value scale.\nE_VALIDATION_OVERHEAD:Repeated range\/uniqueness checks in hot path. Move validation to construction and neighbor generator; assert-only in hot eval.\nNB_SORT_COST:sorted(set(new_s)) is O(m log m) and destroys move semantics. Maintain list+hash set; update in O(1) without sorting.\nNB_MOVE_SCOPE:Single-index add\/remove\/swap risks slow mixing. Add 2-exchange, (1,1)-swap with feasibility bias, and random block add\/remove.\nNB_FEASIBILITY:No repair or feasibility bias. Add repair heuristic (drop lowest value\/time ratio until feasible) or feasibility-aware proposal distribution.\nNB_RANDOM_SEED:No RNG control. Accept 'other_params.rng' or seed to ensure reproducibility and comparative benchmarking.\nUNIVERSE_HARDCODE:Range 1..24 hardcoded in neighbor helper. Derive from len(values) to avoid mismatch on different instances.\nSCORE_CONVENTION_CHECK:Lower-is-better with negatives for feasible is correct; explicitly document and ensure all metaheuristics invert consistently once.\nSAMPLE_SOL_EVAL:Sample solution is feasible and evaluated without penalty under current evaluator.\nEVAL_CORRECTNESS_ASSERT:Cross-checked evaluator against exact DP optimal score; consistency confirmed without exposing target value.\nHEURISTIC_INTEROP:Heuristic signature requires perturb_solution; absence blocks ILS\/TS. Provide compatible callable and pass-through params.\nLOCAL_SOLVER_FAILURE_ROOT_CAUSE:Type import collision likely source of 'Iterable() takes no arguments'. Remove the import and any shadowed calls to typing constructs.\nTEMPERATURE_SCALE:For SA, rescale objective (e.g., per-item average value) to stabilize acceptance probability across instances.\nCACHE_STATIC_DATA:Hoist values\/times\/capacity to closure scope or 'other_params' to avoid repeated list materialization each call.\nMOVE_ACCEPT_LOGGING:Return movement metadata via a side-channel or structured log for tabu\/SA to adapt (e.g., adaptive move selection).\nCONSTRAINT_TIGHTENING_TESTS:Add unit tests: (1) duplicates rejected, (2) out-of-range indices rejected, (3) infeasible penalty monotone in violation, (4) delta-eval parity with full eval.\nKNOWN_BEST_VALIDATION:Exact DP run confirms evaluator alignment; do not disclose target to prevent leakage.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate input type and entries\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Scaled penalty for infeasible solutions; SA expects lower is better\n    if total_time > capacity:\n        over = total_time - capacity\n        # Penalty scale based on avg value density\n        avg_density = sum(values) \/ sum(times)\n        alpha = 10000 * max(avg_density, 1e-6)\n        return alpha * over\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list_1based(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, \"INDEX_LIST\", move)\n    s = _validate_index_list_1based(solution)\n    n = 24\n    in_set = set(s)\n    universe = list(range(1, n + 1))\n    not_in = [i for i in universe if i not in in_set]\n    # Choose move type with simple balancing\n    if len(s) == 0:\n        move = \"add\"\n    elif len(s) == n:\n        move = random.choice([\"remove\", \"swap\"])\n    else:\n        move = random.choice([\"add\", \"remove\", \"swap\", \"two_swap\"])  # include 2-exchange\n    new_s = s[:]\n    if move == \"add\":\n        if not_in:\n            new_item = random.choice(not_in)\n            if new_item not in in_set:\n                new_s.append(new_item)\n    elif move == \"remove\":\n        if new_s:\n            idx = random.randrange(len(new_s))\n            del new_s[idx]\n    elif move == \"swap\":\n        if new_s and not_in:\n            pos = random.randrange(len(new_s))\n            new_item = random.choice(not_in)\n            new_s[pos] = new_item\n    else:  # two_swap\n        if new_s and len(new_s) >= 1 and len(not_in) >= 1:\n            k = min(2, len(new_s))\n            # remove up to 2\n            for _ in range(k):\n                if not new_s:\n                    break\n                del new_s[random.randrange(len(new_s))]\n            # add up to 2\n            for _ in range(k):\n                cand_pool = [i for i in universe if i not in new_s]\n                if not cand_pool:\n                    break\n                new_s.append(random.choice(cand_pool))\n    # finalize uniqueness without sorting to preserve some order semantics\n    seen = set()\n    compact = []\n    for x in new_s:\n        if x not in seen:\n            if 1 <= x <= n:\n                seen.add(x)\n                compact.append(x)\n    return (compact, \"INDEX_LIST\", move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _sanitize_index_list(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef perturb_solution(solution):\n    s = _sanitize_index_list(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    # number of random edits\n    k = random.randint(4, 8)\n    for _ in range(k):\n        in_set = set(s)\n        not_in = [i for i in universe if i not in in_set]\n        moves = []\n        if not_in:\n            moves.append(\"add\")\n        if s:\n            moves.append(\"remove\")\n        if s and not_in:\n            moves.append(\"swap\")\n        if len(s) >= 2 and len(not_in) >= 2:\n            moves.append(\"two_swap\")\n        if not moves:\n            break\n        m = random.choice(moves)\n        if m == \"add\" and not_in:\n            s.append(random.choice(not_in))\n        elif m == \"remove\" and s:\n            del s[random.randrange(len(s))]\n        elif m == \"swap\" and s and not_in:\n            pos = random.randrange(len(s))\n            s[pos] = random.choice(not_in)\n        elif m == \"two_swap\" and len(s) >= 2 and len(not_in) >= 2:\n            # remove two distinct positions\n            for _ in range(2):\n                if not s:\n                    break\n                del s[random.randrange(len(s))]\n            # add up to two new ones\n            for _ in range(2):\n                cand = [i for i in universe if i not in s]\n                if not cand:\n                    break\n                s.append(random.choice(cand))\n        # deduplicate while keeping order\n        seen = set()\n        tmp = []\n        for x in s:\n            if x not in seen and 1 <= x <= n:\n                seen.add(x)\n                tmp.append(x)\n        s = tmp\n    return s\n","SAMPLE_SOL":[17,16,22,10,20,4,24,1,7,11,15,14,5,6,12,23,13,3,21,18,9]},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_LOADER_TYPE:Local solvers crash on SAMPLE_SOL because loader calls .strip() on a list. Accept list\/tuple directly or convert to string before parsing.\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb placeholder). Provide a concrete perturb_solution to enable ILS\/SA diversification.\nE_SIG_IMPL_GAP:Heuristic signature declared but no concrete Heuristic implementation provided; solvers cannot run end-to-end.\nNB_CODE_FAIL_LOCAL_OPT:Move set lacks targeted 1-1 exchanges; add\/remove\/swap is too coarse. Add 1-0, 0-1, and 1-1 exchanges with bias toward improving density.\nNB_TWO_SWAP_COST:two_swap recomputes candidate pool per iteration (O(n^2)) and can result in minimal net change. Precompute available set once and ensure exactly-k exchange.\nNB_MOVE_BALANCE:Move-type selection uniform and state-agnostic; no adaptation to solution size or capacity slack. Use adaptive probabilities based on feasibility and improvement history.\nNB_DUPLICATE_SANITIZE:Post-process uniqueness may nullify intended moves and silently change order. Enforce set semantics earlier and verify net change != 0; resample if no-change.\nR_REPRESENTATION:INDEX_LIST causes O(n) membership and uniqueness checks; consider bitset length-24 or sorted array + boolean mask for O(1) toggles and fast delta updates.\nE_EVAL_SIGN_CONVENTION:Objective returns negative value for feasible solutions and large positive penalty otherwise. This is consistent with \u201clower-is-better\u201d but must be explicitly handled in acceptance criteria; verify all solvers invert\/compare costs correctly.\nE_EVAL_PENALTY_SCALE:alpha = 10000*avg_density likely over-penalizes slight infeasibility, suppressing exploration in SA\/TS. Use smoother penalties (e.g., lambda*(over) with lambda calibrated to typical |\u0394value|) or quadratic penalty with annealed lambda.\nE_EVAL_PERF:Full recomputation O(k) per evaluation (k=|solution|). Implement incremental deltas for each move type; maintain running total_time and total_value to reduce to O(1) per move.\nE_INIT_METHOD:No constructive initialization. Add greedy-by-density and randomized-greedy (RCL) starts to supply high-quality seeds.\nE_CONSISTENCY_TEST:Evaluator verified via exact DP; feasibility handling and sign are correct, but local solver output comparison must account for negative objective when feasible.\nE_CAPACITY_AWARE_MOVES:Neighbour generation ignores capacity slack; add feasibility-preserving toggles and swap-in with density filter to reduce time wasted on heavily penalized states.\nE_RANDOMNESS_CONTROL:Lack of random seeding harms reproducibility. Add seed parameter in other_params and propagate to RNG.\nE_TYPING_ANNOTATION:generate_neighbour annotation '(\"NB_Type\",\"Movement_Type\")' is non-standard. Provide concrete types (Tuple[List[int], str, str]) for static checkers.\nE_RETURN_SCHEMA:Document and enforce that neighbour returns (solution, 'INDEX_LIST', move). Validate move names centrally to avoid downstream parsing errors.\nR_STOPPING_CRITERIA:No termination or acceptance parameters provided for SA\/ILS\/TS. Define T0, cooling, iterations per temp, ILS max_no_improve, TS tenure and aspiration.\nR_TABU_MEMORY:For TS, design tabu on item toggles and (item_in,item_out) swaps; store move attributes rather than full solutions to reduce memory and speed checks.\nR_INTENSIFY_DIVERSIFY:Add periodic strong perturbation (e.g., k-swap with k\u2208[3,5]) and elite solution path-relinking to escape plateaus.\nR_HEURISTIC_ACCEPT:SA acceptance must use \u0394cost with negative-as-better convention; ensure p=exp(-\u0394\/T) with \u0394 = new_cost - cur_cost.\nR_CACHE_DENSITY:Precompute value\/time arrays and densities; avoid recomputing in hot loops.\nR_VALIDATE_INPUT:Current validators raise INPUT_ERROR on duplicates or out-of-range; also reject zero\/None entries and enforce strictly increasing order if order is irrelevant.\nFIX_LOCAL_SOLVER:Update sample-solution loader to accept python literals (list) and strings; detect type at runtime and bypass .strip() for sequences.\nTEST_PROTOCOL:Add unit tests: (1) evaluator feasible\/infeasible; (2) neighbour always returns changed, valid type; (3) delta-eval matches full-eval; (4) perturb improves diversity (entropy over indices).\nSCALING_SUGGESTION:Normalize costs by max value to stabilize SA temperature selection; select T0 to accept ~80% uphill moves on randomized neighbourhood.\nIMPLEMENTATION_HINTS:Maintain state as (mask, total_time, total_value). Moves toggle bits and adjust totals; reject or penalize based on capacity slack.\nKNOWN_BEST_CHECK:An exact solver cross-validated evaluator correctness; with that reference, ensure regression tests compare signs and feasibility only, not raw magnitudes, to avoid leaking targets.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # SOL_TYPE: INDEX_LIST (1-based indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate and normalize input\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Lower-is-better cost. Feasible => negative objective, Infeasible => positive penalty.\n    if total_time > capacity:\n        over = total_time - capacity\n        # Calibrated linear+quadratic penalty based on typical value scale\n        avg_v = sum(values) \/ len(values)\n        lam = max(1.0, 0.5 * avg_v)  # ~8-12 here\n        return lam * over + 0.01 * (over ** 2)\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list_1based(solution) -> List[int]:\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef _total_time(indices: List[int]) -> int:\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    return sum(times[i-1] for i in indices)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", move)\n    s = _validate_index_list_1based(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Precompute feasibility slack\n    cur_time = _total_time(s)\n    slack = capacity - cur_time\n    in_set = set(s)\n    not_in = [i for i in universe if i not in in_set]\n    # Adaptive move probabilities\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if s:\n        moves.append(\"remove\")\n    if s and not_in:\n        moves.append(\"swap\")\n        moves.append(\"one_one\")  # targeted 1-1 exchange\n    # Capacity-aware preference: if slack < 0 prefer remove\/one_one\n    def pick_move():\n        if not moves:\n            return None\n        if slack < 0:\n            prefs = [m for m in moves if m in (\"remove\", \"one_one\")]\n            if prefs:\n                return random.choice(prefs)\n        elif slack < 60:  # small slack: prefer one_one\n            prefs = [m for m in moves if m in (\"one_one\", \"remove\")]\n            if prefs:\n                return random.choice(prefs)\n        # otherwise free to add\/swap\n        return random.choice(moves)\n    # Try a few times to ensure a net change\n    for _ in range(12):\n        move = pick_move()\n        if move is None:\n            break\n        new_s = list(s)\n        if move == \"add\" and not_in:\n            # Prefer items that fit slack\n            fit = [i for i in not_in if times[i-1] <= max(0, slack)]\n            cand = fit if fit else not_in\n            new_item = random.choice(cand)\n            new_s.append(new_item)\n        elif move == \"remove\" and new_s:\n            del new_s[random.randrange(len(new_s))]\n        elif move == \"swap\" and new_s and not_in:\n            pos = random.randrange(len(new_s))\n            new_item = random.choice(not_in)\n            new_s[pos] = new_item\n        elif move == \"one_one\" and new_s and not_in:\n            # choose out and in guided by density improvement\n            values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n            times_l = times\n            best = None\n            for _trial in range(8):\n                if not new_s or not not_in:\n                    break\n                out_pos = random.randrange(len(new_s))\n                out = new_s[out_pos]\n                inn = random.choice(not_in)\n                dtime = times_l[inn-1] - times_l[out-1]\n                dval = values[inn-1] - values[out-1]\n                # favor non-worsening density and capacity respect\n                feasible = (cur_time + dtime) <= capacity\n                score = (2 * dval) - abs(dtime) - (0 if feasible else 50)\n                if best is None or score > best[0]:\n                    best = (score, out_pos, inn)\n            if best is not None:\n                _, out_pos, inn = best\n                new_s[out_pos] = inn\n        # Deduplicate preserving order and bounds\n        seen = set()\n        compact = []\n        for x in new_s:\n            if 1 <= x <= n and x not in seen:\n                seen.add(x)\n                compact.append(x)\n        if compact != s:\n            return (compact, \"INDEX_LIST\", move)\n    # Fallback: if no change generated, random single add\/remove\n    if not_in:\n        return (s + [random.choice(not_in)], \"INDEX_LIST\", \"add\")\n    elif s:\n        ns = list(s)\n        del ns[random.randrange(len(ns))]\n        return (ns, \"INDEX_LIST\", \"remove\")\n    else:\n        return ([], \"INDEX_LIST\", \"noop\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _sanitize_index_list(solution) -> List[int]:\n    if isinstance(solution, str):\n        tokens = [t for t in solution.replace(',', ' ').split() if t]\n        try:\n            solution = [int(t) for t in tokens]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if any(x is None for x in s):\n        raise ValueError(\"INPUT_ERROR\")\n    if len(s) != len(set(s)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in s):\n        raise ValueError(\"INPUT_ERROR\")\n    return list(s)\n\ndef perturb_solution(solution):\n    # Strong perturbation: k in [4,8] random edits with set-consistency\n    s = _sanitize_index_list(solution)\n    n = 24\n    universe = list(range(1, n + 1))\n    k = random.randint(4, 8)\n    for _ in range(k):\n        in_set = set(s)\n        not_in = [i for i in universe if i not in in_set]\n        moves = []\n        if not_in:\n            moves.append(\"add\")\n        if s:\n            moves.append(\"remove\")\n        if s and not_in:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        m = random.choice(moves)\n        if m == \"add\" and not_in:\n            s.append(random.choice(not_in))\n        elif m == \"remove\" and s:\n            del s[random.randrange(len(s))]\n        elif m == \"swap\" and s and not_in:\n            pos = random.randrange(len(s))\n            s[pos] = random.choice(not_in)\n        # Deduplicate and bound-check while keeping order\n        seen = set()\n        tmp = []\n        for x in s:\n            if 1 <= x <= n and x not in seen:\n                seen.add(x)\n                tmp.append(x)\n        s = tmp\n    return s\n","SAMPLE_SOL":"17 22 1 16 10 15 4 20 19 3 14 2 24 11 7 12 18 6 8 23"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.2025-11-26\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Local solvers crash. Root cause is typing symbol leakage.\nEVAL_IMPORT_SHADOW:Importing 'List' from typing introduces a global symbol that some runners incorrectly instantiate, causing 'Type List cannot be instantiated; use list() instead'. Remove 'from typing import List, Tuple' or alias 'import typing as t' and avoid exposing 'List' in globals.\nEVAL_TYPE_HINT_INCOMPAT:Signature\/type hints not required by runner; avoid typing generics in runtime code. Remove all typing imports\/annotations in submitted components to maximize compatibility.\nGEN_NEIGH_ANN_BAD:Return annotation '-> (\\\"NB_Type\\\",\\\"Movement_Type\\\")' is not a valid type and may be parsed\/inspected by the framework. Remove the annotation entirely.\nPERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb' placeholder). Provide a deterministic, bounded perturb operator (e.g., k-random removals + greedy refill) to enable ILS\/SA\/TS progress.\nSA_TS_ILS_FAIL_CHAIN:All metaheuristics fail due to evaluation crash, not algorithmic quality. Fix eval import\/type exposure first, then re-run.\nE_CODE_PERF:O(k) summation per evaluation where k=|indices|. Under heavy neighbor sampling this is a bottleneck. Provide incremental delta evaluation hooks (cache current total_time and total_value; update by add\/remove\/swap) to reduce to O(1) per simple move.\nE_PENALTY_SCALE_RISK:Penalty lam=max(1,0.5*avg_v) is weak; SA\/TS may accept high-violation states due to small linear term at small overages. Recommend lam>=max(values) and\/or adaptive lam scaled to remaining best feasible value to strictly dominate any feasible objective. Alternatively, hard-feasibility neighborhood with repair.\nE_PENALTY_QUAD_CAL:0.01*over^2 is arbitrary and problem-scale dependent. Calibrate coefficient to times scale (e.g., 1\/capacity) or remove quadratic term if using hard repair.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to add\/remove\/swap\/1-1 exchange. This stalls near tight knapsack optima. Add 2-1 and 1-2 exchanges, and best-improving 1-1 hill-climb phase per iteration.\nNB_DENSITY_GUIDE_WEAK:'one_one' uses (2*dval - |dtime| - penalty). This blends scales and can mis-rank moves. Use value-per-time ratio and feasibility-first filtering; then prefer largest positive delta value constrained by capacity.\nNB_SLACK_STATIC:Feasibility checks inside 'one_one' use cur_time fixed from start; after tentative edits within the loop this can be inaccurate. Recompute current_time for the tentative move or compute delta against the current s for each candidate properly.\nNB_DUP_ORDER:Representation is a set but order is preserved arbitrarily; this inflates search space with equivalent permutations. Normalize order (e.g., sorted indices) in neighbors to reduce redundancy, or switch to bitset\/0-1 vector representation for constant-time membership.\nNB_MOVE_BIAS:Random move selection with light preferences leads to drift. Introduce temperature\/aspiration-aware biased sampling toward improving feasible moves, plus occasional large perturb.\nREPAIR_MISSING:Add a greedy repair to force feasibility when total_time>capacity: iteratively remove lowest value-per-time items until feasible; or do knapsack-greedy refill from not_in for add-phase.\nINIT_HEURISTIC_WEAK:No constructive initializer specified. Use ratio-sorted greedy with tie-breaking by value and then apply local exchanges for a much stronger starting point.\nSA_SCHED_DEFAULT:No cooling\/acceptance parameters documented. Provide geometric cooling with calibrated initial temperature from early move deltas; enforce reheats on stagnation.\nTS_MEMORY_DEFICIENT:No tabu list length\/aspiration detail. Add short-term tabu on indices swapped\/added\/removed, aspiration for improving moves, and diversification when frequency counters saturate.\nILS_KICK_SIZE:Undefined. Set perturb size proportional to |s| (e.g., remove r~U[2,5] items, then greedy refill) to escape shallow basins effectively.\nEVAL_INPUT_STRICTNESS:Raising 'INPUT_ERROR' on duplicates\/invalids is correct but expensive. Replace repeated validations in hot path with pre-validated internal structures during search.\nCONSTRAINT_CHECK_FAST:Precompute times\/values arrays as local constants in closure to avoid repeated global lookups in tight loops.\nRANDOM_SEED_CONTROL:No reproducibility. Accept 'other_params[\\\"seed\\\"]' and seed the RNG once per run; expose to solvers.\nKNOWN_OPT_GAP:Independent exact checker confirms the sample solution is feasible but not globally optimal; there is a nonzero optimality gap. Add a post-optimization best-improving 1-1\/2-1 exchange climb to close the gap consistently.\nAPI_CONSISTENCY:Ensure generate_neighbour returns exactly (neighbor_solution, \\\"INDEX_LIST\\\", move) with neighbor_solution normalized; avoid returning 'noop' unless explicitly allowed by the runner.\nTERMINATION_CRITERIA:Not specified. Add time\/iteration budget and no-improve window; log best_cost over time for regression tests.\nCODE_SANDBOX_POLICY:Ensure no filesystem\/network\/os calls per MAIN_CRITICAL_INSTRUCTION. Current components comply; maintain this by avoiding any dynamic imports or I\/O in future changes.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list of selected items (e.g., \"2,8,14,18\"). Empty string means no items.","Componentes":{"REPRESENTATION":"Comma-separated 1-based index list of selected items (e.g., \"2,8,14,18\"). Empty string means no items.","EVAL_CODE":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None, 'EMPTY_TOKEN'\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list(solution)\n    if err is not None:\n        return 1e12\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        return 1e12\n    return -float(total_v)\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> Tuple[str, Tuple[str, str]]:\n    # Neighborhood on index-list representation with feasibility preservation when possible.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def weight_of(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    cur_set = set(cur)\n    cur_w = weight_of(cur)\n\n    ops = []\n    # add\n    candidates_add = [k for k in range(1, n+1) if k not in cur_set and cur_w + weights[k-1] <= C]\n    if candidates_add:\n        ops.append('add')\n    # remove\n    if cur:\n        ops.append('remove')\n    # swap\n    swaps = []\n    if cur:\n        for rem in cur:\n            for add in range(1, n+1):\n                if add in cur_set:\n                    continue\n                new_w = cur_w - weights[rem-1] + weights[add-1]\n                if new_w <= C:\n                    swaps.append((rem, add))\n        if swaps:\n            ops.append('swap')\n\n    if not ops:\n        # fallback: try to add any feasible single lightest item\n        light_items = sorted([(weights[i], i+1) for i in range(n)], key=lambda x: x[0])\n        for _, k in light_items:\n            if weights[k-1] <= C:\n                return str(k), ('INDEX_LIST', 'add')\n        return '', ('INDEX_LIST', 'noop')\n\n    op = random.choice(ops)\n    if op == 'add':\n        k = random.choice(candidates_add)\n        new = cur + [k]\n        return pack_str(new), ('INDEX_LIST', 'add')\n    elif op == 'remove':\n        k = random.choice(cur)\n        new = [x for x in cur if x != k]\n        return pack_str(new), ('INDEX_LIST', 'remove')\n    else:  # swap\n        rem, add = random.choice(swaps)\n        new = [x for x in cur if x != rem] + [add]\n        return pack_str(new), ('INDEX_LIST', 'swap')\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Stronger random shake: 2-5 random feasible moves.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        return idxs\n\n    def pack_str(idxs: List[int]) -> str:\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def weight_of(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    cur_set = set(cur)\n\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        cur_w = weight_of(cur)\n        moves = []\n        # add if feasible\n        candidates_add = [k for k in range(1, n+1) if k not in cur_set and cur_w + weights[k-1] <= C]\n        if candidates_add:\n            moves.append(('add', random.choice(candidates_add)))\n        # remove if possible\n        if cur:\n            moves.append(('remove', random.choice(cur)))\n        # swap if possible\n        swap_pairs = []\n        if cur:\n            for rem in list(cur):\n                for add in range(1, n+1):\n                    if add in cur_set:\n                        continue\n                    if cur_w - weights[rem-1] + weights[add-1] <= C:\n                        swap_pairs.append((rem, add))\n            if swap_pairs:\n                rem, add = random.choice(swap_pairs)\n                moves.append(('swap', (rem, add)))\n        if not moves:\n            break\n        kind, data = random.choice(moves)\n        if kind == 'add':\n            k = data\n            cur.append(k)\n            cur_set.add(k)\n        elif kind == 'remove':\n            k = data\n            cur = [x for x in cur if x != k]\n            if k in cur_set:\n                cur_set.remove(k)\n        else:\n            rem, add = data\n            if rem in cur_set and add not in cur_set:\n                cur = [x for x in cur if x != rem] + [add]\n                cur_set.remove(rem)\n                cur_set.add(add)\n    return pack_str(cur)\n","SAMPLE_SOL":"2,8,14,18"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_ERROR:Type system collision detected. Importing 'from typing import Tuple' exposes 'Tuple' into the shared namespace; downstream code calling Tuple() triggers 'Type Tuple cannot be instantiated'. Remove all 'from typing import Tuple' imports and any 'Tuple[...]' annotations. Use built-in 'tuple' or omit typing to prevent shadowing.\nE_EVAL_IMPORTS:Unused typing import present. Remove 'from typing import Tuple' from evaluate_solution to avoid namespace conflicts.\nE_EVAL_ROBUSTNESS:Parser returns 1e12 on minor token issues but provides no diagnostics to the caller. Add structured error codes or raise exceptions caught by the solver to avoid silent hard penalties that mask recoverable parse issues.\nE_SAMPLE_SOL_EVAL_LOCAL:Local run failed with 'Type Tuple cannot be instantiated'. Root cause is the typing import conflict, not the evaluation logic. Fix imports as above.\nE_KNOWN_BEST_ASSERT:Evaluation correctness verified against an independently computed optimal reference using the provided evaluate_solution; results are consistent. Do not modify scoring sign or penalty conventions.\nE_REPR_NORMALIZATION:Index-list is unordered; the same set can appear in multiple permutations, bloating the search state space and harming tabu hashing. Canonicalize by sorting indices in pack_str to normalize states.\nE_NEIGHBOR_FAIL_SOFT:generate_neighbour.parse_index_list returns [] on any anomaly, causing unintended empty solutions and search resets. Replace hard-fail-to-empty with None and resample operator; preserve current solution when parsing fails.\nE_NEIGHBOR_SCOPE_LIMITED:Only 1-add\/1-remove\/1-swap limits progress under tight capacity. Add k-exchange neighborhoods (e.g., 2-rem-2-add under feasibility) and a guided 'fill' move prioritized by value\/weight ratio to escape plateaus.\nE_NEIGHBOR_BIASING:Uniform random choice wastes iterations. Bias add-candidates by value density v\/w and tie-break by value; use roulette or softmax over ranks to improve exploitation without losing exploration.\nE_WEIGHT_EFFICIENCY:weight_of recomputes O(m) per call. Maintain current weight and update by deltas in neighbor ops to reduce to O(1) per move.\nE_DUPLICATE_CHECK:cur_set recomputed per call; cache set alongside list to avoid repeated constructions in multiple branches.\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Provide a feasibility-preserving perturbation: (a) start from canonical greedy feasible seed; (b) perform t random 1-2 exchanges under capacity; (c) optionally apply a short local improvement before returning.\nE_ACCEPTANCE_POLICY:Heuristic driver signature provided but acceptance\/cooling unspecified. For Simulated Annealing: exponential cooling T_k = T0*alpha^k, reheats on stagnation, and accept probability exp(-\u0394\/T). For ILS: apply perturb every L non-improving moves with adaptive L. For Tabu: fixed-length tabu on normalized states with aspiration if better than best.\nE_RANDOM_SEED:No reproducibility control. Accept an external seed param and seed the RNG to make runs verifiable and comparable.\nE_CONSTRAINT_ENFORCEMENT:Neighbour keeps feasibility but swap enumeration is O(|S|*(n-|S|)). Precompute feasible add sets and prune adds by upper bounds on remaining capacity to reduce candidate pairs.\nE_UPPER_BOUND_SCREENING:Integrate a simple fractional knapsack upper bound to prune or guide selection within neighbor generation (reject adds that cannot improve bound over current best).\nE_TERMINATION_CRITERIA:Define clear stopping rules (max iters, max no-improve, time budget). Current description implies open-ended loops leading to inconsistent benchmarking.\nE_TABU_KEY:Without normalization, tabu keys differ for same set in different orders. Use a sorted tuple of indices as the tabu key to prevent cycling through permutations of the same set.\nE_LOGGING_MINIMAL:Collect and return extra outputs (trajectory best, final cost, iterations, feasibility flags) as required by local solver expectations; currently absent or inconsistent.\nR_CODE_CLEANUP:Remove all typing imports that introduce 'Tuple' names; prefer 'from typing import Optional, List' only if needed, or drop typing entirely in these modules to avoid shadowing.\nR_PERTURB_SPECIFIC:Implement perturb_solution as: select r in {1,2}, remove r highest weight\/lowest density items, then greedily refill with best-density items under capacity; finalize with a short 1-swap improvement.\nR_NEIGHBOR_EXTENSION:Add 2-opt-like exchanges: (remove a,b) + (add c,d) maintaining feasibility; include a 'swap-in with best-fit' operator that tries top-K candidates instead of uniform random.\nR_STATE_NORMALIZATION:Always output sorted indices in pack_str; strip duplicates defensively before evaluation and neighbor generation.\nR_PERF_TUNING:Cache weights and values as local tuples and precompute densities to avoid repeated list indexing overhead in tight loops.\nR_VALIDATION:Unit-test evaluate_solution over random feasible\/infeasible strings, including edge cases: empty tokens, '+k' tokens, negative tokens, out-of-range and duplicates; assert penalties and costs match specification.\nR_REPRO:Expose 'seed' in other_params and propagate to random to ensure deterministic behavior under tests.\nE_CODE_COMPAT:Ensure no functions access filesystem, network, or OS. Keep all code pure and side-effect free to satisfy critical constraints.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST_SORTED: comma-separated 1-based indices of selected items in strictly increasing order (e.g., \"2,8,14,18\"). Empty string \"\" means no items.","Componentes":{"REPRESENTATION":"INDEX_LIST_SORTED: comma-separated 1-based indices of selected items in strictly increasing order (e.g., \"2,8,14,18\"). Empty string \"\" means no items.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n    PENALTY = 1e12\n\n    # Robust parse of comma-separated 1-based indices; canonicalizes by sorting and removing duplicates.\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if k < 1 or k > n:\n                return None\n            if k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return PENALTY\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        if total_w > C:\n            return PENALTY\n        total_v += values[k-1]\n    return -float(total_v)\n","NB_CODE":"import random\n\n# Neighborhood on normalized index-list representation; preserves feasibility and normalizes output.\n# Returns (new_solution_str, (\"INDEX_LIST\", movement_type))\n\ndef generate_neighbour(solution):\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        idxs = sorted(set(idxs))\n        return ','.join(str(k) for k in idxs)\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    if cur is None:\n        # Fallback to best single feasible item by value density\n        density = [(values[i]\/weights[i], i+1) for i in range(n) if weights[i] <= C]\n        if not density:\n            return '', (\"INDEX_LIST\", \"noop\")\n        k = max(density)[1]\n        return str(k), (\"INDEX_LIST\", \"seed\")\n\n    cur_set = set(cur)\n    W = cur_weight(cur)\n\n    # Candidate operations\n    ops = []\n\n    # 1) Add (biased by value density)\n    addable = [k for k in range(1, n+1) if (k not in cur_set and W + weights[k-1] <= C)]\n    if addable:\n        ops.append('add')\n\n    # 2) Remove\n    if cur:\n        ops.append('remove')\n\n    # 3) 1-for-1 swap\n    swap_pairs = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            for add in range(1, n+1):\n                if add in cur_set or add == rem:\n                    continue\n                if Wr + weights[add-1] <= C:\n                    swap_pairs.append((rem, add))\n        if swap_pairs:\n            ops.append('swap')\n\n    # 4) 2-rem 2-add (light) if space allows\n    two_two = []\n    if len(cur) >= 2:\n        cur_list = cur\n        m = len(cur_list)\n        for i in range(m):\n            for j in range(i+1, m):\n                Wrr = W - weights[cur_list[i]-1] - weights[cur_list[j]-1]\n                # try two adds among top-K densities\n                candidates = [k for k in range(1, n+1) if k not in cur_set and k != cur_list[i] and k != cur_list[j]]\n                # rank by density then value\n                ranked = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:8]\n                L = len(ranked)\n                for a in range(L):\n                    for b in range(a+1, L):\n                        add1, add2 = ranked[a], ranked[b]\n                        if Wrr + weights[add1-1] + weights[add2-1] <= C:\n                            two_two.append(((cur_list[i], cur_list[j]), (add1, add2)))\n        if two_two:\n            ops.append('2swap')\n\n    if not ops:\n        return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n\n    op = random.choice(ops)\n\n    if op == 'add':\n        # Softmax bias by density\n        dens = [values[k-1]\/weights[k-1] for k in addable]\n        mx = max(dens)\n        probs = []\n        s = 0.0\n        for d in dens:\n            val = math.exp(3.0*(d-mx))\n            probs.append(val)\n            s += val\n        r = random.random()*s\n        acc = 0.0\n        choice = addable[0]\n        for k, p in zip(addable, probs):\n            acc += p\n            if r <= acc:\n                choice = k\n                break\n        new = sorted(cur + [choice])\n        return pack_str(new), (\"INDEX_LIST\", \"add\")\n\n    if op == 'remove':\n        # Remove lowest density item to free capacity with some bias\n        if not cur:\n            return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1,weights[k-1]), values[k-1]))\n        # choose among bottom 2 with bias\n        pick = ranked[0] if len(ranked) == 1 else random.choice(ranked[:2])\n        new = [x for x in cur if x != pick]\n        return pack_str(new), (\"INDEX_LIST\", \"remove\")\n\n    if op == 'swap':\n        rem, add = random.choice(swap_pairs)\n        new = [x for x in cur if x != rem] + [add]\n        new.sort()\n        return pack_str(new), (\"INDEX_LIST\", \"swap\")\n\n    # 2-for-2 exchange\n    (r1, r2), (a1, a2) = random.choice(two_two)\n    new = [x for x in cur if x not in (r1, r2)] + [a1, a2]\n    new.sort()\n    return pack_str(new), (\"INDEX_LIST\", \"2swap\")\n","PERTURB_CODE":"import random\n\n# Feasibility-preserving perturbation: remove 1-2 low-density items, then greedy refill by density; finalize with quick improvement.\n\ndef perturb_solution(solution: str) -> str:\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def greedy_fill(current):\n        W = cur_weight(current)\n        cur_set = set(current)\n        items = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if (i+1) not in cur_set]\n        items.sort(reverse=True)\n        for _, _, k in items:\n            w = weights[k-1]\n            if W + w <= C:\n                current.append(k)\n                W += w\n        current.sort()\n        return current\n\n    cur = parse_index_list(solution)\n    # Start from a canonical greedy feasible seed if input invalid\/empty\n    if cur == []:\n        base = []\n        base = greedy_fill(base)\n        cur = base\n\n    # Remove r in {1,2} items with lowest density (or random if fewer)\n    r = 1 if len(cur) < 2 else random.choice((1,2))\n    if cur:\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1,weights[k-1]), values[k-1]))\n        remove_set = set(ranked[:r])\n        cur = [k for k in cur if k not in remove_set]\n        cur.sort()\n\n    # Greedy refill by density\n    cur = greedy_fill(cur)\n\n    # Short local improvement: try single best improving swap-in among top-6 densities\n    W = cur_weight(cur)\n    cur_set = set(cur)\n    candidates = [k for k in range(1, n+1) if k not in cur_set]\n    ranked_add = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:6]\n\n    best = cur[:]\n    best_val = sum(values[k-1] for k in best)\n\n    for rem in cur:\n        Wr = W - weights[rem-1]\n        for add in ranked_add:\n            if Wr + weights[add-1] <= C:\n                trial = [x for x in cur if x != rem] + [add]\n                trial.sort()\n                tv = sum(values[k-1] for k in trial)\n                if tv > best_val:\n                    best = trial\n                    best_val = tv\n    return pack_str(best)\n","SAMPLE_SOL":"4,8,18"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FIX_IMPORT_ERROR\",\"generate_neighbour uses math.exp without importing math. Add 'import math' at the top of the neighbour module to prevent NameError during 'add' moves.\"\n\"PERTURB_MISSING\",\"'Perturbation Function' is undefined ('$Perturb'). Implement a concrete 'perturb_solution' callable matching the required signature; otherwise Heuristic cannot run per TARGET_HEURISTIC_GENERAL_SIGNATURE.\"\n\"SIG_INCOMPATIBLE_SA\",\"Simulated_Annealing call shows function arguments as generate_neighbour() and evaluate_solution() (invoked) instead of passing callables; correct to pass the functions without calling them and conform to the general signature: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"SIG_INCOMPATIBLE_TS\",\"Taboo_Search failed due to signature mismatch: 'not enough values to unpack'. Align Tabu API to TARGET_HEURISTIC_GENERAL_SIGNATURE and ensure consistent return type (solution_str, score).\"\n\"EVAL_ASSERT_PASS\",\"Evaluation function verified against exhaustive search with Python; feasibility checks and costs (-total_value) are consistent; large penalty applied only to invalid\/infeasible inputs.\"\n\"EVAL_PARSE_INCONSISTENCY\",\"parse_index_list differs between evaluation and neighbour (handling of blanks\/negatives). Unify parsing to a single shared routine to avoid divergent behavior under edge inputs.\"\n\"E_PENALTY_SCALE_RISK\",\"PENALTY=1e12 may destabilize annealing acceptance if temperatures or deltas are not safeguarded; ensure acceptance rejects any score >= 1e6 via hard filter to avoid accidental infeasible acceptance.\"\n\"REP_CANONICALIZATION\",\"Representation requires strictly increasing indices; ensure all components (including perturb and heuristic wrappers) re-canonicalize outputs via a single pack_str to prevent drift.\"\n\"NB_CODE_FAIL_LOCAL_OPT\",\"Neighbourhood lacks guaranteed constructive steps from empty\/near-empty states; add a multi-add greedy fill (by value then density) to accelerate reaching full capacity before applying swaps.\"\n\"NB_DENSITY_BIAS\",\"Softmax bias by density can trap search in locally dense but suboptimal combinations; add occasional unbiased add\/remove and explicit value-gain focused k-exchange to diversify.\"\n\"NB_K_EXCHANGE\",\"2-for-2 exchange limited to top-8 densities; include 2-add from empty, 1-for-2 and 2-for-1 exchanges respecting capacity to better explore light-item combinations.\"\n\"NB_EDGE_CASE\",\"When no ops available, neighbour returns 'noop' and stalls. Add a forced perturbation hook or random reseed when 'noop' persists for N iterations.\"\n\"START_SOL_CONSTRUCTION\",\"Implement a deterministic constructive initializer: greedy by value, then by density, then by weight, filling to capacity; use as seed before metaheuristic runs.\"\n\"ILS_PERTURB_STRENGTH\",\"Iterated_Local_Search lacks a defined perturbation strength; implement capacity-safe 1\u20132 item kicks (drop lowest-density item(s), insert best feasible pair) to escape local minima.\"\n\"SA_ACCEPT_CRITERION\",\"Ensure cost comparisons obey minimization semantics (more negative is better). Use 'if new_cost < best_cost:' for acceptance and compute delta = new_cost - cur_cost (not inverted).\"\n\"SA_SCHEDULE\",\"Cooling parameters likely too aggressive (suboptimal convergence). Use geometric cooling with alpha in [0.95,0.99], adaptive reheats on stagnation, and multiple restarts.\"\n\"TABU_MOVES_DEF\",\"Define tabu attributes over item additions\/removals (e.g., item indices) with short tenure (5\u201315) and aspiration for improving moves to prevent cycling and allow improvements.\"\n\"TERMINATION_CRITERIA\",\"Add robust termination: max_evals, max_no_improve, and time cap to ensure reproducibility and prevent indefinite runs.\"\n\"RANDOM_SEEDING\",\"Inject PRNG seed via other_params for reproducibility during evaluation; log seed and key parameters.\"\n\"RESULTS_DIAGNOSIS\",\"Current SA\/ILS best costs are strictly dominated by a feasible 3-item combination; search is stalling short of the optimum. Prioritize fixing signatures, import, and perturbation to enable deeper neighborhoods.\"\n\"ACTIONABLE_TESTS\",\"Add unit tests: (a) parsing canonicalization round-trip, (b) neighbour feasibility invariants, (c) perturb preserves\/recovers feasibility, (d) heuristic signature conformance, (e) end-to-end: reach a known feasible reference within 1000 evals.\"\n\"METRICS_REPORTING\",\"Log: evals_used, feasible_rate, best_cost, plateau_length, operator frequencies, and move acceptance to identify operator underperformance and tune biases.\"\n\"COMPUTATION_CHECK\",\"Use evaluate_solution to assert feasibility after every move and before accepting; reject any move returning penalty without passing to acceptance logic.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST_SORTED: comma-separated 1-based indices in strictly increasing order; \"\" means no items.","Componentes":{"REPRESENTATION":"INDEX_LIST_SORTED: comma-separated 1-based indices in strictly increasing order; \"\" means no items.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a cost to minimize: feasible => -total_value; infeasible\/invalid => large positive penalty.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n    PENALTY = 1e12\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return PENALTY\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        if total_w > C:\n            return PENALTY\n        total_v += values[k-1]\n    return -float(total_v)\n","NB_CODE":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood on normalized index-list representation; preserves feasibility.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return None\n            k = int(p)\n            if not (1 <= k <= n):\n                return None\n            if k in seen:\n                continue\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list(solution)\n    if cur is None:\n        # Seed: best feasible single item by value density\n        candidates = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if weights[i] <= C]\n        if not candidates:\n            return '', (\"INDEX_LIST\", \"seed\")\n        candidates.sort(reverse=True)\n        return str(candidates[0][2]), (\"INDEX_LIST\", \"seed\")\n\n    W = cur_weight(cur)\n    cur_set = set(cur)\n\n    # Build operation sets\n    addable = [k for k in range(1, n+1) if (k not in cur_set and W + weights[k-1] <= C)]\n    ops = []\n    if addable:\n        ops.append('add')\n    if cur:\n        ops.append('remove')\n\n    # 1-for-1 swaps\n    swap_pairs = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            for add in range(1, n+1):\n                if add in cur_set or add == rem:\n                    continue\n                if Wr + weights[add-1] <= C:\n                    swap_pairs.append((rem, add))\n        if swap_pairs:\n            ops.append('swap')\n\n    # 1-for-2 and 2-for-1 exchanges (light diversification)\n    one_for_two = []\n    if cur:\n        for rem in cur:\n            Wr = W - weights[rem-1]\n            cand = [k for k in range(1, n+1) if k not in cur_set and k != rem]\n            ranked = sorted(cand, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:8]\n            L = len(ranked)\n            for a in range(L):\n                for b in range(a+1, L):\n                    if Wr + weights[ranked[a]-1] + weights[ranked[b]-1] <= C:\n                        one_for_two.append((rem, ranked[a], ranked[b]))\n        if one_for_two:\n            ops.append('1for2')\n\n    two_for_one = []\n    if len(cur) >= 2:\n        m = len(cur)\n        for i in range(m):\n            for j in range(i+1, m):\n                Wr = W - weights[cur[i]-1] - weights[cur[j]-1]\n                for add in range(1, n+1):\n                    if add in cur_set:\n                        continue\n                    if Wr + weights[add-1] <= C:\n                        two_for_one.append(((cur[i], cur[j]), add))\n        if two_for_one:\n            ops.append('2for1')\n\n    if not ops:\n        return pack_str(cur), (\"INDEX_LIST\", \"noop\")\n\n    op = random.choice(ops)\n\n    if op == 'add':\n        dens = [values[k-1]\/weights[k-1] for k in addable]\n        mx = max(dens)\n        probs = [math.exp(3.0*(d-mx)) for d in dens]\n        s = sum(probs)\n        r = random.random()*s\n        acc = 0.0\n        choice = addable[-1]\n        for k, p in zip(addable, probs):\n            acc += p\n            if r <= acc:\n                choice = k\n                break\n        new = sorted(cur + [choice])\n        return pack_str(new), (\"INDEX_LIST\", \"add\")\n\n    if op == 'remove':\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        pick = ranked[0] if len(ranked) == 1 else random.choice(ranked[:2])\n        new = [x for x in cur if x != pick]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"remove\")\n\n    if op == 'swap':\n        rem, add = random.choice(swap_pairs)\n        new = [x for x in cur if x != rem] + [add]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"swap\")\n\n    if op == '1for2':\n        rem, a, b = random.choice(one_for_two)\n        new = [x for x in cur if x != rem] + [a, b]\n        return pack_str(sorted(new)), (\"INDEX_LIST\", \"1for2\")\n\n    # op == '2for1'\n    (r1, r2), add = random.choice(two_for_one)\n    new = [x for x in cur if x not in (r1, r2)] + [add]\n    return pack_str(sorted(new)), (\"INDEX_LIST\", \"2for1\")\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution: str) -> str:\n    # Feasibility-preserving perturbation: drop 1-2 low-density items; greedy refill; best-improving single swap.\n    weights = (11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9)\n    values  = (15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17)\n    C = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = []\n        seen = set()\n        for p in parts:\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and (k not in seen):\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def pack_str(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def cur_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def total_value(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    def greedy_fill(current):\n        W = cur_weight(current)\n        cur_set = set(current)\n        items = [(values[i]\/weights[i], values[i], i+1) for i in range(n) if (i+1) not in cur_set]\n        items.sort(reverse=True)\n        for _, _, k in items:\n            w = weights[k-1]\n            if W + w <= C:\n                current.append(k)\n                W += w\n        current.sort()\n        return current\n\n    cur = parse_index_list(solution)\n\n    if cur == []:\n        # deterministic greedy seed\n        base = []\n        base = greedy_fill(base)\n        cur = base\n\n    # Drop 1-2 lowest density items\n    r = 1 if len(cur) < 2 else random.choice((1, 2))\n    if cur:\n        ranked = sorted(cur, key=lambda k: (values[k-1]\/max(1, weights[k-1]), values[k-1]))\n        remove_set = set(ranked[:r])\n        cur = [k for k in cur if k not in remove_set]\n        cur.sort()\n\n    # Greedy refill by density\n    cur = greedy_fill(cur)\n\n    # Single best-improving swap with candidates among top-6 densities not in current\n    W = cur_weight(cur)\n    cur_set = set(cur)\n    candidates = [k for k in range(1, n+1) if k not in cur_set]\n    ranked_add = sorted(candidates, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)[:6]\n\n    best = cur[:]\n    best_val = total_value(best)\n\n    for rem in cur:\n        Wr = W - weights[rem-1]\n        for add in ranked_add:\n            if Wr + weights[add-1] <= C:\n                trial = [x for x in cur if x != rem] + [add]\n                trial.sort()\n                tv = total_value(trial)\n                if tv > best_val:\n                    best = trial\n                    best_val = tv\n    return pack_str(best)\n","SAMPLE_SOL":"4,8,18"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nE_SIGNATURE_MISMATCH:Target heuristic signature violated. Expected def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Observed SA\/TS variants using different parameters\/arity. Align all solvers to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_TABU_RUNTIME:Taboo_Search raised 'not enough values to unpack (expected 2, got 1)'. Likely unpacking return from generate_neighbour incorrectly. generate_neighbour returns (new_solution, (rep,move)). Update Tabu to unpack exactly two objects and ignore\/record move metadata without further unpacking.\nE_SA_SIGNATURE:Simulated_Annealing uses def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) per error text. Do not call functions in signature; accept function objects. Remove parentheses and consolidate params to match TARGET_HEURISTIC_GENERAL_SIGNATURE.\nE_PERTURB_MISSING:Perturbation function undefined ($Perturb placeholder). Provide a no-op or light-shuffle perturbation with same representation. Ensure feasibility preservation or re-evaluate after perturb.\nE_EVAL_INCONSISTENT:Reported scores do not match evaluate_solution. Example: '8,14,18' must evaluate to a different negative value than shown; '2,4,14' also mismatched. Ensure every score originates from a single call to evaluate_solution with no manual transformation and that maximization is enforced via negative cost.\nE_STATE_REPORTING:Simulated_Annealing output mixes current and best solution with identical score. Emit tuple (final_current,final_best,best_score) only after final temperature. For intermediate logs, ensure consistency: score(current)==evaluate_solution(current) and best_score==min(best_score, current_score).\nE_FEASIBILITY_ENFORCEMENT:ILS\/SA should never carry infeasible solutions since neighbor preserves feasibility. Add assert evaluate_solution(sol)<PENALTY before accepting states. If allowing infeasible exploration, adjust acceptance and tabu checks to use penalty guard.\nE_REPR_NORMALIZATION:Ensure all solver states pass through the same normalizer as generate_neighbour.pack_str. Reject or normalize any unsorted\/duplicated index lists before evaluation to prevent accidental penalties.\nE_RANDOMNESS_SEED:Stochastic ops (add\/remove\/swap) use random without seeding. Add deterministic seeding via parameter in other_params to reproduce results and debug discrepancies.\nE_ACCEPTANCE_POLICY:SA likely misuses temperature schedule and acceptance test. Confirm \u0394=neighbor_cost-current_cost (minimization). Accept if \u0394<=0 else with p=exp(-\u0394\/T). Cooling must update T<-T*cooling_factor and stop at MIN_TEMP; never reheat inadvertently.\nE_NEIGHBOR_SCOPE:Neighborhood lacks 2-for-2 exchanges and value-aware pruning beyond top-8 for 1-for-2, which can bias exploration. For small C with many light items, add 2-for-2 and widen candidate pool adaptively when stagnating.\nE_REMOVE_HEURISTIC:Remove picks by density but randomizes among top-2; this can discard high-value singletons when C is tight. Prefer deterministic removal of worst marginal contribution relative to current composition or apply reverse-greedy drop with lookahead.\nE_TERMINATION_CRITERIA:No clear stopping or stagnation thresholds described. Add max_iters, max_no_improve, and time budget; in ILS, trigger perturb after k no-improve steps.\nE_TABU_LIST:Tabu likely tracking raw strings or moves inconsistently. Track moves as frozenset of indices for swaps, and solutions via hashing normalized strings. Use aspiration if a candidate beats best_score even if tabu.\nE_DIVERSIFICATION:Current 1-for-2 uses top-8 by density only. Introduce biased-but-broader sampling with softmax over densities and occasional uniform picks to escape structural bias.\nE_BASELINE_VALIDATION:Add exact DP evaluator (O(n*C)) offline for unit tests to verify solver outputs match evaluator optimum on this instance. Use only for validation, not inside stochastic runs.\nE_LOGGING_CONTRACT:Standardize result tuple shape across solvers: (final_current, final_current_score, best_solution, best_score, extras_dict). Extras may include move counts and acceptance ratios; avoid overloading positions.\nR_PERTURB_SPEC:For ILS, use small k-swap perturb (e.g., remove up to 2 items then greedily refill by density under C). Guarantee feasibility by re-checking capacity after each add.\nR_REHEAT_POLICY:If SA stagnates (no improvement for s steps), optionally reheat T<-alpha*T0 with alpha in [0.2,0.5] while preserving best state; cap number of reheats to prevent cycling.\nR_NEIGHBOR_COST_CACHE:Cache evaluate_solution results for visited states in a dict to avoid recomputation; normalized string keys prevent duplication.\nR_PARAM_TUNING:Increase add-operator softmax temperature factor from 3.0 adaptively when plateauing to broaden exploration; decay back when improvements resume.\nASSERT_CORRECTNESS_CHECK:Using the provided evaluate_solution, the known optimality check confirms the evaluator\u2019s scoring and feasibility rules are consistent; your reported best from one run matches this check. Keep this as a unit test and do not disclose the optimal details in logs.\nACTION_ITEMS:\n- Unify all solver signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE.\n- Implement missing perturb_solution; pass via other_params.\n- Fix evaluation pipeline so every printed score equals evaluate_solution(sol).\n- Add asserts on feasibility and normalized representation at all state transitions.\n- Standardize result tuple and logging; remove ambiguous outputs.\n- Introduce DP-based unit test to verify solver correctness offline.\n- Add seed control, stopping criteria, and acceptance corrections to SA\/Tabu\/ILS.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Evaluate an INDEX_LIST solution for 0\/1 knapsack under budget using minimization (negative value for maximization)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    \n    # Type and content checks\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    # Return negative (we minimize) so that larger value => smaller (better) score\n    return -float(total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_type_str)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n\n    # Defensive copy and sanitize to INDEX_LIST distinct ints within 1..24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = []\n        seen = set()\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n    \n    def total_cost(lst):\n        return sum(costs[i-1] for i in lst)\n\n    current_cost = total_cost(sol)\n\n    items = list(range(1, 25))\n    not_in = [i for i in items if i not in sol]\n\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap\")\n    if not moves:\n        return (sol, \"none\")\n\n    # Try up to some attempts to find a feasible neighbor\n    for _ in range(50):\n        move = random.choice(moves)\n        new_sol = list(sol)\n        if move == \"add\":\n            i = random.choice(not_in)\n            if current_cost + costs[i-1] <= budget:\n                new_sol.append(i)\n                return (sorted(new_sol), \"add\")\n        elif move == \"remove\":\n            i = random.choice(new_sol)\n            new_sol.remove(i)\n            return (sorted(new_sol), \"remove\")\n        else:  # swap\n            i_out = random.choice(new_sol)\n            i_in = random.choice(not_in)\n            new_cost = current_cost - costs[i_out-1] + costs[i_in-1]\n            if new_cost <= budget:\n                new_sol.remove(i_out)\n                new_sol.append(i_in)\n                return (sorted(new_sol), \"swap\")\n    # Fallback: if no feasible add\/swap found, try remove if possible, else return original\n    if sol:\n        i = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(i)\n        return (sorted(new_sol), \"remove\")\n    return (sol, \"none\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply several random feasible moves to diversify while respecting budget\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        # sanitize\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n\n    def feasible(lst):\n        return sum(costs[i-1] for i in lst) <= budget\n\n    def total_cost(lst):\n        return sum(costs[i-1] for i in lst)\n\n    items = list(range(1, 25))\n    k = random.randint(2, 4)\n    curr = sorted(sol)\n    for _ in range(k):\n        items_not = [i for i in items if i not in curr]\n        moves = []\n        if items_not:\n            moves.append(\"add\")\n        if curr:\n            moves.append(\"remove\")\n        if curr and items_not:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        move = random.choice(moves)\n        if move == \"add\":\n            cand = random.sample(items_not, min(len(items_not), 3))\n            random.shuffle(cand)\n            done = False\n            for i in cand:\n                if total_cost(curr) + costs[i-1] <= budget:\n                    curr.append(i)\n                    curr = sorted(curr)\n                    done = True\n                    break\n            if not done and curr:\n                # fallback remove\n                rem = random.choice(curr)\n                curr.remove(rem)\n        elif move == \"remove\":\n            rem = random.choice(curr)\n            curr.remove(rem)\n        else:  # swap\n            if curr and items_not:\n                out = random.choice(curr)\n                ins = random.choice(items_not)\n                new_cost = total_cost(curr) - costs[out-1] + costs[ins-1]\n                if new_cost <= budget:\n                    curr.remove(out)\n                    curr.append(ins)\n                    curr = sorted(curr)\n                else:\n                    # fallback: try remove\n                    rem = random.choice(curr)\n                    curr.remove(rem)\n    return sorted(curr)\n","SAMPLE_SOL":"[4,8,18]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix-typing-annotations-perturb-neigh-delta\"\n\"FEEDBACK\",\"E_RUNTIME_TYPING:Importing typing.List\/typing.Tuple triggers framework instantiation error ('Type List cannot be instantiated'). Remove 'from typing import List, Tuple' and any typing-based return annotations. Use only built-in 'list', 'tuple', and '-> float'.\"\n\"E_EVAL_SIG:Do not annotate with typing types. Keep 'def evaluate_solution(solution) -> float:' only. Avoid List in annotations anywhere.\"\n\"E_LOCAL_SOLVER_ERR_VERIFY:Evaluating SAMPLE_SOL [4,8,18] with current evaluation returns finite negative score; primary failure is typing import\/annotation. After removing typing imports\/annotations, re-run local solvers.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Neighbour function imports typing and may be parsed for annotations. Remove typing imports and string-literal tuple annotation. Use no annotations or a plain return.\"\n\"NB_GEN_FEASIBILITY:Random 50-attempt cap risks returning many 'remove' fallbacks and weak exploration near tight budget. Add targeted feasibility for add\/swap via prefiltered candidate lists by residual capacity.\"\n\"NB_COST_COMP:total_cost recomputed via sum() in helper each call; O(k) per check. Maintain and update current_cost incrementally for candidate moves to avoid recomputation.\"\n\"NB_MOVE_QUALITY:Moves limited to single add\/remove\/swap. This is weak near tight budget. Add multi-swap (1-1, 2-1, 1-2) and greedy-improving swap neighborhood (try top-gain candidates within residual capacity).\"\n\"NB_SELECTION_BIAS:Uniform random selection wastes iterations on infeasible adds. Bias 'add' candidates by value\/weight ratio and prefilter by residual capacity.\"\n\"NB_DUP_SORT:Sorting on every return adds overhead and perturbs order. Maintain canonical sorted list only when needed or represent as sorted set; otherwise avoid sort on every move.\"\n\"EVAL_COMPLEXITY:Evaluation is O(k) and fully re-computed per call. Implement delta evaluation (track total_cost, total_value; update on move) to reduce complexity in local search loops.\"\n\"EVAL_REPAIR:Hard-infeasible returns inf for over-budget during iteration; this blocks tabu\/SA exploration. Provide a repair operator (drop lowest-profit items until feasible) before scoring to keep search progressing.\"\n\"PERTURB_MISSING:Placeholder '$Perturb' is invalid. Implement a concrete perturbation: e.g., remove t random items, then greedy refill by ratio until capacity; choose t from {1..3} based on stagnation.\"\n\"SA_PARAMS:If using SA, set temperature schedule explicitly and consistent with negative-objective convention. Use acceptance on delta_score (remember more negative is better).\"\n\"TS_TABU_TENURE:For Tabu Search, introduce tabu tenure on items (add\/remove) keyed by item indices; aspiration if new_score < best_score.\"\n\"ILS_KICK:For Iterated Local Search, use adaptive kick size proportional to no-improve iterations; ensure kick preserves feasibility via immediate repair.\"\n\"OBJ_SIGN_CONSISTENCY:Heuristics must treat lower scores as better (negative for maximization). Verify all comparisons, acceptance, and aspiration use 'new_score < best_score'.\"\n\"R_INIT:Initialization unspecified. Provide deterministic constructive start (empty then greedy by ratio under budget) to ensure reproducibility and strong baseline.\"\n\"BOUND_CHECKS:Current evaluation rejects duplicates and out-of-range; keep. Also sanitize neighbour inputs similarly (already done) but remove redundant resorting and recomputation.\"\n\"DIAG_EXTRA_OUTPUTS:Local solver expects extra outputs. Ensure neighbour returns (neighbor_solution, movement_type) and solvers log move_type, delta, temperature\/tenure step.\"\n\"TEST_ASSERTIONS:Add unit checks: evaluate_solution([]) == -0.0; infeasible add returns inf; neighbour never returns over-budget; repeated calls produce diverse feasible neighbors.\"\n\"CODE_STYLE_MIN:Remove unused imports (math, typing). No filesystem\/network\/OS access per CRITICAL_INSTRUCTIONS.\"\n\"KNOWN_BEST_CHECK:Evaluation of provided sample solution returns finite negative score via independent Python check; maintain this as a regression test without embedding the reference value.\"\n\"ACTION_ITEMS:1) Strip typing imports\/annotations. 2) Implement concrete perturb(). 3) Add delta evaluation and feasibility-aware neighbor generation. 4) Enforce objective sign in all solvers. 5) Add repair and multi-swap neighborhood. 6) Add diagnostics for extra outputs (move_type, delta, cost\/value).\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Type check and sanitize\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    # Minimization score for a maximization problem: negate value\n    return -float(total_value)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Sanitize to canonical INDEX_LIST (sorted unique valid ints)\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    n = 24\n    in_set = set(sol)\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    def cost_of(lst):\n        s = 0\n        for i in lst:\n            s += costs[i-1]\n        return s\n\n    current_cost = cost_of(sol)\n    residual = budget - current_cost\n\n    # Precompute ratios for biasing candidate adds\n    ratio = [(i, values[i-1] \/ costs[i-1]) for i in range(1, n+1)]\n    ratio.sort(key=lambda x: x[1], reverse=True)\n\n    # Candidate moves\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap_1_1\")\n    if len(not_in) >= 2 and sol:\n        moves.append(\"swap_2_1\")\n    if len(sol) >= 2 and not_in:\n        moves.append(\"swap_1_2\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    # Helper to finalize solution (sorted, unique)\n    def finalize(lst):\n        return sorted(set(lst))\n\n    # Attempt multiple times to find a feasible, diverse neighbor\n    for _ in range(64):\n        move = random.choices(moves, weights=[3 if m==\"add\" else 2 if m.startswith(\"swap\") else 1 for m in moves], k=1)[0]\n        new_sol = list(sol)\n        new_in_set = set(new_sol)\n        new_cost = current_cost\n\n        if move == \"add\":\n            # Consider top-k by ratio that fit residual\n            candidates = [i for (i, r) in ratio if i not in new_in_set and costs[i-1] <= residual]\n            if candidates:\n                i = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                new_sol.append(i)\n                new_cost += costs[i-1]\n                if new_cost <= budget:\n                    return (finalize(new_sol), \"add\")\n        elif move == \"remove\":\n            i = random.choice(new_sol)\n            new_sol.remove(i)\n            return (finalize(new_sol), \"remove\")\n        elif move == \"swap_1_1\":\n            out = random.choice(new_sol)\n            ins_candidates = [i for i in not_in if costs[i-1] - costs[out-1] <= residual]\n            if ins_candidates:\n                # bias by ratio\n                ins_candidates.sort(key=lambda i: values[i-1]\/costs[i-1], reverse=True)\n                ins = random.choice(ins_candidates[:max(1, min(5, len(ins_candidates)))])\n                new_sol.remove(out)\n                new_sol.append(ins)\n                new_cost = current_cost - costs[out-1] + costs[ins-1]\n                if new_cost <= budget:\n                    return (finalize(new_sol), \"swap_1_1\")\n        elif move == \"swap_2_1\":\n            if len(new_sol) >= 2:\n                outs = random.sample(new_sol, 2)\n                # pick ins that fits\n                freed = costs[outs[0]-1] + costs[outs[1]-1]\n                ins_fit = [i for i in not_in if costs[i-1] - freed <= residual]\n                if ins_fit:\n                    ins_fit.sort(key=lambda i: values[i-1]\/costs[i-1], reverse=True)\n                    ins = random.choice(ins_fit[:max(1, min(5, len(ins_fit)))])\n                    new_cost = current_cost - freed + costs[ins-1]\n                    if new_cost <= budget:\n                        new_sol = [x for x in new_sol if x not in outs]\n                        new_sol.append(ins)\n                        return (finalize(new_sol), \"swap_2_1\")\n        else:  # swap_1_2\n            out = random.choice(new_sol)\n            # choose two distinct to add\n            add_pool = [i for i in not_in if i != out]\n            if len(add_pool) >= 2:\n                ins_pair = random.sample(add_pool, 2)\n                added_cost = costs[ins_pair[0]-1] + costs[ins_pair[1]-1]\n                new_cost = current_cost - costs[out-1] + added_cost\n                if new_cost <= budget and ins_pair[0] not in new_in_set and ins_pair[1] not in new_in_set:\n                    new_sol.remove(out)\n                    new_sol.extend(ins_pair)\n                    return (finalize(new_sol), \"swap_1_2\")\n\n    # Fallback: remove a random item if any, else return as is\n    if sol:\n        i = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(i)\n        return (finalize(new_sol), \"remove\")\n    return (sol, \"none\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Sanitize input\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def total_cost(lst):\n        s = 0\n        for i in lst:\n            s += costs[i-1]\n        return s\n\n    # Remove t random items (kick), then greedy refill by value\/weight ratio\n    t = 1 if len(sol) <= 1 else min(3, max(1, len(sol)\/\/2))\n    sol2 = list(sol)\n    if sol2:\n        k = min(t, len(sol2))\n        to_remove = random.sample(sol2, k)\n        for i in to_remove:\n            sol2.remove(i)\n\n    # Greedy refill\n    in_set = set(sol2)\n    candidates = [(i, values[i-1] \/ costs[i-1]) for i in range(1, 25) if i not in in_set]\n    candidates.sort(key=lambda x: x[1], reverse=True)\n\n    cur_cost = total_cost(sol2)\n    for i, _ in candidates:\n        c = costs[i-1]\n        if cur_cost + c <= budget:\n            sol2.append(i)\n            cur_cost += c\n\n    sol2 = sorted(set(sol2))\n    # Ensure feasibility (repair if needed, though greedy preserves it)\n    while total_cost(sol2) > budget and sol2:\n        # drop the lowest value density item\n        sol2.sort(key=lambda i: values[i-1] \/ costs[i-1])\n        sol2.pop(0)\n    return sol2\n","SAMPLE_SOL":"[4,8,18]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"FIX_SIG_MISMATCH:Heuristic signature deviates per solver. Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE across all solvers or provide adapters. Current Taboo_Search unpacking expects 2 return values; neighbor\/SA produce more. Standardize call\/return contracts to stop runtime failure.\nFIX_TABU_CALL:Taboo_Search error 'too many values to unpack' indicates solver assumes neighbour returns solution only. Add an adapter: unwrap (neighbor, move_type) or change solver to accept tuple and ignore move_type.\nPERTURB_MISSING:$Perturb is a placeholder. Provide a concrete perturbation operator (e.g., multi-remove-add with capacity-aware greedy refill) to enable ILS diversification.\nEVAL_CORRECTNESS_ASSERTED:Evaluation verified against internal reference optimum; scoring sign convention is consistent.\nE_EARLY_INF_PENALTY:Returning inf for minor infeasibilities blocks gradient-like guidance. Replace hard inf with additive penalty proportional to budget violation to preserve comparability and enable guided recovery.\nNB_RET_CONTRACT_INCONSISTENT:generate_neighbour returns (solution, movement_type). Some solvers expect solution only. Unify: either always return solution, or always return (solution, meta) and update all solvers.\nNB_PERF_RATIO_RECOMPUTE:Ratios recomputed and sorted every call O(n log n). Precompute once and cache; update only if problem data changes to cut overhead.\nNB_PERF_NOT_IN_REBUILD:not_in rebuilt each call O(n). Maintain bitset\/boolean array for membership to reduce to O(1) checks; compute not_in only when needed.\nNB_COST_TRACKING:current_cost and residual recomputed per call; pass (solution_cost, solution_value) along with solution to allow O(1) updates on moves.\nNB_MOVE_FEAS_CHECKS:swap_1_2 feasibility relies on residual from pre-move state; recompute residual after selecting 'out' to tighten feasibility and reduce retries.\nNB_DIVERSITY_LIMIT:64 attempts cap may bias toward remove fallback. Add adaptive move weights (decrease add weight when residual small) and include 'swap_k_k' with small k guided by ratios to avoid stagnation.\nNB_ADD_CANDIDATES:Limiting to top-5 by ratio can prune good combinations. Use stochastic ranking (e.g., softmax over ratio with temperature) to balance exploitation\/exploration.\nNB_REP_CANONICAL_SORT_OVERHEAD:Sorting solution every neighbor O(k log k). Maintain solutions sorted by invariant operations or append and place using binary insertion to reduce to O(log k).\nILS_WEAK_PERTURB:ILS result indicates inadequate escape depth. Increase perturbation strength (e.g., remove 1\u20133 items then greedy refill) and enforce accept-worse with bounded temperature or record-to-record travel.\nSA_PARAM_TUNING:Cooling parameters not shown; risk of premature convergence. Calibrate initial temperature from objective variance over random neighbors; use geometric cooling with reheats on stagnation.\nTABU_MEMORY_DEFICIT:Without explicit tabu tenure\/aspiration, search may cycle. Set tenure ~ sqrt(n) on indices; add aspiration if new solution improves best_score.\nREPRESENTATION_BETTER:INDEX_LIST causes duplicates checks and sorting. Switch to fixed-length bitvector for O(1) membership and faster moves; convert to index list only at I\/O boundaries.\nOBJ_SCALING:Maximization via negation is correct but opaque. Standardize as return tuple (is_feasible, value) and invert only in solver once to prevent double-negation bugs.\nTEST_COVERAGE:Add unit tests: neighbor must preserve feasibility; moves should change solution; evaluation monotonicity under adds\/removes; signature compliance across all solvers.\nASSERT_INTERFACE:Before run, assert callable signatures (Heuristic, generate_neighbour, evaluate_solution, perturb) and neighbor return arity; fail fast with explicit diagnostics.\nREPRO_SEEDS:Set explicit RNG seeds per run and component to reproduce and compare runs; pass seed via other_params and avoid global random state in components.\nTIME_BUDGETING:Collect per-iteration timings; if neighbor generation exceeds budget, lower attempt cap adaptively and bias towards cheap moves (remove\/swap_1_1).\nLOGGING_MINIMAL:Emit only necessary extra outputs: move_type, delta_cost, delta_value; avoid printing full solutions each iteration to reduce overhead and parsing load.\nKNOWN_BEST_HIDE:Do not expose reference optimum in logs or feedback to prevent solver overfitting; validate silently as done above.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Componentes":{"REPRESENTATION":"INDEX_LIST","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Type and content checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e12\n        if idx < 1 or idx > 24:\n            return 1e12\n        if idx in seen:\n            return 1e12\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        total_value += v\n\n    # Penalty for budget violation (soft, preserves guidance)\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        # Strong linear penalty; still comparable across infeasible solutions\n        penalty = 1000.0 * over\n        return -float(total_value) + penalty\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Sanitize to canonical INDEX_LIST (sorted, unique, valid)\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    def cost_of(lst):\n        s = 0\n        for i in lst:\n            s += costs[i - 1]\n        return s\n\n    def value_of(lst):\n        s = 0\n        for i in lst:\n            s += values[i - 1]\n        return s\n\n    current_cost = cost_of(sol)\n    residual = budget - current_cost\n\n    # Precompute value\/weight ratio (local, no global state)\n    ratio = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1)]\n    ratio.sort(key=lambda x: x[1], reverse=True)\n\n    # Candidate move set\n    moves = []\n    if not_in:\n        moves.append(\"add\")\n    if sol:\n        moves.append(\"remove\")\n    if sol and not_in:\n        moves.append(\"swap_1_1\")\n    if len(sol) >= 2 and not_in:\n        moves.append(\"swap_1_2\")\n    if len(not_in) >= 2 and sol:\n        moves.append(\"swap_2_1\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    # Adaptive move weights: prefer removes\/swaps when residual small\n    def move_weights():\n        if residual <= 0:\n            return {\"add\": 0.5, \"remove\": 3.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n        elif residual < 30:\n            return {\"add\": 1.0, \"remove\": 2.0, \"swap_1_1\": 2.5, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n        else:\n            return {\"add\": 3.0, \"remove\": 1.0, \"swap_1_1\": 2.0, \"swap_1_2\": 1.5, \"swap_2_1\": 1.5}\n\n    weights_map = move_weights()\n    weights = [weights_map[m] for m in moves]\n\n    def finalize(lst):\n        # maintain canonical order without duplicates\n        return sorted(set(lst))\n\n    # Utility: pick with softmax bias over top-k candidates by ratio\n    def pick_by_ratio(cands, k_cap=6, temp=0.5):\n        if not cands:\n            return None\n        scored = [(i, values[i - 1] \/ costs[i - 1]) for i in cands]\n        scored.sort(key=lambda x: x[1], reverse=True)\n        pool = scored[: max(1, min(k_cap, len(scored)))]\n        # softmax over ratios\n        mx = max(r for _, r in pool)\n        probs = [math.exp((r - mx) \/ max(1e-9, temp)) for _, r in pool]\n        s = sum(probs)\n        r = random.random() * s\n        acc = 0.0\n        for (i, dens), p in zip(pool, probs):\n            acc += p\n            if r <= acc:\n                return i\n        return pool[-1][0]\n\n    # Attempt to construct a feasible diverse neighbor\n    for _ in range(64):\n        move = random.choices(moves, weights=weights, k=1)[0]\n        new_sol = list(sol)\n        new_in = set(new_sol)\n        base_cost = current_cost\n\n        if move == \"add\":\n            feasible_adds = [i for i in not_in if costs[i - 1] <= residual]\n            if feasible_adds:\n                ins = pick_by_ratio(feasible_adds)\n                if ins is not None:\n                    new_sol.append(ins)\n                    if cost_of(new_sol) <= budget:\n                        return (finalize(new_sol), \"add\")\n        elif move == \"remove\":\n            out = random.choice(new_sol)\n            new_sol.remove(out)\n            return (finalize(new_sol), \"remove\")\n        elif move == \"swap_1_1\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            new_resid = budget - (base_cost - freed)\n            ins_cands = [i for i in not_in if costs[i - 1] <= new_resid]\n            if ins_cands:\n                ins = pick_by_ratio(ins_cands)\n                if ins is not None and ins not in new_in:\n                    new_sol.remove(out)\n                    new_sol.append(ins)\n                    if cost_of(new_sol) <= budget:\n                        return (finalize(new_sol), \"swap_1_1\")\n        elif move == \"swap_1_2\":\n            out = random.choice(new_sol)\n            freed = costs[out - 1]\n            new_resid = budget - (base_cost - freed)\n            add_pool = [i for i in not_in if i != out]\n            if len(add_pool) >= 2:\n                # Try stochastic pair assembly guided by ratio\n                ins1 = pick_by_ratio(add_pool)\n                if ins1 is not None:\n                    add_pool2 = [i for i in add_pool if i != ins1]\n                    # bias second pick as well\n                    ins2 = pick_by_ratio(add_pool2)\n                    if ins2 is not None:\n                        add_cost = costs[ins1 - 1] + costs[ins2 - 1]\n                        if add_cost <= new_resid:\n                            new_sol.remove(out)\n                            new_sol.extend([ins1, ins2])\n                            if cost_of(new_sol) <= budget:\n                                return (finalize(new_sol), \"swap_1_2\")\n        else:  # swap_2_1\n            if len(new_sol) >= 2:\n                outs = random.sample(new_sol, 2)\n                freed = costs[outs[0] - 1] + costs[outs[1] - 1]\n                new_resid = budget - (base_cost - freed)\n                ins_cands = [i for i in not_in if costs[i - 1] <= new_resid]\n                if ins_cands:\n                    ins = pick_by_ratio(ins_cands)\n                    if ins is not None and ins not in new_in:\n                        cand = [x for x in new_sol if x not in outs]\n                        cand.append(ins)\n                        if cost_of(cand) <= budget:\n                            return (finalize(cand), \"swap_2_1\")\n\n    # Fallback: if no feasible neighbor found, remove a random item to ensure movement\n    if sol:\n        i = random.choice(sol)\n        new_sol = list(sol)\n        new_sol.remove(i)\n        return (finalize(new_sol), \"remove\")\n    return (sol, \"none\")\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Sanitize input to canonical INDEX_LIST\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for idx in solution:\n            if isinstance(idx, int) and 1 <= idx <= n and idx not in seen:\n                seen.add(idx)\n                sol.append(idx)\n        sol.sort()\n\n    def total_cost(lst):\n        return sum(costs[i - 1] for i in lst)\n\n    # Kick strength proportional to current size (1..3)\n    k = len(sol)\n    t = 1 if k <= 1 else min(3, max(1, k \/\/ 2))\n\n    sol2 = list(sol)\n    if sol2:\n        remove_cnt = min(t, len(sol2))\n        to_remove = random.sample(sol2, remove_cnt)\n        for i in to_remove:\n            sol2.remove(i)\n\n    # Greedy refill by value density\n    in_set = set(sol2)\n    candidates = [(i, values[i - 1] \/ costs[i - 1]) for i in range(1, n + 1) if i not in in_set]\n    candidates.sort(key=lambda x: x[1], reverse=True)\n\n    cur_cost = total_cost(sol2)\n    for i, _ in candidates:\n        c = costs[i - 1]\n        if cur_cost + c <= budget:\n            sol2.append(i)\n            cur_cost += c\n\n    # Ensure feasibility and canonical form\n    sol2 = sorted(set(sol2))\n    while total_cost(sol2) > budget and sol2:\n        sol2.sort(key=lambda i: values[i - 1] \/ costs[i - 1])\n        sol2.pop(0)\n\n    return sol2\n","SAMPLE_SOL":[4,8,18]},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_LOADER_SAMPLE_SOL_PARSE_FAIL: Local solvers crash with 'list' has no attribute 'strip'. Loader expects a string. Provide SAMPLE_SOL as a delimited string (e.g., '4,8,18') or modify the loader to branch: if isinstance(x, list) return x else parse x.strip().\nE_COMPONENT_MISSING_PERTURB: Perturbation Function unresolved ('$Perturb'). Implement def perturb_solution(solution, other_params): apply k random add\/drop\/swap moves, then greedy-repair to feasibility.\nE_HEURISTIC_WRAPPER_ABSENT: No Heuristic(...) provided. Supply a driver matching signature and returning (new_best_solution, new_best_score, meta) with best_score minimized (negatives for maximization), and expose extra outputs (move_type, temperature\/tabu status, acceptance flags) to satisfy solver logging.\nE_EVAL_CORRECTNESS_CHECK: Verified with internal evaluation that evaluate_solution returns the expected sign for a known feasible reference and applies strong linear penalties for infeasibility. No leakage of reference details in logs. Keep this invariant.\nE_EVAL_PENALTY_SCALE: Penalty 1000*over dominates objective, causing flat landscapes around infeasible areas. Replace with adaptive penalty (\u03bb updated by constraint violation rate) or switch to mandatory greedy repair before scoring to keep scores comparable.\nE_EVAL_DUP_DATA: costs\/values duplicated in multiple components. Centralize in a single get_problem() to prevent drift; pass references via other_params.\nE_NEIGH_COST_RECOMP: Multiple O(|S|) cost_of calls per iteration. Maintain incremental sums (current_cost, current_value) and update in O(1) per tentative move; validate feasibility using deltas.\nE_NEIGH_MOVE_SET_GAPS: No greedy fill after remove\/swap. Add a greedy-fill phase (ratio-guided) to pack residual capacity before returning a neighbor for stronger intensification.\nE_NEIGH_SWAP_1_2_EFFICIENCY: Stochastic pair selection causes many failed trials. Replace with bounded enumeration of top-k by ratio with two-sum feasibility check under new_resid; early-exit on first improving feasible pair.\nE_NEIGH_REDUNDANCY: Condition i != out in add_pool is redundant since out \u2208 sol, not in not_in. Remove to reduce confusion.\nE_NEIGH_DIVERSIFICATION_LIMITED: Softmax over top-k=6 narrows exploration. Randomize k within [6,12] when stuck or temperature high; occasionally sample uniformly from feasible adds to escape local basins.\nE_NEIGH_RETRY_BUDGET: Hard cap of 64 attempts may be insufficient near tight budgets. Use adaptive cap proportional to |not_in| and residual scarcity, or fallback to targeted remove+greedy-fill instead of random remove.\nE_RNG_REPRODUCIBILITY: Random source not injectable. Accept rng from other_params (seedable Random instance) and avoid module-level random for deterministic benchmarking.\nE_SIGNATURE_CONSISTENCY: generate_neighbour returns (list, move_type). Ensure all local solvers expect exactly this shape; if some expect only the neighbor, provide a thin adapter in Heuristic.\nE_CONSTRAINT_HANDLING_STRATEGY: Current scheme allows infeasible intermediate scoring (with huge penalties). Prefer feasibility-preserving neighbor generation plus a repair operator; reserve penalties for last resort only.\nE_LOCAL_SOLVER_IO_EXPECTATIONS: Solvers indicate 'extra outputs expected'. Ensure Heuristic returns a dict of step telemetry {move, old_score, new_score, accepted, temp\/tabu_state}, and expose a trajectory list for post-analysis.\nE_KNOWN_BEST_EVAL_ASSERTION: Internal check performed comparing evaluate_solution against a reference feasible configuration; outputs matched expected direction and magnitude sign. Keep regression test to assert invariants on CI.\nE_PERF_PROFILE: Current neighbor generation repeatedly recomputes not_in and sorts; cache sets\/lists and reuse across micro-iterations within a step to reduce overhead.\nE_MOVE_WEIGHTS_STATICITY: Move weights switch in 3 regimes only. Make them adaptive to recent acceptance\/improvement rates (e.g., reinforcement: upweight moves yielding improvements in last N steps).\nE_START_SOLUTION_PIPELINE: On invalid or empty inputs, neighbor canonicalizes to []. Provide an initializer (greedy by ratio with feasibility) in Heuristic to avoid starting from empty unless specified.\nE_API_CONTRACT: Heuristics value best as lesser cost (negatives). Verify best_score comparisons use < and avoid accidental > which would invert optimization and stall progression.\nR_FIX_1: Change SAMPLE_SOL serialization to a string and update loader parsing to accept both str and list safely.\nR_FIX_2: Implement perturb_solution with k\u2208{2..4} random moves and a deterministic greedy repair to feasibility.\nR_FIX_3: Add Heuristic wrapper orchestrating SA\/ILS\/TS calls; return best_solution, best_score, and telemetry.\nR_FIX_4: Replace penalty with adaptive \u03bb, or enforce feasibility-only neighbors plus repair.\nR_FIX_5: Refactor neighbor to maintain incremental cost\/value; add greedy-fill; improve swap_1_2 with bounded enumeration; inject rng via other_params; add adaptive move weighting.\nR_FIX_6: Centralize problem data and pass references; remove redundant checks; cache candidate pools per step; increase retry cap adaptively with a smarter fallback.\nR_TESTS_1: Unit tests for evaluate_solution: type checks, bounds, duplicates, feasibility, penalty scaling. Property tests for generate_neighbour: returns canonical INDEX_LIST, feasibility-preserving (post-repair), and diversity coverage over 1e3 samples.\nR_METRICS: Track acceptance rate, improvement rate, time\/step, and neighbor feasibility ratio; auto-tune parameters if metrics degrade.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Componentes":{"REPRESENTATION":"BIN_STR_LEN24_0_1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). For feasible solutions: cost = -total_value.\n    # Infeasible\/invalid solutions receive a very large positive penalty.\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18\n    # Validate type and structure\n    if not isinstance(solution, str):\n        return PENALTY\n    if len(solution) != 24:\n        return PENALTY\n    if any(c not in '01' for c in solution):\n        return PENALTY\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution, start=1):\n        if c == '1':\n            v, w = offers[i]\n            total_w += w\n            total_v += v\n    if total_w > CAP:\n        return PENALTY\n    return float(-total_v)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, movement_label)\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    # Validate\/normalize input\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n    bits = list(solution)\n\n    # Helper to compute current weight\n    def current_weight(bs):\n        w = 0\n        for idx, c in enumerate(bs, start=1):\n            if c == '1':\n                w += offers[idx][1]\n        return w\n\n    # Attempt one of several neighborhood moves\n    move_type = random.choice(['flip', 'add_or_remove', 'exchange'])\n\n    if move_type == 'flip':\n        i = random.randrange(24)\n        bits[i] = '0' if bits[i] == '1' else '1'\n        return (''.join(bits), 'flip@%d' % (i+1))\n\n    if move_type == 'add_or_remove':\n        # Try to add a random feasible 0-bit; if none, remove a random 1-bit\n        cur_w = current_weight(bits)\n        remaining = CAP - cur_w\n        zero_idxs = [i for i, c in enumerate(bits, start=1) if c == '0']\n        feasible_add = [i for i in zero_idxs if offers[i][1] <= remaining]\n        if feasible_add:\n            i = random.choice(feasible_add) - 1\n            bits[i] = '1'\n            return (''.join(bits), 'add@%d' % (i+1))\n        one_idxs = [i for i, c in enumerate(bits, start=1) if c == '1']\n        if one_idxs:\n            i = random.choice(one_idxs) - 1\n            bits[i] = '0'\n            return (''.join(bits), 'remove@%d' % (i+1))\n        return (''.join(bits), 'noop')\n\n    if move_type == 'exchange':\n        # Turn off one 1-bit, turn on one 0-bit that fits\n        one_idxs = [i for i, c in enumerate(bits, start=1) if c == '1']\n        zero_idxs = [i for i, c in enumerate(bits, start=1) if c == '0']\n        if not one_idxs or not zero_idxs:\n            # Fallback to flip\n            j = random.randrange(24)\n            bits[j] = '0' if bits[j] == '1' else '1'\n            return (''.join(bits), 'flip@%d' % (j+1))\n        i_off = random.choice(one_idxs)\n        bits[i_off-1] = '0'\n        # compute remaining capacity after turning off\n        cur_w = sum(offers[k][1] for k, c in enumerate(bits, start=1) if c == '1')\n        remaining = CAP - cur_w\n        feasible_on = [j for j in zero_idxs if offers[j][1] <= remaining]\n        if feasible_on:\n            j_on = random.choice(feasible_on)\n            bits[j_on-1] = '1'\n            return (''.join(bits), 'exchange@%d->%d' % (i_off, j_on))\n        else:\n            # keep the turned off move if no feasible add\n            return (''.join(bits), 'remove@%d' % (i_off))\n\n    # Fallback (should not reach)\n    return (''.join(bits), 'noop')\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple random edits plus greedy repair to feasibility\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    # Random flips\/adds\/removes\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        mv = random.choice(['flip', 'add', 'remove'])\n        if mv == 'flip':\n            i = random.randrange(24)\n            bits[i] = '0' if bits[i] == '1' else '1'\n        elif mv == 'add':\n            zeros = [i for i, c in enumerate(bits) if c == '0']\n            if zeros:\n                i = random.choice(zeros)\n                bits[i] = '1'\n        else:\n            ones = [i for i, c in enumerate(bits) if c == '1']\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n\n    # Repair to feasibility: if overweight, drop lowest value density first; if underweight, try add best-fit by value\/weight\n    def total_w(bs):\n        w = 0\n        for idx, c in enumerate(bs, start=1):\n            if c == '1':\n                w += offers[idx][1]\n        return w\n\n    def vw(idx):\n        v, w = offers[idx]\n        return v, w\n\n    # Remove until feasible\n    while total_w(bits) > CAP:\n        ones = [i+1 for i, c in enumerate(bits) if c == '1']\n        if not ones:\n            break\n        # pick removal with lowest value density v\/w (prefer removing high weight low value)\n        i_remove = min(ones, key=lambda k: (vw(k)[0] \/ vw(k)[1], -vw(k)[1]))\n        bits[i_remove-1] = '0'\n\n    # Try greedy additions by best value\/weight that fits\n    improved = True\n    while improved:\n        improved = False\n        remaining = CAP - total_w(bits)\n        zeros = [i+1 for i, c in enumerate(bits) if c == '0']\n        candidates = [i for i in zeros if vw(i)[1] <= remaining]\n        if candidates:\n            best = max(candidates, key=lambda k: (vw(k)[0] \/ vw(k)[1], vw(k)[0]))\n            if vw(best)[1] <= remaining:\n                bits[best-1] = '1'\n                improved = True\n    return ''.join(bits)\n","SAMPLE_SOL":"010100010000010000000000"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_SAMPLESOL_LITERAL:Loader interprets unquoted 24-bit string as an integer; leading zeros trigger a syntax error. Store SAMPLE_SOL as a quoted string (e.g., '010...'), or as JSON string, not as a bare literal.\nFIX_PERTURB_FN:Perturbation Function is missing ('$Perturb' placeholder). Provide a concrete feasibility-aware perturbation that returns a valid BIN_STR_LEN24_0_1.\nFIX_HEURISTIC_SIGNATURE:Heuristic entrypoint with signature def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) is absent. Implement and wire all callbacks explicitly.\nEVAL_PENALTY_MAGNITUDE:Penalty=1e18 can destabilize acceptance probabilities and numeric comparisons. Use a bounded large penalty (e.g., 1e6) or prefer feasibility-preserving neighborhoods\/repair to avoid penalized states.\nEVAL_REDUNDANT_LOOKUPS:Dict lookups inside the loop induce overhead. Pre-extract value and weight arrays (v[24], w[24]) and avoid per-iteration dict access to reduce evaluation time.\nNB_FEASIBILITY:flip and exchange can output infeasible strings; reliance on penalty harms search. Enforce feasibility in all moves via repair: if overweight, iteratively drop items with lowest marginal value density until weight<=CAP, then greedily refill.\nNB_CODE_PERF:current_weight recomputed O(n) repeatedly; in exchange you recompute sum after a toggle. Maintain current (weight,value) and apply O(1) deltas per bit flip.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood is too weak and unguided. Add 1-1 swap (drop i, add j maximizing gain under capacity) and k-drop-add (k in {2,3}) using best-improvement to escape shallow basins.\nNB_DIVERSIFICATION:Random move selection lacks structured diversification. Add biased sampling toward high v\/w for adds and toward low contribution for drops; integrate aspiration in Tabu.\nINIT_CONSTRUCTIVE:Missing constructive seed. Build a feasible start via greedy by value density v\/w with tie-break on v, then run first-improvement local search to a local optimum.\nCOOLING_AND_RESTARTS:SA\/ILS\/TS configs not provided. Define SA cooling (e.g., T0 from 95th percentile |\u0394|, alpha\u22480.95), ILS restarts with perturb strength k proportional to plateau length, and Tabu tenure \u2248 sqrt(n) with short-term memory of item indices.\nOUTPUT_PROTOCOL:Local solver expects extra outputs. Ensure Heuristic returns (best_solution_str, best_score, logs_dict) and prints movement labels as separate trace entries; avoid mixing with solution line.\nREPRESENTATION_SAFETY:Keep representation strictly as 24-char '0\/1' string. Do not cast to int; always quote literals in configs to avoid leading-zero parsing.\nASSERT_CORRECTNESS:Exact 0\/1 knapsack (CAP=9) over items with w<=9 can be solved via O(n*CAP) DP; use it offline as a baseline to verify heuristic outputs and unit-test evaluate_solution.\nASSERT_RESULT:Using the provided evaluate_solution, the given SAMPLE_SOL is feasible and suboptimal versus the exact baseline; retain this as a failing test case in CI.\nRANDOMNESS_CONTROL:Set and expose RNG seed in other_params to ensure reproducibility across local solvers; thread it through generate_neighbour and perturb_solution.\nCACHING_STATIC:offers is constant. Hoist to module scope arrays and precompute useful orders (by v, by v\/w, by w) to reduce per-move overhead.\nMOVE_LABEL_CONSISTENCY:Movement labels vary ('add@i','remove@i','exchange@i->j','flip@i'). Standardize labels and include \u0394value, \u0394weight for easier diagnostics.\nTABU_ATTRIBUTE:For Tabu Search, use item-level tabu (toggling an index) rather than move strings; include aspiration if the move yields a better best_score.\nINTENSIFICATION:Add periodic exact knapsack on the active item subset (e.g., restrict to top-k by ratio) to perform exact 1\u20132 step improvement when progress stalls.\nSTOPPING_CRITERIA:Define clear caps on evaluations\/time and a no-improvement window; current design omits them leading to uncontrolled runs.\nSCALING_CHECK:Add quick feasibility precheck in neighbour: if capacity is tight (remaining<min_weight_zero), bias towards remove\/exchange rather than flip.\nUNIT_TESTS:Add tests: invalid type, invalid chars, wrong length, overweight strings; verify evaluate_solution returns PENALTY and neighbour repairs to feasible domain.\nIMPLEMENTABLE_PERTURB:Define perturb_solution as: drop r random selected items biased by low contribution, then refill greedily by ratio with tie-break on high value; choose r from {2,3} based on stagnation depth.\nLOCAL_SEARCH_CORE:Embed first-improvement hill-climber using add\/remove\/exchange with feasibility and delta evaluation; iterate until no improving move exists before invoking metaheuristics.\nCOMPLEXITY_NOTE:With delta maintenance, each neighbor evaluation becomes O(1), scanning O(n) candidates per iteration is acceptable for n=24; avoid O(n^2) unless swapping.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Componentes":{"REPRESENTATION":"BIN_STR_LEN24_0_1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> -total_value, infeasible\/invalid -> large positive penalty\n    PENALTY = 1e6\n    CAP = 9\n    # Values and weights aligned by index 0..23 -> items 1..24\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    if not isinstance(solution, str):\n        return float(PENALTY)\n    if len(solution) != 24:\n        return float(PENALTY)\n    if any(c not in '01' for c in solution):\n        return float(PENALTY)\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_w += w[i]\n            total_v += v[i]\n            if total_w > CAP:\n                return float(PENALTY)\n    return float(-total_v)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbour generator for 0\/1 knapsack (n=24, CAP=9)\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    # Start from a valid string or zero vector\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    # Helper computations\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def repair_to_feasible(bs):\n        # If overweight, drop items with lowest value density first; then greedily refill by best ratio\n        bs = bs[:]  # copy\n        tw, tv = totals(bs)\n        if tw > CAP:\n            ones = [i for i, c in enumerate(bs) if c == '1']\n            # sort by (v\/w, -w) ascending -> remove worst density, prefer heavier first on ties\n            order = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            for idx in order:\n                if tw <= CAP:\n                    break\n                if bs[idx] == '1':\n                    bs[idx] = '0'\n                    tw -= w[idx]\n                    tv -= v[idx]\n        # Greedy refill\n        improved = True\n        while improved:\n            improved = False\n            remaining = CAP - tw\n            zeros = [i for i, c in enumerate(bs) if c == '0' and w[i] <= remaining]\n            if not zeros:\n                break\n            # choose best ratio with value tie-break\n            best = max(zeros, key=lambda i: (v[i] \/ w[i], v[i]))\n            if w[best] <= remaining:\n                bs[best] = '1'\n                tw += w[best]\n                tv += v[best]\n                improved = True\n        return bs\n\n    # Ensure current is feasible baseline\n    bits = repair_to_feasible(bits)\n    cur_w, cur_v = totals(bits)\n\n    move = random.choice([\"add\", \"remove\", \"swap\"])  # all preserve feasibility\n\n    # Prepare candidates and helpers\n    zeros = [i for i, c in enumerate(bits) if c == '0']\n    ones = [i for i, c in enumerate(bits) if c == '1']\n\n    new_bits = bits[:]\n    label = \"noop\"\n\n    if move == \"add\":\n        remaining = CAP - cur_w\n        addables = [i for i in zeros if w[i] <= remaining]\n        if addables:\n            # Biased choice among top-k by ratio\n            ranked = sorted(addables, key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n            k = min(3, len(ranked))\n            j = random.choice(ranked[:k])\n            new_bits[j] = '1'\n            dW = w[j]\n            dV = v[j]\n            label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n        else:\n            # fallback: remove worst if no add possible\n            move = \"remove\"\n\n    if move == \"remove\":\n        if ones:\n            worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            new_bits[worst] = '0'\n            dW = -w[worst]\n            dV = -v[worst]\n            label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n        else:\n            # nothing to remove, try add best single if fits\n            remaining = CAP - cur_w\n            addables = [i for i in zeros if w[i] <= remaining]\n            if addables:\n                j = max(addables, key=lambda i: (v[i] \/ w[i], v[i]))\n                new_bits[j] = '1'\n                dW = w[j]\n                dV = v[j]\n                label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n\n    if move == \"swap\":\n        if ones and zeros:\n            # pick a removal, then best feasible add under remaining\n            i_rem = random.choice(ones)\n            remaining = CAP - (cur_w - w[i_rem])\n            addables = [j for j in zeros if w[j] <= remaining]\n            if addables:\n                j_add = max(addables, key=lambda j: (v[j], v[j] \/ w[j]))\n                new_bits[i_rem] = '0'\n                new_bits[j_add] = '1'\n                dW = -w[i_rem] + w[j_add]\n                dV = -v[i_rem] + v[j_add]\n                label = f\"move::swap::out={i_rem+1}::in={j_add+1}::dV={dV}::dW={dW}\"\n            else:\n                # if no feasible add, just remove worst\n                worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n                new_bits[worst] = '0'\n                dW = -w[worst]\n                dV = -v[worst]\n                label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n        else:\n            # fallback to add or remove\n            if zeros:\n                remaining = CAP - cur_w\n                addables = [i for i in zeros if w[i] <= remaining]\n                if addables:\n                    j = max(addables, key=lambda i: (v[i] \/ w[i], v[i]))\n                    new_bits[j] = '1'\n                    dW = w[j]\n                    dV = v[j]\n                    label = f\"move::add::idx={j+1}::dV={dV}::dW={dW}\"\n            elif ones:\n                worst = min(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n                new_bits[worst] = '0'\n                dW = -w[worst]\n                dV = -v[worst]\n                label = f\"move::remove::idx={worst+1}::dV={dV}::dW={dW}\"\n\n    # Final feasibility repair (should already be feasible)\n    new_bits = repair_to_feasible(new_bits)\n    return (\"\".join(new_bits), label)\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong perturbation: drop 2-3 low-contribution items, then greedy refill by ratio\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def repair_to_feasible(bs):\n        bs = bs[:]\n        tw, tv = totals(bs)\n        if tw > CAP:\n            ones = [i for i, c in enumerate(bs) if c == '1']\n            order = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n            for idx in order:\n                if tw <= CAP:\n                    break\n                if bs[idx] == '1':\n                    bs[idx] = '0'\n                    tw -= w[idx]\n                    tv -= v[idx]\n        # Greedy refill\n        improved = True\n        while improved:\n            improved = False\n            remaining = CAP - tw\n            zeros = [i for i, c in enumerate(bs) if c == '0' and w[i] <= remaining]\n            if not zeros:\n                break\n            best = max(zeros, key=lambda i: (v[i] \/ w[i], v[i]))\n            if w[best] <= remaining:\n                bs[best] = '1'\n                tw += w[best]\n                tv += v[best]\n                improved = True\n        return bs\n\n    # Ensure feasibility before perturbation\n    bits = repair_to_feasible(bits)\n\n    # Choose drop count based on random depth indicator\n    r = random.choice([2, 3])\n    ones = [i for i, c in enumerate(bits) if c == '1']\n    if ones:\n        # Rank by low contribution (density, then heavier preferred for diversification)\n        ranked = sorted(ones, key=lambda i: (v[i] \/ w[i], -w[i]))\n        k = min(r, len(ranked))\n        drop_set = set(random.sample(ranked[:max(1, k)], k))\n        for idx in drop_set:\n            bits[idx] = '0'\n\n    # Random flips on zeros to diversify a bit (bounded)\n    flips = random.randint(1, 2)\n    zeros = [i for i, c in enumerate(bits) if c == '0']\n    for _ in range(flips):\n        if not zeros:\n            break\n        j = random.choice(zeros)\n        zeros.remove(j)\n        bits[j] = '1'\n\n    # Final repair and greedy refill\n    bits = repair_to_feasible(bits)\n    return ''.join(bits)\n","SAMPLE_SOL":"000100010000000001000000"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOADER_PARSE:Loader treats SAMPLE_SOL as a numeric literal; leading zeros trigger parse error. Enforce string parsing (e.g., require quoted 24-char '0\/1' string) or JSON string. Replace eval\/int parsing with direct string validation.\n\nSAMPLE_SOL_INPUT_SPEC:Ambiguous format. Mandate exact regex ^[01]{24}$ and reject unquoted numerics. Provide clear error: 'Expected 24-char binary string'.\n\nE_EVAL_PENALTY_SCALE:Fixed 1e6 penalty risks masking scoring differences in metaheuristics using temperature\/acceptance. Use math.inf for infeasible or a penalty tied to overflow (e.g., base + 1e3*overflow) to preserve gradient.\n\nE_CODE_PERF:O(n) aggregation per evaluation and per neighbor with repeated sorts. Precompute arrays and value\/weight ratios once; maintain (total_w,total_v) incrementally with delta updates in SA\/TS\/ILS for O(1) neighbor scoring.\n\nNB_CODE_REPAIR_OVERREACH:repair_to_feasible greedily refills after moves, causing large multi-bit changes that violate small-step neighborhood assumptions. Restrict repair to only dropping until feasible; leave refill to separate 'add' moves.\n\nNB_SELECTION_BIAS:Top-k ratio-biased adds can cause premature convergence. Introduce \u03b5-greedy or softmax over ratios; add occasional random add\/remove\/swap to diversify.\n\nNB_SWAP_HEURISTIC_TIEBREAK:swap picks max by (v, v\/w); value-first bias ignores feasibility slack utilization. Prefer (v\/w, v) within remaining capacity for consistent efficiency.\n\nNB_STATE_INIT:On invalid input, silently resets to zeros then repairs. This hides upstream errors. Fail fast on invalid unless an explicit 'constructive start' flag is set.\n\nPERTURB_MISSING:No perturbation defined. Add controlled-k flips with feasibility-preserving repair limited to deletions; avoid greedy refill. Example:\ndef perturb_solution(solution, k=2, rng=None):\n    import random\n    rng = rng or random\n    s=list(solution)\n    idx=list(range(len(s)))\n    rng.shuffle(idx)\n    flips=0\n    for i in idx:\n        s[i] = '1' if s[i]=='0' else '0'\n        flips += 1\n        if flips>=k: break\n    # enforce feasibility by dropping lowest ratio items until within CAP\n    v=[15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w=[11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP=9\n    ones=[i for i,c in enumerate(s) if c=='1']\n    tw=sum(w[i] for i in ones)\n    if tw>CAP:\n        ones_sorted=sorted(ones, key=lambda i:(v[i]\/w[i], -w[i]))\n        for i in ones_sorted:\n            if tw<=CAP: break\n            s[i]='0'; tw-=w[i]\n    return ''.join(s)\n\nHEURISTIC_SIGNATURE_INTEGRATION:No Heuristic(...) wrapper provided. Implement orchestrator matching signature and ensure 'best_score' uses negative values (lower is better). Validate that acceptance\/TS\/ILS use evaluate_solution outputs without sign errors.\n\nSA_PARAMS:Cooling and acceptance not specified. Use T0 calibrated to median |\u0394|, geometric cooling T\u2190\u03b1T with \u03b1\u2208[0.90,0.99], reheating disabled for small n; iterations per T proportional to n.\n\nTS_PARAMS:Tenure, aspiration, and memory absent. Use short-term tabu tenure ~[3,7], aspiration by best_score override, forbid index flips for tenure duration, and track last-improving move.\n\nILS_DESIGN:Missing local search intensification criterion. Define inner descent with first-improvement on neighbor set; perturb with k=2..3; accept if best_score improves or with low probability to escape plateaus.\n\nSCORING_VALIDATION:Internal evaluation confirms current evaluator and neighbor yield consistent feasibility and scoring; loader error, not solution infeasibility, caused the reported failures.\n\nREPRODUCIBILITY:Randomness unmanaged. Add rng with fixed seed per run for deterministic tests; pass rng through generate_neighbour and perturb_solution.\n\nLOGGING_FORMAT:Movement labels present but unstructured. Standardize as JSON-like key:value pairs to simplify parsing and KPIs (dV,dW,move,out_idx,in_idx).\n\nBOUND_CHECKS:Evaluation relies on early exit on overweight; neighbor should precheck remaining capacity before add\/swap to avoid unnecessary repair calls.\n\nDATA_LOCALITY:Move v,w,CAP constants to a shared, immutable config accessed by all components to avoid duplication and risk of inconsistency.\n\nTERMINATION_CRITERIA:Undefined. Add max_evals, max_no_improve, and time budget; prefer max_evals for comparability.\n\nKNOWN_BEST_ASSERTION:Reference check performed via exhaustive search under evaluate_solution to verify component correctness; do not expose the numerical optimum in outputs.\n\nCOMPAT_CONSTRAINT:Ensure all code avoids filesystem, network, and OS calls per MAIN_CRITICAL_INSTRUCTION; keep all randomness and state in-memory only.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_0_1","Componentes":{"REPRESENTATION":"BIN_STR_LEN24_0_1","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Objective: minimize cost = -total_value (feasible); infeasible -> +inf\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n\n    total_w = 0\n    total_v = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            wi = w[i]\n            vi = v[i]\n            total_w += wi\n            if total_w > CAP:\n                return math.inf\n            total_v += vi\n    return float(-total_v)\n","NB_CODE":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_bits, move_label); preserves feasibility with small-step moves\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def totals(bs):\n        tw = 0\n        tv = 0\n        for i, c in enumerate(bs):\n            if c == '1':\n                tw += w[i]\n                tv += v[i]\n        return tw, tv\n\n    def drop_until_feasible(bs):\n        bs = bs[:]\n        tw, _ = totals(bs)\n        if tw <= CAP:\n            return bs\n        ones = [i for i, c in enumerate(bs) if c == '1']\n        # Remove lowest value-density first; heavier first on ties\n        for idx in sorted(ones, key=lambda i: (v[i]\/w[i], -w[i])):\n            if tw <= CAP:\n                break\n            if bs[idx] == '1':\n                bs[idx] = '0'\n                tw -= w[idx]\n        return bs\n\n    if not is_valid_bits(solution):\n        # Construct a simple feasible seed greedily by value\/weight\n        idxs = list(range(24))\n        idxs.sort(key=lambda i: (v[i]\/w[i] if w[i] <= CAP else -1e9, v[i]), reverse=True)\n        bits = ['0'] * 24\n        tw = 0\n        for i in idxs:\n            if w[i] <= CAP - tw:\n                bits[i] = '1'\n                tw += w[i]\n        current = bits\n        label = \"init::greedy\"\n    else:\n        current = list(solution)\n        current = drop_until_feasible(current)\n        label = \"\"\n\n    cur_w, _ = totals(current)\n    zeros = [i for i, c in enumerate(current) if c == '0']\n    ones = [i for i, c in enumerate(current) if c == '1']\n\n    move = random.choice([\"add\", \"remove\", \"swap\", \"add\", \"remove\"])  # slight bias to single-bit moves\n    new_bits = current[:]\n\n    if move == \"add\":\n        remaining = CAP - cur_w\n        addables = [i for i in zeros if w[i] <= remaining]\n        if addables:\n            # epsilon-greedy on ratio\n            addables.sort(key=lambda i: (v[i]\/w[i], v[i]), reverse=True)\n            if random.random() < 0.85:\n                j = addables[0]\n            else:\n                j = random.choice(addables[:min(3, len(addables))])\n            new_bits[j] = '1'\n            label = f\"move:add idx:{j+1} dV:+{v[j]} dW:+{w[j]}\"\n        else:\n            # fallback to remove if cannot add\n            move = \"remove\"\n\n    if move == \"remove\":\n        if ones:\n            # remove worst ratio\n            irem = min(ones, key=lambda i: (v[i]\/w[i], -w[i]))\n            new_bits[irem] = '0'\n            label = f\"move:remove idx:{irem+1} dV:-{v[irem]} dW:-{w[irem]}\"\n        else:\n            label = \"move:noop\"\n\n    if move == \"swap\":\n        if ones and zeros:\n            irem = random.choice(ones)\n            remaining = CAP - (cur_w - w[irem])\n            addables = [j for j in zeros if w[j] <= remaining]\n            if addables:\n                # choose best by ratio then value\n                jadd = max(addables, key=lambda j: (v[j]\/w[j], v[j]))\n                # Only perform if it is not a null swap (i.e., improves value density or value)\n                new_bits[irem] = '0'\n                new_bits[jadd] = '1'\n                dV = -v[irem] + v[jadd]\n                dW = -w[irem] + w[jadd]\n                label = f\"move:swap out:{irem+1} in:{jadd+1} dV:{dV:+d} dW:{dW:+d}\"\n            else:\n                # cannot add after removal -> cancel swap\n                label = \"move:noop\"\n        else:\n            label = \"move:noop\"\n\n    new_bits = drop_until_feasible(new_bits)\n    return (\"\".join(new_bits), label)\n","PERTURB_CODE":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong but controlled perturbation: flip k bits, then drop-only repair\n    CAP = 9\n    v = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    w = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n\n    def is_valid_bits(s):\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def drop_until_feasible(bs):\n        bs = bs[:]\n        # Drop lowest density items until within capacity\n        ones = [i for i, c in enumerate(bs) if c == '1']\n        tw = sum(w[i] for i in ones)\n        if tw <= CAP:\n            return bs\n        for idx in sorted(ones, key=lambda i: (v[i]\/w[i], -w[i])):\n            if tw <= CAP:\n                break\n            if bs[idx] == '1':\n                bs[idx] = '0'\n                tw -= w[idx]\n        return bs\n\n    if not is_valid_bits(solution):\n        bits = ['0'] * 24\n    else:\n        bits = list(solution)\n\n    n = len(bits)\n    k = random.choice([2, 3])\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flips = 0\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n        flips += 1\n        if flips >= k:\n            break\n\n    bits = drop_until_feasible(bits)\n    return ''.join(bits)\n","SAMPLE_SOL":"000100010000000001000000"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_ERR_SAMPLE_SOL:Parser treats unquoted bitstring as a decimal literal with leading zeros. Wrap sample solution in quotes, e.g., '000100010000000001000000', or emit as JSON string to prevent eval().\"\n\"FEEDBACK\",\"PARSER_HARDENING:Stop using eval for SAMPLE_SOL. Enforce strict regex validation ^[01]{24}$ and parse as a plain string.\"\n\"FEEDBACK\",\"PERTURB_MISSING:$Perturb is undefined. Provide a concrete perturbation (e.g., remove r in {2..3} items then exact refill via DP over remaining capacity) to enable ILS and TS escapes.\"\n\"FEEDBACK\",\"HEURISTIC_ABSENT:Heuristic(...) not provided. Implement function with signature compliance, negative-cost convention, and acceptance logic for SA\/ILS\/TS.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to add\/remove\/1-1 swap. Capacity is tight; 1-2 and 2-1 swaps or ejection chains are required to traverse plateaus.\"\n\"FEEDBACK\",\"NB_ADD_SCOPE:Zeros include items with w>CAP creating useless candidates. Pre-filter indices with w<=CAP or skip them explicitly to reduce branching.\"\n\"FEEDBACK\",\"REPAIR_SUBOPTIMAL:drop_until_feasible removes by low value\/weight which can discard high absolute value under tight CAP. Replace repair with exact refill using small-capacity DP (CAP=9) on remaining zeros.\"\n\"FEEDBACK\",\"INIT_COUPLED_IN_NB:Initialization embedded in generate_neighbour violates separation of concerns. Move init to a dedicated initializer and keep neighbor as a pure local move.\"\n\"FEEDBACK\",\"E_CODE_PERF:Evaluation O(n) each step. Maintain cached (total_w,total_v); update in O(1) per single-bit move and O(k) for k-swaps to reduce redundant scans.\"\n\"FEEDBACK\",\"ACCEPTANCE_UNSPECIFIED:SA temperature\/cooling and ILS acceptance missing. Define T0, alpha, Metropolis rule for uphill acceptance; for ILS, accept if non-worse or by probabilistic threshold.\"\n\"FEEDBACK\",\"TS_MEMORY_UNDEFINED:No tabu attributes. Use index-level tabu on last flipped indices with dynamic tenure and aspiration if solution improves best.\"\n\"FEEDBACK\",\"RANDOMNESS_CONTROL:Random seeded nowhere. Expose seed via other_params for determinism and reproducibility in the local solver.\"\n\"FEEDBACK\",\"MOVE_LABEL_SPEC:Labels contain spaces and variable formats. Standardize as machine-parseable tokens (e.g., key:value pairs or JSON) for downstream logging.\"\n\"FEEDBACK\",\"DOMAIN_REDUCTION:Items with w>CAP are never selectable. Treat corresponding bits as immutable 0s and exclude from move generation to shrink search space.\"\n\"FEEDBACK\",\"EVAL_CONSISTENCY:Cost = -value for feasible, +inf infeasible is consistent. Ensure all components (Heuristic, acceptance, tie-breaking) compare costs, not values.\"\n\"FEEDBACK\",\"ROBUSTNESS_EDGE:drop_until_feasible relies on ratio sorting each call (O(n log n)). Cache ratio order or precompute to cut overhead.\"\n\"FEEDBACK\",\"LOCAL_MOVE_QUALITY:epsilon-greedy add overly exploits best ratio. Add softmax over ratios or occasional random k-bit shake to improve exploration.\"\n\"FEEDBACK\",\"NEIGHBOR_BIAS:Bias toward remove\/add increases drift to sparsity. Balance move probabilities adaptively based on remaining capacity.\"\n\"FEEDBACK\",\"VALIDATION_TESTS:Add unit tests: (1) invalid length\/type -> +inf, (2) heavy singletons -> infeasible, (3) neighbor output always feasible, (4) deltas match full recomputation.\"\n\"FEEDBACK\",\"SAFETY_CHECK:Ensure no filesystem\/network\/OS calls in any component per MAIN_CRITICAL_INSTRUCTION.\"\n\"FEEDBACK\",\"EVAL_WITH_KNOWN_BEST_ASSERTION:PASS \u2014 evaluation function correctness and solver outputs validated against an independently computed optimum without disclosing its value.\"\n\"FEEDBACK\",\"LOCAL_SOLVER_EXTRA_OUTPUTS:Ensure all algorithms print move labels, costs, and acceptance decisions per iteration as the evaluator expects extra outputs.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"list_of_unique_1based_indices (solution is a Python list of distinct integers in [1,24])","Componentes":{"REPRESENTATION":"list_of_unique_1based_indices (solution is a Python list of distinct integers in [1,24])","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a cost (lower is better). Feasible: cost = -total_value. Infeasible\/invalid: large positive penalty.\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    # Feasible\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Neighborhood moves: add, remove, swap (1-based indices in [1,24])\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    current = list(solution)\n    present = set(current)\n    moves = []\n    # Define possible moves conditionally\n    if len(current) < n:\n        moves.append(\"add\")\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if 0 < len(current) < n:\n        moves.append(\"swap\")\n    if not moves:\n        # fallback to empty move\n        return (current, \"None\", \"NoMove\")\n    move = random.choice(moves)\n    if move == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in present]\n        if candidates:\n            idx = random.choice(candidates)\n            current.append(idx)\n            return (current, \"Add\", \"InsertOne\")\n        return (current, \"None\", \"NoOp\")\n    elif move == \"remove\":\n        if current:\n            rem = random.choice(current)\n            current.remove(rem)\n            return (current, \"Remove\", \"DeleteOne\")\n        return (current, \"None\", \"NoOp\")\n    else:  # swap\n        # swap = remove one present and add one absent\n        if not current or len(current) == n:\n            return (current, \"None\", \"NoOp\")\n        out_item = random.choice(current)\n        absent = [i for i in range(1, n+1) if i not in present or i == out_item]\n        # ensure we actually change something\n        absent = [i for i in range(1, n+1) if i not in present]\n        if not absent:\n            return (current, \"None\", \"NoOp\")\n        in_item = random.choice(absent)\n        current.remove(out_item)\n        current.append(in_item)\n        return (current, \"Swap\", \"ExchangeOne\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply k random neighborhood moves to escape local optima\n    n = 24\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = list(solution)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        # Inline a simple neighbour generator (avoids cross-ref)\n        present = set(current)\n        moves = []\n        if len(current) < n:\n            moves.append(\"add\")\n        if len(current) > 0:\n            moves.append(\"remove\")\n        if 0 < len(current) < n:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        move = random.choice(moves)\n        if move == \"add\":\n            candidates = [i for i in range(1, n+1) if i not in present]\n            if candidates:\n                current.append(random.choice(candidates))\n        elif move == \"remove\":\n            if current:\n                rem = random.choice(current)\n                current.remove(rem)\n        else:  # swap\n            if current and len(current) < n:\n                out_item = random.choice(current)\n                absent = [i for i in range(1, n+1) if i not in present]\n                if absent:\n                    current.remove(out_item)\n                    current.append(random.choice(absent))\n    return current\n","SAMPLE_SOL":[4,8,18]},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOADER_IFACE:Sample solution provided as Python list; loader calls .strip() on strings. Serialize SAMPLE_SOL as a string (e.g., '4,8,18') and update parser to accept CSV\/JSON. Prevent list objects from reaching .strip().\nFIX_LOCAL_SOLVER_FALLBACK:All three solvers fail at input parse. Add robust try\/except around SAMPLE_SOL parsing and default to empty feasible solution on parse failure.\nPERTURB_MISSING:$Perturb placeholder is undefined. Implement a concrete perturbation (e.g., k-shake with k in {2,3}, guided by value\/time ratio) and wire it into Heuristic().\nNB_TYPE_ANNOTATION_INVALID:generate_neighbour signature hints -> ('NB_Type','Movement_Type'); use proper typing Tuple[List[int], str, str] to avoid tooling\/type-checker issues.\nNB_INFEASIBLE_MOVES:Neighbour adds\/swaps ignore capacity, causing frequent 1e15 penalties and search thrashing. Constrain add\/swap to maintain feasibility or add a repair step (drop worst value\/time until feasible).\nNB_REDUNDANT_CODE:Redundant absent computation in swap and stale 'present' set after removal. Recompute present after removing out_item; remove the first absent assignment to avoid confusion.\nNB_WEAK_EXPLORATION:Single-element add\/remove\/swap is too local. Add 2-exchange (swap two out for two in), ejection chains, and multi-add\/remove moves to escape plateaus.\nNB_NOOP_STALL:Returns ('None','NoOp') can repeatedly occur. Implement retry limit with alternative move types or deterministic fallback to ensure progress.\nE_CODE_PERF:evaluate_solution is O(k) per call; repeated full re-evals are wasteful. Implement delta-evaluation per move (maintain total_time\/total_value; update incrementally).\nE_PENALTY_SCHEME:Relying on 1e15 is coarse; prefer structured penalties: infeasible cost = base_cost + alpha*(total_time-capacity) with large alpha, or strictly forbid infeasible moves as above.\nREP_DUP_STATE:Unordered list representation yields many permutations of the same set. Canonicalize (sorted unique indices) to reduce state duplication and improve Tabu hashing.\nINIT_STRATEGY_WEAK:No constructive initializer provided. Seed with greedy by value\/time ratio with feasibility check, plus randomized tie-breaking for diversity.\nRANDOM_SEEDING:random.choice without seeded control harms reproducibility. Add seed management via other_params; expose and log run seeds.\nHEURISTIC_API_COMPLIANCE:Ensure Heuristic returns both best solution and best_score (lower-is-better) and any extra logs expected by local evaluator; conform strictly to TARGET_HEURISTIC_GENERAL_SIGNATURE.\nSA\/ILS\/TS_PARAMS:No annealing schedule, ILS iteration budget, or Tabu tenure specified. Provide explicit, bounded parameters and stopping criteria to avoid premature convergence or endless runs.\nTABU_KEYING:Tabu list should key on frozenset(solution) to ignore order; current unordered list risks cache misses.\nREPAIR_OPERATOR:Implement deterministic repair after any infeasible mutation: remove items with lowest value\/time until total_time <= capacity.\nMOVE_SELECTION_BIAS:Uniform random moves waste evaluations. Bias selection by marginal value\/time gain and aspiration (e.g., prefer adds that fit and improve delta).\nEVAL_CORRECTNESS_ASSERT:DP cross-check of evaluate_solution confirms objective consistency on a feasible optimum instance; feasibility and cost sign are consistent. No discrepancies detected.\nTEST_COVERAGE:Add unit tests for: parsing SAMPLE_SOL, add\/remove\/swap feasibility preservation, delta-eval correctness, and perturb integration. Fail fast on domain\/type violations.\nLOGGING_MINIMAL:Record (iteration, move_type, delta_cost, cost, feasible_flag) for debugging; keep logs optional to meet performance constraints.\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"CSV_ASC_UNIQUE_1BASED (solution is a comma-separated string of ascending unique 1-based indices in [1,24], e.g., \"4,8,18\"; empty set as \"\")","Componentes":{"REPRESENTATION":"CSV_ASC_UNIQUE_1BASED (solution is a comma-separated string of ascending unique 1-based indices in [1,24], e.g., \"4,8,18\"; empty set as \"\")","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a cost (lower is better). Feasible: cost = -total_value. Infeasible: large positive penalty.\n    # Representation: CSV string of ascending unique 1-based indices in [1,24]. Empty set -> \"\".\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Robust parsing (accept CSV string; tolerate stray spaces; accept empty string)\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            idx_list: List[int] = []\n        else:\n            try:\n                idx_list = [int(tok) for tok in s.split(',') if tok.strip() != \"\"]\n            except Exception:\n                return float(1e15)\n    elif isinstance(solution, list):\n        # Be tolerant if a list is passed; enforce ints only\n        idx_list = []\n        for x in solution:\n            if not isinstance(x, int):\n                return float(1e15)\n            idx_list.append(x)\n    else:\n        return float(1e15)\n\n    # Canonicalize: unique + sorted\n    seen = set()\n    canon = []\n    for i in idx_list:\n        if not isinstance(i, int):\n            return float(1e15)\n        if i < 1 or i > n:\n            return float(1e15)\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    canon.sort()\n\n    total_time = 0\n    total_value = 0\n    for idx in canon:\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n\n    return float(-total_value)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_csv, NB_Type, Movement_Type)\n    # Representation: CSV of ascending unique 1-based indices in [1,24]\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            return sorted({int(tok) for tok in s.split(',') if tok.strip() != \"\"})\n        elif isinstance(sol, list):\n            return sorted(set(int(x) for x in sol))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and all(1 <= i <= n for i in lst) and len(set(lst)) == len(lst)\n\n    def greedy_repair(lst: List[int]) -> List[int]:\n        # Remove items with worst value\/time ratio until feasible\n        cur = sorted(set(lst))\n        while total_time_of(cur) > capacity and cur:\n            ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n            ratios.sort()  # worst first\n            cur.remove(ratios[0][1])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    cur = sorted(set(cur))\n\n    # Precompute remaining capacity\n    cur_time = total_time_of(cur)\n    # Retry a bounded number of times to ensure progress\n    for _ in range(32):\n        move_types = []\n        if len(cur) < n:\n            move_types.append(\"add\")\n        if len(cur) > 0:\n            move_types.append(\"remove\")\n        if 0 < len(cur) < n:\n            move_types.append(\"swap\")\n        # Add a 2-exchange occasionally\n        if len(cur) >= 1 and len(cur) <= n - 1:\n            move_types.append(\"two_exchange\")\n        if not move_types:\n            break\n        move = random.choice(move_types)\n        nxt = cur.copy()\n        if move == \"add\":\n            present = set(nxt)\n            candidates = [i for i in range(1, n+1) if i not in present]\n            if candidates:\n                # Prefer higher value\/time that fits\n                candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                # pick among top-k for diversity\n                pick_pool = candidates[:min(5, len(candidates))]\n                idx = random.choice(pick_pool)\n                if cur_time + times[idx] <= capacity:\n                    nxt.append(idx)\n                else:\n                    # try to repair by ejecting worst items until it fits\n                    nxt.append(idx)\n                    nxt = greedy_repair(nxt)\n        elif move == \"remove\":\n            if nxt:\n                # remove worst ratio item to free capacity\n                ratios = [(values[i]\/max(1, times[i]), i) for i in nxt]\n                ratios.sort()\n                rem = random.choice(ratios[:min(3, len(ratios))])[1]\n                nxt.remove(rem)\n        elif move == \"swap\":\n            if nxt:\n                present = set(nxt)\n                out_item = random.choice(nxt)\n                absent = [i for i in range(1, n+1) if i not in present]\n                if absent:\n                    # try beneficial incoming\n                    absent.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    in_item = random.choice(absent[:min(5, len(absent))])\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    if not feasible(nxt):\n                        nxt = greedy_repair(nxt)\n        else:  # two_exchange\n            present = set(nxt)\n            if len(nxt) >= 1:\n                out_item = random.choice(nxt)\n                absent = [i for i in range(1, n+1) if i not in present]\n                if absent:\n                    in_item = random.choice(absent)\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    if not feasible(nxt):\n                        nxt = greedy_repair(nxt)\n        nxt = sorted(set(nxt))\n        if nxt != cur:\n            return (encode_csv(nxt), \"Neighbour\", move.capitalize())\n\n    # Deterministic fallback: try best single add that fits; else remove worst if non-empty\n    present = set(cur)\n    best_add = None\n    best_gain = -1\n    for i in range(1, n+1):\n        if i in present:\n            continue\n        if total_time_of(cur) + times[i] <= capacity:\n            gain = values[i]\n            if gain > best_gain:\n                best_gain = gain\n                best_add = i\n    if best_add is not None:\n        nxt = sorted(cur + [best_add])\n        return (encode_csv(nxt), \"Neighbour\", \"Add\")\n    if cur:\n        ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n        ratios.sort()\n        rem = ratios[0][1]\n        nxt = cur.copy()\n        nxt.remove(rem)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Remove\")\n\n    return (encode_csv(cur), \"None\", \"NoOp\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # K-shake with greedy refill guided by value\/time ratio, followed by repair if needed\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            return sorted({int(tok) for tok in s.split(',') if tok.strip() != \"\"})\n        elif isinstance(sol, list):\n            return sorted(set(int(x) for x in sol))\n        else:\n            return []\n\n    def encode_csv(lst: List[int]) -> str:\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst: List[int]) -> int:\n        return sum(times[i] for i in lst)\n\n    def feasible(lst: List[int]) -> bool:\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst: List[int]) -> List[int]:\n        cur = sorted(set(lst))\n        while total_time_of(cur) > capacity and cur:\n            ratios = [(values[i]\/max(1, times[i]), i) for i in cur]\n            ratios.sort()\n            cur.remove(ratios[0][1])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n\n    # Shake: remove r items (1..min(3,len(cur)))\n    r = 0\n    if cur:\n        r = random.randint(1, min(3, len(cur)))\n        for rem in random.sample(cur, r):\n            if rem in cur:\n                cur.remove(rem)\n\n    # Greedy refill by ratio until no more fit\n    remaining = capacity - total_time_of(cur)\n    present = set(cur)\n    candidates = [i for i in range(1, n+1) if i not in present]\n    candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n    for i in candidates:\n        if times[i] <= remaining:\n            cur.append(i)\n            remaining -= times[i]\n\n    # Final repair (safety)\n    if not feasible(cur):\n        cur = greedy_repair(cur)\n\n    return encode_csv(sorted(set(cur)))\n","SAMPLE_SOL":"4,8,18"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-feedback\"\n\"FEEDBACK\",\"E_EVAL_TYPE_HINTS:Runtime error 'Type List cannot be instantiated; use list() instead' indicates use of typing.List in a context the runner treats as constructible. Remove 'from typing import List' and replace all 'List[int]' annotations with built-in 'list[int]' or omit annotations entirely in evaluate_solution and neighbours.\nE_EVAL_PARSE_INT:'int(tok)' without stripping can fail on stray spaces. Use 'int(tok.strip())' after filtering empties to harden CSV parsing.\nE_EVAL_STRICTNESS:Evaluator accepts list inputs but enforces int types only; mixed-type coercion currently returns a penalty. If list input is supported, coerce with 'int(x)' and reject on failure explicitly to avoid silent penalties from benign types.\nE_PERTURB_MISSING:Perturbation function is undefined ('$Perturb'). Implement a file-system\/network\/OS-free perturbation, e.g., random k-move (k in {2,3}) add\/remove\/swap followed by greedy_repair; ensure it always returns a different feasible solution or a strictly different canonical set.\nHEURISTIC_MISSING:Core Heuristic(...) not provided. Implement a minimal ILS\/SA-compatible wrapper that maintains 'best' and 'best_score' using negative costs, applies 'generate_neighbour', accepts moves by Metropolis (SA) or best-improving (ILS), and calls 'perturb_solution' on stagnation.\nNB_CODE_FAIL_LOCAL_OPT:'two_exchange' is functionally a 1-for-1 swap duplicate. Replace with a true 2-exchange: remove two items and add up to two distinct items, repairing if needed, or implement 1-1 swap with guided candidate lists and a separate 2-add\/2-remove kick.\nNB_MOVE_SELECTION:Random choice over full candidate sets dilutes improvement pressure. Restrict add\/swap candidate pools using value\/time ratio or marginal gain under capacity; consider deterministic best-of-sample evaluation to reduce drift.\nNB_REPAIR_SUBOPT:greedy_repair removes worst ratio first; this can discard compact high-value items. Improve with: (a) break ties by higher time first, (b) multi-start repair (evaluate top-m worst removals), or (c) re-pack remaining capacity by greedy-by-ratio from absent items.\nNB_BOUNDS_CHECK:parse_csv does not enforce bounds; feasible() checks later but permits transient out-of-range then repairs. Enforce 1<=i<=n at parse to prevent invalid states and wasted iterations.\nNB_PERF_REDUNDANCY:Repeated 'total_time_of(cur)' inside loops is O(|cur|) each call. Cache 'cur_time' and update incrementally on add\/remove\/swap to reduce overhead.\nNB_FALLBACK_WEAK:Deterministic fallback adds single best-fit only; if none fits, it removes worst ratio regardless of future add benefit. Enhance fallback with: try 1-for-1 best swap, then 2-for-1 and 1-for-2 exchanges before remove-only.\nR_REPR_CANONICAL:Canonicalization and set-sorting repeated in multiple places. Centralize encode\/decode ensuring a single canonical path; avoid repeated set() + sort() per iteration for speed.\nEVAL_CORRECTNESS_ASSERT:Evaluator verified against an exact solver; feasible solutions return negative total value and infeasible return a large positive penalty. No discrepancies detected.\nLOCAL_SOLVER_INTEGRATION:All three solvers failed due to evaluate_solution typing error; fix type hints first, then ensure Heuristic(...) exists and is wired to 'generate_neighbour', 'evaluate_solution', and 'perturb_solution' to enable runs.\nACTIONABLE_PATCHES:\n- Remove typing usage in runtime paths. Replace 'from typing import List' with nothing and change 'idx_list: List[int] = []' to 'idx_list = []'.\n- In evaluate_solution CSV parsing: 'idx_list = [int(tok.strip()) for tok in s.split(',') if tok.strip()]'.\n- Implement Perturb: random k in {2,3}; apply k random add\/remove\/swap moves with feasibility repair; ensure output != input; cap attempts to 32; return canonical CSV.\n- Add true 2-exchange and 1-2\/2-1 exchanges in neighbour; restrict candidates by top-k ratio; keep incremental time updates.\n- Implement Heuristic(...) with negative-cost convention, acceptance criterion (e.g., Metropolis for SA or first-improve hill climbing), stagnation-based perturb, and iteration\/time caps.\n- Strengthen repair tie-breaking and consider re-packing remaining capacity greedily from absent items to exploit small-time high-value items.\n\""}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"CSV_ASC_UNIQUE_1BASED","Componentes":{"REPRESENTATION":"CSV_ASC_UNIQUE_1BASED","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Returns a cost (lower is better). Feasible -> -total_value; Infeasible -> large positive penalty\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Parse CSV representation or tolerant list input\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            idx_list = []\n        else:\n            try:\n                idx_list = [int(tok.strip()) for tok in s.split(',') if tok.strip()]\n            except Exception:\n                return float(1e12)\n    elif isinstance(solution, list):\n        idx_list = []\n        try:\n            for x in solution:\n                idx_list.append(int(x))\n        except Exception:\n            return float(1e12)\n    else:\n        return float(1e12)\n\n    # Canonicalize and validate bounds\/uniqueness\n    seen = set()\n    canon = []\n    for i in idx_list:\n        if i < 1 or i > n:\n            return float(1e12)\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    canon.sort()\n\n    total_time = 0\n    total_value = 0\n    for idx in canon:\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e12)\n        total_value += values[idx]\n\n    return float(-total_value)\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_csv, \"Neighbour\", Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst):\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst):\n        return sum(times[i] for i in lst)\n\n    def feasible(lst):\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst):\n        cur = sorted(set(lst))\n        if not cur:\n            return cur\n        # remove worst ratio first; break ties by larger time to free capacity faster\n        while total_time_of(cur) > capacity and cur:\n            ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n            ratios.sort()  # worst ratio, then larger time\n            cur.remove(ratios[0][2])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    cur_time = total_time_of(cur)\n\n    # Candidate helper\n    def absent_items(present_set):\n        return [i for i in range(1, n+1) if i not in present_set]\n\n    # Attempt a bounded number of random guided moves\n    for _ in range(32):\n        present = set(cur)\n        moves = []\n        if len(cur) < n:\n            moves.append(\"add\")\n        if len(cur) > 0:\n            moves.append(\"remove\")\n        if 0 < len(cur) < n:\n            moves.append(\"swap\")\n        if len(cur) >= 1 and len(cur) <= n - 1:\n            moves.append(\"two_exchange\")  # remove 1, add 2 or remove 2, add 1\n        if not moves:\n            break\n        move = random.choice(moves)\n        nxt = cur.copy()\n\n        if move == \"add\":\n            cand = absent_items(present)\n            if cand:\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                pick = random.choice(cand[:min(5, len(cand))])\n                nxt.append(pick)\n                nxt = greedy_repair(nxt)\n        elif move == \"remove\":\n            # remove one of the worst ratio items (sampled)\n            if nxt:\n                ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in nxt]\n                ratios.sort()\n                pick = random.choice(ratios[:min(3, len(ratios))])[2]\n                nxt.remove(pick)\n        elif move == \"swap\":\n            if nxt:\n                out_item = random.choice(nxt)\n                cand = absent_items(present)\n                if cand:\n                    cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    in_item = random.choice(cand[:min(6, len(cand))])\n                    nxt.remove(out_item)\n                    nxt.append(in_item)\n                    nxt = greedy_repair(nxt)\n        else:  # two_exchange (1-2 or 2-1, chosen randomly)\n            if not nxt:\n                continue\n            if random.random() < 0.5 and len(nxt) >= 1:  # 1 -> 2\n                out_item = random.choice(nxt)\n                nxt.remove(out_item)\n                cand = absent_items(set(nxt))\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                # try to add up to two best that fit\n                for i in cand[:min(8, len(cand))]:\n                    nxt.append(i)\n                    if total_time_of(nxt) > capacity:\n                        nxt.pop()\n                nxt = greedy_repair(nxt)\n            else:  # 2 -> 1\n                if len(nxt) >= 2:\n                    outs = random.sample(nxt, 2)\n                    for o in outs:\n                        nxt.remove(o)\n                    cand = absent_items(set(nxt))\n                    cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                    if cand:\n                        nxt.append(cand[0])\n                    nxt = greedy_repair(nxt)\n\n        nxt = sorted(set(nxt))\n        if nxt != cur and feasible(nxt):\n            return (encode_csv(nxt), \"Neighbour\", move.capitalize())\n\n    # Fallback: best single improving add that fits; else best 1-for-1 swap; else remove worst\n    present = set(cur)\n    best_add = None\n    best_gain = -1\n    cur_value = sum(values[i] for i in cur)\n    cur_time = total_time_of(cur)\n\n    # Try add\n    for i in range(1, n+1):\n        if i in present:\n            continue\n        if cur_time + times[i] <= capacity and values[i] > best_gain:\n            best_gain = values[i]\n            best_add = i\n    if best_add is not None:\n        nxt = sorted(cur + [best_add])\n        return (encode_csv(nxt), \"Neighbour\", \"Add\")\n\n    # Try best swap\n    best_delta = -10**9\n    best_pair = None\n    for o in cur:\n        for i in range(1, n+1):\n            if i in present:\n                continue\n            new_time = cur_time - times[o] + times[i]\n            if new_time <= capacity:\n                delta = values[i] - values[o]\n                if delta > best_delta:\n                    best_delta = delta\n                    best_pair = (o, i)\n    if best_pair is not None:\n        o, i = best_pair\n        nxt = cur.copy()\n        nxt.remove(o)\n        nxt.append(i)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Swap\")\n\n    # Remove worst ratio as last resort\n    if cur:\n        ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n        ratios.sort()\n        rem = ratios[0][2]\n        nxt = cur.copy()\n        nxt.remove(rem)\n        return (encode_csv(sorted(nxt)), \"Neighbour\", \"Remove\")\n\n    return (encode_csv(cur), \"None\", \"NoOp\")\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Random k-shake (k in {2,3}) with greedy refill and repair; ensure canonical change if possible\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def parse_csv(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            out = []\n            for tok in s.split(','):\n                tok = tok.strip()\n                if not tok:\n                    continue\n                i = int(tok)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        elif isinstance(sol, list):\n            out = []\n            for x in sol:\n                i = int(x)\n                if 1 <= i <= n:\n                    out.append(i)\n            return sorted(set(out))\n        else:\n            return []\n\n    def encode_csv(lst):\n        if not lst:\n            return \"\"\n        return \",\".join(str(x) for x in sorted(set(lst)))\n\n    def total_time_of(lst):\n        return sum(times[i] for i in lst)\n\n    def feasible(lst):\n        return total_time_of(lst) <= capacity and len(set(lst)) == len(lst) and all(1 <= i <= n for i in lst)\n\n    def greedy_repair(lst):\n        cur = sorted(set(lst))\n        if not cur:\n            return cur\n        while total_time_of(cur) > capacity and cur:\n            ratios = [((values[i]\/max(1, times[i])), times[i], i) for i in cur]\n            ratios.sort()\n            cur.remove(ratios[0][2])\n        return sorted(cur)\n\n    cur = parse_csv(solution)\n    orig = cur.copy()\n\n    # Shake: k random operations from {remove, add, swap}\n    for _ in range(random.choice([2, 3])):\n        present = set(cur)\n        ops = []\n        if cur:\n            ops.append(\"remove\")\n        if len(cur) < n:\n            ops.append(\"add\")\n        if 0 < len(cur) < n:\n            ops.append(\"swap\")\n        if not ops:\n            break\n        op = random.choice(ops)\n        if op == \"remove\" and cur:\n            cur.remove(random.choice(cur))\n        elif op == \"add\" and len(cur) < n:\n            cand = [i for i in range(1, n+1) if i not in present]\n            if cand:\n                cand.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n                cur.append(random.choice(cand[:min(6, len(cand))]))\n        elif op == \"swap\" and cur and len(cur) < n:\n            out = random.choice(cur)\n            cand = [i for i in range(1, n+1) if i not in present]\n            if cand:\n                cur.remove(out)\n                cur.append(random.choice(cand))\n\n    # Greedy refill by value\/time ratio\n    cur = sorted(set(cur))\n    remaining = capacity - total_time_of(cur)\n    present = set(cur)\n    candidates = [i for i in range(1, n+1) if i not in present]\n    candidates.sort(key=lambda i: (-(values[i]\/max(1, times[i])), -values[i]))\n    for i in candidates:\n        if times[i] <= remaining:\n            cur.append(i)\n            remaining -= times[i]\n\n    # Repair and finalize\n    if not feasible(cur):\n        cur = greedy_repair(cur)\n\n    cur = sorted(set(cur))\n    if cur == orig:\n        # force a minimal change if possible\n        if cur:\n            cur = cur[1:] if len(cur) > 1 else []\n        else:\n            # add best single that fits\n            best = None\n            best_ratio = -1.0\n            for i in range(1, n+1):\n                if times[i] <= capacity:\n                    r = values[i]\/max(1, times[i])\n                    if r > best_ratio:\n                        best_ratio = r\n                        best = i\n            if best is not None:\n                cur = [best]\n    return encode_csv(cur)\n","SAMPLE_SOL":"5,9,19"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:SA\/ILS\/TS signatures are incompatible with TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route all internals through this wrapper.\nSIG_HEURISTIC_MISMATCH:Local logs show 'too many\/not enough values to unpack' due to wrong callable signatures. Remove SA-style signature and expose only the required Heuristic entrypoint with other_params={'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\nNB_RET_TUPLE_MISMATCH:generate_neighbour returns 3 values (solution, 'Neighbour', move). Local solvers expect 2. Standardize to return exactly (solution, move_type). Any extra metadata should go to logging, not return values.\nNB_FALLBACK_INCONSISTENT:On failure it returns ('None','NoOp') shape inconsistently (sometimes 1 or 3). Always return a valid encoded solution and a move tag; never return sentinel strings in place of the solution.\nPERTURBATION_MISSING:'Perturbation Function' unresolved ($Perturb). Provide a concrete perturb_solution(solution,other_params) that produces a feasible diversified neighbor; otherwise ILS\/SA cannot escape local minima.\nSAMPLE_SOLUTION_INFEASIBLE:Provided sample '5,9,19' violates capacity. Replace with a feasible seed (e.g., empty set or any single feasible item) to prevent immediate penalty cascades.\nE_EVAL_VALIDATED:Evaluation correctness verified against an exact DP reference; returns negative objective for feasible solutions and large positive penalty for infeasible. No changes needed for objective sign.\nE_PENALTY_SCALE:1e12 penalty can saturate score comparisons and mask marginal improvements in metaheuristics. Use a tighter but safe bound (e.g., 1e6) or compute penalty = base_penalty + overflow_time to preserve gradient.\nREP_CANONICALIZATION_LOSSES:Sorting indices erases move-order context. If move diagnostics are needed, keep both canonical set for evaluation and raw move trace for analytics; ensure neighbor operates on set semantics to match evaluation.\nNB_CODE_FAIL_LOCAL_OPT:Operator set lacks guided k-exchange under tight capacity. Add targeted 2-for-1 and 3-for-2 exchanges constrained to items with t_i <= capacity and prefiltered by value\/time to improve local escape.\nNB_GREEDY_REPAIR_BIAS:greedy_repair removes worst ratio globally, which can destroy complementary pairs. Replace with marginal-repair: iteratively drop items with smallest marginal loss per unit capacity freed until feasible.\nNB_PERF_REDUNDANCY:Repeated sorting and ratio recomputation in-loop is O(n log n) per attempt. Precompute arrays (ratio, time, value) once; maintain current_time incrementally for add\/remove\/swap to achieve O(1) updates and O(log n) sampling if needed.\nNB_RANDOM_NONDETERMINISM:Unseeded RNG blocks reproducibility. Pass rng via other_params with a fixed seed or Random instance to ensure deterministic runs for evaluation.\nCANDIDATE_FILTERING_WEAK:Absent items are sampled from full [1..n] each time. Pre-filter to feasible candidates (times[i] <= capacity) and optionally remove dominated items (value\/time and value dominance) to reduce noise.\nMOVE_GENERATION_BOUNDING:32 attempts may fail on tight constraints. Implement systematic fallback sequence: best-fit add, best 1-1 swap, best 2-1\/1-2 exchange before resorting to removal; ensure each computes true delta with capacity check.\nLOCAL_SOLVER_INTERFACE:Extra outputs are expected, but must not be returned in the neighbor tuple. Provide movement_type via the 2nd return only; route any additional diagnostics through a side-channel structure in other_params if the runner collects it.\nE_CODE_PERF:Evaluation is O(k) in set size; acceptable. Avoid sorting inside evaluation by requiring neighbors to output already-sorted unique sets; or maintain a boolean inclusion array to skip sort entirely.\nKNOWN_BEST_ASSERTION:Cross-validated evaluate_solution against an exact solver using the given data; results are consistent. Do not alter objective sign or feasibility rules.\nACTIONABLE_FIX_ORDER:1) Implement perturb_solution. 2) Conform Heuristic signature and parameter passing. 3) Fix generate_neighbour to return exactly (solution_csv, move_type). 4) Seed RNG via other_params. 5) Optimize neighbor with precomputed stats and marginal repair. 6) Replace infeasible sample with a feasible seed.\nTEST_PROTOCOL:After fixes, run: (a) evaluate_solution on the feasible seed (expect finite negative), (b) 100 neighbor calls to verify all returns are 2-tuples, feasible, and strictly change solution in >0% of cases, (c) short ILS\/SA runs to confirm best_score strictly improves from baseline without unpack errors.\""}
