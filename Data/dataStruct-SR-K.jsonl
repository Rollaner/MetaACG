{"Instancia": "knapsack_hard_dataset_in_house_24_11_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x[i]", "domain": "BINARY for i in ITEMS (0..23)", "meaning": "1 if item with index i (zero-based) is selected, 0 otherwise"}], "DATA_ROLES": {"ITEMS": {"INDEXING": "LIST", "MEANING": "Index set for items, ITEMS = 0..23 (zero-based indices)"}, "weights": {"INDEXING": "LIST", "MEANING": "weights[i] is the weight (kg) of item with index i in ITEMS"}, "values": {"INDEXING": "LIST", "MEANING": "values[i] is the value (â‚¬) of item with index i in ITEMS"}, "capacity": {"INDEXING": "SCALAR", "MEANING": "Maximum allowed total weight (kg)"}}, "DATA": {"weights": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6], "values": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "capacity": 80}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "sum(values[i]*x[i] for i in ITEMS)"}, "CONSTRAINTS": ["sum(weights[i]*x[i] for i in ITEMS) <= capacity", "x[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"type": "list_of_integers_zero_based", "description": "Comma-separated list of selected item indices using zero-based indexing (0..23). Example: \"0,1,3\" corresponds to items 1,2,4 in human-readable 1-based numbering."}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Convert an instance-like object into the target schema:\n      {'ITEMS': [...], 'weights': [...], 'values': [...], 'capacity': scalar}\n    Heuristics:\n      - Reads input.values and input.weights (tuples/lists of numbers or numeric-strings).\n      - Attempts to find a capacity from common attribute names (capacity, cap, C, W, scoreWeight, maxWeight, limit).\n      - If no capacity found, defaults to sum(weights).\n    \"\"\"\n    import re\n\n    def to_int(x):\n        # robustly convert various representations to int\n        if isinstance(x, int):\n            return x\n        if isinstance(x, float):\n            return int(x)\n        if x is None:\n            return 0\n        s = str(x).strip()\n        # plain numeric with possible decimal/comma\n        s2 = s.replace(',', '')  # remove thousands separators if present\n        try:\n            f = float(s2)\n            return int(f)\n        except:\n            # extract first integer-looking token\n            m = re.search(r'-?\\d+', s)\n            if m:\n                return int(m.group(0))\n            # fallback\n            raise ValueError(\"Cannot parse integer from %r\" % (x,))\n\n    # fetch values and weights\n    vals = None\n    wgs = None\n    if hasattr(input, 'values'):\n        vals = getattr(input, 'values')\n    elif hasattr(input, 'valores'):\n        vals = getattr(input, 'valores')\n    if hasattr(input, 'weights'):\n        wgs = getattr(input, 'weights')\n    elif hasattr(input, 'pesos'):\n        wgs = getattr(input, 'pesos')\n\n    # if either missing, try to fall back to attributes that may contain both\n    if vals is None or wgs is None:\n        # try a generic inspection of attributes\n        for name in dir(input):\n            if vals is None and name.lower() in ('values','value','vals'):\n                vals = getattr(input, name)\n            if wgs is None and name.lower() in ('weights','weight','wgs','pesos'):\n                wgs = getattr(input, name)\n\n    if vals is None or wgs is None:\n        raise ValueError(\"Input object lacks required 'values' or 'weights' attributes\")\n\n    # normalize to lists of ints\n    try:\n        values = [to_int(x) for x in list(vals)]\n        weights = [to_int(x) for x in list(wgs)]\n    except Exception as e:\n        raise ValueError(\"Failed to parse values/weights: %s\" % (e,))\n\n    # ensure same length\n    n = min(len(values), len(weights))\n    values = values[:n]\n    weights = weights[:n]\n\n    # determine capacity from common attribute names\n    capacity_candidates = ('capacity','cap','C','W','capacityKg','maxWeight','limit','scoreWeight','knapsack_capacity')\n    cap = None\n    for name in capacity_candidates:\n        if hasattr(input, name):\n            try:\n                cap = to_int(getattr(input, name))\n                break\n            except:\n                pass\n    # also check attributes that contain 'cap' or 'weight' in name\n    if cap is None:\n        for name in dir(input):\n            lname = name.lower()\n            if ('cap' in lname or 'weight' in lname or 'w' == lname) and not name.startswith('__'):\n                try:\n                    cap = to_int(getattr(input, name))\n                    break\n                except:\n                    pass\n\n    # final fallback: use sum(weights)\n    if cap is None:\n        cap = sum(weights)\n\n    items = list(range(n))\n    return {'ITEMS': items, 'weights': weights, 'values': values, 'capacity': cap}"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x[i]", "domain": "{0,1}", "meaning": "binary selection variable for decoration with index i (0-based, i in I)"}], "DATA_ROLES": {"I": {"indexing": "LIST", "meaning": "indices 0..23 (0-based) used to index decorations"}, "costs": {"indexing": "LIST", "meaning": "cost of each decoration indexed by I"}, "points": {"indexing": "LIST", "meaning": "point value (worth) of each decoration indexed by I"}, "budget": {"indexing": "SCALAR", "meaning": "maximum total cost allowed"}}, "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "costs": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "points": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "budget": 800}, "OBJECTIVE": {"sense": "max", "expression": "sum(x[i]*points[i] for i in I)"}, "CONSTRAINTS": ["sum(x[i]*costs[i] for i in I) <= budget", "x[i] binary for i in I"], "SOLUTION_FORMAT": {"type": "list", "description": "Provide a comma-separated list of decoration numbers (1-based) corresponding to selected decorations. Note: internal index I is 0-based; convert to output decoration numbers by i_out = i_in + 1. Example output: \"1,2,5\""}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Parse an instance string like:\n      InstanciaPruebaK(length=20, values=('114','38',...), weights=(...), solution=(...), score=1428, scoreWeight=970, time=0.0)\n    and produce a dict matching the TARGET_SCHEMA:\n      {'I': [0,...,n-1], 'costs': [...], 'points': [...], 'budget': scalar}\n    Assumptions / notes (kept as comments as required):\n      - 'values' -> points\n      - 'weights' -> costs\n      - 'scoreWeight' (if present) -> budget (capacity). Falls back to 'budget' or 'capacity' if those names appear.\n      - function is robust to numeric entries being quoted strings or bare numbers.\n    \"\"\"\n    import re, ast\n    s = input if isinstance(input, str) else str(input)\n\n    # Helper to extract a parenthesized tuple/list and turn into Python object\n    def extract_sequence(name):\n        m = re.search(r'%s\\s*=\\s*(\\([^\\)]*\\)|\\[[^\\]]*\\])' % re.escape(name), s)\n        if not m:\n            return None\n        txt = m.group(1)\n        try:\n            seq = ast.literal_eval(txt)\n            return list(seq)\n        except Exception:\n            # Fallback: try to parse as comma-separated tokens\n            inner = txt.strip(\"()[]\")\n            if not inner:\n                return []\n            parts = [p.strip() for p in inner.split(\",\") if p.strip() != \"\"]\n            return parts\n\n    # Extract values and weights (points and costs)\n    vals = extract_sequence('values')\n    wts = extract_sequence('weights')\n\n    # If values/weights not found under those names, try alternatives\n    if vals is None:\n        vals = extract_sequence('valuesList') or extract_sequence('vals') or []\n    if wts is None:\n        wts = extract_sequence('weightsList') or extract_sequence('wts') or []\n\n    # Convert items to ints when possible\n    def to_int_list(lst):\n        out = []\n        for x in lst:\n            try:\n                out.append(int(x))\n            except Exception:\n                try:\n                    out.append(int(float(x)))\n                except Exception:\n                    # remove quotes/spaces and try\n                    sx = str(x).strip().strip(\"'\\\"\")\n                    try:\n                        out.append(int(sx))\n                    except Exception:\n                        # final fallback: 0\n                        out.append(0)\n        return out\n\n    points = to_int_list(vals)\n    costs = to_int_list(wts)\n\n    # Determine budget: look for scoreWeight, budget, capacity, cap\n    budget = None\n    for key in ('scoreWeight', 'budget', 'capacity', 'cap', 'maxWeight'):\n        m = re.search(r'%s\\s*=\\s*([0-9]+(?:\\.[0-9]+)?)' % re.escape(key), s)\n        if m:\n            try:\n                # prefer integer\n                if '.' in m.group(1):\n                    budget = int(float(m.group(1)))\n                else:\n                    budget = int(m.group(1))\n            except Exception:\n                budget = None\n            break\n\n    # If budget still None, try to infer from a 'solution' field by looking for a nearby \"scoreWeight\" label omitted:\n    if budget is None:\n        # as a safe fallback, set budget to sum of costs (so capacity won't be violated)\n        budget = sum(costs)\n\n    # Build index list based on available points length (robust to mismatched 'length' field)\n    n = len(points)\n    I = list(range(n))\n\n    return {'I': I, 'costs': costs, 'points': points, 'budget': budget}"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x1", "domain": "BINARY", "meaning": "1 if accept customer 1's offer, 0 otherwise"}, {"symbol": "x2", "domain": "BINARY", "meaning": "1 if accept customer 2's offer, 0 otherwise"}, {"symbol": "x3", "domain": "BINARY", "meaning": "1 if accept customer 3's offer, 0 otherwise"}, {"symbol": "x4", "domain": "BINARY", "meaning": "1 if accept customer 4's offer, 0 otherwise"}, {"symbol": "x5", "domain": "BINARY", "meaning": "1 if accept customer 5's offer, 0 otherwise"}, {"symbol": "x6", "domain": "BINARY", "meaning": "1 if accept customer 6's offer, 0 otherwise"}, {"symbol": "x7", "domain": "BINARY", "meaning": "1 if accept customer 7's offer, 0 otherwise"}, {"symbol": "x8", "domain": "BINARY", "meaning": "1 if accept customer 8's offer, 0 otherwise"}, {"symbol": "x9", "domain": "BINARY", "meaning": "1 if accept customer 9's offer, 0 otherwise"}, {"symbol": "x10", "domain": "BINARY", "meaning": "1 if accept customer 10's offer, 0 otherwise"}, {"symbol": "x11", "domain": "BINARY", "meaning": "1 if accept customer 11's offer, 0 otherwise"}, {"symbol": "x12", "domain": "BINARY", "meaning": "1 if accept customer 12's offer, 0 otherwise"}, {"symbol": "x13", "domain": "BINARY", "meaning": "1 if accept customer 13's offer, 0 otherwise"}, {"symbol": "x14", "domain": "BINARY", "meaning": "1 if accept customer 14's offer, 0 otherwise"}, {"symbol": "x15", "domain": "BINARY", "meaning": "1 if accept customer 15's offer, 0 otherwise"}, {"symbol": "x16", "domain": "BINARY", "meaning": "1 if accept customer 16's offer, 0 otherwise"}, {"symbol": "x17", "domain": "BINARY", "meaning": "1 if accept customer 17's offer, 0 otherwise"}, {"symbol": "x18", "domain": "BINARY", "meaning": "1 if accept customer 18's offer, 0 otherwise"}, {"symbol": "x19", "domain": "BINARY", "meaning": "1 if accept customer 19's offer, 0 otherwise"}, {"symbol": "x20", "domain": "BINARY", "meaning": "1 if accept customer 20's offer, 0 otherwise"}, {"symbol": "x21", "domain": "BINARY", "meaning": "1 if accept customer 21's offer, 0 otherwise"}, {"symbol": "x22", "domain": "BINARY", "meaning": "1 if accept customer 22's offer, 0 otherwise"}, {"symbol": "x23", "domain": "BINARY", "meaning": "1 if accept customer 23's offer, 0 otherwise"}, {"symbol": "x24", "domain": "BINARY", "meaning": "1 if accept customer 24's offer, 0 otherwise"}], "DATA_ROLES": [{"name": "prices", "indexing": "LIST", "meaning": "offered price per customer; order corresponds to customer 1..24"}, {"name": "volumes", "indexing": "LIST", "meaning": "gallons requested per customer; order corresponds to customer 1..24"}, {"name": "capacity", "indexing": "SCALAR", "meaning": "maximum total gallons available (scalar)"}, {"name": "known_random_solution", "indexing": "LIST", "meaning": "example candidate solution expressed as indices (indexing convention must be declared)"}, {"name": "expected_result_from_solution", "indexing": "SCALAR", "meaning": "expected revenue produced by known_random_solution (scalar)"}], "DATA": {"prices": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "volumes": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6], "capacity": 80, "known_random_solution": [0, 1, 3, 5, 6, 12, 15, 16, 17, 19, 20, 22], "expected_result_from_solution": 219}, "OBJECTIVE": {"sense": "MAX", "expression": "prices[0]*x1 + prices[1]*x2 + prices[2]*x3 + prices[3]*x4 + prices[4]*x5 + prices[5]*x6 + prices[6]*x7 + prices[7]*x8 + prices[8]*x9 + prices[9]*x10 + prices[10]*x11 + prices[11]*x12 + prices[12]*x13 + prices[13]*x14 + prices[14]*x15 + prices[15]*x16 + prices[16]*x17 + prices[17]*x18 + prices[18]*x19 + prices[19]*x20 + prices[20]*x21 + prices[21]*x22 + prices[22]*x23 + prices[23]*x24"}, "CONSTRAINTS": ["volumes[0]*x1 + volumes[1]*x2 + volumes[2]*x3 + volumes[3]*x4 + volumes[4]*x5 + volumes[5]*x6 + volumes[6]*x7 + volumes[7]*x8 + volumes[8]*x9 + volumes[9]*x10 + volumes[10]*x11 + volumes[11]*x12 + volumes[12]*x13 + volumes[13]*x14 + volumes[14]*x15 + volumes[15]*x16 + volumes[16]*x17 + volumes[17]*x18 + volumes[18]*x19 + volumes[19]*x20 + volumes[20]*x21 + volumes[21]*x22 + volumes[22]*x23 + volumes[23]*x24 <= capacity", "x1 in {0,1}; x2 in {0,1}; x3 in {0,1}; x4 in {0,1}; x5 in {0,1}; x6 in {0,1}; x7 in {0,1}; x8 in {0,1}; x9 in {0,1}; x10 in {0,1}; x11 in {0,1}; x12 in {0,1}; x13 in {0,1}; x14 in {0,1}; x15 in {0,1}; x16 in {0,1}; x17 in {0,1}; x18 in {0,1}; x19 in {0,1}; x20 in {0,1}; x21 in {0,1}; x22 in {0,1}; x23 in {0,1}; x24 in {0,1}"], "SOLUTION_FORMAT": {"type": "COMMA_SEPARATED_CUSTOMER_NUMBERS_1_BASED", "description": "Output must be a comma-separated list of accepted customer numbers using 1-based numbering (e.g., \"1,5,12\"). NOTE: the provided KNOWN_RANDOM_SOLUTION in DATA is a 0-based index list; if using that example for verification convert each index i -> (i+1) to match this SOLUTION_FORMAT before final reporting."}}, "FuncionDeCarga": "def Transform(instance):\n    \"\"\"\n    Convert an input instance object into the target schema:\n      - prices: list of ints (offered price per customer 1..n)\n      - volumes: list of ints (gallons requested per customer 1..n)\n      - capacity: int (maximum total gallons available)\n      - known_random_solution: list of selected customer indices (1-based indexing)\n      - expected_result_from_solution: int (revenue produced by the known_random_solution)\n    \n    Indexing convention for 'known_random_solution': 1-based indices of customers.\n    \"\"\"\n    # helper to coerce a sequence-like attribute to list of ints\n    def seq_to_ints(x):\n        if x is None:\n            return []\n        # if it's a single string with separators, try splitting\n        if isinstance(x, str):\n            # try common separators\n            for sep in (\",\", \";\", \" \"):\n                if sep in x:\n                    parts = [p for p in x.split(sep) if p != \"\"]\n                    try:\n                        return [int(p) for p in parts]\n                    except:\n                        break\n            # fallback: try to parse as single int\n            try:\n                return [int(x)]\n            except:\n                return []\n        # if it's an iterable (tuple/list), convert elements to int where possible\n        try:\n            return [int(e) for e in x]\n        except:\n            # last resort: empty\n            return []\n\n    # Extract prices and volumes from common attribute names\n    prices = []\n    volumes = []\n    # common names from example: values -> prices, weights -> volumes\n    prices = seq_to_ints(getattr(instance, \"values\", None) or getattr(instance, \"prices\", None) or getattr(instance, \"vals\", None))\n    volumes = seq_to_ints(getattr(instance, \"weights\", None) or getattr(instance, \"volumes\", None) or getattr(instance, \"w\", None))\n\n    # Ensure lengths match or handle missing by padding/truncating conservatively\n    n = None\n    if prices:\n        n = len(prices)\n    if volumes:\n        if n is None:\n            n = len(volumes)\n        elif len(volumes) != n:\n            # if mismatch, align to min length\n            m = min(len(prices), len(volumes))\n            prices = prices[:m]\n            volumes = volumes[:m]\n            n = m\n\n    if n is None:\n        # no usable customer data; return empty structure with capacity 0\n        return {\n            \"prices\": [],\n            \"volumes\": [],\n            \"capacity\": 0,\n            \"known_random_solution\": [],\n            \"expected_result_from_solution\": 0\n        }\n\n    # Determine capacity from likely attribute names\n    capacity = None\n    for attr in (\"capacity\", \"capacidad\", \"scoreWeight\", \"maxWeight\", \"W\", \"capacityWeight\", \"cap\"):\n        if hasattr(instance, attr):\n            val = getattr(instance, attr)\n            try:\n                capacity = int(val)\n                break\n            except:\n                # try to parse from string\n                try:\n                    capacity = int(str(val))\n                    break\n                except:\n                    continue\n    if capacity is None:\n        # fallback: sum of volumes (full availability) or 0 if volumes empty\n        capacity = sum(volumes)\n\n    # Build known_random_solution as 1-based indices\n    known_solution_attr = getattr(instance, \"solution\", None) or getattr(instance, \"sol\", None) or getattr(instance, \"known_random_solution\", None)\n    known_random_solution = []\n    if known_solution_attr is None:\n        known_random_solution = []\n    else:\n        sol_list = seq_to_ints(known_solution_attr)\n        if not sol_list:\n            known_random_solution = []\n        else:\n            # Distinguish between binary selection vector versus explicit indices.\n            # If entries are only 0/1 (or strings \"0\"/\"1\"), treat as binary vector.\n            unique_vals = set(sol_list)\n            if unique_vals.issubset({0, 1}):\n                # convert binary vector to 1-based indices where 1 appears\n                known_random_solution = [i + 1 for i, v in enumerate(sol_list[:n]) if v == 1]\n            else:\n                # treat provided numbers as indices. Heuristic: if any index is 0, assume 0-based -> convert to 1-based\n                max_idx = max(sol_list)\n                min_idx = min(sol_list)\n                # if indices look like positions within 1..n, assume 1-based; if within 0..n-1, assume 0-based\n                if min_idx >= 1 and max_idx <= n:\n                    known_random_solution = [int(i) for i in sol_list]\n                elif min_idx >= 0 and max_idx <= n - 1:\n                    known_random_solution = [int(i) + 1 for i in sol_list]\n                else:\n                    # if indices fall outside expected range, clip/convert best-effort: map each to nearest valid 1..n\n                    def clamp_to_1n(x):\n                        xi = int(x)\n                        if xi < 1:\n                            return 1\n                        if xi > n:\n                            return n\n                        return xi\n                    known_random_solution = [clamp_to_1n(i) for i in sol_list]\n\n    # Compute expected revenue from the known_random_solution (sum of prices of selected customers)\n    expected_result_from_solution = 0\n    for idx in known_random_solution:\n        if 1 <= idx <= len(prices):\n            expected_result_from_solution += prices[idx - 1]\n\n    return {\n        \"prices\": prices,\n        \"volumes\": volumes,\n        \"capacity\": capacity,\n        \"known_random_solution\": known_random_solution,\n        \"expected_result_from_solution\": expected_result_from_solution\n    }"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"x": {"symbol": "x[i]", "domain": "{0,1}", "meaning": "binary selection for attraction i (1 if selected, 0 otherwise). Vector of length n, using 0-based indexing corresponding to DATA arrays."}}, "DATA_ROLES": {"scores": {"name": "scores", "indexing": "LIST", "meaning": "point value for each attraction, ordered by attraction number (stored 0-based in DATA.scores[0] = attraction 1)"}, "times": {"name": "times", "indexing": "LIST", "meaning": "time required in minutes for each attraction, ordered same as scores"}, "limit": {"name": "limit", "indexing": "SCALAR", "meaning": "total available sightseeing time in minutes"}, "n": {"name": "n", "indexing": "SCALAR", "meaning": "number of attractions (length of scores and times lists)"}, "known_solution": {"name": "known_solution", "indexing": "LIST", "meaning": "a reference solution given as a binary selection vector using 0-based indexing (length n)"}, "expected_score": {"name": "expected_score", "indexing": "SCALAR", "meaning": "reported objective value corresponding to known_solution"}}, "DATA": {"scores": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "times": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "limit": 800, "n": 24, "known_solution": [0, 1, 3, 5, 6, 12, 15, 16, 17, 19, 20, 22], "expected_score": 219}, "OBJECTIVE": {"SENSE": "MAX", "EXPRESSION": "quicksum(scores[i]*x[i] for i in range(n))", "EVALUATION_FUNCTION": "def eval_solution(x):\n    return sum(scores[i]*x[i] for i in range(n))", "VERIFICATION": "eval_solution(known_solution) == expected_score and sum(times[i]*known_solution[i] for i in range(n)) <= limit"}, "CONSTRAINTS": ["quicksum(times[i]*x[i] for i in range(n)) <= limit", "x[i] in {0,1} for i in range(n)  # binary/integrality constraint"], "SOLUTION_FORMAT": {"TYPE": "comma_separated_list_of_integers", "DESCRIPTION": "List attraction numbers (1-based) separated by commas. Convert internal 0-based selected indices to 1-based IDs when reporting (reported_id = index + 1)."}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Parse an InstanciaPruebaK(...) representation (string or object) and return a dict\n    matching the TARGET_SCHEMA:\n    {'scores': [...], 'times': [...], 'limit': int, 'n': int, 'known_solution': [...], 'expected_score': int}\n    \"\"\"\n    import re, ast\n\n    def to_int_list(x):\n        # Accept tuple/list of strings or numbers -> list of ints\n        return [int(y) for y in (list(x) if not isinstance(x, str) else ast.literal_eval(x))]\n\n    # If input is an object with attributes, extract directly\n    if not isinstance(input, str):\n        # try attribute access\n        obj = input\n        def getattr_safe(name):\n            return getattr(obj, name, None)\n        values = getattr_safe('values') or getattr_safe('values_tuple') or getattr_safe('vals')\n        weights = getattr_safe('weights') or getattr_safe('times')\n        solution = getattr_safe('solution') or getattr_safe('known_solution')\n        score = getattr_safe('score') or getattr_safe('expected_score')\n        scoreWeight = getattr_safe('scoreWeight') or getattr_safe('limit') or getattr_safe('capacity')\n        # Normalize\n        if values is None:\n            # fallback to __dict__\n            try:\n                d = obj.__dict__\n                values = d.get('values')\n                weights = d.get('weights')\n                solution = d.get('solution')\n                score = d.get('score')\n                scoreWeight = d.get('scoreWeight')\n            except Exception:\n                pass\n        # convert\n        scores = to_int_list(values) if values is not None else []\n        times = to_int_list(weights) if weights is not None else []\n        known_solution = [int(x) for x in (list(solution) if solution is not None and not isinstance(solution, str) else (ast.literal_eval(solution) if solution is not None else []))]\n        expected_score = int(score) if score is not None else sum([scores[i] for i,bit in enumerate(known_solution) if bit])\n        limit = int(scoreWeight) if scoreWeight is not None else None\n        n = len(scores)\n        return {'scores': scores, 'times': times, 'limit': limit, 'n': n, 'known_solution': known_solution, 'expected_score': expected_score}\n\n    # If input is a string, parse it\n    s = input.strip()\n    # extract content inside the outermost parentheses\n    if '(' in s and s.rstrip().endswith(')'):\n        body = s[s.find('(')+1 : s.rfind(')')]\n    else:\n        body = s\n\n    # Build a dict-literal string by quoting keys, then literal_eval\n    dict_like = '{' + body + '}'\n    dict_like = re.sub(r'(\\b\\w+\\b)\\s*=', r\"'\\1':\", dict_like)\n    # Safely evaluate\n    data = ast.literal_eval(dict_like)\n\n    # Possible key names\n    values = data.get('values') or data.get('values_tuple') or data.get('vals')\n    weights = data.get('weights') or data.get('times')\n    solution = data.get('solution') or data.get('known_solution')\n    score = data.get('score') or data.get('expected_score')\n    scoreWeight = data.get('scoreWeight') or data.get('limit') or data.get('capacity')\n\n    # Convert to required types\n    scores = to_int_list(values) if values is not None else []\n    times = to_int_list(weights) if weights is not None else []\n    if solution is None:\n        known_solution = []\n    else:\n        # solution may be tuple of '0'/'1' strings or ints\n        if isinstance(solution, str):\n            known_solution = [int(x) for x in ast.literal_eval(solution)]\n        else:\n            known_solution = [int(x) for x in list(solution)]\n    expected_score = int(score) if score is not None else sum([scores[i] for i,bit in enumerate(known_solution) if bit])\n    limit = int(scoreWeight) if scoreWeight is not None else None\n    n = len(scores)\n\n    return {'scores': scores, 'times': times, 'limit': limit, 'n': n, 'known_solution': known_solution, 'expected_score': expected_score}"}
