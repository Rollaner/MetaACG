{"Instancia": "knapsack_hard_dataset_in_house_24_0_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "INDEXING": "ITEMS", "MEANING": "X[i] == 1 if item i is selected, 0 otherwise. ITEMS uses 1-based indices 1..24."}], "DATA_ROLES": [{"NAME": "ITEMS", "INDEXING": "LIST", "MEANING": "Index set of item identifiers (1..24), 1-based indexing."}, {"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "Weight of each item i (kg), aligned with ITEMS (Python list indexed 0..23; use i-1 when indexing)."}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "Value of each item i (€), aligned with ITEMS (Python list indexed 0..23; use i-1 when indexing)."}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Maximum allowable total weight of selected items (kg)."}], "DATA": {"ITEMS": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "WEIGHTS": [18, 17, 6, 20, 3, 10, 20, 15, 8, 15, 21, 7, 24, 23, 2, 6, 24, 9, 3, 5, 11, 9, 17, 14], "VALUES": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "CAPACITY": 103}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(VALUES[i-1]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i-1]*X[i] for i in ITEMS) <= CAPACITY", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "Comma-separated list of selected item numbers using 1-based indices as in the problem statement, e.g. \"1,3,5\"."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d.get('DATA', {})\n    items = data.get('ITEMS', [])\n    weights = data.get('WEIGHTS', [])\n    values = data.get('VALUES', [])\n    capacity = data.get('CAPACITY', 0)\n    standardDataclass.length = len(items)\n    standardDataclass.values = list(values)\n    standardDataclass.weights = list(weights)\n    standardDataclass.capacity = capacity\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "ITEMS", "DOMAIN": "LIST", "MEANING": "List of item indices (0..23) corresponding to items 1..24"}, {"SYMBOL": "X", "DOMAIN": "BINARY_VECTOR", "MEANING": "Decision variable X[i] = 1 if item i is included in the bag, 0 otherwise, indexed by ITEMS"}], "DATA_ROLES": [{"NAME": "W", "INDEXING": "LIST", "MEANING": "Weights (kg) of items 1..24 in order"}, {"NAME": "V", "INDEXING": "LIST", "MEANING": "Values (€) of items 1..24 in order"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Bag capacity in kg"}], "DATA": {"W": [18, 17, 6, 20, 3, 10, 20, 15, 8, 15, 21, 7, 24, 23, 2, 6, 24, 9, 3, 5, 11, 9, 17, 14], "V": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "CAPACITY": 103}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(V[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(W[i]*X[i] for i in ITEMS) <= CAPACITY", "for i in ITEMS: X[i] in BINARY"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of item indices to include in the bag (e.g. \"0,2,5\")"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    ed = ast.literal_eval(extractedData)\n    d = ed['DATA']\n    W = d['W']\n    V = d['V']\n    CAP = d['CAPACITY']\n    standardDataclass.length = len(W)\n    standardDataclass.values = V\n    standardDataclass.weights = W\n    standardDataclass.capacity = CAP\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i] = 1 if decoration with 0-based index i is purchased, 0 otherwise; i in ITEMS"}], "DATA_ROLES": [{"name": "ITEMS", "indexing": "LIST", "meaning": "list of 0-based decoration indices (0..23) corresponding to Decoration 1..24"}, {"name": "COSTS", "indexing": "LIST", "meaning": "cost of each decoration in the order of ITEMS"}, {"name": "POINTS", "indexing": "LIST", "meaning": "point value (benefit) of each decoration in the order of ITEMS"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "available budget (upper bound on total cost)"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [180, 170, 60, 200, 30, 100, 200, 150, 80, 150, 210, 70, 240, 230, 20, 60, 240, 90, 30, 50, 110, 90, 170, 140], "POINTS": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "BUDGET": 1030}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "quicksum(POINTS[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*X[i] for i in ITEMS) <= BUDGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"type": "0-indexed comma-separated list", "description": "Comma-separated list of chosen decorations using 0-based indices (e.g. \"0,3,5\"). Each index corresponds to Decoration (index+1)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    data = parsed['DATA']\n    standardDataclass.length = len(data['ITEMS'])\n    standardDataclass.values = list(data['POINTS'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = data['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if offer from customer i (0-indexed) is accepted, 0 otherwise; indexed by CUSTOMERS"}], "DATA_ROLES": [{"NAME": "CUSTOMERS", "INDEXING": "LIST", "MEANING": "Index set of customers, 0-indexed"}, {"NAME": "PRICE", "INDEXING": "CUSTOMERS", "MEANING": "Offered revenue (dollars) from each customer i"}, {"NAME": "VOLUME", "INDEXING": "CUSTOMERS", "MEANING": "Requested volume (gallons) from each customer i"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Total available gallons of lemonade"}], "DATA": {"CUSTOMERS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "PRICE": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "VOLUME": [18, 17, 6, 20, 3, 10, 20, 15, 8, 15, 21, 7, 24, 23, 2, 6, 24, 9, 3, 5, 11, 9, 17, 14], "CAPACITY": 103}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(PRICE[i]*X[i] for i in CUSTOMERS)"}, "CONSTRAINTS": ["quicksum(VOLUME[i]*X[i] for i in CUSTOMERS) <= CAPACITY"], "SOLUTION_FORMAT": {"TYPE": "COMMA_SEPARATED_INDICES", "DESCRIPTION": "0-indexed, comma-separated list of customer indices whose offers to accept (e.g. 0,3,5)."}}, "FuncionDeCarga": "import ast\n\ndef Transform(extractedData, standardDataclass):\n    d = ast.literal_eval(extractedData)\n    data = d.get('DATA', {})\n    customers = data.get('CUSTOMERS', [])\n    standardDataclass.length = len(customers)\n    standardDataclass.values = list(data.get('PRICE', standardDataclass.values))\n    standardDataclass.weights = list(data.get('VOLUME', standardDataclass.weights))\n    standardDataclass.capacity = data.get('CAPACITY', standardDataclass.capacity)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY_INDEXED_BY_I", "meaning": "X[i] = 1 if attraction i is chosen, 0 otherwise"}], "DATA_ROLES": [{"name": "I", "indexing": "LIST", "meaning": "Index set of attractions (0-indexed)"}, {"name": "SCORES", "indexing": "LIST", "meaning": "Point value for each attraction, indexed by I"}, {"name": "TIMES", "indexing": "LIST", "meaning": "Time in minutes required for each attraction, indexed by I"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "Total available sightseeing time in minutes"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "SCORES": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "TIMES": [180, 170, 60, 200, 30, 100, 200, 150, 80, 150, 210, 70, 240, 230, 20, 60, 240, 90, 30, 50, 110, 90, 170, 140], "BUDGET": 1030}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "quicksum(SCORES[i] * X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i] * X[i] for i in I) <= BUDGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"type": "0-indexed comma-separated list", "description": "List of attraction indices (0-based). Example optimal solution found: [0,2,4,5,10,14,17,18,19,20,23] with total score = 174 and total time = 1020 <= 1030."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d.get('DATA', {})\n    I = data.get('I', [])\n    SCORES = data.get('SCORES', [])\n    TIMES = data.get('TIMES', [])\n    BUDGET = data.get('BUDGET', 0)\n    standardDataclass.length = len(I)\n    standardDataclass.values = list(SCORES)\n    standardDataclass.weights = list(TIMES)\n    standardDataclass.capacity = BUDGET\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "Binary", "MEANING": "Decision variable X[i] for i in ITEMS: 1 if item i is taken, 0 otherwise (ITEMS is 0-indexed)"}], "DATA_ROLES": [{"NAME": "ITEMS", "INDEXING": "LIST", "MEANING": "Index set of items, 0-indexed positions corresponding to the item list order"}, {"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "Weight of each item in kilograms, ordered by ITEMS"}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "Value of each item in euros, ordered by ITEMS"}, {"NAME": "REQUIRED_WEIGHT", "INDEXING": "SCALAR", "MEANING": "Minimum required total weight (kg)"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHTS": [18, 17, 6, 20, 3, 10, 20, 15, 8, 15, 21, 7, 24, 23, 2, 6, 24, 9, 3, 5, 11, 9, 17, 14], "VALUES": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "REQUIRED_WEIGHT": 204}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(VALUES[i] * X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i] * X[i] for i in ITEMS) >= REQUIRED_WEIGHT", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed comma-separated list of item indices to pack (each element is an integer corresponding to an ITEMS entry)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['ITEMS'])\n    standardDataclass.values = list(data['VALUES'])\n    standardDataclass.weights = list(data['WEIGHTS'])\n    standardDataclass.capacity = int(data['REQUIRED_WEIGHT'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "X[i] in {0,1} for i in ITEMS", "MEANING": "Binary decision: X[i]=1 if decoration with index i is purchased, 0 otherwise"}], "DATA_ROLES": [{"NAME": "ITEMS", "INDEXING": "LIST", "MEANING": "List of item indices (0-based) for the 24 decorations"}, {"NAME": "COSTS", "INDEXING": "LIST", "MEANING": "COSTS[i] is the dollar cost of decoration with index i"}, {"NAME": "POINTS", "INDEXING": "LIST", "MEANING": "POINTS[i] is the point value (decoration worth) of decoration with index i"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Minimum total spend required (in dollars)"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [180, 170, 60, 200, 30, 100, 200, 150, 80, 150, 210, 70, 240, 230, 20, 60, 240, 90, 30, 50, 110, 90, 170, 140], "POINTS": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "BUDGET": 2040}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "QUICKSUM(POINTS[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["QUICKSUM(COSTS[i]*X[i] for i in ITEMS) >= BUDGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list of integers", "DESCRIPTION": "Return the indices (0-based) of decorations to purchase as a comma-separated list, e.g. \"0,3,5\""}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['ITEMS'])\n    standardDataclass.values = list(data['POINTS'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = int(data['BUDGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X[I]", "DOMAIN": "BINARY, for I = 0..N-1", "MEANING": "X[I] = 1 if we accept the offer from customer with index I (0-indexed), 0 otherwise"}], "DATA_ROLES": [{"NAME": "PRICES", "INDEXING": "LIST", "MEANING": "Price (dollars) offered by customer at index I, ordered by customer number (customer 1 -> index 0, ..., customer 24 -> index 23)"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "Gallons of lemonade requested by customer at index I, ordered by customer number (customer 1 -> index 0, ..., customer 24 -> index 23)"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of customer offers (length of PRICES and GALLONS lists)"}, {"NAME": "TARGET", "INDEXING": "SCALAR", "MEANING": "Required minimum total gallons to sell"}], "DATA": {"PRICES": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "GALLONS": [18, 17, 6, 20, 3, 10, 20, 15, 8, 15, 21, 7, 24, 23, 2, 6, 24, 9, 3, 5, 11, 9, 17, 14], "N": 24, "TARGET": 204}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "SUM(PRICES[I] * X[I] for I = 0..N-1)"}, "CONSTRAINTS": ["SUM(GALLONS[I] * X[I] for I = 0..N-1) >= TARGET", "X[I] in {0,1} for I = 0..N-1"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list", "DESCRIPTION": "Return the selected customer indices (0 through 23) as a comma-separated list with no spaces, e.g. \"0,3,5\"."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    inst = standardDataclass()\n    inst.length = d['DATA']['N']\n    inst.values = d['DATA']['PRICES']\n    inst.weights = d['DATA']['GALLONS']\n    inst.capacity = d['DATA']['TARGET']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_0_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "X[i] in {0,1} for all i in I", "meaning": "Binary decision variable: 1 if attraction i is suggested to the friend, 0 otherwise"}], "DATA_ROLES": [{"name": "I", "indexing": "LIST", "meaning": "Index set for attractions (0-indexed)"}, {"name": "SCORE", "indexing": "LIST", "meaning": "Point value (score) for each attraction indexed by I"}, {"name": "TIME", "indexing": "LIST", "meaning": "Time required in minutes for each attraction indexed by I"}, {"name": "TARGET_TIME", "indexing": "SCALAR", "meaning": "Required minimum total time the friend must spend (minutes)"}, {"name": "N", "indexing": "SCALAR", "meaning": "Number of attractions"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "SCORE": [16, 4, 24, 6, 3, 23, 11, 7, 1, 8, 16, 1, 18, 13, 19, 2, 17, 17, 8, 12, 15, 11, 3, 21], "TIME": [180, 170, 60, 200, 30, 100, 200, 150, 80, 150, 210, 70, 240, 230, 20, 60, 240, 90, 30, 50, 110, 90, 170, 140], "TARGET_TIME": 2040, "N": 24}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(SCORE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i]*X[i] for i in I) >= TARGET_TIME", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed comma-separated list of attraction indices to suggest to the friend (each index is an integer corresponding to an entry in I)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    data = eval(extractedData)\n    D = data['DATA']\n    standardDataclass.length = D['N']\n    standardDataclass.values = D['SCORE']\n    standardDataclass.weights = D['TIME']\n    standardDataclass.capacity = D['TARGET_TIME']\n    standardDataclass.score = 0\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY for i in ITEMS_INDEX (X[i] in {0,1})", "MEANING": "1 if item i is selected, 0 otherwise"}], "DATA_ROLES": [{"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "weight of each item in kilograms (order corresponds to item indices 0..23)"}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "value of each item in euros (order corresponds to item indices 0..23)"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "bag capacity in kilograms"}, {"NAME": "ITEMS_INDEX", "INDEXING": "LIST", "MEANING": "0-indexed list of item indices"}], "DATA": {"ITEMS_INDEX": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHTS": [15, 9, 23, 5, 7, 4, 13, 17, 9, 10, 22, 6, 17, 19, 5, 4, 20, 9, 19, 7, 6, 14, 15, 1], "VALUES": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "CAPACITY": 106}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(VALUES[i]*X[i] for i in ITEMS_INDEX)"}, "CONSTRAINTS": ["sum(WEIGHTS[i]*X[i] for i in ITEMS_INDEX) <= CAPACITY", "X[i] in {0,1} for i in ITEMS_INDEX"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of selected item indices. Optimal solution (verified): 0,1,3,4,6,9,14,15,17,19,20,22,23 (total value = 212, total weight = 106)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    inst = standardDataclass()\n    inst.length = len(d['DATA']['WEIGHTS'])\n    inst.values = d['DATA']['VALUES']\n    inst.weights = d['DATA']['WEIGHTS']\n    inst.capacity = d['DATA']['CAPACITY']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x", "domain": "binary {0,1} indexed by I", "meaning": "x[i] = 1 if decoration at index i is purchased, 0 otherwise"}], "DATA_ROLES": [{"name": "COSTS", "indexing": "LIST", "meaning": "list of costs for each decoration in order (indexing I corresponds to positions 0..N-1)"}, {"name": "POINTS", "indexing": "LIST", "meaning": "list of point values for each decoration in order (indexing I corresponds to positions 0..N-1)"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "total available budget"}, {"name": "I", "indexing": "LIST", "meaning": "index set for decorations (0-indexed positions into COSTS and POINTS)"}, {"name": "N", "indexing": "SCALAR", "meaning": "number of available decorations"}], "DATA": {"COSTS": [150, 90, 230, 50, 70, 40, 130, 170, 90, 100, 220, 60, 170, 190, 50, 40, 200, 90, 190, 70, 60, 140, 150, 10], "POINTS": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "BUDGET": 1060, "N": 24, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "quicksum(POINTS[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*x[i] for i in I) <= BUDGET", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"type": "LIST", "description": "0-indexed, comma-separated list of decoration indices to purchase (indices correspond to positions in DATA.COSTS and DATA.POINTS).\n\nFEEDBACK KEYS (classified):\nDATA_ERROR: No data errors detected. The COSTS and POINTS lists have length N=24, indexing is 0-based, and DATA entries match the declared DATA_ROLES and indexing rules.\nLOGIC_ERROR: No logic errors detected. Objective and budget constraint correctly model a 0-1 knapsack: maximize sum(POINTS[i]*x[i]) subject to sum(COSTS[i]*x[i]) <= BUDGET with binary x.\nRESULTS_NOT_CONSISTENT: No inconsistency found. The KNOWN_RANDOM_SOLUTION provided yields the expected totals (see EVALUATION below).\n\nPINPOINTED_MATH_REVIEW: No specific mathematical flaws found. All operators and formulations align with the problem statement. If a future issue appears, indicate the offending expression line (e.g., 'quicksum(COSTS[i]*x[i] ...)') and suggest the correction.\n\nEVALUATION_FUNCTION (ground-truth verification): To verify any candidate solution SOL (a list of indices), evaluate:\n  total_points = sum(POINTS[i] for i in SOL)\n  total_cost = sum(COSTS[i] for i in SOL)\nThis provides an independent check of objective value and feasibility against BUDGET.\n\nEXAMPLE_VERIFICATION_FOR_KNOWN_RANDOM_SOLUTION: KNOWN_RANDOM_SOLUTION = [0,1,3,4,6,9,14,15,17,19,20,22,23]\n  total_points = 212\n  total_cost = 1060\nBoth values match the EXPECTED_RESULT_FROM_SOLUTION and satisfy the budget constraint exactly (<= BUDGET).\n\nACTIONABLE_SUGGESTIONS FOR IMPROVEMENT:\n1) Include an explicit 'KNOWN_SOLUTION' and 'EXPECTED_METRICS' keys in DATA for automated pipelines to validate candidate solutions programmatically.\n2) Provide solver-agnostic evaluation code snippet (above) in a machine-readable field if integration with local solvers or ast_eval dynamic checks is required.\n3) When scaling to larger instances, include item-level IDs and optionally fractional-relaxation bounds to help debugging and verifying solver outputs."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = list(data['POINTS'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = data['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "N", "DOMAIN": "SCALAR", "MEANING": "Number of customers"}, {"SYMBOL": "I", "DOMAIN": "INDEX_SET", "MEANING": "Index set for customers: I = range(0,N)"}, {"SYMBOL": "X", "DOMAIN": "BINARY_VECTOR_INDEXED_BY_I", "MEANING": "Decision variables X[i] = 1 if we accept customer i's offer, 0 otherwise; indexed by I"}], "DATA_ROLES": [{"NAME": "REVENUES", "INDEXING": "LIST", "MEANING": "Revenue offered by each customer, aligned with indices 0..N-1"}, {"NAME": "VOLUMES", "INDEXING": "LIST", "MEANING": "Gallons requested by each customer, aligned with indices 0..N-1"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Maximum total gallons available"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of customers"}], "DATA": {"REVENUES": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "VOLUMES": [15, 9, 23, 5, 7, 4, 13, 17, 9, 10, 22, 6, 17, 19, 5, 4, 20, 9, 19, 7, 6, 14, 15, 1], "CAPACITY": 106, "N": 24}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(REVENUES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["I = range(0,N)", "quicksum(VOLUMES[i]*X[i] for i in I) <= CAPACITY", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTEGERS", "DESCRIPTION": "0-indexed comma-separated list of customer indices to accept (each integer in 0..N-1)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    standardDataclass.length = d['DATA']['N']\n    standardDataclass.values = d['DATA']['REVENUES']\n    standardDataclass.weights = d['DATA']['VOLUMES']\n    standardDataclass.capacity = d['DATA']['CAPACITY']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "ITEMS", "DOMAIN": "LIST", "MEANING": "Index set of attractions using 0-based indexing: ITEMS = range(0,24) (i.e., 0..23). Declare before use."}, {"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "Decision variable X[i] in {0,1} for i in ITEMS; X[i]=1 indicates selecting attraction i."}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "ITEMS", "MEANING": "Points for each attraction; order corresponds to attractions 1..24 mapped to indices 0..23."}, {"NAME": "TIMES", "INDEXING": "ITEMS", "MEANING": "Time in minutes required for each attraction; order corresponds to attractions 1..24 mapped to indices 0..23."}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Total available sightseeing time in minutes (upper bound on sum(TIMES[i] * X[i]))."}], "DATA": {"SCORES": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "TIMES": [150, 90, 230, 50, 70, 40, 130, 170, 90, 100, 220, 60, 170, 190, 50, 40, 200, 90, 190, 70, 60, 140, 150, 10], "BUDGET": 1060}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "maximize quicksum(SCORES[i] * X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(TIMES[i] * X[i] for i in ITEMS) <= BUDGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list", "DESCRIPTION": "Selected attractions represented by their 0-based indices separated by commas (e.g., \"0,1,3\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['SCORES'])\n    standardDataclass.values = list(data['SCORES'])\n    standardDataclass.weights = list(data['TIMES'])\n    standardDataclass.capacity = int(data['BUDGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"I": {"DOMAIN": "0..23", "MEANING": "INDEX SET FOR ITEMS (0-BASED)"}, "X": {"DOMAIN": "{0,1} FOR ALL i IN I", "MEANING": "BINARY DECISION VARIABLE, X[i]=1 IF ITEM i IS TAKEN (i IS 0-BASED INDEX)"}}, "DATA_ROLES": {"WEIGHT": {"INDEXING": "LIST", "MEANING": "WEIGHT OF EACH ITEM IN KG, ORDERED BY 0-BASED ITEM INDEX"}, "VALUE": {"INDEXING": "LIST", "MEANING": "VALUE OF EACH ITEM IN EUR, ORDERED BY 0-BASED ITEM INDEX"}, "N": {"INDEXING": "SCALAR", "MEANING": "NUMBER OF ITEMS"}}, "DATA": {"WEIGHT": [15, 9, 23, 5, 7, 4, 13, 17, 9, 10, 22, 6, 17, 19, 5, 4, 20, 9, 19, 7, 6, 14, 15, 1], "VALUE": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "N": 24}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "sum(VALUE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["sum(WEIGHT[i]*X[i] for i in I) >= 170", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "A 0-indexed comma-separated list of item indices to include in the bag (e.g. \"0,3,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast, re\n    data = ast.literal_eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = d.get('N', 0)\n    standardDataclass.values = list(d.get('VALUE', []))\n    standardDataclass.weights = list(d.get('WEIGHT', []))\n    cons = data.get('CONSTRAINTS', [])\n    s = ''.join(cons) if isinstance(cons, list) else str(cons)\n    m = re.search(r'\\d+', s or '')\n    standardDataclass.capacity = int(m.group()) if m else 0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "0..23", "MEANING": "Index set for decorations (i ranges over 0..23, zero-based indexing)"}, {"SYMBOL": "X", "DOMAIN": "Binary over I", "MEANING": "Binary decision variable X[i] = 1 if decoration i (0-based) is selected, 0 otherwise"}], "DATA_ROLES": [{"NAME": "COSTS", "INDEXING": "LIST", "MEANING": "Cost of each decoration in order 0..23 (zero-based)"}, {"NAME": "POINTS", "INDEXING": "LIST", "MEANING": "Point value of each decoration in order 0..23 (zero-based)"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Minimum total spending required"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of decorations"}], "DATA": {"COSTS": [150, 90, 230, 50, 70, 40, 130, 170, 90, 100, 220, 60, 170, 190, 50, 40, 200, 90, 190, 70, 60, 140, 150, 10], "POINTS": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "BUDGET": 1700, "N": 24}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "sum(POINTS[i]*X[i] for i in I)"}, "CONSTRAINTS": ["sum(COSTS[i]*X[i] for i in I) >= BUDGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED-LIST", "DESCRIPTION": "Comma-separated list of selected decoration indices using 0-based indexing (valid values 0..23)"}}, "FuncionDeCarga": "import ast\n\ndef Transform(extractedData, standardDataclass):\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = list(data['POINTS'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = data['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "INDEX_SET_0_TO_23", "MEANING": "Index set for customers (0-indexed): 0..23"}, {"SYMBOL": "X", "DOMAIN": "BINARY[I]", "MEANING": "Decision binary vector X[i]=1 if offer from customer i (0-indexed) is accepted, 0 otherwise"}], "DATA_ROLES": [{"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "Offered revenue in dollars for each customer, ordered by customer number 1..24 mapped to index 0..23"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "Gallons of lemonade requested by each customer, ordered by customer number 1..24 mapped to index 0..23"}, {"NAME": "TARGET_GALLONS", "INDEXING": "SCALAR", "MEANING": "Minimum total gallons that must be sold"}], "DATA": {"PRICE": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "GALLONS": [15, 9, 23, 5, 7, 4, 13, 17, 9, 10, 22, 6, 17, 19, 5, 4, 20, 9, 19, 7, 6, 14, 15, 1], "TARGET_GALLONS": 170}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "minimize: sum(PRICE[i] * X[i] for i in I)"}, "CONSTRAINTS": ["sum(GALLONS[i] * X[i] for i in I) >= TARGET_GALLONS", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "A 0-indexed, comma-separated list of selected customer indices (integers from 0 to 23) representing accepted offers"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    data = parsed['DATA']\n    prices = data['PRICE']\n    gallons = data['GALLONS']\n    target = data['TARGET_GALLONS']\n    standardDataclass.length = len(prices)\n    standardDataclass.values = list(prices)\n    standardDataclass.weights = list(gallons)\n    standardDataclass.capacity = int(target)\n    standardDataclass.score = 0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_10_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"INDEX": "0..23 (INDEX is the set of 0-indexed attraction indices, inclusive)", "X": "Binary for I in INDEX: X[I] in {0,1} where X[I]=1 if attraction I is suggested to friend"}, "DATA_ROLES": {"SCORES": "LIST indexed by INDEX: integer score for each attraction", "TIMES": "LIST indexed by INDEX: integer minutes required for each attraction", "TIME_REQUIREMENT": "SCALAR: minimum total minutes the friend should spend (>= 1700)"}, "DATA": {"SCORES": [20, 9, 20, 16, 16, 1, 16, 21, 4, 14, 1, 5, 4, 1, 23, 19, 21, 20, 8, 17, 9, 15, 18, 15], "TIMES": [150, 90, 230, 50, 70, 40, 130, 170, 90, 100, 220, 60, 170, 190, 50, 40, 200, 90, 190, 70, 60, 140, 150, 10], "TIME_REQUIREMENT": 1700}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORES[I]*X[I] for I in INDEX)"}, "CONSTRAINTS": ["quicksum(TIMES[I]*X[I] for I in INDEX) >= TIME_REQUIREMENT", "X[I] in {0,1} for I in INDEX"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed, comma-separated list of attractions to suggest to friend (optimal selection verified by DP): \"2,5,7,8,10,11,12,13,16,18,21\""}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['SCORES'])\n    standardDataclass.values = list(data['SCORES'])\n    standardDataclass.weights = list(data['TIMES'])\n    standardDataclass.capacity = int(data['TIME_REQUIREMENT'])\n    standardDataclass.time = float(data['TIME_REQUIREMENT'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "I", "domain": "LIST of integers 0..23", "meaning": "Index set for items (0-indexed)"}, {"symbol": "X", "domain": "Binary for each i in I, X[i] in {0,1}", "meaning": "Decision variable: X[i]=1 if item i is included, 0 otherwise"}], "DATA_ROLES": [{"name": "WEIGHTS", "indexing": "LIST", "meaning": "Weight of each item in kilograms (ordered by item index 0..23)"}, {"name": "VALUES", "indexing": "LIST", "meaning": "Value of each item in euros (ordered by item index 0..23)"}, {"name": "CAPACITY", "indexing": "SCALAR", "meaning": "Maximum allowed total weight of selected items in kilograms"}], "DATA": {"WEIGHTS": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6], "VALUES": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "CAPACITY": 80}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION_SOLVER_COMPATIBLE": "quicksum(VALUES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i]*X[i] for i in I) <= CAPACITY", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST", "DESCRIPTION": "Comma-separated list of selected item indices using 0-based numbering (e.g., \"0,3,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    d = parsed['DATA']\n    inst = standardDataclass()\n    inst.length = len(d['VALUES'])\n    inst.values = d['VALUES']\n    inst.weights = d['WEIGHTS']\n    inst.capacity = d['CAPACITY']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "Binary", "meaning": "X[i] == 1 if decoration with 0-based index i is purchased, 0 otherwise"}], "DATA_ROLES": {"I": {"indexing": "LIST", "meaning": "Index set of items (0-based indices for the 24 decorations)"}, "COSTS": {"indexing": "LIST", "meaning": "Cost of each decoration (aligned by index with I)"}, "VALUES": {"indexing": "LIST", "meaning": "Point value of each decoration (aligned by index with I)"}, "BUDGET": {"indexing": "SCALAR", "meaning": "Available budget (total cost must not exceed this)"}}, "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "VALUES": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "BUDGET": 800}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "quicksum(VALUES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*X[i] for i in I) <= BUDGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "string", "DESCRIPTION": "A 0-indexed comma-separated list of decoration indices selected, e.g. \"0,3,5\""}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    payload = ast.literal_eval(extractedData)\n    data = payload['DATA']\n    standardDataclass.length = len(data['I'])\n    standardDataclass.values = list(data['VALUES'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = int(data['BUDGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DATA_ROLES": [{"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "offered revenue (dollars) from each customer indexed by CUSTOMERS"}, {"NAME": "VOLUME", "INDEXING": "LIST", "MEANING": "gallons of lemonade requested by each customer indexed by CUSTOMERS"}, {"NAME": "CUSTOMERS", "INDEXING": "LIST", "MEANING": "set/list of customer indices (0-indexed) used for indexing decision variables and data"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "total available gallons of lemonade (upper bound)"}], "DATA": {"PRICE": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "VOLUME": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6], "CUSTOMERS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "CAPACITY": 80}, "DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] == 1 if offer from customer i is accepted, 0 otherwise; indexed by CUSTOMERS"}], "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum( PRICE[i]*X[i] for i in CUSTOMERS )"}, "CONSTRAINTS": ["quicksum( VOLUME[i]*X[i] for i in CUSTOMERS ) <= CAPACITY"], "SOLUTION_FORMAT": {"TYPE": "COMMA_SEPARATED_INTS", "DESCRIPTION": "0-indexed comma-separated list of customer indices to accept (e.g. \"0,3,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = len(d['CUSTOMERS'])\n    standardDataclass.values = list(d['PRICE'])\n    standardDataclass.weights = list(d['VOLUME'])\n    standardDataclass.capacity = d['CAPACITY']\n    if 'SOLUTION' in d:\n        standardDataclass.solution = list(d['SOLUTION'])\n    if 'SCORE' in d:\n        standardDataclass.score = d['SCORE']\n    if 'TIME' in d:\n        standardDataclass.time = float(d['TIME'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "Binary indexed by I", "MEANING": "Selection variable: X[i] = 1 if attraction i is selected, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "Attraction scores in order attraction 1..24"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "Time in minutes required for each attraction in order attraction 1..24"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of attractions"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set containing 0..N-1"}], "DATA": {"SCORES": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "TIMES": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "N": 24, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "maximize", "EXPRESSION": "quicksum(X[i]*SCORES[i] for i in I)"}, "CONSTRAINTS": ["quicksum(X[i]*TIMES[i] for i in I) <= 800", "X is binary indexed by I", "N == 24", "len(I) == N"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of attraction numbers (integers from I where X[i] == 1)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = data['SCORES']\n    standardDataclass.weights = data['TIMES']\n    cons = d['CONSTRAINTS']\n    import re\n    cap = 0\n    for c in cons:\n        m = re.search(r'<=\\s*([0-9]+)', c)\n        if m:\n            cap = int(m.group(1))\n            break\n    standardDataclass.capacity = cap\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "I = 0..23", "MEANING": "Index set of the 24 items (0-indexed)"}, {"SYMBOL": "x", "DOMAIN": "x[i] in {0,1} for i in I", "MEANING": "Binary decision variable: 1 if item i is included, 0 otherwise"}], "DATA_ROLES": [{"NAME": "W", "INDEXING": "I", "MEANING": "Weight of each item in kg"}, {"NAME": "V", "INDEXING": "I", "MEANING": "Value of each item in €"}, {"NAME": "W_MIN", "INDEXING": "SCALAR", "MEANING": "Minimum required total weight (kg)"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "List of item indices (0..23)"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "W": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6], "V": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "W_MIN": 211}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(V[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(W[i]*x[i] for i in I) >= W_MIN", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed comma-separated list of item indices to include (each index corresponds to the item number minus one)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    inst = standardDataclass\n    data = d.get('DATA', {})\n    I = data.get('I', [])\n    inst.length = len(I)\n    inst.values = list(data.get('V', []))\n    inst.weights = list(data.get('W', []))\n    inst.capacity = data.get('W_MIN', 0)\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i] = 1 if decoration i is purchased, 0 otherwise; indexed by ITEMS"}], "DATA_ROLES": [{"name": "ITEMS", "indexing": "LIST", "meaning": "Index set of decorations (0..23)"}, {"name": "COSTS", "indexing": "LIST", "meaning": "Cost of each decoration, indexed by ITEMS"}, {"name": "POINTS", "indexing": "LIST", "meaning": "Point value of each decoration, indexed by ITEMS"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "Minimum total spend required"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "POINTS": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "BUDGET": 2110}, "OBJECTIVE": {"sense": "minimize", "expression": "quicksum(POINTS[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*X[i] for i in ITEMS) >= BUDGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"type": "0-INDEXED_LIST", "description": "Comma-separated list of purchased decoration indices using 0-based numbering (decoration 1 -> 0, decoration 24 -> 23)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = len(d['ITEMS'])\n    standardDataclass.values = d['POINTS']\n    standardDataclass.weights = d['COSTS']\n    standardDataclass.capacity = d['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY indexed by CUSTOMERS", "MEANING": "X[i] = 1 if offer from customer i is accepted, 0 otherwise. CUSTOMERS are 0-indexed (0..23) corresponding to original customers 1..24."}], "DATA_ROLES": [{"NAME": "CUSTOMERS", "INDEXING": "LIST", "MEANING": "List of customer identifiers (0..23), used for indexing PRICE and GALLONS arrays"}, {"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "Offered money amounts aligned with CUSTOMERS (0..23)"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "Gallons requested aligned with CUSTOMERS (0..23)"}], "DATA": {"CUSTOMERS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "PRICE": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "GALLONS": [4, 2, 11, 2, 24, 5, 12, 24, 21, 20, 21, 23, 13, 21, 5, 8, 5, 8, 20, 9, 4, 15, 8, 6]}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(PRICE[i]*X[i] for i in CUSTOMERS)"}, "CONSTRAINTS": ["quicksum(GALLONS[i]*X[i] for i in CUSTOMERS) >= 211", "X[i] in {0,1} for i in CUSTOMERS"], "SOLUTION_FORMAT": {"TYPE": "list_of_ints_0_indexed", "DESCRIPTION": "Comma-separated list of accepted customer indices, 0-indexed (0 -> original Customer 1, ..., 23 -> original Customer 24)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import re\n    data = eval(extractedData)\n    d = data['DATA']\n    inst = standardDataclass\n    inst.length = len(d['CUSTOMERS'])\n    inst.values = list(d['PRICE'])\n    inst.weights = list(d['GALLONS'])\n    constraints = data.get('CONSTRAINTS', [])\n    cap = 0\n    for c in constraints:\n        m = re.search(r'>=\\s*([0-9]+)', c)\n        if m:\n            cap = int(m.group(1))\n            break\n    inst.capacity = cap\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_11_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"I": {"DOMAIN": "0..23", "MEANING": "INDEX SET FOR ATTRACTIONS (0-BASED)"}, "X": {"DOMAIN": "{0,1} FOR EACH i IN I", "MEANING": "BINARY DECISION VARIABLE, X[i]=1 IF FRIEND VISITS ATTRACTION i"}}, "DATA_ROLES": {"SCORE": {"INDEXING": "LIST", "MEANING": "POINT VALUE FOR EACH ATTRACTION, ORDERED BY INDEX 0..23"}, "TIME": {"INDEXING": "LIST", "MEANING": "TIME REQUIRED (MINUTES) FOR EACH ATTRACTION, ORDERED BY INDEX 0..23"}, "TOTAL_TIME_REQUIREMENT": {"INDEXING": "SCALAR", "MEANING": "MINIMUM TOTAL TIME (MINUTES) FRIEND MUST SPEND, AT LEAST THIS MANY MINUTES"}}, "DATA": {"SCORE": [22, 22, 4, 5, 6, 14, 15, 12, 3, 10, 7, 3, 23, 21, 7, 19, 20, 22, 6, 19, 14, 24, 24, 1], "TIME": [40, 20, 110, 20, 240, 50, 120, 240, 210, 200, 210, 230, 130, 210, 50, 80, 50, 80, 200, 90, 40, 150, 80, 60], "TOTAL_TIME_REQUIREMENT": 2110}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(SCORE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i]*X[i] for i in I) >= TOTAL_TIME_REQUIREMENT", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed comma-separated list of attraction indices to suggest to friend (e.g. \"0,3,5\")"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    scores = d['DATA']['SCORE']\n    times = d['DATA']['TIME']\n    total_req = d['DATA']['TOTAL_TIME_REQUIREMENT']\n    standardDataclass.length = len(scores)\n    standardDataclass.values = list(scores)\n    standardDataclass.weights = list(times)\n    standardDataclass.capacity = int(total_req)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] == 1 if item i is selected, 0 otherwise; indexed by ITEMS (0-based)"}], "DATA_ROLES": [{"NAME": "ITEMS", "INDEXING": "LIST", "MEANING": "List of item indices (0-based) aligned with WEIGHTS and VALUES"}, {"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "Weight of each item, aligned with ITEMS"}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "Value of each item, aligned with ITEMS"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Maximum allowable total weight of selected items"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHTS": [21, 7, 12, 18, 17, 3, 2, 13, 19, 18, 19, 6, 18, 16, 8, 11, 8, 18, 22, 13, 7, 7, 5, 15], "VALUES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "CAPACITY": 80}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(VALUES[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i]*X[i] for i in ITEMS) <= CAPACITY", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "COMMA_SEPARATED_INTS_0_INDEXED", "DESCRIPTION": {"TEXT": "Return a 0-indexed comma-separated list of item indices to include in the knapsack (example: \"0,3,5\"). The provided candidate solution is [1,2,3,5,6,11,14,15,21,22] with claimed total_value=183 and total_weight=79 (<=CAPACITY).", "FEEDBACK_MESSAGES": ["DATA_ERROR: Ambiguity in indexing between original human-readable statement (items numbered 1..24) and model-extracted ITEMS (0..23). Confirmed mapping used: human item k -> index k-1. Suggest explicitly declare '0-based indices' in any solver prompt to avoid off-by-one mistakes.", "LOGIC_ERROR: None detected. Objective expression and weight constraint correctly encode the 0-1 knapsack. Integrality constraint X[i] in {0,1} is present. No operator changes necessary in the objective or constraints.", "RESULTS_NOT_CONSISTENT: No inconsistency found. Verified candidate solution [1,2,3,5,6,11,14,15,21,22] using dynamic programming: total_value = 183, total_weight = 79 <= 80. DP ground-truth also returns optimal value 183 with the same item set, so the claimed solution is optimal.", "ACTIONABLE_SUGGESTIONS: 1) Make indexing explicit in the top-level problem statement (e.g., 'items indexed 0..23') to prevent misinterpretation. 2) Provide the small evaluation function and DP solver to allow deterministic local verification of any candidate solution. 3) When testing heuristics or random solutions, always run the provided evaluate(sol) to check feasibility and value, and compare against dp_solve() to confirm optimality.", "VERIFICATION_NOTE: The supplied evaluation function and dp_solve() are self-contained and do not access the filesystem or network. They can be executed locally to verify any candidate solution and to produce the ground-truth optimal set for this instance."]}}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    data = parsed['DATA']\n    standardDataclass.length = len(data['ITEMS'])\n    standardDataclass.values = list(data['VALUES'])\n    standardDataclass.weights = list(data['WEIGHTS'])\n    standardDataclass.capacity = data['CAPACITY']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "LIST", "MEANING": "Index set of decorations (0..23)"}, {"SYMBOL": "x", "DOMAIN": "{0,1}^I", "MEANING": "Binary decision variable: x[i]=1 if decoration i (0-based) is purchased, 0 otherwise"}], "DATA_ROLES": [{"NAME": "COST", "INDEXING": "I", "MEANING": "Cost of each decoration in dollars, ordered by decoration index 0..23"}, {"NAME": "VALUE", "INDEXING": "I", "MEANING": "Point value of each decoration, ordered by decoration index 0..23"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Total budget available in dollars"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COST": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "VALUE": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "BUDGET": 800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(VALUE[i]*x[i] for i in I)"}, "CONSTRAINTS": ["sum(COST[i]*x[i] for i in I) <= BUDGET", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST", "DESCRIPTION": "A comma-separated list of selected decoration indices using 0-based numbering (e.g., \"0,3,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    data = eval(extractedData)\n    inst = standardDataclass\n    inst.length = len(data['DATA']['I'])\n    inst.values = [int(v) for v in data['DATA']['VALUE']]\n    inst.weights = [int(w) for w in data['DATA']['COST']]\n    inst.capacity = int(data['DATA']['BUDGET'])\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "X[i] in {0,1} for i in I", "MEANING": "Binary decision variable: 1 if offer from customer i is accepted, 0 otherwise"}], "DATA_ROLES": [{"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "Offered revenue in dollars for each customer i (0-indexed)"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "Gallons of lemonade requested by each customer i (0-indexed)"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of customers (0-indexed)"}], "DATA": {"PRICE": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "GALLONS": [21, 7, 12, 18, 17, 3, 2, 13, 19, 18, 19, 6, 18, 16, 8, 11, 8, 18, 22, 13, 7, 7, 5, 15], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "OBJ: sum(PRICE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["GALLON_LIMIT: sum(GALLONS[i]*X[i] for i in I) <= 80", "BINARY_DOMAIN: X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTEGERS", "DESCRIPTION": "0-indexed, comma-separated list of customer indices whose offers to accept (e.g. \"0,3,5\")"}}, "FuncionDeCarga": "def Transform(extractedData,standardDataclass):\n    d = eval(extractedData)\n    sd = standardDataclass\n    sd.length = len(d['DATA']['I'])\n    sd.values = list(d['DATA']['PRICE'])\n    sd.weights = list(d['DATA']['GALLONS'])\n    sd.capacity = int(d['CONSTRAINTS'][0].split('<=')[1].strip())\n    return sd"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "0..23", "MEANING": "INDEX SET OF ATTRACTIONS (0-BASED INDICES)"}, {"SYMBOL": "X", "DOMAIN": "binary for each i in I (0 or 1)", "MEANING": "DECISION VARIABLE: X[i]=1 if attraction i is selected, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "POINT VALUE FOR EACH ATTRACTION i IN I (0-BASED INDEXING)"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "TIME REQUIRED (MINUTES) FOR EACH ATTRACTION i IN I (0-BASED INDEXING)"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "NUMBER OF ATTRACTIONS"}, {"NAME": "T_LIMIT", "INDEXING": "SCALAR", "MEANING": "TOTAL AVAILABLE TIME (MINUTES)"}], "DATA": {"SCORES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "TIMES": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "N": 24, "T_LIMIT": 800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(i in I) SCORES[i]*X[i]"}, "CONSTRAINTS": ["sum(i in I) TIMES[i]*X[i] <= T_LIMIT", "for all i in I: X[i] in {0,1}"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST_OF_INTEGERS", "DESCRIPTION": "Return the selected attractions as a 0-indexed comma-separated list (each entry is the attraction number using 0-based indexing)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    root = ast.literal_eval(extractedData)\n    data = root['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = list(data['SCORES'])\n    standardDataclass.weights = list(data['TIMES'])\n    standardDataclass.capacity = data['T_LIMIT']\n    standardDataclass.score = 0\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "x", "DOMAIN": "BINARY (indexed by I)", "MEANING": "Decision variable: x[i]=1 if item i is included in the bag, 0 otherwise"}, {"SYMBOL": "I", "DOMAIN": "INDEX_SET", "MEANING": "Index set of items (0-based indices)"}], "DATA_ROLES": [{"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "Weights of items in kilograms, ordered by item index 0..23 (corresponds to items 1..24 in problem description)"}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "Values of items in euros, ordered by item index 0..23 (corresponds to items 1..24 in problem description)"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "List of item indices (0-based) used for indexing decision variables"}], "DATA": {"WEIGHTS": [21, 7, 12, 18, 17, 3, 2, 13, 19, 18, 19, 6, 18, 16, 8, 11, 8, 18, 22, 13, 7, 7, 5, 15], "VALUES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(VALUES[i] * x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i] * x[i] for i in I) >= 223", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "A 0-indexed, comma-separated list of item indices to put in the bag (e.g. \"0,3,5\"). Each entry is an integer in I."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast, re\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    vals = list(data['VALUES'])\n    wts = list(data['WEIGHTS'])\n    obj = standardDataclass()\n    obj.length = len(vals)\n    obj.values = vals\n    obj.weights = wts\n    nums = [int(n) for n in re.findall(r'-?\\d+', ''.join(d['CONSTRAINTS']))]\n    obj.capacity = max(nums)\n    return obj"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "x", "DOMAIN": "{0,1}", "MEANING": "x[i] = 1 if decoration with index i (0-indexed) is purchased, 0 otherwise; indexed by I"}], "DATA_ROLES": [{"NAME": "C", "INDEXING": "LIST", "MEANING": "Cost list C[i] for i in I"}, {"NAME": "P", "INDEXING": "LIST", "MEANING": "Point value list P[i] for i in I"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Minimum total spend required"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set I containing item indices 0..N-1"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of available decorations"}], "DATA": {"C": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "P": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "BUDGET": 2230, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "N": 24}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(P[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(C[i]*x[i] for i in I) >= BUDGET", "forall i in I: x[i] in {0,1}"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed comma-separated list of integers representing chosen decorations (each integer is the 0-based index of a decoration)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    standardDataclass.length = d['DATA']['N']\n    standardDataclass.values = d['DATA']['P']\n    standardDataclass.weights = d['DATA']['C']\n    standardDataclass.capacity = d['DATA']['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "{0,1}", "indexing": "CUSTOMER_INDEX", "meaning": "Binary decision variable: X[i]=1 if offer from customer i is accepted, 0 otherwise"}], "DATA_ROLES": {"PRICE": {"INDEXING": "LIST", "MEANING": "Payment offered by each customer in dollars, indexed by CUSTOMER_INDEX"}, "VOLUME": {"INDEXING": "LIST", "MEANING": "Gallons requested by each customer, indexed by CUSTOMER_INDEX"}, "CUSTOMER_INDEX": {"INDEXING": "LIST", "MEANING": "0-indexed list of customer indices"}, "REQUIRED_GALLONS": {"INDEXING": "SCALAR", "MEANING": "Minimum total gallons to sell"}}, "DATA": {"CUSTOMER_INDEX": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "PRICE": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "VOLUME": [21, 7, 12, 18, 17, 3, 2, 13, 19, 18, 19, 6, 18, 16, 8, 11, 8, 18, 22, 13, 7, 7, 5, 15], "REQUIRED_GALLONS": 223}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(PRICE[i]*X[i] for i in CUSTOMER_INDEX)"}, "CONSTRAINTS": ["quicksum(VOLUME[i]*X[i] for i in CUSTOMER_INDEX) >= REQUIRED_GALLONS", "X[i] in {0,1} for i in CUSTOMER_INDEX"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of customer indices to accept (for example: \"0,2,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['PRICE'])\n    standardDataclass.values = list(data['PRICE'])\n    standardDataclass.weights = list(data['VOLUME'])\n    standardDataclass.capacity = int(data['REQUIRED_GALLONS'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "X[i] in {0,1} for i in I", "meaning": "X[i] = 1 if friend visits attraction i, 0 otherwise"}], "DATA_ROLES": [{"name": "SCORES", "indexing": "LIST", "meaning": "score (points) for each attraction; index 0 corresponds to Attraction 1"}, {"name": "TIMES", "indexing": "LIST", "meaning": "time in minutes required for each attraction; index 0 corresponds to Attraction 1"}, {"name": "I", "indexing": "LIST", "meaning": "index set for attractions (0-based indices)"}, {"name": "TARGET_TIME", "indexing": "SCALAR", "meaning": "minimum total time friend should be assigned (minutes)"}], "DATA": {"SCORES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "TIMES": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "TARGET_TIME": 2230}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*X[i] for i in I) >= TARGET_TIME", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST_OF_INTEGERS", "DESCRIPTION": "A comma-separated list of 0-based attraction indices to suggest to the friend (e.g. \"0,5,6\"). Each index corresponds to an attraction in SCORES and TIMES lists."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    data = parsed['DATA']\n    scores = data['SCORES']\n    times = data['TIMES']\n    target = data['TARGET_TIME']\n    standardDataclass.length = len(scores)\n    standardDataclass.values = list(scores)\n    standardDataclass.weights = list(times)\n    standardDataclass.solution = parsed.get('SOLUTION', standardDataclass.solution)\n    standardDataclass.score = parsed.get('SCORE', 0)\n    standardDataclass.capacity = target\n    standardDataclass.time = parsed.get('TIME', 0.0)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "Selection decision for each item indexed by I (1 if item is taken, 0 otherwise)"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of items (1-based indices for the data arrays)"}, {"NAME": "WEIGHTS", "INDEXING": "LIST", "MEANING": "Weight of each item, aligned with index set I"}, {"NAME": "VALUES", "INDEXING": "LIST", "MEANING": "Value of each item, aligned with index set I"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Maximum allowed total weight of selected items"}], "DATA": {"I": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "WEIGHTS": [3, 12, 19, 19, 23, 22, 24, 19, 1, 24, 22, 2, 14, 16, 20, 13, 20, 10, 9, 6, 21, 20, 19, 21], "VALUES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "CAPACITY": 280}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(VALUES[i-1]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i-1]*X[i] for i in I) <= CAPACITY"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list", "DESCRIPTION": "List the selected item indices as 0-based integers (0..23), separated by commas, e.g. \"0,3,5\"."}}, "FuncionDeCarga": "def Transform(extractedData,standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    d = parsed['DATA']\n    inst = standardDataclass()\n    inst.length = len(d['I'])\n    inst.values = list(d['VALUES'])\n    inst.weights = list(d['WEIGHTS'])\n    inst.capacity = d['CAPACITY']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if decoration i is purchased, 0 otherwise; indexed by I (1..24)"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of decorations (1..24)"}, {"NAME": "COSTS", "INDEXING": "I", "MEANING": "Cost of decoration i"}, {"NAME": "VALUES", "INDEXING": "I", "MEANING": "Point value of decoration i"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Total budget available"}], "DATA": {"I": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "COSTS": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "VALUES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "BUDGET": 2800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION_SOLVER_COMPATIBLE": "quicksum(VALUES[i-1]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i-1]*X[i] for i in I) <= BUDGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST", "DESCRIPTION": "Final answer must be a comma-separated list of chosen decoration numbers using 0-based numbering (0..23). Example: \"0,3,5\" corresponds to decorations 1,4,6 in 1-based indexing."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d.get('DATA', {})\n    I = data.get('I', [])\n    costs = data.get('COSTS', [])\n    values = data.get('VALUES', [])\n    budget = data.get('BUDGET', 0)\n    standardDataclass.length = len(I)\n    standardDataclass.values = list(values)\n    standardDataclass.weights = list(costs)\n    standardDataclass.capacity = budget\n    standardDataclass.solution = d.get('SOLUTION', standardDataclass.solution)\n    standardDataclass.score = d.get('SCORE', standardDataclass.score)\n    standardDataclass.time = d.get('TIME', standardDataclass.time)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "x", "DOMAIN": "BINARY", "MEANING": "x[i-1] = 1 if we accept the offer of customer i, 0 otherwise; indexed by I"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Customer index set (1..24), used to index offers and decision variables"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "GALLONS[i] is the gallons of lemonade required for customer i (i in I)"}, {"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "PRICE[i] is the payment offered by customer i (i in I)"}], "DATA": {"I": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "GALLONS": [3, 12, 19, 19, 23, 22, 24, 19, 1, 24, 22, 2, 14, 16, 20, 13, 20, 10, 9, 6, 21, 20, 19, 21], "PRICE": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16]}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(PRICE[i-1] * x[i-1] for i in I)"}, "CONSTRAINTS": ["sum(GALLONS[i-1] * x[i-1] for i in I) <= 280", "x[i-1] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of customer indices to accept. Use 0..23 where 0 corresponds to customer 1, 1 to customer 2, ..., 23 to customer 24."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    data = d['DATA']\n    I = data['I']\n    standardDataclass.length = len(I)\n    standardDataclass.values = list(data['PRICE'])\n    standardDataclass.weights = list(data['GALLONS'])\n    cons = d['CONSTRAINTS']\n    s = cons[0]\n    i = s.find('<=')\n    standardDataclass.capacity = int(''.join(ch for ch in s[i+2:] if ch.isdigit()))\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x", "domain": "BINARY(I)", "meaning": "x[i] = 1 if attraction with index i (0-indexed) is selected, 0 otherwise"}], "DATA_ROLES": [{"name": "SCORES", "indexing": "LIST", "meaning": "List of point values for each attraction in order (attraction 1 through 24)"}, {"name": "TIMES", "indexing": "LIST", "meaning": "List of time requirements in minutes for each attraction in order (attraction 1 through 24)"}, {"name": "N", "indexing": "SCALAR", "meaning": "Number of attractions"}, {"name": "I", "indexing": "LIST", "meaning": "Index set for attractions, 0-indexed"}, {"name": "CAPACITY", "indexing": "SCALAR", "meaning": "Total available sightseeing time in minutes"}], "DATA": {"SCORES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "TIMES": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "N": 24, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "CAPACITY": 2800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(SCORES[i] * x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i] * x[i] for i in I) <= CAPACITY", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list", "DESCRIPTION": "Return a comma-separated list of selected attraction indices using 0-based indexing (e.g., \"0,1,2\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    ed = ast.literal_eval(extractedData)\n    data = ed['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = data['SCORES']\n    standardDataclass.weights = data['TIMES']\n    standardDataclass.capacity = data['CAPACITY']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i] = 1 if item i is selected, 0 otherwise; i ranges over ITEMS"}], "DATA_ROLES": [{"name": "ITEMS", "indexing": "LIST", "meaning": "list of item indices (0-based)"}, {"name": "WEIGHTS", "indexing": "LIST", "meaning": "WEIGHTS[i] is the weight (kg) of item i"}, {"name": "VALUES", "indexing": "LIST", "meaning": "VALUES[i] is the value (euros) of item i"}, {"name": "WEIGHT_TARGET", "indexing": "SCALAR", "meaning": "minimum required total weight (kg)"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHTS": [3, 12, 19, 19, 23, 22, 24, 19, 1, 24, 22, 2, 14, 16, 20, 13, 20, 10, 9, 6, 21, 20, 19, 21], "VALUES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "WEIGHT_TARGET": 99}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(VALUES[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i]*X[i] for i in ITEMS) >= WEIGHT_TARGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "0_INDEXED_COMMA_SEPARATED_LIST", "DESCRIPTION": "A 0-indexed comma-separated list of selected item indices (e.g. \"0,2,4\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    items = data.get('ITEMS', [])\n    weights = data.get('WEIGHTS', [])\n    values = data.get('VALUES', [])\n    capacity = data.get('WEIGHT_TARGET', 0)\n    standardDataclass.length = len(items)\n    standardDataclass.values = list(values)\n    standardDataclass.weights = list(weights)\n    standardDataclass.capacity = capacity\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "ITEMS", "domain": "LIST", "meaning": "Index set of decoration items (0-indexed): 0..N-1"}, {"symbol": "X", "domain": "BINARY[ITEMS]", "meaning": "Binary decision variable: X[i]=1 if item i is purchased, 0 otherwise"}], "DATA_ROLES": [{"name": "COST", "indexing": "LIST", "meaning": "Cost of each decoration aligned with ITEMS (0..N-1)"}, {"name": "POINTS", "indexing": "LIST", "meaning": "Point value of each decoration aligned with ITEMS (0..N-1)"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "Minimum total spend required"}, {"name": "N", "indexing": "SCALAR", "meaning": "Number of items (length of ITEMS)"}], "DATA": {"COST": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "POINTS": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "BUDGET": 990, "N": 24}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "minimize sum(POINTS[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["ITEMS = range(N)", "sum(COST[i]*X[i] for i in ITEMS) >= BUDGET", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "0-indexed, comma-separated list of integers", "DESCRIPTION": "Return chosen decorations as 0-based indices (e.g. 0,5,23). Each index corresponds to the entry position in COST and POINTS (ITEM 0 = Decoration 1)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    standardDataclass.length = d['DATA']['N']\n    standardDataclass.values = list(d['DATA']['POINTS'])\n    standardDataclass.weights = list(d['DATA']['COST'])\n    standardDataclass.capacity = d['DATA']['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"X": {"SYMBOL": "X", "INDEXING": "LIST", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if the offer from customer i (0-indexed) is accepted, 0 otherwise; list indexed by IDX"}}, "DATA_ROLES": {"PRICES": {"INDEXING": "LIST", "MEANING": "Offered prices in dollars for customers 1..24 in the given order (used with 0-indexed IDX)"}, "GALLONS": {"INDEXING": "LIST", "MEANING": "Requested gallons for customers 1..24 in the given order (used with 0-indexed IDX)"}, "N": {"INDEXING": "SCALAR", "MEANING": "Number of customers (length of PRICES and GALLONS)"}, "TARGET_GALLONS": {"INDEXING": "SCALAR", "MEANING": "Minimum total gallons to sell (goal)"}, "IDX": {"INDEXING": "LIST", "MEANING": "Index set for decision variables: 0-indexed integers from 0 to N-1"}}, "DATA": {"PRICES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "GALLONS": [3, 12, 19, 19, 23, 22, 24, 19, 1, 24, 22, 2, 14, 16, 20, 13, 20, 10, 9, 6, 21, 20, 19, 21], "N": 24, "TARGET_GALLONS": 99, "IDX": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(PRICES[i]*X[i] for i in IDX)"}, "CONSTRAINTS": ["quicksum(GALLONS[i]*X[i] for i in IDX) >= TARGET_GALLONS", "X[i] in {0,1} for i in IDX", "N == len(IDX)", "len(PRICES) == N", "len(GALLONS) == N"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "A 0-indexed, comma-separated list of customer indices (integers from 0 to N-1) whose offers should be accepted to meet the constraint while minimizing total revenue."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    parsed = ast.literal_eval(extractedData)\n    inst = standardDataclass()\n    inst.length = parsed['DATA']['N']\n    inst.values = parsed['DATA']['PRICES']\n    inst.weights = parsed['DATA']['GALLONS']\n    inst.capacity = parsed['DATA']['TARGET_GALLONS']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i] = 1 if attraction i is suggested for the friend to visit (selected), 0 otherwise", "indexing": "I"}], "DATA_ROLES": [{"name": "SCORES", "indexing": "I", "meaning": "score (points) of attraction i"}, {"name": "TIMES", "indexing": "I", "meaning": "time in minutes required for attraction i"}, {"name": "I", "indexing": "LIST", "meaning": "index set for attractions using 0-based indexing"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "SCORES": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "TIMES": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210]}, "OBJECTIVE": {"sense": "MINIMIZE", "expression": "quicksum(SCORES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*X[i] for i in I) >= 990", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"type": "0-INDEXED_COMMA_SEPARATED_LIST", "description": "Comma-separated list of 0-based attraction indices to suggest to the friend (e.g. \"0,3,5\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast, re\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    I = data['I']\n    SCORES = data['SCORES']\n    TIMES = data['TIMES']\n    standardDataclass.length = len(I)\n    standardDataclass.values = SCORES\n    standardDataclass.weights = TIMES\n    s = ''.join(d['CONSTRAINTS'])\n    m = re.search(r'>=\\s*([0-9]+)', s)\n    standardDataclass.capacity = int(m.group(1))\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"X": {"symbol": "X", "domain": "BINARY for i in ITEMS (X[i] in {0,1})", "meaning": "Decision variable: 1 if item i is selected, 0 otherwise"}}, "DATA_ROLES": {"ITEMS": {"name": "ITEMS", "indexing": "LIST", "meaning": "Index set of items (0-indexed)"}, "WEIGHT": {"name": "WEIGHT", "indexing": "LIST", "meaning": "Weight of each item in kilograms, indexed by ITEMS"}, "VALUE": {"name": "VALUE", "indexing": "LIST", "meaning": "Monetary value of each item in euros, indexed by ITEMS"}, "CAPACITY": {"name": "CAPACITY", "indexing": "SCALAR", "meaning": "Maximum total weight capacity of the bag in kilograms"}}, "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHT": [4, 10, 9, 11, 2, 23, 22, 16, 9, 16, 5, 22, 5, 8, 18, 6, 2, 9, 7, 9, 22, 11, 12, 4], "VALUE": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "CAPACITY": 91}, "OBJECTIVE": {"sense": "MAXIMIZE", "expression": "quicksum(VALUE[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHT[i]*X[i] for i in ITEMS) <= CAPACITY", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"type": "LIST", "description": "0-indexed comma-separated list of integers representing item numbers to include in the bag"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    standardDataclass.length = len(d['DATA']['ITEMS'])\n    standardDataclass.values = list(d['DATA']['VALUE'])\n    standardDataclass.weights = list(d['DATA']['WEIGHT'])\n    standardDataclass.capacity = d['DATA']['CAPACITY']\n    standardDataclass.score = 0\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if decoration i (0-indexed) is purchased, 0 otherwise"}], "DATA_ROLES": [{"NAME": "COST", "INDEXING": "LIST", "MEANING": "Cost of each decoration in order (index 0 corresponds to Decoration 1)"}, {"NAME": "VALUE", "INDEXING": "LIST", "MEANING": "Point value of each decoration in order (index 0 corresponds to Decoration 1)"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Total budget available"}, {"NAME": "ITEMS", "INDEXING": "LIST", "MEANING": "Index set of decorations, 0-indexed"}], "DATA": {"COST": [40, 100, 90, 110, 20, 230, 220, 160, 90, 160, 50, 220, 50, 80, 180, 60, 20, 90, 70, 90, 220, 110, 120, 40], "VALUE": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "BUDGET": 910, "ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(VALUE[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["sum(COST[i]*X[i] for i in ITEMS) <= BUDGET"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of integers representing selected decoration indices (each integer in 0..23)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    inst = standardDataclass()\n    inst.length = len(data['DATA']['ITEMS'])\n    inst.values = list(data['DATA']['VALUE'])\n    inst.weights = list(data['DATA']['COST'])\n    inst.capacity = data['DATA']['BUDGET']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "0..23", "MEANING": "Index set for the 24 offers (0-based indices)"}, {"SYMBOL": "x[I]", "DOMAIN": "BINARY", "MEANING": "Decision variable: 1 if offer i is accepted, 0 otherwise"}], "DATA_ROLES": [{"NAME": "PRICE", "INDEXING": "LIST", "MEANING": "Offered revenue amounts for each offer, indexed by I"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "Gallons requested in each offer, indexed by I"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of offers"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "Total gallons available (capacity)"}], "DATA": {"PRICE": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "GALLONS": [4, 10, 9, 11, 2, 23, 22, 16, 9, 16, 5, 22, 5, 8, 18, 6, 2, 9, 7, 9, 22, 11, 12, 4], "N": 24, "CAPACITY": 91}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(PRICE[i] * x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(GALLONS[i] * x[i] for i in I) <= CAPACITY"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of chosen customer indices (integers)"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    s = extractedData\n    start = s.find('{')\n    end = s.rfind('}')\n    core = s[start:end+1]\n    d = ast.literal_eval(core)\n    dd = d['DATA']\n    standardDataclass.length = dd['N']\n    standardDataclass.values = list(dd['PRICE'])\n    standardDataclass.weights = list(dd['GALLONS'])\n    standardDataclass.capacity = dd['CAPACITY']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if attraction i is selected, 0 otherwise; defined for all i in I"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of attractions (0-based indices 0..N-1)"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of attractions"}, {"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "Point value for each attraction, indexed by I"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "Time in minutes required for each attraction, indexed by I"}, {"NAME": "TMAX", "INDEXING": "SCALAR", "MEANING": "Available sightseeing time in minutes (capacity)"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "N": 24, "SCORES": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "TIMES": [40, 100, 90, 110, 20, 230, 220, 160, 90, 160, 50, 220, 50, 80, 180, 60, 20, 90, 70, 90, 220, 110, 120, 40], "TMAX": 910}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(SCORES[i] * X[i] for i in I)"}, "CONSTRAINTS": ["sum(TIMES[i] * X[i] for i in I) <= TMAX", "X[i] in {0,1} for i in I", "len(I) == N"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of selected attraction indices (e.g. \"0,3,5\"). Each element is an integer index referencing the DATA.I set."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = list(data['SCORES'])\n    standardDataclass.weights = list(data['TIMES'])\n    standardDataclass.capacity = data['TMAX']\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "X[i] in {0,1} for i in I", "meaning": "Binary decision variable, 1 if item i is selected, 0 otherwise"}], "DATA_ROLES": [{"name": "I", "indexing": "LIST", "meaning": "Index set of items (0..23) used to index W and V"}, {"name": "W", "indexing": "LIST", "meaning": "Weights of items aligned with I"}, {"name": "V", "indexing": "LIST", "meaning": "Values of items aligned with I"}, {"name": "CAPACITY", "indexing": "SCALAR", "meaning": "Required minimum total weight"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "W": [4, 10, 9, 11, 2, 23, 22, 16, 9, 16, 5, 22, 5, 8, 18, 6, 2, 9, 7, 9, 22, 11, 12, 4], "V": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "CAPACITY": 171}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "sum(V[i]*X[i] for i in I)"}, "CONSTRAINTS": ["sum(W[i]*X[i] for i in I) >= CAPACITY"], "SOLUTION_FORMAT": {"TYPE": "list", "DESCRIPTION": "0-indexed, comma-separated list of item indices (each item represented by its number). Example: [0,3,5]"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    obj = standardDataclass\n    obj.length = len(d['DATA']['I'])\n    obj.values = list(d['DATA']['V'])\n    obj.weights = list(d['DATA']['W'])\n    obj.capacity = int(d['DATA']['CAPACITY'])\n    return obj"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "LIST", "MEANING": "Index set of available decorations (0-indexed indices 0..23)"}, {"SYMBOL": "x", "DOMAIN": "BINARY", "MEANING": "Decision variable x[i] = 1 if decoration i is purchased, 0 otherwise (defined for i in I)"}], "DATA_ROLES": [{"NAME": "COSTS", "INDEXING": "LIST", "MEANING": "Cost of each decoration in the provided order (index 0 corresponds to Decoration 1)"}, {"NAME": "POINTS", "INDEXING": "LIST", "MEANING": "Point value (worth) of each decoration in the provided order (index 0 corresponds to Decoration 1)"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Minimum total spending required"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Explicit index list 0..23 for use in solver expressions"}], "DATA": {"COSTS": [40, 100, 90, 110, 20, 230, 220, 160, 90, 160, 50, 220, 50, 80, 180, 60, 20, 90, 70, 90, 220, 110, 120, 40], "POINTS": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "BUDGET": 1710, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(POINTS[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*x[i] for i in I) >= BUDGET", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of integers representing decorations to buy (e.g., 0 corresponds to Decoration 1)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = len(d['COSTS'])\n    standardDataclass.values = list(d['POINTS'])\n    standardDataclass.weights = list(d['COSTS'])\n    standardDataclass.score = 0\n    standardDataclass.capacity = int(d['BUDGET'])\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "SET(0..23)", "MEANING": "Index set for the 24 customers, 0-indexed"}, {"SYMBOL": "X", "DOMAIN": "BINARY[I]", "MEANING": "Decision variable: X[i]=1 if accept customer i's offer, 0 otherwise"}], "DATA_ROLES": [{"NAME": "PRICES", "INDEXING": "LIST", "MEANING": "Offered price in dollars for each customer, indexed by I (0-indexed)"}, {"NAME": "VOLUMES", "INDEXING": "LIST", "MEANING": "Gallons requested by each customer, indexed by I (0-indexed)"}, {"NAME": "TARGET", "INDEXING": "SCALAR", "MEANING": "Minimum total gallons that must be sold"}], "DATA": {"PRICES": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "VOLUMES": [4, 10, 9, 11, 2, 23, 22, 16, 9, 16, 5, 22, 5, 8, 18, 6, 2, 9, 7, 9, 22, 11, 12, 4], "TARGET": 171}, "OBJECTIVE": {"SENSE": "MIN", "EXPRESSION": "quicksum(PRICES[i] * X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(VOLUMES[i] * X[i] for i in I) >= TARGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of selected customer indices (integers). Example: \"0,3,5\". Verification: given a candidate solution sol (list of indices), compute total_revenue = sum(PRICES[i] for i in sol) and total_volume = sum(VOLUMES[i] for i in sol)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    standardDataclass.length = len(d['DATA']['PRICES'])\n    standardDataclass.values = list(d['DATA']['PRICES'])\n    standardDataclass.weights = list(d['DATA']['VOLUMES'])\n    standardDataclass.capacity = int(d['DATA']['TARGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_14_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "SET{0..N-1}", "MEANING": "Index set of attractions (indices 0 through N-1)"}, {"SYMBOL": "X", "DOMAIN": "{0,1} for i in I", "MEANING": "Binary decision variable: X[i]=1 if friend visits attraction i, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORE", "INDEXING": "LIST", "MEANING": "Point value (score) of each attraction indexed by I"}, {"NAME": "TIME", "INDEXING": "LIST", "MEANING": "Time required (in minutes) for each attraction indexed by I"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of attractions"}, {"NAME": "ATTRACTION_IDS", "INDEXING": "LIST", "MEANING": "List of attraction identifiers (0-based indices 0..N-1)"}], "DATA": {"SCORE": [6, 11, 4, 20, 10, 1, 18, 21, 13, 4, 14, 7, 17, 22, 6, 8, 3, 19, 24, 3, 18, 13, 22, 15], "TIME": [40, 100, 90, 110, 20, 230, 220, 160, 90, 160, 50, 220, 50, 80, 180, 60, 20, 90, 70, 90, 220, 110, 120, 40], "N": 24, "ATTRACTION_IDS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i]*X[i] for i in I) >= 1710", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "A 0-indexed, comma-separated list of attraction indices (integers). Example: \"0,3,5\""}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast, re\n    obj = ast.literal_eval(extractedData)\n    data = obj['DATA']\n    standardDataclass.length = int(data['N'])\n    standardDataclass.values = list(data['SCORE'])\n    standardDataclass.weights = list(data['TIME'])\n    cons_text = ' '.join(obj.get('CONSTRAINTS', []))\n    nums = re.findall(r'([0-9]+(?:\\.[0-9]+)?)', cons_text)\n    standardDataclass.capacity = int(nums[-1]) if len(nums) else 0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_textbook_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DATA_ROLES": {"ITEMS": {"INDEXING": "LIST", "MEANING": "List of item identifiers (index set, zero-based 0..23)"}, "WEIGHT": {"INDEXING": "LIST", "MEANING": "Weight of each item in kg, aligned with ITEMS"}, "VALUE": {"INDEXING": "LIST", "MEANING": "Monetary value of each item in €, aligned with ITEMS"}, "CAPACITY": {"INDEXING": "SCALAR", "MEANING": "Bag capacity in kg"}}, "DECISION_VARIABLES": {"X": {"DOMAIN": "BINARY", "INDEXING": "ITEMS", "MEANING": "Decision variable: 1 if item i is selected, 0 otherwise"}}, "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHT": [21, 15, 21, 17, 23, 3, 12, 6, 8, 3, 2, 19, 2, 5, 21, 16, 5, 22, 2, 16, 16, 16, 17, 19], "VALUE": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "CAPACITY": 5}, "OBJECTIVE": {"SENSE": "MAX", "EXPRESSION": "quicksum(VALUE[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHT[i]*X[i] for i in ITEMS) <= CAPACITY", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "string", "DESCRIPTION": "0-indexed comma-separated list of item indices (each item represented by its zero-based index). Example: \"9,18\" corresponds to original items 10 and 19."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    data = eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = len(d['ITEMS'])\n    standardDataclass.values = list(d['VALUE'])\n    standardDataclass.weights = list(d['WEIGHT'])\n    standardDataclass.capacity = d['CAPACITY']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i] = 1 if decoration i is selected, 0 otherwise; i in I"}], "DATA_ROLES": [{"name": "I", "indexing": "LIST", "meaning": "Index set for decorations, 0-indexed"}, {"name": "COSTS", "indexing": "LIST", "meaning": "Cost of decoration i in dollars, indexed by I"}, {"name": "POINTS", "indexing": "LIST", "meaning": "Point value of decoration i, indexed by I"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "Total budget in dollars"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "POINTS": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "BUDGET": 50}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(POINTS[i]*X[i] for i in I)"}, "CONSTRAINTS": ["sum(COSTS[i]*X[i] for i in I) <= BUDGET", "for i in I: X[i] in {0,1}"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of selected decoration numbers."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    dd = d['DATA']\n    standardDataclass.length = len(dd['I'])\n    standardDataclass.values = list(dd['POINTS'])\n    standardDataclass.weights = list(dd['COSTS'])\n    standardDataclass.capacity = int(dd['BUDGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_lemonade_stand_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "binary for i in CUSTOMERS", "MEANING": "1 if offer i is accepted, 0 otherwise"}], "DATA_ROLES": [{"NAME": "PAYMENTS", "INDEXING": "LIST", "MEANING": "payment offered by each customer in input order"}, {"NAME": "GALLONS", "INDEXING": "LIST", "MEANING": "gallons requested by each customer in input order"}, {"NAME": "CAPACITY", "INDEXING": "SCALAR", "MEANING": "maximum total gallons available to sell"}, {"NAME": "CUSTOMERS", "INDEXING": "LIST", "MEANING": "0-indexed list of customer indices corresponding to the PAYMENTS and GALLONS lists"}], "DATA": {"PAYMENTS": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "GALLONS": [21, 15, 21, 17, 23, 3, 12, 6, 8, 3, 2, 19, 2, 5, 21, 16, 5, 22, 2, 16, 16, 16, 17, 19], "CAPACITY": 5, "CUSTOMERS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(PAYMENTS[i]*X[i] for i in CUSTOMERS)"}, "CONSTRAINTS": ["quicksum(GALLONS[i]*X[i] for i in CUSTOMERS) <= CAPACITY", "X[i] in {0,1} for i in CUSTOMERS"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "A 0-indexed comma-separated list of selected customer indices (e.g. \"0,3,5\")"}}, "FuncionDeCarga": "def Transform(extractedData,standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.values = list(data['PAYMENTS'])\n    standardDataclass.weights = list(data['GALLONS'])\n    standardDataclass.capacity = data['CAPACITY']\n    standardDataclass.length = len(standardDataclass.values)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_sightseeing_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY; X[i] in {0,1} for i in I", "MEANING": "Decision variable: 1 if attraction i is selected, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "SCORES[i] is the point value of attraction i for i in I"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "TIMES[i] is the time in minutes required for attraction i for i in I"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of attractions"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of attractions, 0-based"}, {"NAME": "TIME_LIMIT", "INDEXING": "SCALAR", "MEANING": "Total available sightseeing time in minutes"}], "DATA": {"SCORES": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "TIMES": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "N": 24, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "TIME_LIMIT": 50}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(SCORES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*X[i] for i in I) <= TIME_LIMIT", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of attraction indices to visit (e.g. \"9,18\")"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = data['SCORES']\n    standardDataclass.weights = data['TIMES']\n    standardDataclass.capacity = data['TIME_LIMIT']\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_textbook_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X[ITEMS]", "domain": "{0,1}", "meaning": "Binary selection variable: X[i]=1 if item i is included, 0 otherwise (i in ITEMS, 0-based)."}], "DATA_ROLES": [{"name": "ITEMS", "indexing": "LIST", "meaning": "List of item indices (0..23) using 0-based indexing"}, {"name": "WEIGHTS", "indexing": "LIST", "meaning": "Weight of each item in kilograms, aligned with ITEMS (0-based order)"}, {"name": "VALUES", "indexing": "LIST", "meaning": "Value of each item in euros, aligned with ITEMS (0-based order)"}, {"name": "CAPACITY", "indexing": "SCALAR", "meaning": "Required minimum total weight (kg)"}], "DATA": {"ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "WEIGHTS": [21, 15, 21, 17, 23, 3, 12, 6, 8, 3, 2, 19, 2, 5, 21, 16, 5, 22, 2, 16, 16, 16, 17, 19], "VALUES": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "CAPACITY": 302}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(VALUES[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["quicksum(WEIGHTS[i]*X[i] for i in ITEMS) >= CAPACITY", "X[i] in {0,1} for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "0-INDEXED_COMMA_SEPARATED_LIST", "DESCRIPTION": "Comma-separated list of selected item indices (0-based). Optimal solution for this instance: 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23 (exclude items 9 and 18). Total weight = 302 (meets CAPACITY). Total value = 248."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    inst = standardDataclass()\n    inst.length = len(data['DATA']['ITEMS'])\n    inst.values = data['DATA']['VALUES']\n    inst.weights = data['DATA']['WEIGHTS']\n    desc = data['SOLUTION_FORMAT']['DESCRIPTION']\n    marker = 'Optimal solution for this instance: '\n    start = desc.find(marker) + len(marker)\n    end = desc.find(' (', start)\n    sol_str = desc[start:end]\n    inst.solution = [int(s) for s in sol_str.split(',') if s.strip() != '']\n    inst.score = int(desc.split('Total value = ')[1].split('.')[0])\n    inst.capacity = data['DATA']['CAPACITY']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_party_planning_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "x", "INDEXING": "I in 0..23", "DOMAIN": "Binary", "MEANING": "x[I] = 1 if decoration I is purchased, 0 otherwise (I indexes decorations 0..23 corresponding to Decoration 1..24)"}], "DATA_ROLES": [{"NAME": "COSTS", "INDEXING": "LIST", "MEANING": "cost of each decoration, index 0..23 corresponds to Decoration 1..24"}, {"NAME": "POINTS", "INDEXING": "LIST", "MEANING": "point value of each decoration, index 0..23 corresponds to Decoration 1..24"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "minimum total spend required"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "number of decorations"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "index set 0..N-1"}], "DATA": {"COSTS": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "POINTS": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "BUDGET": 3020, "N": 24, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(POINTS[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*x[i] for i in I) >= BUDGET", "x[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of integers representing selected decoration indices (each integer in 0..23). Include an evaluation function that returns (total_cost, total_points, feasible_boolean) to verify any candidate solution."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    d = data['DATA']\n    standardDataclass.length = d['N']\n    standardDataclass.values = list(d['POINTS'])\n    standardDataclass.weights = list(d['COSTS'])\n    standardDataclass.capacity = d['BUDGET']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_lemonade_stand_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"X": "X[i] in {0,1} FOR i IN I - binary decision variable: 1 if take customer's offer, 0 otherwise"}, "DATA_ROLES": {"PRICE": "LIST - PRICE[i] is the dollar amount offered by customer i (i indexed by I, order corresponds to customers 1..24)", "GALLONS": "LIST - GALLONS[i] is the gallons demanded by customer i (i indexed by I, order corresponds to customers 1..24)", "I": "LIST - index set of customers (0-indexed): 0..23"}, "DATA": {"PRICE": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "GALLONS": [21, 15, 21, 17, 23, 3, 12, 6, 8, 3, 2, 19, 2, 5, 21, 16, 5, 22, 2, 16, 16, 16, 17, 19], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(PRICE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(GALLONS[i]*X[i] for i in I) >= 302", "X[i] in {0,1} FOR i IN I"], "SOLUTION_FORMAT": {"TYPE": "0-indexed comma-separated list of integers", "DESCRIPTION": "List the selected customer indices (0-indexed). Example: \"0,1,2\" means take offers from customers 1,2,3."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    items = data['I']\n    standardDataclass.length = len(items)\n    standardDataclass.values = list(data['PRICE'])\n    standardDataclass.weights = list(data['GALLONS'])\n    standardDataclass.capacity = int(302)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"X": {"DOMAIN": "Binary for i in I", "MEANING": "Decision variable X[i]=1 if friend visits attraction i, 0 otherwise"}, "I": {"DOMAIN": "LIST", "MEANING": "Index set of attractions (0-indexed)"}}, "DATA_ROLES": {"SCORES": {"INDEXING": "LIST", "MEANING": "Points value for each attraction, indexed by i in I"}, "TIMES": {"INDEXING": "LIST", "MEANING": "Time in minutes required for each attraction, indexed by i in I"}, "N": {"INDEXING": "SCALAR", "MEANING": "Number of attractions"}, "TARGET_TIME": {"INDEXING": "SCALAR", "MEANING": "Minimum total time friend should spend visiting attractions (minutes)"}, "I": {"INDEXING": "LIST", "MEANING": "Index set 0..N-1"}}, "DATA": {"SCORES": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "TIMES": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "N": 24, "TARGET_TIME": 3020, "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MIN", "EXPRESSION": "quicksum(SCORES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*X[i] for i in I) >= TARGET_TIME", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of attraction indices (integers from 0 to 23) representing attractions to suggest to the friend"}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    sd = standardDataclass\n    sd.length = d['DATA']['N']\n    sd.values = list(d['DATA']['SCORES'])\n    sd.weights = list(d['DATA']['TIMES'])\n    sd.capacity = d['DATA']['TARGET_TIME']\n    sd.time = float(sum(d['DATA']['TIMES']))\n    sd.score = int(sum(d['DATA']['SCORES']))\n    sd.solution = sd.solution\n    return sd"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "INDEXING": "I", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if friend visits attraction i, 0 otherwise"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Set of 0-indexed attraction indices (0..23)"}, {"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "Point value for each attraction in order (attraction 1..24 mapped to indices 0..23)"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "Minutes required for each attraction in order (attraction 1..24 mapped to indices 0..23)"}, {"NAME": "REQUIRED_MIN_TOTAL_TIME", "INDEXING": "SCALAR", "MEANING": "Minimum total time (minutes) friend should spend before you join"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "SCORES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "TIMES": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "REQUIRED_MIN_TOTAL_TIME": 2230}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(SCORES[i] * X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i] * X[i] for i in I) >= REQUIRED_MIN_TOTAL_TIME", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of attraction indices to suggest to friend (e.g. \"0,3,5\"). Indices correspond to attractions 1..24 as 0..23."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    from ast import literal_eval\n    data = literal_eval(extractedData)\n    inst = standardDataclass()\n    inst.length = len(data['DATA']['I'])\n    inst.values = data['DATA']['SCORES']\n    inst.weights = data['DATA']['TIMES']\n    inst.capacity = data['DATA']['REQUIRED_MIN_TOTAL_TIME']\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": {"I": {"DOMAIN": "INDEX_SET", "MEANING": "set of decoration indices 0..23 used for indexing decision variables and data"}, "X": {"DOMAIN": "BINARY", "INDEXING": "I", "MEANING": "binary decision variable: X[i]=1 if decoration i is purchased, 0 otherwise"}}, "DATA_ROLES": {"COSTS": {"INDEXING": "LIST", "MEANING": "cost of each decoration indexed by I (dollars)"}, "POINTS": {"INDEXING": "LIST", "MEANING": "point value of each decoration indexed by I"}, "BUDGET": {"INDEXING": "SCALAR", "MEANING": "total available budget (dollars)"}}, "DATA": {"COSTS": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "POINTS": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "BUDGET": 2800}, "OBJECTIVE": {"SENSE": "MAX", "EXPRESSION": "quicksum(POINTS[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i]*X[i] for i in I) <= BUDGET", "for i in I: X[i] in {0,1}"], "SOLUTION_FORMAT": {"TYPE": "0-indexed list", "DESCRIPTION": "Comma-separated list of integers representing chosen decorations using 0-based numbering (decoration 1 -> 0, decoration 2 -> 1, ..., decoration 24 -> 23)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    costs = data['COSTS']\n    points = data['POINTS']\n    budget = data['BUDGET']\n    standardDataclass.length = len(points)\n    standardDataclass.values = list(points)\n    standardDataclass.weights = list(costs)\n    standardDataclass.capacity = int(budget)\n    standardDataclass.score = 0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "0..N-1", "MEANING": "Index set for attractions (indices 0 through N-1)"}, {"SYMBOL": "X", "DOMAIN": "binary for i in I", "MEANING": "Decision variable: 1 if attraction i is suggested to friend, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "Point value for each attraction in index order (0-indexed)"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "Time in minutes required for each attraction in index order (0-indexed)"}, {"NAME": "N", "INDEXING": "SCALAR", "MEANING": "Number of attractions"}, {"NAME": "REQUIRED_TIME", "INDEXING": "SCALAR", "MEANING": "Minimum total time friend must spend (minutes)"}], "DATA": {"SCORES": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "TIMES": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "N": 24, "REQUIRED_TIME": 3020}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "quicksum(SCORES[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*X[i] for i in I) >= REQUIRED_TIME", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed list of selected attraction indices (integers). Example: [0,1,5]. For this instance the optimal feasible selection that minimizes total score while achieving at least REQUIRED_TIME = 3020 is [0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23] (i.e. all indices except 9 and 18)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = data['N']\n    standardDataclass.values = list(data['SCORES'])\n    standardDataclass.weights = list(data['TIMES'])\n    standardDataclass.capacity = data['REQUIRED_TIME']\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "INDEXING": "LIST", "DOMAIN": "BINARY", "MEANING": "1 if friend visits attraction i, 0 otherwise; index i taken from DATA.I"}], "DATA_ROLES": [{"NAME": "SCORE", "INDEXING": "LIST", "MEANING": "point value for each attraction in index order"}, {"NAME": "TIME", "INDEXING": "LIST", "MEANING": "minutes required for each attraction in index order"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "index set for attractions (0-based indices)"}], "DATA": {"SCORE": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "TIME": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORE[i] * X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i] * X[i] for i in I) >= 2230", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTS", "DESCRIPTION": "0-indexed comma-separated list of attraction indices to suggest to friend; indices correspond to the order in DATA.SCORE and DATA.TIME."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast, re\n    data = ast.literal_eval(extractedData)\n    inst = standardDataclass()\n    d = data['DATA']\n    s = d['SCORE']\n    t = d['TIME']\n    inst.length = len(s)\n    inst.values = list(s)\n    inst.weights = list(t)\n    cons = data.get('CONSTRAINTS', [])\n    cons_str = cons[0] if cons else ''\n    m = re.search(r'>=\\s*([0-9]+)', cons_str)\n    inst.capacity = int(m.group(1)) if m else 0\n    return inst"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": ["X[I] : BINARY : X[i] = 1 if decoration i is purchased, 0 otherwise (i in I)"], "DATA_ROLES": [{"NAME": "COSTS", "INDEXING": "LIST", "MEANING": "COSTS[i] is the cost of decoration i for i in I"}, {"NAME": "POINTS", "INDEXING": "LIST", "MEANING": "POINTS[i] is the point value of decoration i for i in I"}, {"NAME": "BUDGET", "INDEXING": "SCALAR", "MEANING": "Maximum total spend allowed"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of decorations (0-indexed)"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "COSTS": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "POINTS": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "BUDGET": 2800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "quicksum(POINTS[i] * X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(COSTS[i] * X[i] for i in I) <= BUDGET", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "A 0-indexed, comma-separated list of chosen decoration indices (e.g. \"0,1,3\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['I'])\n    standardDataclass.values = [int(x) for x in data['POINTS']]\n    standardDataclass.weights = [int(x) for x in data['COSTS']]\n    standardDataclass.capacity = int(data['BUDGET'])\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "binary", "MEANING": "X[i] = 1 if friend visits attraction i, 0 otherwise; indexed by i in I"}], "DATA_ROLES": [{"NAME": "I", "INDEXING": "LIST", "MEANING": "Index set of attractions (0-indexed)"}, {"NAME": "SCORE", "INDEXING": "LIST", "MEANING": "Point value (score) of each attraction in order indexed by I"}, {"NAME": "TIME", "INDEXING": "LIST", "MEANING": "Time required (minutes) for each attraction in order indexed by I"}, {"NAME": "TIME_LIMIT", "INDEXING": "SCALAR", "MEANING": "Minimum total time the friend should spend visiting attractions"}], "DATA": {"I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "SCORE": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "TIME": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "TIME_LIMIT": 3020}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i]*X[i] for i in I) >= TIME_LIMIT", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "STRING", "DESCRIPTION": "0-indexed comma-separated list of attraction indices that friend should visit (e.g., \"0,5,10\")."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    d = eval(extractedData)\n    data = d['DATA']\n    I = data['I']\n    SCORE = data['SCORE']\n    TIME = data['TIME']\n    TIME_LIMIT = data['TIME_LIMIT']\n    standardDataclass.length = len(I)\n    standardDataclass.values = list(SCORE)\n    standardDataclass.weights = list(TIME)\n    standardDataclass.capacity = TIME_LIMIT\n    standardDataclass.score = sum(SCORE)\n    standardDataclass.time = float(TIME_LIMIT)\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_12_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "I", "DOMAIN": "INDEX_SET = {0..23}", "MEANING": "Index set for the 24 attractions (0-indexed)"}, {"SYMBOL": "x", "DOMAIN": "Binary for each i in I (x[i] in {0,1})", "MEANING": "Decision variable: x[i]=1 if friend visits attraction i, 0 otherwise"}], "DATA_ROLES": [{"NAME": "SCORES", "INDEXING": "LIST", "MEANING": "Point value for each attraction in order index 0..23 (0-indexed)"}, {"NAME": "TIMES", "INDEXING": "LIST", "MEANING": "Minutes required for each attraction in order index 0..23 (0-indexed)"}, {"NAME": "THRESHOLD", "INDEXING": "SCALAR", "MEANING": "Minimum total minutes the friend should spend visiting attractions"}], "DATA": {"SCORES": [2, 23, 16, 18, 10, 17, 14, 2, 4, 4, 14, 23, 2, 8, 22, 23, 9, 10, 4, 5, 3, 12, 15, 10], "TIMES": [210, 70, 120, 180, 170, 30, 20, 130, 190, 180, 190, 60, 180, 160, 80, 110, 80, 180, 220, 130, 70, 70, 50, 150], "THRESHOLD": 2230}, "OBJECTIVE": {"SENSE": "MIN", "EXPRESSION_SOLVER_COMPATIBLE": "quicksum(SCORES[i]*x[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIMES[i]*x[i] for i in I) >= THRESHOLD", "x[i] in {0,1} for all i in I", "I = {0..23}"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTEGERS", "DESCRIPTION": "0-indexed, comma-separated list of attraction indices to suggest to the friend (each integer in 0..23)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    data = ast.literal_eval(extractedData)\n    scores = list(data['DATA']['SCORES'])\n    times = list(data['DATA']['TIMES'])\n    threshold = data['DATA']['THRESHOLD']\n    standardDataclass.length = len(scores)\n    standardDataclass.values = scores\n    standardDataclass.weights = times\n    standardDataclass.capacity = threshold\n    standardDataclass.score = 0\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_13_party_planning_standard", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "X", "domain": "BINARY", "meaning": "X[i]=1 if decoration i is purchased, 0 otherwise; indexed by ITEMS"}], "DATA_ROLES": [{"name": "COSTS", "indexing": "LIST", "meaning": "cost of each decoration; COSTS[i] corresponds to decoration index i (0-indexed)"}, {"name": "POINTS", "indexing": "LIST", "meaning": "point value of each decoration; POINTS[i] corresponds to decoration index i (0-indexed)"}, {"name": "ITEMS", "indexing": "LIST", "meaning": "set/list of decoration indices (0-indexed)"}, {"name": "BUDGET", "indexing": "SCALAR", "meaning": "available budget (upper bound on total cost)"}], "DATA": {"COSTS": [30, 120, 190, 190, 230, 220, 240, 190, 10, 240, 220, 20, 140, 160, 200, 130, 200, 100, 90, 60, 210, 200, 190, 210], "POINTS": [1, 10, 6, 9, 4, 19, 3, 20, 17, 13, 22, 22, 8, 23, 24, 23, 24, 6, 10, 1, 11, 3, 23, 16], "ITEMS": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "BUDGET": 2800}, "OBJECTIVE": {"SENSE": "MAXIMIZE", "EXPRESSION": "sum(POINTS[i]*X[i] for i in ITEMS)"}, "CONSTRAINTS": ["sum(COSTS[i]*X[i] for i in ITEMS) <= BUDGET", "X[i] binary for i in ITEMS"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of decoration indices to purchase (e.g. 0,3,5)."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import ast\n    d = ast.literal_eval(extractedData)\n    data = d['DATA']\n    standardDataclass.length = len(data['ITEMS'])\n    standardDataclass.values = list(data['POINTS'])\n    standardDataclass.weights = list(data['COSTS'])\n    standardDataclass.capacity = data['BUDGET']\n    standardDataclass.score = 0\n    standardDataclass.time = 0.0\n    return standardDataclass"}
{"Instancia": "knapsack_hard_dataset_in_house_24_15_sightseeing_inverted", "Tipo_de_problema": "knapsack", "SchemaDataClass": {"DECISION_VARIABLES": [{"SYMBOL": "X", "DOMAIN": "BINARY", "MEANING": "X[i] = 1 if the friend visits attraction i, 0 otherwise; indexed by I"}], "DATA_ROLES": [{"NAME": "SCORE", "INDEXING": "LIST", "MEANING": "score (points) for each attraction, ordered by attraction index 0..23"}, {"NAME": "TIME", "INDEXING": "LIST", "MEANING": "time (minutes) required for each attraction, ordered by attraction index 0..23"}, {"NAME": "I", "INDEXING": "LIST", "MEANING": "index set for attractions (0-indexed)"}], "DATA": {"SCORE": [12, 2, 12, 13, 1, 16, 8, 10, 11, 23, 2, 13, 16, 14, 5, 19, 7, 9, 21, 21, 19, 4, 20, 14], "TIME": [210, 150, 210, 170, 230, 30, 120, 60, 80, 30, 20, 190, 20, 50, 210, 160, 50, 220, 20, 160, 160, 160, 170, 190], "I": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "quicksum(SCORE[i]*X[i] for i in I)"}, "CONSTRAINTS": ["quicksum(TIME[i]*X[i] for i in I) >= 3020", "X[i] in {0,1} for i in I"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "0-indexed comma-separated list of attraction indices selected (each an integer between 0 and 23). Optimal selection (minimizes total score while ensuring total time >=3020) is: 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23 (i.e., all attractions except indices 9 and 18). This selection yields TOTAL_SCORE=248 and TOTAL_TIME=3020."}}, "FuncionDeCarga": "def Transform(extractedData, standardDataclass):\n    import re\n    data = eval(extractedData)\n    sd = standardDataclass\n    sd.values = list(data['DATA']['SCORE'])\n    sd.weights = list(data['DATA']['TIME'])\n    sd.length = len(sd.values)\n    desc = data['SOLUTION_FORMAT']['DESCRIPTION']\n    parts = desc.split('This selection yields')\n    left = parts[0]\n    right = parts[1] if len(parts) > 1 else ''\n    sd.solution = [int(x) for x in re.findall(r'\\d+', left)]\n    totals = re.findall(r'\\d+', right)\n    if totals:\n        sd.score = int(totals[0])\n        sd.capacity = int(totals[1])\n        sd.time = float(totals[1])\n    return sd"}
