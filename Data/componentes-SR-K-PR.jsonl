{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: sorted unique list of 1-based customer indices selected (x_i=1 iff index present).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Return a cost (lower is better). Feasible: -revenue. Infeasible: positive penalty with overflow gradient.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n    # Validate\n    if not isinstance(solution, list):\n        return 10**18\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**18\n        if idx < 1 or idx > n:\n            return 10**18\n        if idx in seen:\n            return 10**18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n    overflow = weight - capacity\n    base_penalty = 20 * sum(prices)  # 5740\n    return base_penalty + overflow\n","Vecindad":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Best-improvement feasible neighborhood with lexicographic tie-break\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        # sorted unique and valid range\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n))\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def total_revenue(sol: List[int]) -> int:\n        return sum(prices[i-1] for i in sol)\n\n    cur = canonical(solution)\n    cur_w = total_weight(cur)\n    cur_rev = total_revenue(cur)\n\n    # If overweight (should not happen normally), repair greedily by removing lowest density\n    if cur_w > capacity:\n        dens = sorted(cur, key=lambda i: (prices[i-1]\/gallons[i-1], i))\n        sset = set(cur)\n        for i in dens:\n            if cur_w <= capacity:\n                break\n            sset.remove(i)\n            cur_w -= gallons[i-1]\n            cur_rev -= prices[i-1]\n        cur = sorted(sset)\n\n    best = cur\n    best_rev = cur_rev\n    best_move = (\"none\")\n\n    in_set = set(cur)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # 1-add moves\n    for i in out_list:\n        nw = cur_w + gallons[i-1]\n        if nw <= capacity:\n            nrev = cur_rev + prices[i-1]\n            if nrev > best_rev or (nrev == best_rev and [*cur, i] and sorted([*cur, i]) < best):\n                best = sorted([*cur, i])\n                best_rev = nrev\n                best_move = \"add\"\n\n    # 1-drop moves\n    for i in cur:\n        nrev = cur_rev - prices[i-1]\n        if nrev > best_rev or (nrev == best_rev and sorted([j for j in cur if j != i]) < best):\n            best = sorted([j for j in cur if j != i])\n            best_rev = nrev\n            best_move = \"drop\"\n\n    # 1-1 swap moves\n    for i_out in cur:\n        for i_in in out_list:\n            nw = cur_w - gallons[i_out-1] + gallons[i_in-1]\n            if nw <= capacity:\n                nrev = cur_rev - prices[i_out-1] + prices[i_in-1]\n                cand = sorted([j for j in cur if j != i_out] + [i_in])\n                if nrev > best_rev or (nrev == best_rev and cand < best):\n                    best = cand\n                    best_rev = nrev\n                    best_move = \"swap\"\n\n    # 2-1 exchanges (drop two, add one)\n    lc = len(cur)\n    for a_idx in range(lc):\n        i1 = cur[a_idx]\n        for b_idx in range(a_idx+1, lc):\n            i2 = cur[b_idx]\n            base_w = cur_w - gallons[i1-1] - gallons[i2-1]\n            base_rev = cur_rev - prices[i1-1] - prices[i2-1]\n            if base_w < 0:\n                continue\n            for i_in in out_list:\n                nw = base_w + gallons[i_in-1]\n                if nw <= capacity:\n                    nrev = base_rev + prices[i_in-1]\n                    cand = sorted([j for j in cur if j not in (i1, i2)] + [i_in])\n                    if nrev > best_rev or (nrev == best_rev and cand < best):\n                        best = cand\n                        best_rev = nrev\n                        best_move = \"2-1\"\n\n    # 1-2 exchanges (drop one, add two)\n    lo = len(out_list)\n    for i_out in cur:\n        base_w = cur_w - gallons[i_out-1]\n        base_rev = cur_rev - prices[i_out-1]\n        for x in range(lo):\n            i_in1 = out_list[x]\n            for y in range(x+1, lo):\n                i_in2 = out_list[y]\n                nw = base_w + gallons[i_in1-1] + gallons[i_in2-1]\n                if nw <= capacity:\n                    nrev = base_rev + prices[i_in1-1] + prices[i_in2-1]\n                    cand = sorted([j for j in cur if j != i_out] + [i_in1, i_in2])\n                    if nrev > best_rev or (nrev == best_rev and cand < best):\n                        best = cand\n                        best_rev = nrev\n                        best_move = \"1-2\"\n\n    return (best, \"FeasibleNB\", best_move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        return sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= n))\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(gallons[i-1] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        w = total_weight(sol)\n        if w <= capacity:\n            return canonical(sol)\n        # remove lowest density first\n        sol = canonical(sol)\n        dens = sorted(sol, key=lambda i: (prices[i-1]\/gallons[i-1], i))\n        keep = set(sol)\n        for i in dens:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    pert = canonical(solution)\n    k = max(2, n \/\/ 6)\n    for _ in range(k):\n        r = random.random()\n        in_set = set(pert)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        if r < 0.34 and pert:\n            # drop\n            idx = random.randrange(len(pert))\n            del pert[idx]\n        elif r < 0.68 and out_list:\n            # add if feasible else skip\n            i = random.choice(out_list)\n            if total_weight(pert) + gallons[i-1] <= capacity:\n                pert.append(i)\n                pert = sorted(set(pert))\n        else:\n            # swap\n            if pert and out_list:\n                i_out = random.choice(pert)\n                i_in = random.choice(out_list)\n                cand = sorted([j for j in pert if j != i_out] + [i_in])\n                if total_weight(cand) <= capacity:\n                    pert = cand\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return canonical(pert)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: sorted unique 1-based indices of selected customers.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Cost function (lower is better). Feasible: -revenue. Infeasible: large positive penalty with overflow gradient.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Validate and canonicalize to sorted unique 1-based indices\n    if not isinstance(solution, list):\n        return 10**18\n    s = []\n    seen = set()\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**18\n        if x < 1 or x > n:\n            return 10**18\n        if x not in seen:\n            seen.add(x)\n            s.append(x)\n    s.sort()\n\n    revenue = 0\n    weight = 0\n    for idx in s:\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n\n    overflow = weight - capacity\n    # Strong penalty: base + linear and quadratic overflow\n    base_penalty = 10**6\n    return base_penalty + 1000 * overflow + overflow * overflow","Vecindad":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, lexicographically-tiebroken best-improvement neighborhood over feasible solutions\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        # Sorted unique and valid 1-based indices\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def totals(sol: List[int]):\n        w = 0\n        r = 0\n        for i in sol:\n            j = i - 1\n            w += gallons[j]\n            r += prices[j]\n        return w, r\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        # Lagrangian-guided removal: remove items with smallest (p - lambda*w)\n        s = canonical(sol)\n        w, r = totals(s)\n        if w <= capacity:\n            return s\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        items = list(s)\n        # sort by (p - lam*w), then by index for determinism (remove worst first)\n        items_sorted = sorted(items, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        kept = set(items)\n        for i in items_sorted:\n            if w <= capacity:\n                break\n            if i in kept:\n                kept.remove(i)\n                w -= gallons[i-1]\n        return sorted(kept)\n\n    cur = repair_feasible(canonical(solution))\n    cur_w, cur_rev = totals(cur)\n\n    best = cur\n    best_rev = cur_rev\n    best_move = \"none\"\n\n    in_set = set(cur)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Helper: lex-accept if better revenue or equal revenue but lexicographically smaller\n    def consider(cand: List[int], nrev: int, move_name: str):\n        nonlocal best, best_rev, best_move\n        if nrev > best_rev or (nrev == best_rev and cand < best):\n            best = cand\n            best_rev = nrev\n            best_move = move_name\n\n    # 1-add moves\n    residual = capacity - cur_w\n    for i in out_list:\n        wi = gallons[i-1]\n        if wi <= residual:\n            nrev = cur_rev + prices[i-1]\n            cand = cur.copy()\n            # insert maintaining order\n            lo, hi = 0, len(cand)\n            while lo < hi:\n                mid = (lo + hi) \/\/ 2\n                if cand[mid] < i:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            cand.insert(lo, i)\n            consider(cand, nrev, \"add\")\n\n    # 1-drop moves\n    for idx, i in enumerate(cur):\n        nrev = cur_rev - prices[i-1]\n        cand = cur[:idx] + cur[idx+1:]\n        consider(cand, nrev, \"drop\")\n\n    # 1-1 swap moves\n    for idx_out, i_out in enumerate(cur):\n        w_out = gallons[i_out-1]\n        r_out = prices[i_out-1]\n        base_w = cur_w - w_out\n        base_r = cur_rev - r_out\n        residual2 = capacity - base_w\n        for i_in in out_list:\n            wi = gallons[i_in-1]\n            if wi <= residual2:\n                nrev = base_r + prices[i_in-1]\n                # build candidate without full sort: remove position and insert i_in\n                cand = cur[:idx_out] + cur[idx_out+1:]\n                # insert maintaining order\n                lo, hi = 0, len(cand)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if cand[mid] < i_in:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                cand.insert(lo, i_in)\n                consider(cand, nrev, \"swap\")\n\n    # Limited 2-2 swaps: try pairs of out items among top-k by price and pairs of in items among smallest by price\n    k = min(8, len(out_list))\n    top_out = sorted(out_list, key=lambda i: (-prices[i-1], gallons[i-1], i))[:k]\n    # choose up to k in-set items with smallest price (more likely candidates to drop)\n    top_in = sorted(cur, key=lambda i: (prices[i-1], gallons[i-1], i))[:min(k, len(cur))]\n    li = len(top_in)\n    lo = len(top_out)\n    for a in range(li):\n        i1 = top_in[a]\n        w1 = gallons[i1-1]\n        r1 = prices[i1-1]\n        for b in range(a+1, li):\n            i2 = top_in[b]\n            w2 = gallons[i2-1]\n            r2 = prices[i2-1]\n            base_w = cur_w - w1 - w2\n            base_r = cur_rev - r1 - r2\n            resid = capacity - base_w\n            if resid <= 0:\n                continue\n            for x in range(lo):\n                j1 = top_out[x]\n                wj1 = gallons[j1-1]\n                if wj1 >= resid:\n                    # need at least two adds to fit, skip pair if single already exceeds\n                    pass\n                for y in range(x+1, lo):\n                    j2 = top_out[y]\n                    wj2 = gallons[j2-1]\n                    nw = base_w + wj1 + wj2\n                    if nw <= capacity:\n                        nrev = base_r + prices[j1-1] + prices[j2-1]\n                        # construct candidate\n                        cand_set = []\n                        rem = set((i1, i2))\n                        for t in cur:\n                            if t not in rem:\n                                cand_set.append(t)\n                        # insert j1 and j2 maintaining order\n                        for add_item in (j1, j2):\n                            lo2, hi2 = 0, len(cand_set)\n                            while lo2 < hi2:\n                                mid2 = (lo2 + hi2) \/\/ 2\n                                if cand_set[mid2] < add_item:\n                                    lo2 = mid2 + 1\n                                else:\n                                    hi2 = mid2\n                            cand_set.insert(lo2, add_item)\n                        consider(cand_set, nrev, \"2-2\")\n\n    return (best, \"FeasibleNB\", best_move)","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        w = 0\n        for i in sol:\n            w += gallons[i-1]\n        return w\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        s = canonical(sol)\n        w = total_weight(s)\n        if w <= capacity:\n            return s\n        # remove by lowest (p - lambda*w)\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        order = sorted(s, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        keep = set(s)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    base = canonical(solution)\n    # Deterministic RNG seed derived from solution contents for reproducibility\n    seed = 1469598103934665603\n    for i in base:\n        seed ^= (i * 1099511628211) & 0xFFFFFFFFFFFFFFFF\n        seed &= 0xFFFFFFFFFFFFFFFF\n    rng = random.Random(seed)\n\n    pert = base[:]\n    k = max(3, n \/\/ 5)\n    for _ in range(k):\n        in_set = set(pert)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        move = rng.random()\n        if move < 0.33 and pert:\n            # drop random\n            j = rng.randrange(len(pert))\n            pert.pop(j)\n        elif move < 0.66 and out_list:\n            # add random if feasible\n            i = rng.choice(out_list)\n            if total_weight(pert) + gallons[i-1] <= capacity:\n                # insert maintaining order\n                lo, hi = 0, len(pert)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if pert[mid] < i:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                pert.insert(lo, i)\n        else:\n            # swap\n            if pert and out_list:\n                i_out = rng.choice(pert)\n                i_in = rng.choice(out_list)\n                cand = [x for x in pert if x != i_out]\n                # insert maintaining order\n                lo, hi = 0, len(cand)\n                while lo < hi:\n                    mid = (lo + hi) \/\/ 2\n                    if cand[mid] < i_in:\n                        lo = mid + 1\n                    else:\n                        hi = mid\n                cand.insert(lo, i_in)\n                if total_weight(cand) <= capacity:\n                    pert = cand\n\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return canonical(pert)","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST: sorted unique 1-based indices of selected customers (x_i=1 iff i in list).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better: feasible => -revenue; infeasible => large positive penalty\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Validate and canonicalize to sorted unique 1-based indices\n    if not isinstance(solution, list):\n        return 10**18\n    s = []\n    seen = set()\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**18\n        if x < 1 or x > n:\n            return 10**18\n        if x not in seen:\n            seen.add(x)\n            s.append(x)\n    s.sort()\n\n    revenue = 0\n    weight = 0\n    for idx in s:\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    capacity = 304\n    if weight <= capacity:\n        return -revenue\n\n    overflow = weight - capacity\n    base_penalty = 10**6\n    return base_penalty + 1000 * overflow + overflow * overflow\n","Vecindad":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic best-improvement neighborhood with feasibility enforcement\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def totals(sol: List[int]):\n        w = 0\n        r = 0\n        for i in sol:\n            j = i - 1\n            w += gallons[j]\n            r += prices[j]\n        return w, r\n\n    def insert_sorted(arr: List[int], val: int) -> List[int]:\n        lo, hi = 0, len(arr)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if arr[mid] < val:\n                lo = mid + 1\n            else:\n                hi = mid\n        arr.insert(lo, val)\n        return arr\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        s = canonical(sol)\n        w, _ = totals(s)\n        if w <= capacity:\n            return s\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        order = sorted(s, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        keep = set(s)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = repair_feasible(canonical(solution))\n    cur_w, cur_rev = totals(cur)\n\n    best = cur\n    best_rev = cur_rev\n    best_move = \"none\"\n\n    in_set = set(cur)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    def consider(cand: List[int], nrev: int, move_name: str):\n        nonlocal best, best_rev, best_move\n        if nrev > best_rev or (nrev == best_rev and cand < best):\n            best = cand\n            best_rev = nrev\n            best_move = move_name\n\n    # 1-add moves (feasible-only)\n    residual = capacity - cur_w\n    if residual > 0:\n        for i in out_list:\n            wi = gallons[i-1]\n            if wi <= residual:\n                nrev = cur_rev + prices[i-1]\n                cand = cur.copy()\n                insert_sorted(cand, i)\n                consider(cand, nrev, \"add\")\n\n    # 1-drop moves\n    for idx, i in enumerate(cur):\n        nrev = cur_rev - prices[i-1]\n        cand = cur[:idx] + cur[idx+1:]\n        consider(cand, nrev, \"drop\")\n\n    # 1-1 swaps\n    if cur:\n        out_set = set(out_list)\n        for pos_out, i_out in enumerate(cur):\n            w_out = gallons[i_out-1]\n            r_out = prices[i_out-1]\n            base_w = cur_w - w_out\n            base_r = cur_rev - r_out\n            residual2 = capacity - base_w\n            if residual2 <= 0:\n                continue\n            for i_in in out_list:\n                wi = gallons[i_in-1]\n                if wi <= residual2:\n                    nrev = base_r + prices[i_in-1]\n                    cand = cur[:pos_out] + cur[pos_out+1:]\n                    insert_sorted(cand, i_in)\n                    consider(cand, nrev, \"swap\")\n\n    # Density-based candidate pools for multi-exchanges\n    density = [(prices[i]-0.0)\/gallons[i] for i in range(n)]\n    # top-k out by density then price\n    k = 10\n    top_out = sorted(out_list, key=lambda i: (-density[i-1], -prices[i-1], gallons[i-1], i))[:min(k, len(out_list))]\n    # bottom-k in by density then price (candidates to drop)\n    top_in = sorted(cur, key=lambda i: (density[i-1], prices[i-1], -gallons[i-1], i))[:min(k, len(cur))]\n\n    # 2-1 exchanges: drop two, add one\n    li = len(top_in)\n    lo = len(top_out)\n    for a in range(li):\n        i1 = top_in[a]\n        w1 = gallons[i1-1]\n        r1 = prices[i1-1]\n        for b in range(a+1, li):\n            i2 = top_in[b]\n            w2 = gallons[i2-1]\n            r2 = prices[i2-1]\n            base_w = cur_w - w1 - w2\n            base_r = cur_rev - r1 - r2\n            residual3 = capacity - base_w\n            if residual3 <= 0:\n                continue\n            for j in top_out:\n                wj = gallons[j-1]\n                if wj <= residual3:\n                    nrev = base_r + prices[j-1]\n                    cand = []\n                    rem = {i1, i2}\n                    for t in cur:\n                        if t not in rem:\n                            cand.append(t)\n                    insert_sorted(cand, j)\n                    consider(cand, nrev, \"2-1\")\n\n    # 1-2 exchanges: drop one, add two\n    for pos_out, i_out in enumerate(top_in):\n        w_out = gallons[i_out-1]\n        r_out = prices[i_out-1]\n        base_w = cur_w - w_out\n        base_r = cur_rev - r_out\n        residual4 = capacity - base_w\n        if residual4 <= 0:\n            continue\n        lo2 = len(top_out)\n        for x in range(lo2):\n            j1 = top_out[x]\n            w1 = gallons[j1-1]\n            if w1 >= residual4:\n                continue\n            for y in range(x+1, lo2):\n                j2 = top_out[y]\n                w2 = gallons[j2-1]\n                nw = base_w + w1 + w2\n                if nw <= capacity:\n                    nrev = base_r + prices[j1-1] + prices[j2-1]\n                    cand = [t for t in cur if t != i_out]\n                    insert_sorted(cand, j1)\n                    insert_sorted(cand, j2)\n                    consider(cand, nrev, \"1-2\")\n\n    return (best, \"FeasibleNB\", best_move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Deterministic, capacity-aware perturbation with guided removals and greedy reinsertion\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def canonical(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                s.append(x)\n        s.sort()\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        w = 0\n        for i in sol:\n            w += gallons[i-1]\n        return w\n\n    def total_revenue(sol: List[int]) -> int:\n        r = 0\n        for i in sol:\n            r += prices[i-1]\n        return r\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        s = canonical(sol)\n        w = total_weight(s)\n        if w <= capacity:\n            return s\n        avg_p = sum(prices) \/ n\n        avg_w = sum(gallons) \/ n\n        lam = avg_p \/ max(1.0, avg_w)\n        order = sorted(s, key=lambda i: (prices[i-1] - lam * gallons[i-1], i))\n        keep = set(s)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    base = canonical(solution)\n\n    # Deterministic RNG seed derived from solution contents (FNV-like)\n    seed = 1469598103934665603\n    for i in base:\n        seed ^= (i * 1099511628211) & 0xFFFFFFFFFFFFFFFF\n        seed &= 0xFFFFFFFFFFFFFFFF\n    rng = random.Random(seed)\n\n    pert = base[:]\n\n    # Phase 1: remove k_low items biased to low density\n    density = [(prices[i]-0.0)\/gallons[i] for i in range(n)]\n    k_low = max(2, n \/\/ 8)\n    for _ in range(k_low):\n        if not pert:\n            break\n        # pick among bottom-m by density currently in solution\n        m = min(5, len(pert))\n        cand = sorted(pert, key=lambda i: (density[i-1], prices[i-1], -gallons[i-1], i))[:m]\n        drop = rng.choice(cand)\n        pert = [x for x in pert if x != drop]\n\n    # Phase 2: greedy reinsert by density and price\n    def insert_sorted(arr: List[int], val: int) -> None:\n        lo, hi = 0, len(arr)\n        while lo < hi:\n            mid = (lo + hi) \/\/ 2\n            if arr[mid] < val:\n                lo = mid + 1\n            else:\n                hi = mid\n        arr.insert(lo, val)\n\n    w_now = total_weight(pert)\n    available = [i for i in range(1, n+1) if i not in set(pert)]\n    available.sort(key=lambda i: (-density[i-1], -prices[i-1], gallons[i-1], i))\n    for i in available:\n        wi = gallons[i-1]\n        if w_now + wi <= capacity:\n            insert_sorted(pert, i)\n            w_now += wi\n\n    # Phase 3: random few swap attempts to diversify (only if feasible)\n    t_swaps = 5\n    for _ in range(t_swaps):\n        in_set = set(pert)\n        out_list = [i for i in range(1, n+1) if i not in in_set]\n        if not pert or not out_list:\n            break\n        i_out = rng.choice(pert)\n        i_in = rng.choice(out_list)\n        new_w = w_now - gallons[i_out-1] + gallons[i_in-1]\n        if new_w <= capacity:\n            cand = [x for x in pert if x != i_out]\n            insert_sorted(cand, i_in)\n            pert = cand\n            w_now = new_w\n\n    if total_weight(pert) > capacity:\n        pert = repair_feasible(pert)\n    return canonical(pert)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]. Set semantics; order ignored; no duplicates.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization fitness for SA\/ILS\/TS runners\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Validate and compute objective\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return 1_000_000_000.0  # large positive penalty for invalid solutions\n\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n\n    if total_time <= capacity:\n        # Feasible: minimize negative objective\n        return float(-obj)\n\n    # Infeasible: strong positive penalty, slightly offset by obj\n    overflow = total_time - capacity\n    penalty = 1_000_000.0 + float(overflow) - obj\n    if penalty <= 0.0:\n        penalty = 1_000_000.0 + float(overflow)  # ensure positive cost\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes representation; Movement_Type encodes operator used.\n    \"\"\"\n    # Problem data embedded\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Canonicalize input to unique valid indices\n    if isinstance(solution, list):\n        base = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        base = []\n    seen = set()\n    canon = []\n    for i in base:\n        if i not in seen:\n            canon.append(i)\n            seen.add(i)\n\n    # Utility: compute total time quickly\n    total_time = 0\n    for i in canon:\n        total_time += times[i - 1]\n\n    # Helper operators\n    def add_random(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        candidates = [i for i in range(1, 25) if i not in present]\n        if not candidates:\n            return sol[:], \"NoMove\"\n        choice = random.choice(candidates)\n        return sol + [choice], \"Add\"\n\n    def add_ratio_guided(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        best = None\n        best_ratio = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_ratio:\n                best_ratio = r\n                best = i\n        if best is None:\n            return sol[:], \"NoMove\"\n        return sol + [best], \"AddRG\"\n\n    def remove_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return sol[:], \"NoMove\"\n        j = random.randrange(len(sol))\n        new_sol = sol[:]\n        new_sol.pop(j)\n        return new_sol, \"Remove\"\n\n    def remove_worst_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return sol[:], \"NoMove\"\n        worst_idx = 0\n        worst_ratio = float('inf')\n        for k, i in enumerate(sol):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_ratio:\n                worst_ratio = r\n                worst_idx = k\n        new_sol = sol[:]\n        new_sol.pop(worst_idx)\n        return new_sol, \"RemoveWR\"\n\n    def swap_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return add_random(sol)[0], \"Add\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return remove_random(sol)\n        rem = random.choice(sol)\n        add = random.choice(outside)\n        new_sol = [x for x in sol if x != rem] + [add]\n        return new_sol, \"Swap\"\n\n    def swap_two(sol: List[int]) -> Tuple[List[int], str]:\n        if len(sol) < 2:\n            return swap_random(sol)\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if len(outside) < 2:\n            return swap_random(sol)\n        rem = random.sample(sol, 2)\n        add = random.sample(outside, 2)\n        pool = [x for x in sol if x not in rem] + add\n        return pool, \"Swap2\"\n\n    # Choose move with feasibility awareness\n    overweight = total_time > capacity\n    u = random.random()\n    if overweight:\n        # Prefer removals when overweight\n        if u < 0.6:\n            neigh, mv = remove_worst_ratio(canon)\n        elif u < 0.85:\n            neigh, mv = remove_random(canon)\n        else:\n            neigh, mv = swap_random(canon)\n    else:\n        if u < 0.35:\n            neigh, mv = add_ratio_guided(canon)\n        elif u < 0.6:\n            neigh, mv = add_random(canon)\n        elif u < 0.85:\n            neigh, mv = swap_random(canon)\n        else:\n            neigh, mv = swap_two(canon)\n\n    # Final uniqueness clamp (preserve order of first occurrence)\n    seen2 = set()\n    final = []\n    for i in neigh:\n        if 1 <= i <= 24 and i not in seen2:\n            final.append(i)\n            seen2.add(i)\n\n    return final, \"IndexList\", mv\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-kick perturbation combining add\/remove\/swap with guided steps\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    if isinstance(solution, list):\n        sol = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        sol = []\n    # Deduplicate preserving order\n    seen = set()\n    sol_clean = []\n    for i in sol:\n        if i not in seen:\n            sol_clean.append(i)\n            seen.add(i)\n    sol = sol_clean\n\n    K = 6 + random.randint(0, 6)\n\n    def add_best_ratio(sol_: List[int]) -> List[int]:\n        present = set(sol_)\n        best = None\n        best_r = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_r:\n                best_r = r\n                best = i\n        return sol_ + [best] if best is not None else sol_\n\n    def remove_worst_ratio(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return sol_\n        worst_idx = 0\n        worst_r = float('inf')\n        for k, i in enumerate(sol_):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_r:\n                worst_r = r\n                worst_idx = k\n        out = sol_[:]\n        out.pop(worst_idx)\n        return out\n\n    def swap_random(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return sol_\n        present = set(sol_)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return sol_\n        rem = random.choice(sol_)\n        add = random.choice(outside)\n        return [x for x in sol_ if x != rem] + [add]\n\n    for _ in range(K):\n        r = random.random()\n        if r < 0.34:\n            sol = add_best_ratio(sol)\n        elif r < 0.67:\n            sol = remove_worst_ratio(sol)\n        else:\n            sol = swap_random(sol)\n        # Deduplicate and clamp\n        seen2 = set()\n        tmp = []\n        for i in sol:\n            if 1 <= i <= 24 and i not in seen2:\n                tmp.append(i)\n                seen2.add(i)\n        sol = tmp\n\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list[int] of unique 1-based indices in [1,24]; set semantics (order ignored); no duplicates.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    # Validate representation: list of unique 1-based integers\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns a minimization fitness for SA\/ILS\/TS.\n    Feasible solutions: cost = -objective (since we maximize objective).\n    Infeasible or invalid: large positive penalty.\n    \"\"\"\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Validate and compute objective\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return 1_000_000_000.0  # invalid representation penalty\n\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n\n    if total_time <= capacity:\n        # Feasible: minimize negative objective\n        return float(-obj)\n\n    # Infeasible: strong positive penalty, slightly offset by obj but ensure positive\n    overflow = total_time - capacity\n    penalty = 1_000_000.0 + float(overflow) - obj\n    if penalty <= 0.0:\n        penalty = 1_000_000.0 + float(overflow)\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes representation; Movement_Type encodes operator used.\n    Representation: INDEX_LIST of unique 1-based indices in [1,24].\n    Canonicalization: sort unique indices to avoid permutation duplicates.\n    Includes feasibility-aware behavior and greedy repair after Add moves.\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Canonicalize input: keep valid, unique indices\n    if isinstance(solution, list):\n        base = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        base = []\n    seen = set()\n    canon = []\n    for i in base:\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    # Canonical sort to set semantics\n    canon.sort()\n\n    # Utility: compute total time\n    def total_time(sol: List[int]) -> int:\n        tt = 0\n        for i in sol:\n            tt += times[i - 1]\n        return tt\n\n    # Greedy repair to restore feasibility by removing lowest score\/time ratio\n    def repair_feasible(sol: List[int]) -> List[int]:\n        tt = total_time(sol)\n        if tt <= capacity:\n            return sol\n        sol2 = list(sol)\n        while tt > capacity and sol2:\n            worst_idx = 0\n            worst_ratio = float('inf')\n            for k, i in enumerate(sol2):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_ratio:\n                    worst_ratio = r\n                    worst_idx = k\n            removed = sol2.pop(worst_idx)\n            tt -= times[removed - 1]\n        # Final canonicalization\n        sol2 = sorted(set(sol2))\n        return sol2\n\n    # Operators\n    def add_random(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        candidates = [i for i in range(1, 25) if i not in present]\n        if not candidates:\n            return list(sol), \"NoMove\"\n        choice = random.choice(candidates)\n        out = list(sol) + [choice]\n        return out, \"Add\"\n\n    def add_ratio_guided(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        best = None\n        best_ratio = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_ratio:\n                best_ratio = r\n                best = i\n        if best is None:\n            return list(sol), \"NoMove\"\n        out = list(sol) + [best]\n        return out, \"AddRG\"\n\n    def remove_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        j = random.randrange(len(sol))\n        out = list(sol)\n        out.pop(j)\n        return out, \"Remove\"\n\n    def remove_worst_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        worst_idx = 0\n        worst_ratio = float('inf')\n        for k, i in enumerate(sol):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_ratio:\n                worst_ratio = r\n                worst_idx = k\n        out = list(sol)\n        out.pop(worst_idx)\n        return out, \"RemoveWR\"\n\n    def swap_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return add_random(sol)[0], \"Add\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return remove_random(sol)\n        rem = random.choice(sol)\n        add = random.choice(outside)\n        out = [x for x in sol if x != rem] + [add]\n        return out, \"Swap\"\n\n    def swap_improve_time_or_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        # Try a targeted 1-1 swap that improves ratio or reduces time\n        if not sol:\n            return add_ratio_guided(sol)\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol), \"NoMove\"\n        best_out = list(sol)\n        best_gain = -1e18\n        base_time = total_time(sol)\n        for rem in sol:\n            for add in outside:\n                new_time = base_time - times[rem - 1] + times[add - 1]\n                gain = (scores[add - 1] - scores[rem - 1])\n                # Prefer swaps that reduce time when overweight or improve score\/time ratio otherwise\n                ratio_gain = (scores[add - 1] \/ float(times[add - 1])) - (scores[rem - 1] \/ float(times[rem - 1]))\n                merit = gain + 0.5 * ratio_gain - max(0, new_time - capacity)\n                if merit > best_gain:\n                    best_gain = merit\n                    best_out = [x for x in sol if x != rem] + [add]\n        return best_out, \"SwapGuided\"\n\n    # Choose move with feasibility awareness\n    overweight = total_time(canon) > capacity\n    u = random.random()\n    if overweight:\n        # Prefer removals when overweight\n        if u < 0.7:\n            neigh, mv = remove_worst_ratio(canon)\n        elif u < 0.9:\n            neigh, mv = swap_improve_time_or_ratio(canon)\n        else:\n            neigh, mv = remove_random(canon)\n    else:\n        if u < 0.35:\n            neigh, mv = add_ratio_guided(canon)\n        elif u < 0.6:\n            neigh, mv = add_random(canon)\n        elif u < 0.85:\n            neigh, mv = swap_improve_time_or_ratio(canon)\n        else:\n            neigh, mv = swap_random(canon)\n\n    # If we just performed an Add that made it infeasible, repair greedily\n    if mv in (\"Add\", \"AddRG\"):\n        neigh = repair_feasible(neigh)\n\n    # Final canonicalization: sort unique indices within [1,24]\n    final = sorted({i for i in neigh if isinstance(i, int) and 1 <= i <= 24})\n\n    return final, \"IndexList\", mv\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-kick perturbation combining guided removals and additions.\n    - Deduplicate and canonicalize input\n    - Apply K in [6..12] kicks of:\n      * remove worst ratio\n      * add best ratio\n      * random swap\n    - Greedy feasibility repair if overweight\n    - Canonicalize (sorted unique) at end\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Clean and canonicalize input\n    if isinstance(solution, list):\n        sol = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        sol = []\n    sol = sorted(set(sol))\n\n    def total_time(sol_: List[int]) -> int:\n        tt = 0\n        for i in sol_:\n            tt += times[i - 1]\n        return tt\n\n    def add_best_ratio(sol_: List[int]) -> List[int]:\n        present = set(sol_)\n        best = None\n        best_r = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_r:\n                best_r = r\n                best = i\n        return sol_ + [best] if best is not None else list(sol_)\n\n    def remove_worst_ratio(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        worst_idx = 0\n        worst_r = float('inf')\n        for k, i in enumerate(sol_):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_r:\n                worst_r = r\n                worst_idx = k\n        out = list(sol_)\n        out.pop(worst_idx)\n        return out\n\n    def swap_random(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        present = set(sol_)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol_)\n        rem = random.choice(sol_)\n        add = random.choice(outside)\n        return [x for x in sol_ if x != rem] + [add]\n\n    def repair_feasible(sol_: List[int]) -> List[int]:\n        tt = total_time(sol_)\n        if tt <= capacity:\n            return sorted(set(sol_))\n        out = list(sol_)\n        while tt > capacity and out:\n            worst_idx = 0\n            worst_r = float('inf')\n            for k, i in enumerate(out):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_r:\n                    worst_r = r\n                    worst_idx = k\n            rem = out.pop(worst_idx)\n            tt -= times[rem - 1]\n        return sorted(set(out))\n\n    K = 6 + random.randint(0, 6)\n    for _ in range(K):\n        r = random.random()\n        if r < 0.34:\n            sol = add_best_ratio(sol)\n        elif r < 0.67:\n            sol = remove_worst_ratio(sol)\n        else:\n            sol = swap_random(sol)\n        # Clamp to valid domain and canonicalize during perturbation\n        sol = sorted({i for i in sol if isinstance(i, int) and 1 <= i <= 24})\n        # Light repair if clearly overweight to avoid excessive penalties\n        if total_time(sol) > capacity and len(sol) >= 2:\n            sol = repair_feasible(sol)\n\n    # Final canonicalization\n    sol = sorted(set(sol))\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST: list of unique 1-based integers in [1,24]; order ignored; no duplicates.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    # Scores (v_i) for attractions 1..24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    # Validate representation: list of unique 1-based integers\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_score = 0\n    seen = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > 24:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_score += scores[idx - 1]\n    return float(total_score)\n\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns a minimization fitness for SA\/ILS\/TS.\n    Feasible solutions: cost = -objective (since we maximize objective).\n    Infeasible or invalid: large positive penalty.\n    \"\"\"\n    # Times (t_i) for attractions 1..24\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Validate and compute objective\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return 1_000_000_000.0  # invalid representation penalty\n\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n\n    if total_time <= capacity:\n        # Feasible: minimize negative objective\n        return float(-obj)\n\n    # Infeasible: strong positive penalty\n    overflow = total_time - capacity\n    penalty = 1_000_000.0 + float(overflow)\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution: List[int], NB_Type: str, Movement_Type: str)\n    NB_Type encodes representation; Movement_Type encodes operator used.\n    Representation: INDEX_LIST of unique 1-based indices in [1,24].\n    Canonicalization: sort unique indices to avoid permutation duplicates.\n    Includes feasibility-aware behavior and greedy repair after Add moves.\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Canonicalize input: keep valid, unique indices\n    if isinstance(solution, list):\n        base = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        base = []\n    seen = set()\n    canon = []\n    for i in base:\n        if i not in seen:\n            seen.add(i)\n            canon.append(i)\n    # Canonical sort to set semantics\n    canon.sort()\n\n    # Utility: compute total time\n    def total_time(sol: List[int]) -> int:\n        tt = 0\n        for i in sol:\n            tt += times[i - 1]\n        return tt\n\n    # Greedy repair to restore feasibility by removing lowest score\/time ratio\n    def repair_feasible(sol: List[int]) -> List[int]:\n        tt = total_time(sol)\n        if tt <= capacity:\n            return sorted(set(sol))\n        out = list(sol)\n        while tt > capacity and out:\n            worst_idx = 0\n            worst_ratio = float('inf')\n            for k, i in enumerate(out):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_ratio:\n                    worst_ratio = r\n                    worst_idx = k\n            removed = out.pop(worst_idx)\n            tt -= times[removed - 1]\n        return sorted(set(out))\n\n    # Operators\n    def add_random(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        candidates = [i for i in range(1, 25) if i not in present]\n        if not candidates:\n            return list(sol), \"NoMove\"\n        choice = random.choice(candidates)\n        out = list(sol) + [choice]\n        return out, \"Add\"\n\n    def add_ratio_guided(sol: List[int]) -> Tuple[List[int], str]:\n        present = set(sol)\n        best = None\n        best_ratio = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_ratio:\n                best_ratio = r\n                best = i\n        if best is None:\n            return list(sol), \"NoMove\"\n        out = list(sol) + [best]\n        return out, \"AddRG\"\n\n    def remove_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        j = random.randrange(len(sol))\n        out = list(sol)\n        out.pop(j)\n        return out, \"Remove\"\n\n    def remove_worst_ratio(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            return list(sol), \"NoMove\"\n        worst_idx = 0\n        worst_ratio = float('inf')\n        for k, i in enumerate(sol):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_ratio:\n                worst_ratio = r\n                worst_idx = k\n        out = list(sol)\n        out.pop(worst_idx)\n        return out, \"RemoveWR\"\n\n    def swap_random(sol: List[int]) -> Tuple[List[int], str]:\n        if not sol:\n            nb, _ = add_random(sol)\n            return nb, \"Add\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return remove_random(sol)\n        rem = random.choice(sol)\n        add = random.choice(outside)\n        out = [x for x in sol if x != rem] + [add]\n        return out, \"Swap\"\n\n    def swap_guided(sol: List[int]) -> Tuple[List[int], str]:\n        # Try a targeted 1-1 swap guided by ratio and time (Lagrangian-like)\n        if not sol:\n            nb, _ = add_ratio_guided(sol)\n            return nb, \"AddRG\"\n        present = set(sol)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol), \"NoMove\"\n        best_out = list(sol)\n        best_merit = -1e18\n        base_time = total_time(sol)\n        # Estimate lambda from slack: lambda ~ 0 when under capacity, >0 when overweight\n        slack = 3040 - base_time\n        lam = 0.0 if slack >= 0 else 0.5\n        for rem in sol:\n            for add in outside:\n                new_time = base_time - times[rem - 1] + times[add - 1]\n                gain = (scores[add - 1] - scores[rem - 1])\n                time_delta = new_time - base_time\n                ratio_gain = (scores[add - 1] \/ float(times[add - 1])) - (scores[rem - 1] \/ float(times[rem - 1]))\n                merit = gain + 0.25 * ratio_gain - lam * max(0, new_time - capacity) - 0.02 * max(0, time_delta)\n                if merit > best_merit:\n                    best_merit = merit\n                    best_out = [x for x in sol if x != rem] + [add]\n        return best_out, \"SwapGuided\"\n\n    # Choose move with feasibility awareness\n    overweight = total_time(canon) > capacity\n    u = random.random()\n    if overweight:\n        # Prefer removals when overweight\n        if u < 0.7:\n            neigh, mv = remove_worst_ratio(canon)\n        elif u < 0.9:\n            neigh, mv = swap_guided(canon)\n        else:\n            neigh, mv = remove_random(canon)\n    else:\n        if u < 0.35:\n            neigh, mv = add_ratio_guided(canon)\n        elif u < 0.6:\n            neigh, mv = add_random(canon)\n        elif u < 0.85:\n            neigh, mv = swap_guided(canon)\n        else:\n            neigh, mv = swap_random(canon)\n\n    # If we just performed an Add that may make it infeasible, repair greedily\n    if mv in (\"Add\", \"AddRG\"):\n        neigh = repair_feasible(neigh)\n\n    # Final canonicalization: sort unique indices within [1,24]\n    final = sorted({i for i in neigh if isinstance(i, int) and 1 <= i <= 24})\n\n    return final, \"IndexList\", mv\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-kick perturbation combining guided removals and additions.\n    - Deduplicate and canonicalize input\n    - Apply K in [6..12] kicks of:\n      * remove worst ratio\n      * add best ratio\n      * random swap\n    - Greedy feasibility repair if overweight\n    - Canonicalize (sorted unique) at end\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    # Clean and canonicalize input\n    if isinstance(solution, list):\n        sol = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n    else:\n        sol = []\n    sol = sorted(set(sol))\n\n    def total_time(sol_: List[int]) -> int:\n        tt = 0\n        for i in sol_:\n            tt += times[i - 1]\n        return tt\n\n    def add_best_ratio(sol_: List[int]) -> List[int]:\n        present = set(sol_)\n        best = None\n        best_r = -1.0\n        for i in range(1, 25):\n            if i in present:\n                continue\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r > best_r:\n                best_r = r\n                best = i\n        return sol_ + [best] if best is not None else list(sol_)\n\n    def remove_worst_ratio(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        worst_idx = 0\n        worst_r = float('inf')\n        for k, i in enumerate(sol_):\n            r = scores[i - 1] \/ float(times[i - 1])\n            if r < worst_r:\n                worst_r = r\n                worst_idx = k\n        out = list(sol_)\n        out.pop(worst_idx)\n        return out\n\n    def swap_random(sol_: List[int]) -> List[int]:\n        if not sol_:\n            return list(sol_)\n        present = set(sol_)\n        outside = [i for i in range(1, 25) if i not in present]\n        if not outside:\n            return list(sol_)\n        rem = random.choice(sol_)\n        add = random.choice(outside)\n        return [x for x in sol_ if x != rem] + [add]\n\n    def repair_feasible(sol_: List[int]) -> List[int]:\n        tt = total_time(sol_)\n        if tt <= capacity:\n            return sorted(set(sol_))\n        out = list(sol_)\n        while tt > capacity and out:\n            worst_idx = 0\n            worst_r = float('inf')\n            for k, i in enumerate(out):\n                r = scores[i - 1] \/ float(times[i - 1])\n                if r < worst_r:\n                    worst_r = r\n                    worst_idx = k\n            rem = out.pop(worst_idx)\n            tt -= times[rem - 1]\n        return sorted(set(out))\n\n    K = 6 + random.randint(0, 6)\n    for _ in range(K):\n        r = random.random()\n        if r < 0.34:\n            sol = add_best_ratio(sol)\n        elif r < 0.67:\n            sol = remove_worst_ratio(sol)\n        else:\n            sol = swap_random(sol)\n        # Clamp to valid domain and canonicalize during perturbation\n        sol = sorted({i for i in sol if isinstance(i, int) and 1 <= i <= 24})\n        # Light repair if clearly overweight to avoid excessive penalties\n        if total_time(sol) > capacity and len(sol) >= 2:\n            sol = repair_feasible(sol)\n\n    # Final canonicalization\n    sol = sorted(set(sol))\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float('inf')\n    # Internal data (scores v_i and times t_i)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    # Objective helper (sum of selected scores)\n    def objective_function(sol):\n        total = 0\n        seen = set()\n        for idx in sol:\n            if not isinstance(idx, int):\n                return float('-inf')\n            if idx < 1 or idx > n_items:\n                return float('-inf')\n            if idx in seen:\n                return float('-inf')\n            seen.add(idx)\n            total += scores[idx - 1]\n        return float(total)\n    obj = objective_function(solution)\n    if obj == float('-inf'):\n        return float('inf')\n    # Compute total time\n    total_time = 0\n    for idx in solution:\n        total_time += times[idx - 1]\n    capacity = 3040\n    # Cost convention: minimize cost; feasible cost = -objective\n    if total_time <= capacity:\n        return float(-obj)\n    # Infeasible: strong positive penalty to be worse than any feasible\n    overflow = total_time - capacity\n    penalty = 100000.0 + float(overflow)\n    return float(penalty)","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to a valid unique list within [1,24]\n    n_items = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    if isinstance(solution, list):\n        seen = set()\n        current = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                current.append(x)\n    else:\n        current = []\n    # Helper: compute time and feasibility\n    cur_time = 0\n    for i in current:\n        cur_time += times[i - 1]\n    # Helper: repair to feasibility by removing worst efficiency items if needed\n    def repair(sol):\n        total_t = 0\n        for k in sol:\n            total_t += times[k - 1]\n        if total_t <= capacity:\n            return sol\n        # Remove items with lowest value-to-time ratio until feasible\n        ratios = [(idx, scores[idx - 1] \/ times[idx - 1]) for idx in sol]\n        # Sort ascending by ratio (worst first)\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol)\n        for idx, _ in ratios:\n            if total_t <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                total_t -= times[idx - 1]\n        # Preserve original relative order\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n    # Candidate moves: add, remove, swap (1-1)\n    moves = []\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if 0 < len(current) < n_items:\n        moves.append(\"swap\")\n    if not moves:\n        # Initialize with a single random valid item\n        item = random.randint(1, n_items)\n        return ([item], \"INDEX_LIST\", \"init\")\n    move = random.choice(moves)\n    new_sol = list(current)\n    if move == \"add\":\n        present = set(new_sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n            new_sol = repair(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            pos = random.randrange(len(new_sol))\n            new_sol.pop(pos)\n            # Already feasible by construction after removal\n    else:  # swap 1-1\n        if new_sol:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                pos = random.randrange(len(new_sol))\n                out_item = random.choice(outside)\n                new_sol[pos] = out_item\n                # Ensure uniqueness\n                dedup_seen = set()\n                dedup = []\n                for x in new_sol:\n                    if x not in dedup_seen:\n                        dedup_seen.add(x)\n                        dedup.append(x)\n                new_sol = repair(dedup)\n    return (new_sol, \"INDEX_LIST\", move)","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Normalize input\n    n_items = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    if isinstance(solution, list):\n        seen = set()\n        sol = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                sol.append(x)\n    else:\n        sol = []\n    # Helper: feasibility repair removing lowest ratio items\n    def repair(sol_local):\n        total_t = 0\n        for k in sol_local:\n            total_t += times[k - 1]\n        if total_t <= capacity:\n            return sol_local\n        ratios = [(idx, scores[idx - 1] \/ times[idx - 1]) for idx in sol_local]\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol_local)\n        for idx, _ in ratios:\n            if total_t <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                total_t -= times[idx - 1]\n        new_sol = []\n        seen_local = set()\n        for x in sol_local:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n    # Perform k random edits to escape local minima\n    k = random.randint(3, 6)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            sol = [random.randint(1, n_items)]\n            continue\n        m = random.choice(moves)\n        if m == \"add\":\n            present = set(sol)\n            candidates = [i for i in range(1, n_items + 1) if i not in present]\n            if candidates:\n                sol.append(random.choice(candidates))\n                sol = repair(sol)\n        elif m == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol:\n                present = set(sol)\n                outside = [i for i in range(1, n_items + 1) if i not in present]\n                if outside:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(outside)\n                    # Deduplicate and repair\n                    dedup_seen = set()\n                    dedup = []\n                    for x in sol:\n                        if x not in dedup_seen:\n                            dedup_seen.add(x)\n                            dedup.append(x)\n                    sol = repair(dedup)\n    return sol","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Minimization cost: feasible -> negative objective; infeasible -> large positive penalty\n    # Internal data (embedded constants)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n    # Validate type and contents\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_score = 0.0\n    total_time = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n_items:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        total_score += float(scores[idx - 1])\n        total_time += times[idx - 1]\n    if total_time <= capacity:\n        return float(-total_score)\n    overflow = total_time - capacity\n    penalty = 100000.0 + float(overflow)\n    return float(penalty)","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal constants\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Normalize input -> unique 1..n list\n    if isinstance(solution, list):\n        seen = set()\n        current = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                current.append(x)\n    else:\n        current = []\n\n    def total_time_of(sol):\n        tt = 0\n        for k in sol:\n            tt += times[k - 1]\n        return tt\n\n    # Feasibility repair: remove lowest value\/time until feasible\n    def repair(sol):\n        tt = total_time_of(sol)\n        if tt <= capacity:\n            return sol\n        ratios = [(idx, scores[idx - 1] \/ float(times[idx - 1])) for idx in sol]\n        ratios.sort(key=lambda x: x[1])  # worst first\n        keep = set(sol)\n        for idx, _ in ratios:\n            if tt <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                tt -= times[idx - 1]\n        # Preserve initial order of remaining items\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n\n    # If empty, seed with a greedy best-ratio item\n    if not current:\n        best_idx = max(range(1, n_items + 1), key=lambda i: scores[i - 1] \/ float(times[i - 1]))\n        return ([best_idx], \"init\")\n\n    move_types = []\n    if len(current) < n_items:\n        move_types.append(\"add\")\n    if len(current) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(current) < n_items:\n        move_types.append(\"swap1-1\")\n        if len(current) >= 2:\n            move_types.append(\"swap2-1\")\n        if len(current) <= n_items - 2:\n            move_types.append(\"swap1-2\")\n\n    move = random.choice(move_types) if move_types else \"add\"\n    new_sol = list(current)\n\n    if move == \"add\":\n        present = set(new_sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n            # Dedup implicit; repair for feasibility\n            new_sol = repair(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            pos = random.randrange(len(new_sol))\n            new_sol.pop(pos)\n    elif move == \"swap1-1\":\n        if new_sol:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                pos = random.randrange(len(new_sol))\n                out_item = random.choice(outside)\n                new_sol[pos] = out_item\n                # Dedup then repair\n                ded = []\n                seen_d = set()\n                for x in new_sol:\n                    if x not in seen_d:\n                        seen_d.add(x)\n                        ded.append(x)\n                new_sol = repair(ded)\n    elif move == \"swap2-1\":\n        if len(new_sol) >= 2:\n            present = set(new_sol)\n            outside = [i for i in range(1, n_items + 1) if i not in present]\n            if outside:\n                # remove two, add one\n                pos1 = random.randrange(len(new_sol))\n                pos2 = random.randrange(len(new_sol))\n                while pos2 == pos1 and len(new_sol) > 1:\n                    pos2 = random.randrange(len(new_sol))\n                pos_low, pos_high = (pos1, pos2) if pos1 < pos2 else (pos2, pos1)\n                keep = [x for i, x in enumerate(new_sol) if i not in (pos_low, pos_high)]\n                keep.append(random.choice(outside))\n                # Dedup then repair\n                ded = []\n                seen_d = set()\n                for x in keep:\n                    if x not in seen_d:\n                        seen_d.add(x)\n                        ded.append(x)\n                new_sol = repair(ded)\n    else:  # swap1-2\n        present = set(new_sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if new_sol and len(outside) >= 2:\n            pos = random.randrange(len(new_sol))\n            add_items = random.sample(outside, 2)\n            cand = [x for i, x in enumerate(new_sol) if i != pos]\n            cand.extend(add_items)\n            # Dedup then repair\n            ded = []\n            seen_d = set()\n            for x in cand:\n                if x not in seen_d:\n                    seen_d.add(x)\n                    ded.append(x)\n            new_sol = repair(ded)\n\n    return (new_sol, move)","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal constants\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Normalize\n    if isinstance(solution, list):\n        seen = set()\n        sol = []\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                sol.append(x)\n    else:\n        sol = []\n\n    def total_time_of(sol):\n        tt = 0\n        for k in sol:\n            tt += times[k - 1]\n        return tt\n\n    def repair(sol):\n        tt = total_time_of(sol)\n        if tt <= capacity:\n            return sol\n        ratios = [(idx, scores[idx - 1] \/ float(times[idx - 1])) for idx in sol]\n        ratios.sort(key=lambda x: x[1])\n        keep = set(sol)\n        for idx, _ in ratios:\n            if tt <= capacity:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                tt -= times[idx - 1]\n        new_sol = []\n        seen_local = set()\n        for x in sol:\n            if x in keep and x not in seen_local:\n                new_sol.append(x)\n                seen_local.add(x)\n        return new_sol\n\n    # Strength via random edits\n    k = random.randint(3, 6)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            sol = [random.randint(1, n_items)]\n            continue\n        m = random.choice(moves)\n        if m == \"add\":\n            present = set(sol)\n            candidates = [i for i in range(1, n_items + 1) if i not in present]\n            if candidates:\n                sol.append(random.choice(candidates))\n                sol = repair(sol)\n        elif m == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol:\n                present = set(sol)\n                outside = [i for i in range(1, n_items + 1) if i not in present]\n                if outside:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(outside)\n                    # Dedup and repair\n                    ded = []\n                    seen_d = set()\n                    for x in sol:\n                        if x not in seen_d:\n                            seen_d.add(x)\n                            ded.append(x)\n                    sol = repair(ded)\n\n    # Intensify: greedy fill by ratio within remaining capacity\n    present = set(sol)\n    remaining = capacity - total_time_of(sol)\n    if remaining > 0:\n        candidates = [i for i in range(1, n_items + 1) if i not in present and times[i - 1] <= remaining]\n        candidates.sort(key=lambda i: (scores[i - 1] \/ float(times[i - 1]), scores[i - 1]), reverse=True)\n        for i in candidates:\n            if total_time_of(sol) + times[i - 1] <= capacity:\n                sol.append(i)\n    sol = repair(sol)\n    return sol","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Validate type and contents\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_score = 0.0\n    total_time = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n_items:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        total_score += float(scores[idx - 1])\n        total_time += times[idx - 1]\n\n    # Feasible: minimize negative score (i.e., maximize score)\n    if total_time <= capacity:\n        return float(-total_score)\n\n    # Infeasible: scaled penalty preserving gradient\n    overflow = total_time - capacity\n    # Penalty factor tuned for guidance near boundary\n    M = 50.0\n    penalty = M * float(overflow) - float(total_score)\n    return float(penalty)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    # Utilities\n    def canon(sol):\n        # Unique 1..n, sorted for canonical set representation\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_time(sol):\n        return sum(times[i - 1] for i in sol)\n\n    def repair(sol):\n        # If feasible, return as canonical\n        sol = canon(sol)\n        tt = total_time(sol)\n        if tt <= capacity:\n            return sol\n        # Drop worst score\/time until feasible\n        items = [(i, scores[i - 1] \/ float(times[i - 1])) for i in sol]\n        items.sort(key=lambda x: x[1])  # lowest ratio first\n        keep = set(i for i, _ in items)\n        for i, _ in items:\n            if tt <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                tt -= times[i - 1]\n        new_sol = [i for i in sol if i in keep]\n        new_sol.sort()\n        return new_sol\n\n    # Normalize current solution\n    current = canon(solution if isinstance(solution, list) else [])\n\n    # If empty, use greedy constructive seed by score\/time\n    if not current:\n        idxs = list(range(1, n_items + 1))\n        idxs.sort(key=lambda i: (scores[i - 1] \/ float(times[i - 1]), scores[i - 1]), reverse=True)\n        seed = []\n        used_time = 0\n        for i in idxs:\n            if used_time + times[i - 1] <= capacity:\n                seed.append(i)\n                used_time += times[i - 1]\n        seed = canon(seed)\n        return (seed, \"init-greedy\")\n\n    move_types = []\n    if len(current) < n_items:\n        move_types.append(\"add\")\n    if len(current) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(current) < n_items:\n        move_types.append(\"swap1-1\")\n        if len(current) >= 2:\n            move_types.append(\"swap2-1\")\n            move_types.append(\"swap2-2\")\n        if len(current) <= n_items - 2:\n            move_types.append(\"swap1-2\")\n\n    move = random.choice(move_types) if move_types else \"add\"\n    sol = list(current)\n\n    if move == \"add\":\n        present = set(sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present]\n        if candidates:\n            sol.append(random.choice(candidates))\n        sol = repair(sol)\n    elif move == \"remove\":\n        if sol:\n            pos = random.randrange(len(sol))\n            sol.pop(pos)\n            sol = canon(sol)\n    elif move == \"swap1-1\":\n        present = set(sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if sol and outside:\n            pos = random.randrange(len(sol))\n            sol[pos] = random.choice(outside)\n            sol = repair(sol)\n    elif move == \"swap2-1\":\n        present = set(sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if len(sol) >= 2 and outside:\n            pos1 = random.randrange(len(sol))\n            pos2 = random.randrange(len(sol))\n            while pos2 == pos1 and len(sol) > 1:\n                pos2 = random.randrange(len(sol))\n            keep = [x for k, x in enumerate(sol) if k not in (min(pos1, pos2), max(pos1, pos2))]\n            keep.append(random.choice(outside))\n            sol = repair(keep)\n    elif move == \"swap1-2\":\n        present = set(sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if sol and len(outside) >= 2:\n            pos = random.randrange(len(sol))\n            add_items = random.sample(outside, 2)\n            cand = [x for k, x in enumerate(sol) if k != pos] + add_items\n            sol = repair(cand)\n    else:  # swap2-2\n        present = set(sol)\n        outside = [i for i in range(1, n_items + 1) if i not in present]\n        if len(sol) >= 2 and len(outside) >= 2:\n            pos1 = random.randrange(len(sol))\n            pos2 = random.randrange(len(sol))\n            while pos2 == pos1 and len(sol) > 1:\n                pos2 = random.randrange(len(sol))\n            add_items = random.sample(outside, 2)\n            cand = [x for k, x in enumerate(sol) if k not in (min(pos1, pos2), max(pos1, pos2))] + add_items\n            sol = repair(cand)\n\n    return (sol, move)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n_items = 24\n    capacity = 3040\n\n    def canon(sol):\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_time(sol):\n        return sum(times[i - 1] for i in sol)\n\n    def repair(sol):\n        sol = canon(sol)\n        tt = total_time(sol)\n        if tt <= capacity:\n            return sol\n        items = [(i, scores[i - 1] \/ float(times[i - 1])) for i in sol]\n        items.sort(key=lambda x: x[1])\n        keep = set(i for i, _ in items)\n        for i, _ in items:\n            if tt <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                tt -= times[i - 1]\n        new_sol = [i for i in sol if i in keep]\n        new_sol.sort()\n        return new_sol\n\n    sol = canon(solution if isinstance(solution, list) else [])\n\n    # If invalid\/empty, seed greedily\n    if not sol:\n        idxs = list(range(1, n_items + 1))\n        idxs.sort(key=lambda i: (scores[i - 1] \/ float(times[i - 1]), scores[i - 1]), reverse=True)\n        used = 0\n        for i in idxs:\n            if used + times[i - 1] <= capacity:\n                sol.append(i)\n                used += times[i - 1]\n        sol = canon(sol)\n\n    # Random multi-edit kick\n    k = random.randint(4, 8)\n    for _ in range(k):\n        moves = []\n        if len(sol) < n_items:\n            moves.append(\"add\")\n        if len(sol) > 0:\n            moves.append(\"remove\")\n        if 0 < len(sol) < n_items:\n            moves.append(\"swap\")\n        if not moves:\n            continue\n        m = random.choice(moves)\n        if m == \"add\":\n            present = set(sol)\n            candidates = [i for i in range(1, n_items + 1) if i not in present]\n            if candidates:\n                sol.append(random.choice(candidates))\n                sol = repair(sol)\n        elif m == \"remove\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n                sol = canon(sol)\n        else:  # swap\n            if sol:\n                present = set(sol)\n                outside = [i for i in range(1, n_items + 1) if i not in present]\n                if outside:\n                    pos = random.randrange(len(sol))\n                    sol[pos] = random.choice(outside)\n                    sol = repair(sol)\n\n    # Intensification: greedy fill within remaining capacity\n    remaining = capacity - total_time(sol)\n    if remaining > 0:\n        present = set(sol)\n        candidates = [i for i in range(1, n_items + 1) if i not in present and times[i - 1] <= remaining]\n        candidates.sort(key=lambda i: (scores[i - 1] \/ float(times[i - 1]), scores[i - 1]), reverse=True)\n        for i in candidates:\n            if total_time(sol) + times[i - 1] <= capacity:\n                sol.append(i)\n    sol = repair(sol)\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique integers in [1,24]). Order is not evaluated; uniqueness and bounds are enforced. Example encoding: [3,7,12,18].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Representation: INDEX_LIST (1-based unique indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    # Heuristic convention: minimize cost; use negative value for maximization\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _validate_index_list(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # INDEX_LIST 1-based; enforce feasibility-aware add\/replace; avoid null swap\n    n_items = 24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    current = _validate_index_list(solution, n_items)\n    cur_set = set(current)\n    # Compute current load\n    cur_time = sum(times[i-1] for i in current)\n    # Candidate moves\n    moves = []\n    if len(current) >= 1:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) >= 1 and len(current) < n_items:\n        moves.append(\"replace\")\n    if not moves:\n        moves = [\"add\"]\n    move = random.choice(moves)\n    new_sol = list(current)\n    if move == \"remove\" and len(new_sol) >= 1:\n        idx = random.randrange(len(new_sol))\n        del new_sol[idx]\n    elif move == \"add\" and len(new_sol) < n_items:\n        remaining_cap = capacity - cur_time\n        available = [i for i in range(1, n_items+1) if i not in cur_set and times[i-1] <= max(remaining_cap, 0)]\n        if available:\n            # bias by value\/time ratio among feasible additions\n            available.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            # pick from top-c to diversify\n            c = min(5, len(available))\n            cand = random.choice(available[:c])\n            insert_pos = random.randrange(len(new_sol)+1)\n            new_sol.insert(insert_pos, cand)\n        else:\n            # fallback to remove if cannot add feasibly\n            if len(new_sol) >= 1:\n                idx = random.randrange(len(new_sol))\n                del new_sol[idx]\n                move = \"remove\"\n    elif move == \"replace\" and len(new_sol) >= 1 and len(new_sol) < n_items:\n        # remove one then try to add a feasible high-ratio item\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        new_time = cur_time - times[out_item-1]\n        remaining_cap = capacity - new_time\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item and times[i-1] <= max(remaining_cap, 0)]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = min(5, len(candidates))\n            in_item = random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n        else:\n            # if no feasible replacement, perform a remove\n            del new_sol[out_pos]\n            move = \"remove\"\n    # Final validation\n    _ = _validate_index_list(new_sol, n_items)\n    return (new_sol, \"INDEX_LIST\", move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef _validate_index_list_perturb(sol: List[int], n: int) -> List[int]:\n    if not isinstance(sol, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in sol]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    return indices\n\ndef perturb_solution(solution):\n    # Large-step perturbation: remove r items, then greedily refill by value\/time ratio within capacity\n    n_items = 24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    cur = _validate_index_list_perturb(solution, n_items)\n    s = list(cur)\n    # remove r random distinct positions\n    if len(s) > 0:\n        r = min(len(s), random.randint(3, 6))\n        remove_positions = sorted(random.sample(range(len(s)), r), reverse=True)\n        for pos in remove_positions:\n            del s[pos]\n    # compute remaining capacity\n    used_time = sum(times[i-1] for i in s)\n    remaining = capacity - used_time\n    # Greedily add best ratio items that fit\n    in_set = set(s)\n    candidates = [i for i in range(1, n_items+1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        t = times[i-1]\n        if t <= remaining:\n            s.append(i)\n            remaining -= t\n            if remaining <= 0:\n                break\n    # final validate\n    _ = _validate_index_list_perturb(s, n_items)\n    return s\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST.1-BASED.UNIQUE.INTS[1..24]. Order-irrelevant; feasibility enforced via capacity 3040 on summed times.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation: INDEX_LIST (1-based unique indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    # Heuristic convention: minimize cost; use negative total value for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # INDEX_LIST 1-based; returns (new_solution, \"INDEX_LIST\", move)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n\n    def _validate_index_list(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            indices = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(indices) != len(set(indices)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in indices):\n            raise ValueError(\"INPUT_ERROR\")\n        return indices\n\n    def _total_time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair_feasible(sol):\n        # If over capacity, iteratively drop worst value\/time ratio items until feasible\n        cur = list(sol)\n        cur_time = _total_time(cur)\n        if cur_time <= capacity:\n            return cur\n        # compute ratios for items in cur\n        while cur and cur_time > capacity:\n            # pick worst ratio item to drop\n            worst_idx = min(range(len(cur)), key=lambda k: (values[cur[k]-1]\/times[cur[k]-1], values[cur[k]-1]))\n            cur_time -= times[cur[worst_idx]-1]\n            del cur[worst_idx]\n        return cur\n\n    current = _validate_index_list(solution)\n    cur_set = set(current)\n    cur_time = _total_time(current)\n\n    # Candidate move types\n    moves = []\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) >= 1 and len(current) < n_items:\n        moves.append(\"replace\")\n    if len(current) >= 2:\n        moves.append(\"swap\")  # 1-1 exchange\n    if not moves:\n        moves = [\"add\"]\n\n    move = random.choice(moves)\n    new_sol = list(current)\n\n    if move == \"remove\" and new_sol:\n        pos = random.randrange(len(new_sol))\n        del new_sol[pos]\n\n    elif move == \"add\" and len(new_sol) < n_items:\n        # allow temporary infeasible add; then repair\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set]\n        if candidates:\n            # epsilon-greedy on value\/time ratio\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            if random.random() < 0.8:\n                pick = candidates[0]\n            else:\n                pick = random.choice(candidates[:c])\n            insert_pos = random.randrange(len(new_sol)+1)\n            new_sol.insert(insert_pos, pick)\n            new_sol = _repair_feasible(new_sol)\n\n    elif move == \"replace\" and new_sol:\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        else:\n            # fallback to remove\n            del new_sol[out_pos]\n\n    elif move == \"swap\" and len(new_sol) >= 1:\n        # swap out one item and add a different one (1-1 exchange), then repair\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n            c = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:c])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        # else: no-op avoided by validation below\n\n    # Final validation\n    _ = _validate_index_list(new_sol)\n    return (new_sol, \"INDEX_LIST\", move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Large-step perturbation: remove k items, then greedy refill by ratio; final feasibility repair\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n\n    def _validate(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            idx = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(idx) != len(set(idx)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in idx):\n            raise ValueError(\"INPUT_ERROR\")\n        return idx\n\n    def _time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair(sol):\n        s = list(sol)\n        cur_time = _time(s)\n        if cur_time <= capacity:\n            return s\n        # drop worst ratio items until feasible\n        while s and cur_time > capacity:\n            worst = min(range(len(s)), key=lambda k: (values[s[k]-1]\/times[s[k]-1], values[s[k]-1]))\n            cur_time -= times[s[worst]-1]\n            del s[worst]\n        return s\n\n    cur = _validate(solution)\n    s = list(cur)\n\n    # Remove k items uniformly at random (if available)\n    if s:\n        k = random.randint(2, min(6, len(s)))\n        rem_pos = sorted(random.sample(range(len(s)), k), reverse=True)\n        for p in rem_pos:\n            del s[p]\n\n    # Greedy refill by value\/time ratio within remaining capacity\n    used_time = _time(s)\n    remaining = max(0, capacity - used_time)\n    in_set = set(s)\n    candidates = [i for i in range(1, n_items+1) if i not in in_set]\n    candidates.sort(key=lambda i: (values[i-1]\/times[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        t = times[i-1]\n        if t <= remaining:\n            s.append(i)\n            remaining -= t\n            if remaining <= 0:\n                break\n\n    # Small random 1-1 exchanges to diversify\n    for _ in range(2):\n        if not s:\n            break\n        out_pos = random.randrange(len(s))\n        out_item = s[out_pos]\n        pool = [i for i in range(1, n_items+1) if i not in set(s) and i != out_item]\n        if not pool:\n            continue\n        cand = random.choice(pool[:max(1, min(5, len(pool)))])\n        s[out_pos] = cand\n        s = _repair(s)\n\n    s = _repair(s)\n    _ = _validate(s)\n    return s\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST.1-BASED.UNIQUE.INTS[1..24].Order-irrelevant; canonicalized as sorted ascending after every move.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Representation: INDEX_LIST (1-based unique indices)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    # Validate\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    zero_idx = [i - 1 for i in indices]\n    total_time = 0\n    total_value = 0\n    for i in zero_idx:\n        total_time += times[i]\n        total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 1_000_000_000.0 + float(overflow)\n    # Heuristic convention: minimize cost; use negative total value for maximization\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, \"INDEX_LIST\", move_name)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n    ratio = [values[i]\/times[i] for i in range(n_items)]\n\n    def _validate_index_list(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            idx = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(idx) != len(set(idx)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in idx):\n            raise ValueError(\"INPUT_ERROR\")\n        return idx\n\n    def _total_time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair_feasible(sol):\n        # If over capacity, iteratively drop item minimizing value loss per recovered time\n        s = list(sol)\n        cur_time = _total_time(s)\n        if cur_time <= capacity:\n            return sorted(s)\n        # precompute v and t for s\n        while s and cur_time > capacity:\n            # select removal with minimal (value \/ time) and then by value\n            worst_pos = min(range(len(s)), key=lambda k: (ratio[s[k]-1], values[s[k]-1]))\n            cur_time -= times[s[worst_pos]-1]\n            del s[worst_pos]\n        return sorted(s)\n\n    current = _validate_index_list(solution)\n    current = sorted(current)\n    cur_set = set(current)\n\n    # Decide move type\n    moves = []\n    if len(current) > 0:\n        moves.append(\"remove\")\n    if len(current) < n_items:\n        moves.append(\"add\")\n    if len(current) >= 1 and len(current) < n_items:\n        moves.append(\"replace\")\n    if len(current) >= 2:\n        moves.append(\"swap\")  # 1-1 exchange\n    move = random.choice(moves) if moves else \"add\"\n\n    new_sol = list(current)\n\n    if move == \"remove\" and new_sol:\n        pos = random.randrange(len(new_sol))\n        del new_sol[pos]\n        new_sol = sorted(new_sol)\n\n    elif move == \"add\" and len(new_sol) < n_items:\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set]\n        if candidates:\n            # biased pick within top-k by ratio\n            candidates.sort(key=lambda i: (ratio[i-1], values[i-1]), reverse=True)\n            k = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            pick = candidates[0] if random.random() < 0.8 else random.choice(candidates[:k])\n            new_sol.append(pick)\n            new_sol = _repair_feasible(new_sol)\n\n    elif move == \"replace\" and new_sol:\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (ratio[i-1], values[i-1]), reverse=True)\n            k = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:k])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        else:\n            # fallback to removal\n            del new_sol[out_pos]\n            new_sol = sorted(new_sol)\n\n    elif move == \"swap\" and len(new_sol) >= 1:\n        out_pos = random.randrange(len(new_sol))\n        out_item = new_sol[out_pos]\n        candidates = [i for i in range(1, n_items+1) if i not in cur_set and i != out_item]\n        if candidates:\n            candidates.sort(key=lambda i: (ratio[i-1], values[i-1]), reverse=True)\n            k = max(1, min(len(candidates), max(3, int(0.1*len(candidates)))))\n            in_item = candidates[0] if random.random() < 0.8 else random.choice(candidates[:k])\n            new_sol[out_pos] = in_item\n            new_sol = _repair_feasible(new_sol)\n        else:\n            new_sol = sorted(new_sol)\n\n    # Final validation and canonicalization\n    _ = _validate_index_list(new_sol)\n    new_sol = sorted(new_sol)\n    return (new_sol, \"INDEX_LIST\", move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate with greedy refill and feasibility repair; canonical output\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n_items = 24\n    ratio = [values[i]\/times[i] for i in range(n_items)]\n\n    def _validate(sol):\n        if not isinstance(sol, (list, tuple)):\n            raise ValueError(\"INPUT_ERROR\")\n        try:\n            idx = [int(x) for x in sol]\n        except Exception:\n            raise ValueError(\"INPUT_ERROR\")\n        if len(idx) != len(set(idx)):\n            raise ValueError(\"INPUT_ERROR\")\n        if any(i < 1 or i > n_items for i in idx):\n            raise ValueError(\"INPUT_ERROR\")\n        return idx\n\n    def _time(sol):\n        return sum(times[i-1] for i in sol)\n\n    def _repair(sol):\n        s = list(sol)\n        cur_t = _time(s)\n        if cur_t <= capacity:\n            return sorted(s)\n        while s and cur_t > capacity:\n            worst_pos = min(range(len(s)), key=lambda k: (ratio[s[k]-1], values[s[k]-1]))\n            cur_t -= times[s[worst_pos]-1]\n            del s[worst_pos]\n        return sorted(s)\n\n    cur = sorted(_validate(solution))\n    s = list(cur)\n\n    # Ruin: remove r items (prefer lower ratio with higher probability)\n    if s:\n        r = random.randint(2, min(6, len(s)))\n        # Weighted sample: lower ratio get higher chance to be removed\n        weights = [1.0\/(ratio[i-1] + 1e-9) for i in s]\n        total_w = sum(weights)\n        probs = [w\/total_w for w in weights]\n        # sample without replacement via roulette\n        to_remove = []\n        pool = list(range(len(s)))\n        for _ in range(r):\n            if not pool:\n                break\n            cum = 0.0\n            rnum = random.random()\n            acc = 0.0\n            for idx_pos in range(len(pool)):\n                j = pool[idx_pos]\n                acc += probs[j]\n                if acc >= rnum:\n                    to_remove.append(j)\n                    # remove selected index from pool and probs\n                    del pool[idx_pos]\n                    del probs[j]\n                    del weights[j]\n                    # renormalize\n                    tw = sum(weights) if weights else 1.0\n                    probs = [w\/tw for w in weights] if weights else []\n                    break\n        for pos in sorted(to_remove, reverse=True):\n            if 0 <= pos < len(s):\n                del s[pos]\n        s = sorted(s)\n\n    # Recreate: greedy by ratio within remaining capacity\n    used_t = _time(s)\n    remaining = max(0, capacity - used_t)\n    in_set = set(s)\n    candidates = [i for i in range(1, n_items+1) if i not in in_set]\n    candidates.sort(key=lambda i: (ratio[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        t = times[i-1]\n        if t <= remaining:\n            s.append(i)\n            remaining -= t\n            if remaining <= 0:\n                break\n\n    # Local shuffle via limited 1-1 exchanges with repair\n    for _ in range(2):\n        if not s:\n            break\n        out_pos = random.randrange(len(s))\n        out_item = s[out_pos]\n        pool = [i for i in range(1, n_items+1) if i not in set(s) and i != out_item]\n        if not pool:\n            continue\n        cand = max(pool, key=lambda i: (ratio[i-1], values[i-1])) if random.random() < 0.7 else random.choice(pool[:max(1, min(5, len(pool)))])\n        s[out_pos] = cand\n        s = _repair(s)\n\n    s = _repair(s)\n    _ = _validate(s)\n    return sorted(s)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"from typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 1000000000000000000\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Validate type and indices\n    if not isinstance(solution, list):\n        return 1000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value\n    obj = objective_function(solution)\n    # Feasibility check: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible: large penalty + deficit\n    deficit = 67 - total_weight\n    return 1000000000000 + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal data\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                s.append(x)\n                seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(weights[i] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # Greedily add items with smallest value\/weight until feasible\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Optional tightening: try to drop expensive items while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            # sort by decreasing value\/weight, then value\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67:\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    move_name = (\"noop\", \"noop\")\n\n    # Choose operator with diversification\n    r = random.random()\n    if r < 0.30:\n        # guided add (prefer low value\/weight)\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if cands:\n            cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n            k = 1 if random.random() < 0.8 else 2  # occasional multi-add\n            pick = cands[:max(1, min(k, len(cands)))]\n            s2 = s + pick\n            s2 = repair_to_feasible(s2)\n            move_name = (\"add\", \"guided-1to2\")\n            return (s2, move_name)\n    elif r < 0.60:\n        # guided remove (try to keep feasibility or repair afterward)\n        if s:\n            # remove highest value\/weight first\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            k = 1 if random.random() < 0.85 else 2  # occasional multi-remove\n            rem = order[:max(1, min(k, len(order)))]\n            s2 = [x for x in s if x not in rem]\n            if total_weight(s2) < 67:\n                s2 = repair_to_feasible(s2)\n            else:\n                # tighten if possible\n                s2 = repair_to_feasible(s2)\n            move_name = (\"remove\", \"guided-1to2\")\n            return (s2, move_name)\n    elif r < 0.85:\n        # swap: remove one, add one (guided add)\n        if s:\n            out = random.choice(s)\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if cands:\n                cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n                inn = cands[0]\n                s2 = [x for x in s if x != out] + [inn]\n                s2 = repair_to_feasible(s2)\n                move_name = (\"swap\", \"exchange-1-1\")\n                return (s2, move_name)\n    else:\n        # shake: random k modifications then repair\n        s2 = s[:]\n        k = random.randint(2, 4)\n        for _ in range(k):\n            op = random.random()\n            if op < 0.4:\n                present = set(s2)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    s2.append(random.choice(cands))\n            elif op < 0.8:\n                if s2:\n                    j = random.randrange(len(s2))\n                    s2.pop(j)\n            else:\n                if s2:\n                    present = set(s2)\n                    cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                    if cands:\n                        j = random.randrange(len(s2))\n                        s2[j] = random.choice(cands)\n        s2 = repair_to_feasible(s2)\n        move_name = (\"shake\", \"k-perturb\")\n        return (s2, move_name)\n\n    # Fallback noop -> ensure feasibility\n    s = repair_to_feasible(s)\n    return (s, move_name)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                s.append(x)\n                seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        return sum(weights[i] for i in sol)\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (values[i]\/weights[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # tighten by attempting beneficial removals\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-(values[i]\/weights[i]), -values[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67:\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        op = random.random()\n        if op < 0.4:\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if cands:\n                s.append(random.choice(cands))\n        elif op < 0.8:\n            if s:\n                j = random.randrange(len(s))\n                s.pop(j)\n        else:\n            if s:\n                present = set(s)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    j = random.randrange(len(s))\n                    s[j] = random.choice(cands)\n    s = repair_to_feasible(s)\n    return s\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"from typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    # Strict validation to match evaluator behavior\n    if not isinstance(solution, list):\n        return 1000000000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000000000\n    total = 0\n    for idx in solution:\n        total += values[idx]\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Validate type and indices\n    if not isinstance(solution, list):\n        return 1000000000000\n    if any((not isinstance(i, int)) for i in solution):\n        return 1000000000000\n    if len(solution) != len(set(solution)):\n        return 1000000000000\n    if any(i < 1 or i > 24 for i in solution):\n        return 1000000000000\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value\n    obj = objective_function(solution)\n    # Feasibility check: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible: large penalty + deficit\n    deficit = 67 - total_weight\n    return 1000000000000 + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Constants\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        tw = 0\n        for i in sol:\n            tw += weights[i]\n        return tw\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # Ensure feasibility by adding low ratio items, then tighten by removing high-value items if possible\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Tighten: try removing items with highest absolute value first while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67 and sum(values[x] for x in s_try) <= sum(values[x] for x in s):\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n\n    # Early return if empty -> construct a feasible seed greedily\n    if not s:\n        present = set()\n        cands = list(range(1, N_ITEMS+1))\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        seed = []\n        for i in cands:\n            if i not in present:\n                seed.append(i)\n                present.add(i)\n                if total_weight(seed) >= 67:\n                    break\n        seed = repair_to_feasible(seed)\n        return (seed, (\"seed\", \"greedy-low-ratio\"))\n\n    # Choose operator\n    r = random.random()\n\n    if r < 0.28:\n        # Guided add: prefer lowest ratio\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if cands:\n            cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n            k = 1 if random.random() < 0.8 else 2\n            add_list = cands[:max(1, min(k, len(cands)))]\n            s2 = s + add_list\n            s2 = repair_to_feasible(s2)\n            return (s2, (\"add\", \"guided-1to2\"))\n\n    elif r < 0.56:\n        # Guided remove: remove highest absolute value first; repair if infeasible\n        if s:\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            k = 1 if random.random() < 0.85 else 2\n            rem = set(order[:max(1, min(k, len(order)))])\n            s2 = [x for x in s if x not in rem]\n            if total_weight(s2) < 67:\n                s2 = repair_to_feasible(s2)\n            else:\n                # Try tightening even if still feasible\n                s2 = repair_to_feasible(s2)\n            return (s2, (\"remove\", \"guided-1to2\"))\n\n    elif r < 0.82:\n        # Multi-try swap: try up to T candidates, pick best improving\n        if s:\n            present = set(s)\n            out = random.choice(s)\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                pool.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n                T = min(8, len(pool))\n                best_s2 = None\n                best_val = None\n                base_val = sum(values[i] for i in s)\n                for inn in pool[:T]:\n                    cand = [x for x in s if x != out] + [inn]\n                    cand = repair_to_feasible(cand)\n                    val = sum(values[i] for i in cand)\n                    if best_val is None or val < best_val or (val == best_val and len(cand) < len(best_s2)):\n                        best_val = val\n                        best_s2 = cand\n                if best_s2 is not None and (best_val is not None and best_val <= base_val):\n                    return (best_s2, (\"swap\", \"multi-try\"))\n                else:\n                    # Fallback single swap with best ratio\n                    inn = pool[0]\n                    s2 = [x for x in s if x != out] + [inn]\n                    s2 = repair_to_feasible(s2)\n                    return (s2, (\"swap\", \"exchange-1-1\"))\n\n    else:\n        # Shake: k random edits then repair\n        s2 = s[:]\n        k = random.randint(2, 4)\n        for _ in range(k):\n            op = random.random()\n            if op < 0.4:\n                present = set(s2)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    s2.append(random.choice(cands))\n            elif op < 0.8:\n                if s2:\n                    j = random.randrange(len(s2))\n                    s2.pop(j)\n            else:\n                if s2:\n                    present = set(s2)\n                    cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                    if cands:\n                        j = random.randrange(len(s2))\n                        s2[j] = random.choice(cands)\n        s2 = repair_to_feasible(s2)\n        return (s2, (\"shake\", \"k-perturb\"))\n\n    # Fallback: ensure feasibility and return\n    s = repair_to_feasible(s)\n    return (s, (\"noop\", \"repair-only\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    N_ITEMS = 24\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        tw = 0\n        for i in sol:\n            tw += weights[i]\n        return tw\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        s = sanitize(sol)\n        if total_weight(s) >= 67:\n            return s\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= 67:\n                break\n        # Tighten: remove highest-value items while feasible and non-worsening objective\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(s, key=lambda i: (-values[i], ratios[i]))\n            for j in order:\n                s_try = [x for x in s if x != j]\n                if total_weight(s_try) >= 67 and sum(values[x] for x in s_try) <= sum(values[x] for x in s):\n                    s = s_try\n                    improved = True\n                    break\n        return s\n\n    s = sanitize(solution)\n    # Strength-controlled k-perturbation\n    k = random.randint(3, 7)\n    if not s:\n        # Build a seed if needed\n        present = set()\n        cands = list(range(1, N_ITEMS+1))\n        cands.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n        for i in cands:\n            if i not in present:\n                s.append(i)\n                present.add(i)\n                if total_weight(s) >= 67:\n                    break\n    for _ in range(k):\n        op = random.random()\n        if op < 0.33:\n            # Remove r items with highest value density to escape basin\n            if s:\n                order = sorted(s, key=lambda i: (-ratios[i], -values[i]))\n                r = 1 if random.random() < 0.7 else 2\n                for j in order[:min(r, len(order))]:\n                    if j in s:\n                        s.remove(j)\n        elif op < 0.66:\n            # Add from next-best decile by ratio\n            present = set(s)\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                pool.sort(key=lambda i: (ratios[i], values[i], -weights[i]))\n                start = max(0, len(pool)\/\/10)\n                pick = pool[start:start+max(1, len(pool)\/\/10)]\n                s.append(random.choice(pick if pick else pool))\n        else:\n            # Swap: replace one in-set with an out-of-set medium-ratio item\n            if s:\n                present = set(s)\n                out = random.choice(s)\n                pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if pool:\n                    pool.sort(key=lambda i: abs(ratios[i] - (sum(ratios[j] for j in s)\/len(s))))\n                    inn = pool[0]\n                    s = [x for x in s if x != out] + [inn]\n    s = repair_to_feasible(s)\n    return s\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    CAP = 67\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) for i in sol):\n            return False\n        if len(sol) != len(set(sol)):\n            return False\n        if any(i < 1 or i > 24 for i in sol):\n            return False\n        return True\n\n    def objective_function(sol: List[int]) -> int:\n        if not is_valid(sol):\n            return 1000000000000000000\n        total = 0\n        for idx in sol:\n            total += values[idx]\n        return total\n\n    # Validate\n    if not is_valid(solution):\n        return 1000000000000\n\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n\n    # Objective value\n    obj = objective_function(solution)\n\n    # Feasibility check: sum weights >= CAP\n    if total_weight >= CAP:\n        return obj\n\n    # Infeasible: large penalty + deficit\n    deficit = CAP - total_weight\n    return 1000000000000 + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    N_ITEMS = 24\n    CAP = 67\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def wv(sol: List[int]) -> Tuple[int,int]:\n        tw = 0\n        tv = 0\n        for i in sol:\n            tw += weights[i]\n            tv += values[i]\n        return tw, tv\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        # Make feasible by adding low ratio items; then prune by best value per released weight\n        s = sanitize(sol)\n        tw, tv = wv(s)\n        if tw < CAP:\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            # For minimizing value with weight >= CAP, prefer low ratio, then heavier, then lower value\n            cands.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n            for i in cands:\n                s.append(i)\n                tw += weights[i]\n                tv += values[i]\n                if tw >= CAP:\n                    break\n        # Prune redundant items while keeping feasibility; drop with lowest penalty per released weight\n        changed = True\n        guard = 0\n        while changed and guard < 200:\n            guard += 1\n            changed = False\n            # Sort by increasing value\/weight, then by lower value\n            order = sorted(s, key=lambda i: (values[i]\/weights[i], values[i]))\n            for j in order:\n                tw_try = tw - weights[j]\n                if tw_try >= CAP:\n                    # Removing j keeps feasibility; accept removal if it does not worsen objective (it always helps here)\n                    s.remove(j)\n                    tw = tw_try\n                    tv -= values[j]\n                    changed = True\n                    break\n        return s\n\n    s = sanitize(solution)\n\n    # If empty or infeasible, build feasible seed by low ratio greedy then prune\n    tw, _ = wv(s)\n    if not s or tw < CAP:\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        cands.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n        for i in cands:\n            s.append(i)\n            if wv(s)[0] >= CAP:\n                break\n        s = repair_to_feasible(s)\n        return (s, (\"seed\", \"greedy-low-ratio-prune\"))\n\n    r = random.random()\n\n    # Operator 1: Guided add (low ratio 1-2 adds), then prune\n    if r < 0.25:\n        present = set(s)\n        cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if cands:\n            cands.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n            k = 1 if random.random() < 0.8 else 2\n            add_list = cands[:max(1, min(k, len(cands)))]\n            s2 = s + add_list\n            s2 = repair_to_feasible(s2)\n            return (s2, (\"add\", \"guided-1to2\"))\n\n    # Operator 2: Guided remove (drop lowest penalty per released weight), then repair\n    if r < 0.5:\n        if s:\n            order = sorted(s, key=lambda i: (values[i]\/weights[i], values[i]))\n            k = 1 if random.random() < 0.85 else 2\n            rem = set(order[:max(1, min(k, len(order)))])\n            s2 = [x for x in s if x not in rem]\n            if wv(s2)[0] < CAP:\n                s2 = repair_to_feasible(s2)\n            else:\n                s2 = repair_to_feasible(s2)\n            return (s2, (\"remove\", \"guided-1to2\"))\n\n    # Operator 3: Targeted 1-1 swap using top-m outs and top-n ins\n    if r < 0.75:\n        if s:\n            present = set(s)\n            outs = sorted(s, key=lambda i: (-ratios[i], -values[i]))[:min(3, len(s))]\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                ins = sorted(pool, key=lambda i: (ratios[i], -weights[i], values[i]))[:min(6, len(pool))]\n                best_s2 = None\n                best_val = None\n                base_val = sum(values[i] for i in s)\n                for o in outs:\n                    for inn in ins:\n                        cand = [x for x in s if x != o] + [inn]\n                        cand = repair_to_feasible(cand)\n                        val = sum(values[i] for i in cand)\n                        if (best_val is None) or (val < best_val) or (val == best_val and len(cand) < len(best_s2)):\n                            best_val = val\n                            best_s2 = cand\n                if best_s2 is not None and (best_val is not None):\n                    return (best_s2, (\"swap\", \"targeted-1-1\"))\n\n    # Operator 4: 2-for-1 or 1-for-2 k-exchange\n    if r < 0.9:\n        present = set(s)\n        pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n        if len(s) >= 2 and pool:\n            o1, o2 = random.sample(s, 2)\n            inn = min(pool, key=lambda i: (ratios[i], -weights[i], values[i]))\n            cand = [x for x in s if x not in (o1, o2)] + [inn]\n            cand = repair_to_feasible(cand)\n            return (cand, (\"k-exchange\", \"2-1\"))\n        if s and len(pool) >= 2:\n            o = random.choice(s)\n            inn_list = sorted(pool, key=lambda i: (ratios[i], -weights[i], values[i]))[:2]\n            cand = [x for x in s if x != o] + inn_list\n            cand = repair_to_feasible(cand)\n            return (cand, (\"k-exchange\", \"1-2\"))\n\n    # Operator 5: Shake with adaptive k, then repair\n    k = random.randint(3, 6)\n    s2 = s[:]\n    for _ in range(k):\n        op = random.random()\n        if op < 0.4:\n            present = set(s2)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if cands:\n                s2.append(random.choice(cands))\n        elif op < 0.8:\n            if s2:\n                j = random.randrange(len(s2))\n                s2.pop(j)\n        else:\n            if s2:\n                present = set(s2)\n                cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if cands:\n                    j = random.randrange(len(s2))\n                    s2[j] = random.choice(cands)\n    s2 = repair_to_feasible(s2)\n    return (s2, (\"shake\", \"k-perturb\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    N_ITEMS = 24\n    CAP = 67\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8, 18, 8, 9]\n    ratios  = [0.0] + [values[i]\/weights[i] for i in range(1, N_ITEMS+1)]\n\n    def sanitize(sol: List[int]) -> List[int]:\n        s = []\n        seen = set()\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= N_ITEMS and x not in seen:\n                    s.append(x)\n                    seen.add(x)\n        return s\n\n    def total_weight(sol: List[int]) -> int:\n        tw = 0\n        for i in sol:\n            tw += weights[i]\n        return tw\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        s = sanitize(sol)\n        tw = total_weight(s)\n        if tw < CAP:\n            present = set(s)\n            cands = [i for i in range(1, N_ITEMS+1) if i not in present]\n            cands.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n            for i in cands:\n                s.append(i)\n                tw += weights[i]\n                if tw >= CAP:\n                    break\n        # Prune redundant items\n        changed = True\n        guard = 0\n        while changed and guard < 200:\n            guard += 1\n            changed = False\n            order = sorted(s, key=lambda i: (values[i]\/weights[i], values[i]))\n            for j in order:\n                if tw - weights[j] >= CAP:\n                    s.remove(j)\n                    tw -= weights[j]\n                    changed = True\n                    break\n        return s\n\n    s = sanitize(solution)\n\n    # If empty, build a seed\n    if not s:\n        present = set()\n        cands = list(range(1, N_ITEMS+1))\n        cands.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n        for i in cands:\n            s.append(i)\n            if total_weight(s) >= CAP:\n                break\n        s = repair_to_feasible(s)\n        return s\n\n    # Strength-controlled multi-edit\n    k = random.randint(3, 7)\n    for _ in range(k):\n        op = random.random()\n        if op < 0.33:\n            if s:\n                order = sorted(s, key=lambda i: (-ratios[i], -values[i]))\n                r = 1 if random.random() < 0.7 else 2\n                for j in order[:min(r, len(order))]:\n                    if j in s:\n                        s.remove(j)\n        elif op < 0.66:\n            present = set(s)\n            pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n            if pool:\n                pool.sort(key=lambda i: (ratios[i], -weights[i], values[i]))\n                start = max(0, len(pool)\/\/10)\n                segment = pool[start:start+max(1, len(pool)\/\/10)]\n                pick_from = segment if segment else pool\n                s.append(random.choice(pick_from))\n        else:\n            if s:\n                present = set(s)\n                out = random.choice(s)\n                pool = [i for i in range(1, N_ITEMS+1) if i not in present]\n                if pool:\n                    target = sum(ratios[j] for j in s)\/len(s)\n                    inn = min(pool, key=lambda i: abs(ratios[i] - target))\n                    s = [x for x in s if x != out] + [inn]\n    s = repair_to_feasible(s)\n    return s\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 10**18\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    if not isinstance(solution, list):\n        return 10**12\n    if any((not isinstance(i, int)) for i in solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(i < 1 or i > 24 for i in solution):\n        return 10**12\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    obj = objective_function(solution)\n    if total_weight >= 67:\n        return obj\n    deficit = 67 - total_weight\n    return 10**12 + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    n_items = 24\n    sol_set = set()\n    current = []\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in sol_set:\n                sol_set.add(i)\n                current.append(i)\n    if not current:\n        move_type = \"Add\"\n    elif len(current) >= n_items:\n        move_type = \"Remove\"\n    else:\n        move_type = random.choice([\"Add\", \"Remove\", \"Swap\", \"1-Flip\"])  # richer neighborhood\n    new_sol = current.copy()\n    nb_type = move_type\n    movement = \"\"\n    if move_type == \"Add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in sol_set]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n        movement = \"insert_one_index\"\n    elif move_type == \"Remove\":\n        if new_sol:\n            j = random.choice(new_sol)\n            new_sol.remove(j)\n        movement = \"delete_one_index\"\n    elif move_type == \"Swap\":\n        if new_sol and len(new_sol) < n_items:\n            out_idx = random.choice(new_sol)\n            excluded = [i for i in range(1, n_items + 1) if i not in sol_set]\n            if excluded:\n                in_idx = random.choice(excluded)\n                new_sol.remove(out_idx)\n                new_sol.append(in_idx)\n        movement = \"swap_out_in\"\n    else:  # 1-Flip toggle\n        j = random.randint(1, n_items)\n        if j in new_sol:\n            new_sol.remove(j)\n            movement = \"flip_off\"\n        else:\n            new_sol.append(j)\n            movement = \"flip_on\"\n    # ensure uniqueness and valid indices\n    filtered = []\n    seen = set()\n    for i in new_sol:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n            filtered.append(i)\n            seen.add(i)\n    return filtered, nb_type, movement\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    # sanitize input\n    base = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n                base.append(i)\n                seen.add(i)\n    new_sol = set(base)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.choice([\"flip\", \"add\", \"remove\"])\n        if move == \"flip\":\n            j = random.randint(1, n_items)\n            if j in new_sol:\n                new_sol.remove(j)\n            else:\n                new_sol.add(j)\n        elif move == \"add\":\n            excluded = [i for i in range(1, n_items + 1) if i not in new_sol]\n            if excluded:\n                new_sol.add(random.choice(excluded))\n        else:  # remove\n            included = list(new_sol)\n            if included:\n                new_sol.remove(random.choice(included))\n    return sorted(new_sol)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1. Example: [5,7,9,13]","Evaluacion":"import random\nimport math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [0,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    if not isinstance(solution, list):\n        return 10**18\n    total = 0\n    seen = set()\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n            total += values[idx]\n            seen.add(idx)\n    return total\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    if any((not isinstance(i, int)) for i in solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(i < 1 or i > 24 for i in solution):\n        return 10**12\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n    # Objective value (minimize)\n    obj = objective_function(solution)\n    # Feasibility: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n    # Infeasible penalty with deficit\n    deficit = 67 - total_weight\n    return 10**12 + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    n_items = 24\n    # sanitize and ensure uniqueness and domain\n    sol_set = set()\n    current = []\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in sol_set:\n                sol_set.add(i)\n                current.append(i)\n    # choose move type\n    if not current:\n        move_type = \"Add\"\n    elif len(current) >= n_items:\n        move_type = \"Remove\"\n    else:\n        move_type = random.choice([\"Add\", \"Remove\", \"Swap\", \"1-Flip\"])  # diversified neighborhood\n    new_sol = current.copy()\n    nb_type = move_type\n    movement = \"\"\n    if move_type == \"Add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in sol_set]\n        if candidates:\n            j = random.choice(candidates)\n            new_sol.append(j)\n        movement = \"insert_one_index\"\n    elif move_type == \"Remove\":\n        if new_sol:\n            j = random.choice(new_sol)\n            new_sol.remove(j)\n        movement = \"delete_one_index\"\n    elif move_type == \"Swap\":\n        if new_sol and len(new_sol) < n_items:\n            out_idx = random.choice(new_sol)\n            excluded = [i for i in range(1, n_items + 1) if i not in sol_set]\n            if excluded:\n                in_idx = random.choice(excluded)\n                new_sol.remove(out_idx)\n                new_sol.append(in_idx)\n        movement = \"swap_out_in\"\n    else:  # 1-Flip toggle\n        j = random.randint(1, n_items)\n        if j in new_sol:\n            new_sol.remove(j)\n            movement = \"flip_off\"\n        else:\n            new_sol.append(j)\n            movement = \"flip_on\"\n    # ensure uniqueness and valid indices\n    filtered = []\n    seen = set()\n    for i in new_sol:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n            filtered.append(i)\n            seen.add(i)\n    return filtered, nb_type, movement\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    # sanitize base solution\n    base = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in seen:\n                base.append(i)\n                seen.add(i)\n    new_set = set(base)\n\n    # random k-perturbation\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.choice([\"flip\", \"add\", \"remove\"])\n        if move == \"flip\":\n            j = random.randint(1, n_items)\n            if j in new_set:\n                new_set.remove(j)\n            else:\n                new_set.add(j)\n        elif move == \"add\":\n            excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n            if excluded:\n                new_set.add(random.choice(excluded))\n        else:  # remove\n            included = list(new_set)\n            if included:\n                new_set.remove(random.choice(included))\n\n    # feasibility repair: ensure sum(weights) >= 67 by greedy additions with low value\/weight\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8,18, 8, 9]\n\n    def total_weight(idx_set):\n        return sum(weights[i] for i in idx_set)\n\n    # add items with best value\/weight until feasible\n    if total_weight(new_set) < 67:\n        candidates = [(i, values[i]\/weights[i]) for i in range(1, n_items+1) if i not in new_set]\n        candidates.sort(key=lambda x: (x[1], values[x[0]]))  # prioritize low ratio, then low value\n        cw = total_weight(new_set)\n        for i, _ in candidates:\n            if cw >= 67:\n                break\n            new_set.add(i)\n            cw += weights[i]\n\n    # final sanitize and return as list (unsorted to allow diversity)\n    result = []\n    seen2 = set()\n    for i in new_set:\n        if isinstance(i, int) and 1 <= i <= n_items and i not in seen2:\n            result.append(i)\n            seen2.add(i)\n    return result\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST: solution is a list of unique integers in [1,24], where each integer i indicates x_i=1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    PENALTY = 10**12\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values =  [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8,18, 8, 9]\n\n    def objective_function(sol: List[int]) -> int:\n        if not isinstance(sol, list):\n            return PENALTY\n        total = 0\n        seen = set()\n        for idx in sol:\n            if isinstance(idx, int) and 1 <= idx <= 24 and idx not in seen:\n                total += values[idx]\n                seen.add(idx)\n        return total\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return PENALTY\n    if any((not isinstance(i, int)) for i in solution):\n        return PENALTY\n    if len(solution) != len(set(solution)):\n        return PENALTY\n    if any(i < 1 or i > 24 for i in solution):\n        return PENALTY\n\n    # Compute total weight\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i]\n\n    # Objective value (minimization)\n    obj = objective_function(solution)\n\n    # Feasibility: sum weights >= 67\n    if total_weight >= 67:\n        return obj\n\n    # Infeasible penalty with deficit\n    deficit = 67 - total_weight\n    return PENALTY + deficit\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Constants\n    n_items = 24\n    W_REQ = 67\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8,18, 8, 9]\n\n    # Sanitize input to unique, valid indices\n    sol_set = set()\n    current: List[int] = []\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items and i not in sol_set:\n                sol_set.add(i)\n                current.append(i)\n\n    # Helper: compute weight and slack\n    cur_weight = sum(weights[i] for i in sol_set)\n    slack = cur_weight - W_REQ  # >=0 if feasible\n\n    # Choose neighborhood depending on feasibility\n    nb_type = \"\"\n    movement = \"\"\n    new_set = set(sol_set)\n\n    # Utility: ratio for sorting\n    def ratio(i: int) -> float:\n        return values[i] \/ weights[i]\n\n    if cur_weight < W_REQ:\n        # Infeasible: prefer Add\/Flip-on of lowest ratio items\n        nb_type = \"Feasibility-Repair\"\n        candidates = [i for i in range(1, n_items + 1) if i not in new_set]\n        if candidates:\n            # pick one with lowest value\/weight ratio (and low absolute value tie-break)\n            candidates.sort(key=lambda i: (ratio(i), values[i]))\n            j = random.choice(candidates[:max(1, min(5, len(candidates)))])\n            new_set.add(j)\n            movement = f\"add_{j}\"\n        else:\n            movement = \"noop\"\n    else:\n        # Feasible: choose among Remove (if safe), 1-1 Swap, Drop-worst\n        move_choice = random.random()\n        if move_choice < 0.34 and new_set:\n            # Safe Remove: remove an item only if feasibility kept\n            nb_type = \"Remove\"\n            removable = [i for i in new_set if slack >= weights[i]]\n            if removable:\n                # remove the worst ratio (highest value\/weight)\n                i_out = max(removable, key=ratio)\n                new_set.remove(i_out)\n                movement = f\"remove_{i_out}\"\n            else:\n                movement = \"no_safe_remove\"\n        elif move_choice < 0.68:\n            # 1-1 Swap: swap out higher ratio for lower ratio while keeping feasibility\n            nb_type = \"Swap1-1\"\n            if new_set and len(new_set) < n_items:\n                i_out = max(new_set, key=ratio)  # candidate to remove\n                excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n                if excluded:\n                    # try a few best candidates to add\n                    excluded.sort(key=lambda i: (ratio(i), values[i]))\n                    i_in = random.choice(excluded[:max(1, min(5, len(excluded)))])\n                    # Check feasibility: cur_weight - w_out + w_in >= W_REQ\n                    if cur_weight - weights[i_out] + weights[i_in] >= W_REQ:\n                        new_set.remove(i_out)\n                        new_set.add(i_in)\n                        movement = f\"swap_out_{i_out}_in_{i_in}\"\n                    else:\n                        movement = \"swap_infeasible\"\n                else:\n                    movement = \"no_excluded\"\n            else:\n                movement = \"swap_unavailable\"\n        else:\n            # Drop-worst if safe, else small add of good item\n            if new_set:\n                worst = max(new_set, key=ratio)\n                if slack >= weights[worst]:\n                    nb_type = \"DropWorst\"\n                    new_set.remove(worst)\n                    movement = f\"drop_{worst}\"\n                else:\n                    nb_type = \"Improve-Add\"\n                    excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n                    if excluded:\n                        excluded.sort(key=lambda i: (ratio(i), values[i]))\n                        i_in = random.choice(excluded[:max(1, min(5, len(excluded)))])\n                        new_set.add(i_in)\n                        movement = f\"add_{i_in}\"\n                    else:\n                        movement = \"noop\"\n            else:\n                nb_type = \"Improve-Add\"\n                i_in = random.randint(1, n_items)\n                new_set.add(i_in)\n                movement = f\"add_{i_in}\"\n\n    # Return as list with stable order (sorted for determinism within this step)\n    new_solution = sorted(new_set)\n    return new_solution, nb_type, movement\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n_items = 24\n    W_REQ = 67\n    weights = [0,11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [0,19,21,22,13, 1, 9, 7,10, 4,11,11,12, 6,15,17, 8,13,11,24,10, 8,18, 8, 9]\n\n    # Sanitize base\n    base_set = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n_items:\n                base_set.add(i)\n\n    # Helper\n    def ratio(i: int) -> float:\n        return values[i] \/ weights[i]\n\n    new_set = set(base_set)\n\n    # k-perturbation with biased 1-1 exchanges and flips\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.5 and new_set and len(new_set) < n_items:\n            # 1-1 exchange: remove a high-ratio item, add a low-ratio item\n            i_out = max(new_set, key=ratio)\n            excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n            if excluded:\n                excluded.sort(key=lambda i: (ratio(i), values[i]))\n                i_in = random.choice(excluded[:max(1, min(5, len(excluded)))])\n                new_set.remove(i_out)\n                new_set.add(i_in)\n        elif move < 0.75:\n            # flip random index\n            j = random.randint(1, n_items)\n            if j in new_set:\n                new_set.remove(j)\n            else:\n                new_set.add(j)\n        else:\n            # add a good item or remove a bad one\n            if random.random() < 0.5 and len(new_set) < n_items:\n                excluded = [i for i in range(1, n_items + 1) if i not in new_set]\n                if excluded:\n                    excluded.sort(key=lambda i: (ratio(i), values[i]))\n                    new_set.add(excluded[0])\n            elif new_set:\n                worst = max(new_set, key=ratio)\n                if worst in new_set:\n                    new_set.remove(worst)\n\n    # Greedy feasibility repair: ensure sum(weights) >= W_REQ with low ratio additions\n    def total_weight(s):\n        return sum(weights[i] for i in s)\n\n    if total_weight(new_set) < W_REQ:\n        candidates = [i for i in range(1, n_items + 1) if i not in new_set]\n        candidates.sort(key=lambda i: (values[i] \/ weights[i], values[i]))\n        cw = total_weight(new_set)\n        for i in candidates:\n            if cw >= W_REQ:\n                break\n            new_set.add(i)\n            cw += weights[i]\n\n    # Return as list (sorted for determinism)\n    return sorted(new_set)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value\n","Vecindad":"import random\nimport math\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbour move; returns (representation_type, movement_type)\n    # Representation: INDEX_LIST (list of distinct 1-based indices)\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n\n    n = 24\n\n    def sanitize(sol):\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        # Ensure feasibility (weight >= 67) with minimal added cost, then trim redundant costly items\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        # Feasibility repair: add cheapest value\/weight absent items until weight >= 67\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n+1) if i not in sol]\n            # sort by ratio then by absolute value\n            absent.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                sol.append(absent[j])\n                tw += weights[absent[j]-1]\n                tv += values[absent[j]-1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        # Trimming: try removing items that keep feasibility, preferring removal of high value\/weight\n        if tw >= 67 and len(sol) > 0:\n            # sort indices in solution by decreasing value\/weight, then by value\n            cand = sorted(sol, key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n            changed = True\n            while changed:\n                changed = False\n                for i in list(cand):\n                    wi = weights[i-1]\n                    vi = values[i-1]\n                    if tw - wi >= 67:\n                        # remove i\n                        try:\n                            sol.remove(i)\n                        except ValueError:\n                            continue\n                        tw -= wi\n                        tv -= vi\n                        changed = True\n                        # update candidate list\n                        cand = sorted(sol, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)\n                        break\n        sanitize(sol)\n\n    # sanitize before move\n    sanitize(solution)\n\n    # choose a move\n    move_types = []\n    if len(solution) > 0:\n        move_types.append(\"remove\")\n    if len(solution) < n:\n        move_types.append(\"add\")\n    if 0 < len(solution) < n:\n        move_types.append(\"swap\")\n    if not move_types:\n        return (\"INDEX_LIST\", \"no-op\")\n\n    move = random.choice(move_types)\n\n    if move == \"remove\" and len(solution) > 0:\n        ridx = random.randrange(len(solution))\n        del solution[ridx]\n    elif move == \"add\" and len(solution) < n:\n        available = [i for i in range(1, n+1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution)+1)\n            solution.insert(pos, new_item)\n        else:\n            move = \"no-op\"\n    elif move == \"swap\" and 0 < len(solution) < n:\n        ridx = random.randrange(len(solution))\n        removed = solution.pop(ridx)\n        available = [i for i in range(1, n+1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution)+1)\n            solution.insert(pos, new_item)\n        else:\n            solution.insert(ridx, removed)\n            move = \"no-op\"\n    else:\n        move = \"no-op\"\n\n    # Repair and trim to improve feasibility and cost\n    repair_feasible_and_trim(solution)\n\n    return (\"INDEX_LIST\", move)\n","Perturbacion":"import random\nimport math\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random edits followed by feasibility repair and trimming\n    if not isinstance(solution, list):\n        return\n\n    n = 24\n\n    def sanitize(sol):\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n+1) if i not in sol]\n            absent.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                sol.append(absent[j])\n                tw += weights[absent[j]-1]\n                tv += values[absent[j]-1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            cand = sorted(sol, key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n            changed = True\n            while changed:\n                changed = False\n                for i in list(cand):\n                    wi = weights[i-1]\n                    if tw - wi >= 67:\n                        try:\n                            sol.remove(i)\n                        except ValueError:\n                            continue\n                        tw -= wi\n                        changed = True\n                        cand = sorted(sol, key=lambda k: (values[k-1]\/weights[k-1], values[k-1]), reverse=True)\n                        break\n        sanitize(sol)\n\n    sanitize(solution)\n\n    # number of random edits\n    k = max(3, len(solution) \/\/ 2)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34 and len(solution) > 0:\n            # remove\n            del solution[random.randrange(len(solution))]\n        elif r < 0.67 and len(solution) < n:\n            # add\n            available = [i for i in range(1, n+1) if i not in solution]\n            if available:\n                solution.insert(random.randrange(len(solution)+1), random.choice(available))\n        else:\n            # swap\n            if 0 < len(solution) < n:\n                ridx = random.randrange(len(solution))\n                removed = solution.pop(ridx)\n                available = [i for i in range(1, n+1) if i not in solution]\n                if available:\n                    solution.insert(random.randrange(len(solution)+1), random.choice(available))\n                else:\n                    solution.insert(ridx, removed)\n    repair_feasible_and_trim(solution)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor move; returns (representation_type, movement_type)\n    # Representation: INDEX_LIST (list of distinct 1-based indices)\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        # Ensure feasibility (weight >= 67) and attempt local trimming to reduce value\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n + 1) if i not in sol]\n            # Prefer lower value-per-weight, then higher weight, then lower value\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                i = absent[j]\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            # Single pass trimming: try removing items with worst value-per-weight first\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in list(order):\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67 and i in sol:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n\n    sanitize(solution)\n\n    # Choose a move type\n    candidates = []\n    if len(solution) > 0:\n        candidates.append(\"remove\")\n    if len(solution) < n:\n        candidates.append(\"add\")\n    if 0 < len(solution) < n:\n        candidates.append(\"swap\")\n    if not candidates:\n        return (\"INDEX_LIST\", \"no-op\")\n\n    move = random.choice(candidates)\n\n    if move == \"remove\" and len(solution) > 0:\n        ridx = random.randrange(len(solution))\n        del solution[ridx]\n    elif move == \"add\" and len(solution) < n:\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            move = \"no-op\"\n    elif move == \"swap\" and 0 < len(solution) < n:\n        ridx = random.randrange(len(solution))\n        removed = solution.pop(ridx)\n        available = [i for i in range(1, n + 1) if i not in solution]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            solution.insert(ridx, removed)\n            move = \"no-op\"\n    else:\n        move = \"no-op\"\n\n    repair_feasible_and_trim(solution)\n\n    return (\"INDEX_LIST\", move)","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random edits followed by feasibility repair and trimming\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        sol[:] = sorted(set([x for x in sol if isinstance(x, int) and 1 <= x <= n]))\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            absent = [i for i in range(1, n + 1) if i not in sol]\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            j = 0\n            while tw < 67 and j < len(absent):\n                i = absent[j]\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n                j += 1\n            sol[:] = sorted(set(sol))\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in list(order):\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67 and i in sol:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return\n\n    sanitize(solution)\n\n    k = max(3, max(1, len(solution)) \/\/ 2)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34 and len(solution) > 0:\n            del solution[random.randrange(len(solution))]\n        elif r < 0.67 and len(solution) < n:\n            available = [i for i in range(1, n + 1) if i not in solution]\n            if available:\n                solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n        else:\n            if 0 < len(solution) < n:\n                ridx = random.randrange(len(solution))\n                removed = solution.pop(ridx)\n                available = [i for i in range(1, n + 1) if i not in solution]\n                if available:\n                    solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n                else:\n                    solution.insert(ridx, removed)\n\n    repair_feasible_and_trim(solution)","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"INDEX_LIST (list[int], 1-based distinct indices of items to include)","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect: solution is a list of distinct 1-based indices in 1..24\n    # Returns: objective value if feasible, else +inf. Objective is total value (minimize)\n    if not isinstance(solution, list):\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int):\n            return float('inf')\n    n = 24\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(x < 1 or x > n for x in solution):\n        return float('inf')\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n    if total_weight < 67:\n        return float('inf')\n    return total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor move; returns (representation_type, movement_type)\n    # Representation: INDEX_LIST (list of distinct 1-based indices)\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        # Keep only valid ints in range and unique\n        filtered = []\n        seen = [False]*(n+1)\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and not seen[x]:\n                filtered.append(x)\n                seen[x] = True\n        sol[:] = filtered\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        # Ensure feasibility (weight >= 67) and attempt local trimming to reduce value\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            # Greedy additions prioritizing low value per weight, then higher weight, then lower value\n            present = [False]*(n+1)\n            for i in sol:\n                present[i] = True\n            absent = [i for i in range(1, n + 1) if not present[i]]\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            for i in absent:\n                if tw >= 67:\n                    break\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n            sanitize(sol)\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            # Single-pass trimming: remove worst value-per-weight first if feasibility kept\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in order:\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return (\"INDEX_LIST\", \"no-op\")\n\n    sanitize(solution)\n\n    # Choose a move type\n    candidates = []\n    if len(solution) > 0:\n        candidates.append(\"remove\")\n    if len(solution) < n:\n        candidates.append(\"add\")\n    if 0 < len(solution) < n:\n        candidates.append(\"swap\")\n    if not candidates:\n        return (\"INDEX_LIST\", \"no-op\")\n\n    move = random.choice(candidates)\n\n    if move == \"remove\" and len(solution) > 0:\n        ridx = random.randrange(len(solution))\n        del solution[ridx]\n    elif move == \"add\" and len(solution) < n:\n        present = [False]*(n+1)\n        for i in solution:\n            present[i] = True\n        available = [i for i in range(1, n + 1) if not present[i]]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            move = \"no-op\"\n    elif move == \"swap\" and 0 < len(solution) < n:\n        ridx = random.randrange(len(solution))\n        removed = solution.pop(ridx)\n        present = [False]*(n+1)\n        for i in solution:\n            present[i] = True\n        available = [i for i in range(1, n + 1) if not present[i]]\n        if available:\n            new_item = random.choice(available)\n            pos = random.randrange(len(solution) + 1)\n            solution.insert(pos, new_item)\n        else:\n            solution.insert(ridx, removed)\n            move = \"no-op\"\n    else:\n        move = \"no-op\"\n\n    repair_feasible_and_trim(solution)\n\n    return (\"INDEX_LIST\", move)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random edits followed by feasibility repair and trimming\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return\n        filtered = []\n        seen = [False]*(n+1)\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and not seen[x]:\n                filtered.append(x)\n                seen[x] = True\n        sol[:] = filtered\n\n    def totals(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw = 0\n        tv = 0\n        for i in sol:\n            idx = i - 1\n            tw += weights[idx]\n            tv += values[idx]\n        return tw, tv\n\n    def repair_feasible_and_trim(sol):\n        weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n        values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        tw, tv = totals(sol)\n        if tw < 67:\n            present = [False]*(n+1)\n            for i in sol:\n                present[i] = True\n            absent = [i for i in range(1, n + 1) if not present[i]]\n            absent.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n            for i in absent:\n                if tw >= 67:\n                    break\n                sol.append(i)\n                tw += weights[i - 1]\n                tv += values[i - 1]\n            sanitize(sol)\n            tw, tv = totals(sol)\n        if tw >= 67 and len(sol) > 0:\n            order = sorted(sol, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n            for i in order:\n                wi = weights[i - 1]\n                vi = values[i - 1]\n                if tw - wi >= 67:\n                    sol.remove(i)\n                    tw -= wi\n                    tv -= vi\n        sanitize(sol)\n\n    if not isinstance(solution, list):\n        return\n\n    sanitize(solution)\n\n    k = max(3, max(1, len(solution)) \/\/ 2)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.34 and len(solution) > 0:\n            del solution[random.randrange(len(solution))]\n        elif r < 0.67 and len(solution) < n:\n            present = [False]*(n+1)\n            for i in solution:\n                present[i] = True\n            available = [i for i in range(1, n + 1) if not present[i]]\n            if available:\n                solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n        else:\n            if 0 < len(solution) < n:\n                ridx = random.randrange(len(solution))\n                removed = solution.pop(ridx)\n                present = [False]*(n+1)\n                for i in solution:\n                    present[i] = True\n                available = [i for i in range(1, n + 1) if not present[i]]\n                if available:\n                    solution.insert(random.randrange(len(solution) + 1), random.choice(available))\n                else:\n                    solution.insert(ridx, removed)\n\n    repair_feasible_and_trim(solution)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices of selected decorations\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                clean.append(x)\n                seen.add(x)\n        return clean\n\n    def compute_cost_points(sol):\n        c = 0\n        p = 0\n        sset = set(sol)\n        for i in sset:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        # Ensure feasibility: cost >= 670 with minimal point increase; then prune redundant high-ratio items\n        sol = validize(sol)\n        c, p = compute_cost_points(sol)\n        ratio = [(i, points[i-1] \/ costs[i-1]) for i in range(1, n+1)]\n        if c < 670:\n            # add by ascending ratio until feasible\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            k = 0\n            while c < 670 and k < len(available):\n                i = available[k]\n                sol.append(i)\n                c += costs[i-1]\n                p += points[i-1]\n                k += 1\n        # prune: remove highest ratio items while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            # sort current items by descending ratio, then by points to try remove expensive-point items first\n            cur = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1], costs[i-1]))\n            for i in cur:\n                if c - costs[i-1] >= 670:\n                    sol.remove(i)\n                    c -= costs[i-1]\n                    p -= points[i-1]\n                    improved = True\n                    break\n        return sol\n\n    sol = validize(solution)\n    if len(sol) == 0:\n        # initialize by adding a low ratio item\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n        sol = [candidates[0]]\n        return (repair(sol), \"INIT_ADD\")\n\n    move_r = random.random()\n    movement = \"ADD\"\n    if move_r < 0.4:\n        # ADD low-ratio not-included\n        available = [i for i in range(1, n+1) if i not in sol]\n        if available:\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n            add = random.choice(available[:max(1, min(5, len(available)))])\n            new_sol = sol + [add]\n            movement = \"ADD\"\n        else:\n            # fallback to remove\n            rem = random.choice(sol)\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n    elif move_r < 0.75:\n        # REMOVE high-ratio included\n        rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n        rem = rem_candidates[0]\n        new_sol = [x for x in sol if x != rem]\n        movement = \"REMOVE\"\n    else:\n        # SWAP: remove a higher-ratio in, add a lower-ratio out\n        if len(sol) < n:\n            rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n            rem = rem_candidates[0]\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n            add = available[0]\n            new_sol = [x for x in sol if x != rem] + [add]\n            movement = \"SWAP\"\n        else:\n            rem = random.choice(sol)\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n\n    repaired = repair(new_sol)\n    return (repaired, movement if repaired == validize(new_sol) else \"REPAIR\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                clean.append(x)\n                seen.add(x)\n        return clean\n\n    def compute_cost_points(sol):\n        c = 0\n        p = 0\n        sset = set(sol)\n        for i in sset:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        sol = validize(sol)\n        c, p = compute_cost_points(sol)\n        if c < 670:\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            k = 0\n            while c < 670 and k < len(available):\n                i = available[k]\n                sol.append(i)\n                c += costs[i-1]\n                p += points[i-1]\n                k += 1\n        improved = True\n        while improved:\n            improved = False\n            cur = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1], costs[i-1]))\n            for i in cur:\n                if c - costs[i-1] >= 670:\n                    sol.remove(i)\n                    c -= costs[i-1]\n                    p -= points[i-1]\n                    improved = True\n                    break\n        return sol\n\n    sol = validize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        action = random.random()\n        if action < 0.33:\n            # ADD low ratio\n            available = [i for i in range(1, n+1) if i not in sol]\n            if available:\n                available.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                choice_pool = available[:max(1, min(5, len(available)))]\n                sol.append(random.choice(choice_pool))\n        elif action < 0.66 and sol:\n            # REMOVE high ratio\n            rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n            sol = [x for x in sol if x != rem_candidates[0]]\n        else:\n            # SWAP high-out, low-in\n            if sol and len(sol) < n:\n                rem_candidates = sorted(sol, key=lambda i: (-(points[i-1]\/costs[i-1]), -points[i-1]))\n                available = [i for i in range(1, n+1) if i not in sol]\n                available.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                if available:\n                    rem = rem_candidates[0]\n                    add = available[0]\n                    sol = [x for x in sol if x != rem] + [add]\n    return repair(sol)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices of selected items\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    # Type and feasibility checks\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    # Feasibility: spend at least 670\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    # Moderate penalty to preserve gradient among infeasible solutions\n    return 1e6 + float(shortfall)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_type_string)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def try_prune(sol):\n        # Greedily remove items while keeping feasibility, prioritizing max point drop then surplus drop\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        changed = True\n        while changed:\n            changed = False\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]  # removal reduces points by this amount\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                c -= costs[best_i-1]\n                p -= points[best_i-1]\n                changed = True\n        return sol\n\n    def repair(sol):\n        # Ensure feasibility (cost >= 670) with minimal expected point increase; then prune\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            # Rank by low points-per-cost; sample from top-L for diversification\n            L = 5\n            available = [i for i in range(1, n+1) if i not in sol]\n            available.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1], costs[i-1]))\n            idx = 0\n            while c < 670 and available:\n                pool = available[:min(L, len(available))]\n                add = random.choice(pool)\n                sol.append(add)\n                c += costs[add-1]\n                p += points[add-1]\n                available.remove(add)\n        # Prune to reduce points and surplus lexicographically\n        sol = try_prune(sol)\n        return sol\n\n    sol = validize(solution)\n    # Start from a minimal seed if empty\n    if not sol:\n        # pick the single item with best cost gain per point (low p\/c), then repair\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1], costs[i-1]))\n        init = [candidates[0]]\n        return (repair(init), \"INIT_ADD\")\n\n    # Movement selection: ADD, REMOVE, SWAP(1-1), SWAP(1-2)\n    r = random.random()\n    movement = \"ADD\"\n    new_sol = sol[:]\n\n    if r < 0.3:\n        # ADD: add low p\/c item not in solution\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            k = min(6, len(avail))\n            add = random.choice(avail[:k])\n            new_sol = sol + [add]\n            movement = \"ADD\"\n        else:\n            movement = \"NOOP\"\n    elif r < 0.55 and sol:\n        # REMOVE: remove item with highest points (to try reduce objective)\n        rem = max(sol, key=lambda i: points[i-1])\n        new_sol = [x for x in sol if x != rem]\n        movement = \"REMOVE\"\n    elif r < 0.8 and sol:\n        # SWAP 1-1: remove high-point item, add low p\/c not in\n        rem = max(sol, key=lambda i: points[i-1])\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            add = random.choice(avail[:min(6, len(avail))])\n            new_sol = [x for x in sol if x != rem] + [add]\n            movement = \"SWAP_1_1\"\n        else:\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n    else:\n        # SWAP 1-2: remove one (highest points), add two low p\/c distinct\n        rem = max(sol, key=lambda i: points[i-1]) if sol else None\n        avail = [i for i in range(1, n+1) if i not in sol and i != rem]\n        if rem is not None and len(avail) >= 2:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            k = min(6, len(avail))\n            a1 = random.choice(avail[:k])\n            avail2 = [i for i in avail[:k] if i != a1]\n            a2 = random.choice(avail2) if avail2 else a1\n            new_sol = [x for x in sol if x != rem] + [a1, a2]\n            movement = \"SWAP_1_2\"\n        else:\n            movement = \"NOOP\"\n\n    repaired = repair(new_sol)\n    if repaired == validize(new_sol):\n        return (repaired, movement)\n    else:\n        return (repaired, \"REPAIR_\" + movement)\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def repair(sol):\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            avail = [i for i in range(1, n+1) if i not in sol]\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1], costs[i-1]))\n            L = 6\n            while c < 670 and avail:\n                add = random.choice(avail[:min(L, len(avail))])\n                sol.append(add)\n                c += costs[add-1]\n                p += points[add-1]\n                avail.remove(add)\n        # prune to reduce points while feasible\n        changed = True\n        while changed:\n            changed = False\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            c, p = cost_points(sol)\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                changed = True\n        return sol\n\n    sol = validize(solution)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        action = random.random()\n        if action < 0.34:\n            # random ADD from low p\/c pool\n            avail = [i for i in range(1, n+1) if i not in sol]\n            if avail:\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                sol.append(random.choice(avail[:min(6, len(avail))]))\n        elif action < 0.67 and sol:\n            # random REMOVE biased to high-point items\n            rem = max(sol, key=lambda i: points[i-1])\n            sol = [x for x in sol if x != rem]\n        else:\n            # SWAP: remove a random in, add two low p\/c items if possible\n            if sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                avail = [i for i in range(1, n+1) if i not in sol]\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n                if avail:\n                    sol.append(avail[0])\n                if len(avail) > 1:\n                    sol.append(avail[1])\n    return repair(sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: list of unique 1-based item indices representing the selected set.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx-1]\n        total_points += points[idx-1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def try_prune(sol):\n        sol = validize(sol)\n        changed = True\n        while changed:\n            changed = False\n            c, p = cost_points(sol)\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                changed = True\n        return sol\n\n    def repair(sol):\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            shortfall = 670 - c\n            avail = [i for i in range(1, n+1) if i not in sol]\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], max(0, shortfall - costs[i-1]), points[i-1], costs[i-1]))\n            idx = 0\n            K = max(6, int(0.2 * max(1, len(avail))))\n            while c < 670 and avail:\n                pick = random.choice(avail[:min(K, len(avail))])\n                sol.append(pick)\n                c += costs[pick-1]\n                p += points[pick-1]\n                shortfall = max(0, 670 - c)\n                avail.remove(pick)\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], max(0, shortfall - costs[i-1]), points[i-1], costs[i-1]))\n        sol = try_prune(sol)\n        return sol\n\n    sol = validize(solution)\n    if not sol:\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1], costs[i-1]))\n        init = [candidates[0]]\n        return (repair(init), \"INIT_ADD\")\n\n    r = random.random()\n    movement = \"ADD\"\n    new_sol = sol[:]\n\n    if r < 0.25:\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            K = max(6, int(0.15 * len(avail)))\n            add = random.choice(avail[:min(K, len(avail))])\n            new_sol = sol + [add]\n            movement = \"ADD\"\n        else:\n            movement = \"NOOP\"\n    elif r < 0.45 and sol:\n        rem = max(sol, key=lambda i: points[i-1])\n        new_sol = [x for x in sol if x != rem]\n        movement = \"REMOVE\"\n    elif r < 0.7 and sol:\n        rem = max(sol, key=lambda i: points[i-1])\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            add = random.choice(avail[:min(8, len(avail))])\n            new_sol = [x for x in sol if x != rem] + [add]\n            movement = \"SWAP_1_1\"\n        else:\n            new_sol = [x for x in sol if x != rem]\n            movement = \"REMOVE\"\n    elif r < 0.85 and len(sol) >= 2:\n        # SWAP 2-1: remove two highest-point items, add one low p\/c\n        rems = sorted(sol, key=lambda i: points[i-1], reverse=True)[:2]\n        base = [x for x in sol if x not in rems]\n        avail = [i for i in range(1, n+1) if i not in base]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            add = random.choice(avail[:min(8, len(avail))])\n            new_sol = base + [add]\n            movement = \"SWAP_2_1\"\n        else:\n            new_sol = base\n            movement = \"REMOVE2\"\n    else:\n        # SWAP 1-2: remove one highest-point, add two low p\/c\n        rem = max(sol, key=lambda i: points[i-1]) if sol else None\n        avail = [i for i in range(1, n+1) if i not in sol and i != rem]\n        if rem is not None and len(avail) >= 1:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            a1 = avail[0]\n            a2 = avail[1] if len(avail) > 1 else a1\n            if a2 == a1:\n                new_sol = [x for x in sol if x != rem] + [a1]\n                movement = \"SWAP_1_1_ALT\"\n            else:\n                new_sol = [x for x in sol if x != rem] + [a1, a2]\n                movement = \"SWAP_1_2\"\n        else:\n            movement = \"NOOP\"\n\n    repaired = repair(new_sol)\n    if repaired == validize(new_sol):\n        return (repaired, movement)\n    else:\n        return (repaired, \"REPAIR_\" + movement)\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n\n    def validize(sol):\n        seen = set()\n        clean = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    clean.append(x)\n                    seen.add(x)\n        return clean\n\n    def cost_points(sol):\n        c = 0\n        p = 0\n        for i in sol:\n            c += costs[i-1]\n            p += points[i-1]\n        return c, p\n\n    def prune(sol):\n        changed = True\n        while changed:\n            changed = False\n            c, p = cost_points(sol)\n            best_i = None\n            best_delta_p = -1\n            best_surplus = None\n            for i in list(sol):\n                new_c = c - costs[i-1]\n                if new_c >= 670:\n                    delta_p = points[i-1]\n                    surplus = new_c - 670\n                    if (delta_p > best_delta_p) or (delta_p == best_delta_p and (best_surplus is None or surplus < best_surplus)):\n                        best_i = i\n                        best_delta_p = delta_p\n                        best_surplus = surplus\n            if best_i is not None:\n                sol.remove(best_i)\n                changed = True\n        return sol\n\n    def refill(sol):\n        sol = validize(sol)\n        c, p = cost_points(sol)\n        if c < 670:\n            shortfall = 670 - c\n            avail = [i for i in range(1, n+1) if i not in sol]\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], max(0, shortfall - costs[i-1]), points[i-1], costs[i-1]))\n            K = max(6, int(0.25 * max(1, len(avail))))\n            while c < 670 and avail:\n                add = random.choice(avail[:min(K, len(avail))])\n                sol.append(add)\n                c += costs[add-1]\n                p += points[add-1]\n                shortfall = max(0, 670 - c)\n                avail.remove(add)\n                avail.sort(key=lambda i: (points[i-1]\/costs[i-1], max(0, shortfall - costs[i-1]), points[i-1], costs[i-1]))\n        return prune(sol)\n\n    sol = validize(solution)\n    if not sol:\n        return refill(sol)\n\n    k_remove = random.randint(1, min(3, len(sol)))\n    # remove k highest-point items\n    to_remove = sorted(sol, key=lambda i: points[i-1], reverse=True)[:k_remove]\n    sol = [x for x in sol if x not in to_remove]\n\n    # additional random swaps to diversify\n    for _ in range(random.randint(0, 2)):\n        if sol:\n            rem = random.choice(sol)\n            sol = [x for x in sol if x != rem]\n        avail = [i for i in range(1, n+1) if i not in sol]\n        if avail:\n            avail.sort(key=lambda i: (points[i-1]\/costs[i-1], points[i-1]))\n            sol.append(avail[0])\n            if len(avail) > 1 and random.random() < 0.5:\n                sol.append(avail[1])\n\n    return refill(sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: list of unique 1-based integers in [1..24] encoding selected item indices.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total points subject to total cost >= 670\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_points += points[idx - 1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _repair_and_trim(sol: List[int]) -> List[int]:\n    # Feasibility-aware quick repair\/trim to respect representation, not mandatory optimal\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    base = [i for i in sorted(set(sol)) if isinstance(i, int) and 1 <= i <= n]\n    # Helper totals\n    def totals(S: List[int]) -> Tuple[int, int]:\n        c = 0\n        p = 0\n        for j in S:\n            c += costs[j - 1]\n            p += points[j - 1]\n        return c, p\n    total_cost, total_points = totals(base)\n    # If infeasible: greedily add best cost per point until feasible\n    if total_cost < 670:\n        remaining = [i for i in range(1, n + 1) if i not in base]\n        remaining.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n        for i in remaining:\n            base.append(i)\n            total_cost += costs[i - 1]\n            total_points += points[i - 1]\n            if total_cost >= 670:\n                break\n    # If feasible: try trimming by removing worst point efficiency while keeping feasibility\n    if total_cost >= 670:\n        improved = True\n        while improved:\n            improved = False\n            # Candidate removals sorted by descending points per cost (worst first)\n            order = sorted(base, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - costs[rem - 1]\n                if new_cost >= 670:\n                    base.remove(rem)\n                    total_cost = new_cost\n                    total_points -= points[rem - 1]\n                    improved = True\n                    break\n    return sorted(set(base))\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= n]\n\n    # Determine feasibility\n    total_cost = sum(costs[i - 1] for i in base)\n    feasible = total_cost >= 670\n\n    # Move selection with feasibility bias\n    moves = []\n    if not base:\n        moves = [\"ADD\"]\n    else:\n        if feasible:\n            moves = [\"REMOVE\", \"SWAP\", \"SWAP\", \"REMOVE\", \"ADD\"]\n        else:\n            moves = [\"ADD\", \"ADD\", \"SWAP\", \"ADD\", \"ADD\"]\n\n    attempt = 0\n    neighbor = base[:]\n    move_type = \"ADD\"\n    while attempt < 10:\n        attempt += 1\n        neighbor = base[:]\n        move_type = random.choice(moves)\n        if move_type == \"ADD\":\n            # Prefer low points per cost\n            candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n            if candidates:\n                candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                # pick from top-k best\n                k = min(5, len(candidates))\n                pick = random.choice(candidates[:k])\n                neighbor.append(pick)\n        elif move_type == \"REMOVE\":\n            if neighbor:\n                # Prefer removing high points per cost\n                rem = max(neighbor, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                    k = min(5, len(candidates))\n                    addi = random.choice(candidates[:k])\n                    neighbor.append(addi)\n                else:\n                    # revert if no candidates\n                    neighbor.append(rem)\n        neighbor = sorted(set(neighbor))\n        if neighbor != base:\n            break\n    # Light repair\/trim for feasibility consistency and improved quality\n    neighbor = _repair_and_trim(neighbor)\n    return neighbor, \"INDEX_LIST\", move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= n]\n    k = random.randint(2, 4)\n    neighbor = base[:]\n    for _ in range(k):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) if neighbor else \"ADD\"\n        if move == \"ADD\":\n            candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n            if candidates:\n                # Bias to low points per cost\n                candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                pick = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                neighbor.append(pick)\n        elif move == \"REMOVE\":\n            if neighbor:\n                # Remove worst efficiency\n                rem = max(neighbor, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = random.choice(neighbor)\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, n + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n                    pick = random.choice(candidates[:max(1, min(5, len(candidates)))])\n                    neighbor.append(pick)\n                else:\n                    neighbor.append(rem)\n        neighbor = sorted(set(neighbor))\n    # finalize with quick repair\/trim to ensure representation quality\n    def _repair_and_trim_local(sol: List[int]) -> List[int]:\n        def totals(S: List[int]):\n            c = 0\n            p = 0\n            for j in S:\n                c += costs[j - 1]\n                p += points[j - 1]\n            return c, p\n        S = sorted(set(sol))\n        total_cost, total_points = totals(S)\n        if total_cost < 670:\n            remaining = [i for i in range(1, n + 1) if i not in S]\n            remaining.sort(key=lambda i: (points[i - 1] \/ costs[i - 1], points[i - 1], i))\n            for i in remaining:\n                S.append(i)\n                total_cost += costs[i - 1]\n                total_points += points[i - 1]\n                if total_cost >= 670:\n                    break\n        if total_cost >= 670:\n            improved = True\n            while improved:\n                improved = False\n                order = sorted(S, key=lambda i: (points[i - 1] \/ max(1, costs[i - 1]), -costs[i - 1], i), reverse=True)\n                for rem in order:\n                    new_cost = total_cost - costs[rem - 1]\n                    if new_cost >= 670:\n                        S.remove(rem)\n                        total_cost = new_cost\n                        total_points -= points[rem - 1]\n                        improved = True\n                        break\n        return sorted(set(S))\n    return _repair_and_trim_local(neighbor)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total points subject to total cost >= 670\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_points += points[idx - 1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Internal data (embedded)\n_COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n_POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n_N = len(_POINTS)\n_RATIOS = [(_POINTS[i] \/ _COSTS[i]) for i in range(_N)]\n_THRESHOLD = 670\n\n\ndef _totals(sol: List[int]) -> Tuple[int, int]:\n    c = 0\n    p = 0\n    for j in sol:\n        c += _COSTS[j - 1]\n        p += _POINTS[j - 1]\n    return c, p\n\n\ndef _repair_and_trim(sol: List[int]) -> List[int]:\n    # Ensure valid indices, uniqueness, feasibility; trim redundant items while keeping feasibility\n    S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= _N))\n    total_cost, total_points = _totals(S)\n    if total_cost < _THRESHOLD:\n        remaining = [i for i in range(1, _N + 1) if i not in S]\n        remaining.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n        for i in remaining:\n            S.append(i)\n            total_cost += _COSTS[i - 1]\n            total_points += _POINTS[i - 1]\n            if total_cost >= _THRESHOLD:\n                break\n    # Trim by removing items with worst (highest) ratio first while maintaining feasibility\n    if total_cost >= _THRESHOLD and S:\n        improved = True\n        while improved:\n            improved = False\n            # Try removing any item that keeps feasibility; prioritize highest ratios and higher points\n            order = sorted(S, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - _COSTS[rem - 1]\n                if new_cost >= _THRESHOLD:\n                    S.remove(rem)\n                    total_cost = new_cost\n                    total_points -= _POINTS[rem - 1]\n                    improved = True\n                    break\n    return sorted(S)\n\n\ndef _best_improving_move(S: List[int]) -> Tuple[List[int], str]:\n    # Deterministic steepest descent: try remove, then 1-1 exchange\n    base_set = set(S)\n    total_cost, total_points = _totals(S)\n    best_delta = 0\n    best_move = None\n    move_type = \"NONE\"\n\n    # 1) Pure removal: remove any item while keeping feasibility; choose max point reduction\n    for rem in S:\n        new_cost = total_cost - _COSTS[rem - 1]\n        if new_cost >= _THRESHOLD:\n            delta_points = -_POINTS[rem - 1]\n            if delta_points < best_delta:\n                best_delta = delta_points\n                best_move = (\"REMOVE\", rem, None)\n                move_type = \"REMOVE\"\n\n    # 2) 1-1 exchange: for each rem, add best candidate that maintains feasibility; choose most negative delta_points\n    # Pre-sort candidates by ratio for efficiency\n    candidates = [i for i in range(1, _N + 1) if i not in base_set]\n    if candidates:\n        # Try swaps that keep feasibility\n        for rem in S:\n            rem_cost = _COSTS[rem - 1]\n            rem_points = _POINTS[rem - 1]\n            budget_after_rem = total_cost - rem_cost\n            # Feasible additions are any; we only must ensure final cost >= threshold\n            for add in candidates:\n                new_cost = budget_after_rem + _COSTS[add - 1]\n                if new_cost >= _THRESHOLD:\n                    delta_points = _POINTS[add - 1] - rem_points\n                    if delta_points < best_delta:\n                        best_delta = delta_points\n                        best_move = (\"SWAP\", rem, add)\n                        move_type = \"SWAP\"\n\n    if best_move is None:\n        return S[:], \"NONE\"\n\n    if best_move[0] == \"REMOVE\":\n        rem = best_move[1]\n        newS = [i for i in S if i != rem]\n        return sorted(newS), \"REMOVE\"\n    else:\n        rem, add = best_move[1], best_move[2]\n        newS = [i for i in S if i != rem]\n        newS.append(add)\n        return sorted(set(newS)), \"SWAP\"\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns: (neighbor_solution, NB_Type, Movement_Type)\n    base = _repair_and_trim(solution if isinstance(solution, list) else [])\n    total_cost, _ = _totals(base)\n    feasible = total_cost >= _THRESHOLD\n\n    if not feasible:\n        # Intensify feasibility: add lowest ratio items until feasible\n        neighbor = _repair_and_trim(base)\n        return neighbor, \"INDEX_LIST\", \"REPAIR\"\n\n    # Feasible: try deterministic best-improving move\n    neighbor, move = _best_improving_move(base)\n    if neighbor != base:\n        neighbor = _repair_and_trim(neighbor)\n        return neighbor, \"INDEX_LIST\", move\n\n    # If no improving move, diversify lightly: swap out highest-ratio for a low-ratio candidate\n    if base:\n        worst = max(base, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n        candidates = [i for i in range(1, _N + 1) if i not in set(base)]\n        if candidates:\n            candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n            # pick among top-3 best ratios to avoid cycling\n            pick = random.choice(candidates[:min(3, len(candidates))])\n            tmp = [i for i in base if i != worst]\n            tmp.append(pick)\n            tmp = _repair_and_trim(tmp)\n            return tmp, \"INDEX_LIST\", \"DIVERSIFY_SWAP\"\n\n    # Fallback: return as-is\n    return base, \"INDEX_LIST\", \"NONE\"\n","Perturbacion":"import random\nfrom typing import List\n\n_COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n_POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n_N = len(_POINTS)\n_THRESHOLD = 670\n_RATIOS = [(_POINTS[i] \/ _COSTS[i]) for i in range(_N)]\n\n\ndef _repair_and_trim_local(sol: List[int]) -> List[int]:\n    S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= _N))\n    total_cost = sum(_COSTS[j - 1] for j in S)\n    total_points = sum(_POINTS[j - 1] for j in S)\n    if total_cost < _THRESHOLD:\n        remaining = [i for i in range(1, _N + 1) if i not in S]\n        remaining.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n        for i in remaining:\n            S.append(i)\n            total_cost += _COSTS[i - 1]\n            total_points += _POINTS[i - 1]\n            if total_cost >= _THRESHOLD:\n                break\n    if total_cost >= _THRESHOLD and S:\n        improved = True\n        while improved:\n            improved = False\n            order = sorted(S, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i), reverse=True)\n            for rem in order:\n                new_cost = total_cost - _COSTS[rem - 1]\n                if new_cost >= _THRESHOLD:\n                    S.remove(rem)\n                    total_cost = new_cost\n                    total_points -= _POINTS[rem - 1]\n                    improved = True\n                    break\n    return sorted(S)\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # k-random biased swaps\/adds\/removes followed by repair\/trim\n    rng = random.Random()\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= _N]\n    neighbor = base[:]\n    k = rng.randint(2, 4)\n    for _ in range(k):\n        move = \"ADD\" if not neighbor else rng.choice([\"ADD\", \"REMOVE\", \"SWAP\"]) \n        if move == \"ADD\":\n            candidates = [i for i in range(1, _N + 1) if i not in set(neighbor)]\n            if candidates:\n                candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n                pick = rng.choice(candidates[:min(5, len(candidates))])\n                neighbor.append(pick)\n        elif move == \"REMOVE\":\n            if neighbor:\n                rem = max(neighbor, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n                neighbor.remove(rem)\n        else:  # SWAP\n            if neighbor:\n                rem = max(neighbor, key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], -_COSTS[i - 1], i))\n                neighbor.remove(rem)\n                candidates = [i for i in range(1, _N + 1) if i not in set(neighbor)]\n                if candidates:\n                    candidates.sort(key=lambda i: (_RATIOS[i - 1], _POINTS[i - 1], i))\n                    addi = rng.choice(candidates[:min(5, len(candidates))])\n                    neighbor.append(addi)\n        neighbor = sorted(set(neighbor))\n    neighbor = _repair_and_trim_local(neighbor)\n    return neighbor\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total points subject to total cost >= 670\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(points)\n    if not isinstance(solution, list):\n        return 1e12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 1e12\n        seen.add(idx)\n        total_cost += costs[idx - 1]\n        total_points += points[idx - 1]\n    if total_cost >= 670:\n        return float(total_points)\n    shortfall = 670 - total_cost\n    return 1e9 + 1000.0 * float(shortfall) + float(total_points)\n","Vecindad":"import math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Embedded data\n    COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    N = len(POINTS)\n    THRESHOLD = 670\n    RATIOS = [POINTS[i] \/ COSTS[i] for i in range(N)]\n\n    def totals(sol: List[int]) -> Tuple[int, int]:\n        c = 0\n        p = 0\n        for j in sol:\n            c += COSTS[j - 1]\n            p += POINTS[j - 1]\n        return c, p\n\n    def repair_and_trim(sol: List[int]) -> List[int]:\n        S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= N))\n        total_cost, total_points = totals(S)\n        if total_cost < THRESHOLD:\n            remaining = [i for i in range(1, N + 1) if i not in S]\n            remaining.sort(key=lambda i: (RATIOS[i - 1], POINTS[i - 1], i))\n            for i in remaining:\n                S.append(i)\n                total_cost += COSTS[i - 1]\n                total_points += POINTS[i - 1]\n                if total_cost >= THRESHOLD:\n                    break\n        if total_cost >= THRESHOLD and S:\n            improved = True\n            while improved:\n                improved = False\n                order = sorted(S, key=lambda i: (RATIOS[i - 1], POINTS[i - 1], -COSTS[i - 1], i), reverse=True)\n                for rem in order:\n                    new_cost = total_cost - COSTS[rem - 1]\n                    if new_cost >= THRESHOLD:\n                        S.remove(rem)\n                        total_cost = new_cost\n                        total_points -= POINTS[rem - 1]\n                        improved = True\n                        break\n        return sorted(S)\n\n    def best_improving_move(S: List[int]) -> Tuple[List[int], str]:\n        base_set = set(S)\n        total_cost, _ = totals(S)\n        best_delta = 0\n        best_move = None\n        move_type = \"NONE\"\n        # Try remove\n        for rem in S:\n            new_cost = total_cost - COSTS[rem - 1]\n            if new_cost >= THRESHOLD:\n                delta_points = -POINTS[rem - 1]\n                if delta_points < best_delta:\n                    best_delta = delta_points\n                    best_move = (\"REMOVE\", rem, None)\n                    move_type = \"REMOVE\"\n        # Try 1-1 swap\n        candidates = [i for i in range(1, N + 1) if i not in base_set]\n        if candidates:\n            for rem in S:\n                rem_cost = COSTS[rem - 1]\n                rem_points = POINTS[rem - 1]\n                budget_after_rem = total_cost - rem_cost\n                for add in candidates:\n                    new_cost = budget_after_rem + COSTS[add - 1]\n                    if new_cost >= THRESHOLD:\n                        delta_points = POINTS[add - 1] - rem_points\n                        if delta_points < best_delta:\n                            best_delta = delta_points\n                            best_move = (\"SWAP\", rem, add)\n                            move_type = \"SWAP\"\n        if best_move is None:\n            return S[:], \"NONE\"\n        if best_move[0] == \"REMOVE\":\n            rem = best_move[1]\n            newS = [i for i in S if i != rem]\n            return sorted(newS), \"REMOVE\"\n        else:\n            rem, add = best_move[1], best_move[2]\n            newS = [i for i in S if i != rem]\n            newS.append(add)\n            return sorted(set(newS)), \"SWAP\"\n\n    base = repair_and_trim(solution if isinstance(solution, list) else [])\n    total_cost, _ = totals(base)\n    feasible = total_cost >= THRESHOLD\n    if not feasible:\n        neighbor = repair_and_trim(base)\n        return neighbor, \"INDEX_LIST\", \"REPAIR\"\n    neighbor, move = best_improving_move(base)\n    if neighbor != base:\n        neighbor = repair_and_trim(neighbor)\n        return neighbor, \"INDEX_LIST\", move\n    # Deterministic diversify: replace worst-ratio item with best outside, then repair\n    if base:\n        worst = sorted(base, key=lambda i: (RATIOS[i - 1], POINTS[i - 1], -COSTS[i - 1], i), reverse=True)[0]\n        outside = [i for i in range(1, N + 1) if i not in set(base)]\n        if outside:\n            outside.sort(key=lambda i: (RATIOS[i - 1], POINTS[i - 1], i))\n            pick = outside[0]\n            tmp = [i for i in base if i != worst]\n            tmp.append(pick)\n            tmp = repair_and_trim(tmp)\n            return tmp, \"INDEX_LIST\", \"DIVERSIFY_SWAP\"\n    return base, \"INDEX_LIST\", \"NONE\"\n","Perturbacion":"import math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic shake: remove k worst by ratio, add k best outside by ratio, then repair\/trim\n    COSTS = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    POINTS = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    N = len(POINTS)\n    THRESHOLD = 670\n    RATIOS = [POINTS[i] \/ COSTS[i] for i in range(N)]\n\n    def totals(sol: List[int]):\n        c = 0\n        p = 0\n        for j in sol:\n            c += COSTS[j - 1]\n            p += POINTS[j - 1]\n        return c, p\n\n    def repair_and_trim(sol: List[int]) -> List[int]:\n        S = sorted(set(j for j in sol if isinstance(j, int) and 1 <= j <= N))\n        total_cost, total_points = totals(S)\n        if total_cost < THRESHOLD:\n            remaining = [i for i in range(1, N + 1) if i not in S]\n            remaining.sort(key=lambda i: (RATIOS[i - 1], POINTS[i - 1], i))\n            for i in remaining:\n                S.append(i)\n                total_cost += COSTS[i - 1]\n                total_points += POINTS[i - 1]\n                if total_cost >= THRESHOLD:\n                    break\n        if total_cost >= THRESHOLD and S:\n            improved = True\n            while improved:\n                improved = False\n                order = sorted(S, key=lambda i: (RATIOS[i - 1], POINTS[i - 1], -COSTS[i - 1], i), reverse=True)\n                for rem in order:\n                    new_cost = total_cost - COSTS[rem - 1]\n                    if new_cost >= THRESHOLD:\n                        S.remove(rem)\n                        total_cost = new_cost\n                        total_points -= POINTS[rem - 1]\n                        improved = True\n                        break\n        return sorted(S)\n\n    base = [i for i in sorted(set(solution)) if isinstance(i, int) and 1 <= i <= N]\n    if not base:\n        return repair_and_trim(base)\n    k = 2 if len(base) >= 2 else 1\n    worst = sorted(base, key=lambda i: (RATIOS[i - 1], POINTS[i - 1], -COSTS[i - 1], i), reverse=True)[:k]\n    tmp = [i for i in base if i not in set(worst)]\n    outside = [i for i in range(1, N + 1) if i not in set(tmp)]\n    outside.sort(key=lambda i: (RATIOS[i - 1], POINTS[i - 1], i))\n    for add in outside[:k]:\n        tmp.append(add)\n    return repair_and_trim(tmp)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST of unique 1-based item indices, e.g., [5,7,9,13].","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**6 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    # Precompute ratio order once for efficiency\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: points[i-1] \/ costs[i-1])\n\n    def greedy_fill(sol):\n        # Efficient fill maintaining a running sum\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # Ensure feasibility baseline\n    if total_cost(sol) < 670:\n        sol = greedy_fill(sol.copy())\n        if total_cost(sol) < 670:\n            # Fallback random add until feasible\n            remaining = [i for i in range(1, n+1) if i not in sol]\n            random.shuffle(remaining)\n            for i in remaining:\n                sol.append(i)\n                if total_cost(sol) >= 670:\n                    break\n\n    cur_cost = total_cost(sol)\n    slack = cur_cost - 670\n\n    # Adaptive move selection\n    if slack < 40:\n        weights = [0.55, 0.05, 0.40]  # add, remove, swap\n    elif slack < 150:\n        weights = [0.35, 0.25, 0.40]\n    else:\n        weights = [0.20, 0.45, 0.35]\n\n    move = random.choices([\"add\", \"remove\", \"swap\"], weights=weights, k=1)[0]\n\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Heuristic helpers\n    def best_add_candidate(candidates):\n        # Prefer low point-per-cost first, else random\n        if not candidates:\n            return None\n        candidates.sort(key=lambda i: points[i-1] \/ costs[i-1])\n        if random.random() < 0.7:\n            return candidates[0]\n        return random.choice(candidates)\n\n    if move == \"add\" and out_list:\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    if move == \"remove\" and sol:\n        # Remove item that least harms objective: try removing highest point-per-cost among removable\n        removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n        if removable:\n            removable.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]), reverse=True)\n            rem = removable[0] if random.random() < 0.7 else random.choice(removable)\n            new_sol = [i for i in sol if i != rem]\n            return new_sol, \"remove\"\n        # else fall through to swap\n\n    # Swap: try up to dynamic trials, accept feasibility and non-worsening points with bias\n    if sol and out_list:\n        best_delta = math.inf\n        best_pair = None\n        trials = max(30, 2 * len(out_list))\n        for _ in range(trials):\n            out_i = random.choice(sol)\n            in_j = random.choice(out_list)\n            new_cost = cur_cost - costs[out_i-1] + costs[in_j-1]\n            if new_cost >= 670:\n                delta_points = points[in_j-1] - points[out_i-1]\n                if delta_points < best_delta or (delta_points == best_delta and random.random() < 0.25):\n                    best_delta = delta_points\n                    best_pair = (out_i, in_j)\n        if best_pair is not None:\n            new_sol = sol.copy()\n            new_sol.remove(best_pair[0])\n            new_sol.append(best_pair[1])\n            return new_sol, \"swap\"\n        # If no feasible swap found, try add as last resort\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        return new_sol, \"add\"\n\n    # No-op fallback\n    return sol.copy(), \"noop\"","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: random multi-remove, then greedy refill, then optional beneficial swaps.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: points[i-1] \/ costs[i-1])\n\n    def greedy_fill(sol):\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    sol = sanitize(solution)\n\n    # Build feasible base if needed using greedy by ratio\n    if total_cost(sol) < 670 or not sol:\n        base = []\n        cur_cost = 0\n        for i in ratio_order:\n            base.append(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        sol = base\n\n    # Randomly remove k items (intensity scales mildly with size)\n    k = 2 if len(sol) < 6 else 3\n    k = min(max(1, k), max(1, len(sol) - 1))\n    to_remove = random.sample(sol, k)\n    sol = [i for i in sol if i not in to_remove]\n\n    # Refill greedily to restore feasibility\n    sol = greedy_fill(sol)\n\n    # Optional improvement: try a few non-worsening feasible swaps\n    cur_points = sum(points[i-1] for i in sol)\n    cur_cost = total_cost(sol)\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    attempts = 40\n    improved = False\n    for _ in range(attempts):\n        if not sol or not out_list:\n            break\n        a = random.choice(sol)\n        b = random.choice(out_list)\n        new_cost = cur_cost - costs[a-1] + costs[b-1]\n        if new_cost >= 670 and points[b-1] <= points[a-1]:\n            sol.remove(a)\n            sol.append(b)\n            out_list.remove(b)\n            out_list.append(a)\n            cur_cost = new_cost\n            cur_points += points[b-1] - points[a-1]\n            improved = True\n            if random.random() < 0.3:\n                break\n    return sol","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: list of unique 1-based item indices selected, e.g., [5,7,9,13].","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns numeric fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**9 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    # Precompute ratio order once per call\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n\n    def greedy_fill(sol):\n        # Fill by best ratio until feasibility\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    def greedy_prune(sol):\n        # Remove items (worst by points then ratio) while staying feasible to reduce points\n        changed = True\n        while changed:\n            changed = False\n            cur_cost = total_cost(sol)\n            if not sol:\n                break\n            # Candidates whose removal keeps feasibility\n            removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n            if not removable:\n                break\n            # Prioritize highest absolute points, then highest points-per-cost\n            removable.sort(key=lambda i: (points[i-1], points[i-1]\/costs[i-1]), reverse=True)\n            # Try removing best candidate if it keeps feasibility\n            i = removable[0]\n            sol2 = [x for x in sol if x != i]\n            if total_cost(sol2) >= 670 and sum(points[x-1] for x in sol2) <= sum(points[x-1] for x in sol):\n                sol = sol2\n                changed = True\n        return sol\n\n    sol = sanitize(solution)\n\n    # Ensure feasibility baseline via repair\n    if total_cost(sol) < 670:\n        sol = greedy_fill(sol.copy())\n        if total_cost(sol) < 670:\n            remaining = [i for i in range(1, n+1) if i not in sol]\n            random.shuffle(remaining)\n            for i in remaining:\n                sol.append(i)\n                if total_cost(sol) >= 670:\n                    break\n\n    cur_cost = total_cost(sol)\n    slack = cur_cost - 670\n\n    # Safety margin allows removals if after removal still feasible\n    min_cost = min(costs)\n\n    # Adaptive move selection\n    if slack < min_cost:\n        weights = [0.55, 0.05, 0.40]  # add, remove, swap\n    elif slack < 2*min_cost:\n        weights = [0.35, 0.25, 0.40]\n    else:\n        weights = [0.20, 0.45, 0.35]\n\n    move = random.choices([\"add\", \"remove\", \"swap\"], weights=weights, k=1)[0]\n\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n\n    # Helper: prefer low points-per-cost\n    def best_add_candidate(candidates):\n        if not candidates:\n            return None\n        candidates.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n        if random.random() < 0.7:\n            return candidates[0]\n        return random.choice(candidates)\n\n    # ADD\n    if move == \"add\" and out_list:\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        new_sol = greedy_prune(new_sol)\n        return new_sol, \"add\"\n\n    # REMOVE\n    if move == \"remove\" and sol:\n        removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n        if removable:\n            removable.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]), reverse=True)\n            rem = removable[0] if random.random() < 0.7 else random.choice(removable)\n            new_sol = [i for i in sol if i != rem]\n            new_sol = greedy_prune(new_sol)\n            return new_sol, \"remove\"\n        # Fall through to swap if nothing removable\n\n    # SWAP\n    if sol and out_list:\n        best_delta = math.inf\n        best_pair = None\n        trials = max(30, 2 * len(out_list))\n        for _ in range(trials):\n            out_i = random.choice(sol)\n            in_j = random.choice(out_list)\n            new_cost = cur_cost - costs[out_i-1] + costs[in_j-1]\n            if new_cost >= 670:\n                delta_points = points[in_j-1] - points[out_i-1]\n                if (delta_points < best_delta) or (delta_points == best_delta and random.random() < 0.25):\n                    best_delta = delta_points\n                    best_pair = (out_i, in_j)\n        if best_pair is not None:\n            new_sol = sol.copy()\n            new_sol.remove(best_pair[0])\n            new_sol.append(best_pair[1])\n            new_sol = greedy_prune(new_sol)\n            return new_sol, \"swap\"\n        # If no feasible swap found, try add as last resort\n        new_sol = sol.copy()\n        cand = best_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        if total_cost(new_sol) < 670:\n            new_sol = greedy_fill(new_sol)\n        new_sol = greedy_prune(new_sol)\n        return new_sol, \"add\"\n\n    # No-op fallback\n    return sol.copy(), \"noop\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Diversification: multi-remove, greedy refill, prune, and a few improving swaps\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            sol = []\n        cleaned = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cleaned.append(x)\n        return cleaned\n\n    def total_cost(sol):\n        return sum(costs[i-1] for i in sol)\n\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n\n    def greedy_fill(sol):\n        cur_cost = total_cost(sol)\n        if cur_cost >= 670:\n            return sol\n        in_set = set(sol)\n        for i in ratio_order:\n            if i in in_set:\n                continue\n            sol.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        return sol\n\n    def greedy_prune(sol):\n        changed = True\n        while changed:\n            changed = False\n            cur_cost = total_cost(sol)\n            if not sol:\n                break\n            removable = [i for i in sol if (cur_cost - costs[i-1]) >= 670]\n            if not removable:\n                break\n            removable.sort(key=lambda i: (points[i-1], points[i-1]\/costs[i-1]), reverse=True)\n            candidate = removable[0]\n            sol2 = [x for x in sol if x != candidate]\n            if total_cost(sol2) >= 670 and sum(points[x-1] for x in sol2) <= sum(points[x-1] for x in sol):\n                sol = sol2\n                changed = True\n        return sol\n\n    sol = sanitize(solution)\n\n    # Build feasible base if needed using greedy by ratio\n    if total_cost(sol) < 670 or not sol:\n        base = []\n        cur_cost = 0\n        for i in ratio_order:\n            base.append(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= 670:\n                break\n        sol = base\n\n    # Randomly remove k items (intensity scales with size)\n    k = 3 if len(sol) >= 6 else 2\n    k = min(max(1, k), max(1, len(sol) - 1))\n    to_remove = random.sample(sol, k)\n    sol = [i for i in sol if i not in to_remove]\n\n    # Refill to feasibility, then prune\n    sol = greedy_fill(sol)\n    sol = greedy_prune(sol)\n\n    # Optional improving swaps (first-improvement, bounded attempts)\n    cur_cost = total_cost(sol)\n    cur_points = sum(points[i-1] for i in sol)\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    attempts = 50\n    for _ in range(attempts):\n        if not sol or not out_list:\n            break\n        a = random.choice(sol)\n        b = random.choice(out_list)\n        new_cost = cur_cost - costs[a-1] + costs[b-1]\n        if new_cost >= 670 and points[b-1] < points[a-1]:\n            # perform improving swap\n            sol.remove(a)\n            sol.append(b)\n            out_list.remove(b)\n            out_list.append(a)\n            cur_cost = new_cost\n            cur_points += points[b-1] - points[a-1]\n            # occasional early stop\n            if random.random() < 0.3:\n                break\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # solution: INDEX_LIST (1-based). Returns numeric fitness (lower is better).\n    # Feasible solutions return their total points; infeasible return large penalty.\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    # Validate solution format\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > 24:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n\n    # Feasibility: spend at least 670\n    if total_cost < 670:\n        return 10**9 + (670 - total_cost)\n\n    # Feasible: fitness equals objective (minimize points)\n    return total_points\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Internal immutable data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    budget = 670\n\n    # Utilities\n    def sanitize(sol_list):\n        if not isinstance(sol_list, list):\n            return []\n        seen = set()\n        out = []\n        for x in sol_list:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def cost_of(sol_set):\n        return sum(costs[i-1] for i in sol_set)\n\n    def points_of(sol_set):\n        return sum(points[i-1] for i in sol_set)\n\n    # Precomputed candidate orders\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n    min_points_order = list(range(1, n+1))\n    min_points_order.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]))\n\n    def greedy_fill(sol_list):\n        # Prioritize by ratio; if deficit small, prefer minimal absolute points\n        cur_cost = cost_of(sol_list)\n        deficit = max(0, budget - cur_cost)\n        in_set = set(sol_list)\n        if deficit <= 0:\n            return sol_list\n        # Choose ordering based on deficit\n        order = min_points_order if deficit <= 120 else ratio_order\n        for i in order:\n            if i in in_set:\n                continue\n            sol_list.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= budget:\n                break\n        return sol_list\n\n    def repair_feasible(sol_list):\n        sol_list = sanitize(sol_list)\n        sol_list = greedy_fill(sol_list)\n        # If still infeasible (edge case), add random items until feasible\n        in_set = set(sol_list)\n        while cost_of(sol_list) < budget:\n            cand = random.randint(1, n)\n            if cand not in in_set:\n                sol_list.append(cand)\n                in_set.add(cand)\n        return sol_list\n\n    def prune_simple(sol_list):\n        # Remove items greedily while staying feasible, allowing temporary non-monotone steps in metaheuristic elsewhere\n        improved = True\n        while improved and sol_list:\n            improved = False\n            cur_cost = cost_of(sol_list)\n            removable = [i for i in sol_list if (cur_cost - costs[i-1]) >= budget]\n            if not removable:\n                break\n            # Remove the highest points (then worst ratio) item first\n            removable.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]), reverse=True)\n            best_rm = removable[0]\n            new_sol = [x for x in sol_list if x != best_rm]\n            # Accept removal if it doesn't increase total points\n            if points_of(new_sol) <= points_of(sol_list):\n                sol_list = new_sol\n                improved = True\n        return sol_list\n\n    # Start from sanitized and feasible solution\n    base = repair_feasible(solution if isinstance(solution, list) else [])\n    base = sorted(set(base))\n    cur_cost = cost_of(base)\n    cur_points = points_of(base)\n\n    in_set = set(base)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    min_item_cost = min(costs)\n    slack = cur_cost - budget\n\n    # Adaptive move selection with expanded neighborhood\n    moves = [\"add\", \"remove\", \"swap1-1\", \"swap2-1\", \"swap1-2\"]\n    if slack < min_item_cost:\n        weights = [0.50, 0.00, 0.45, 0.03, 0.02]\n    elif slack < 2 * min_item_cost:\n        weights = [0.35, 0.15, 0.40, 0.05, 0.05]\n    else:\n        weights = [0.20, 0.45, 0.25, 0.05, 0.05]\n    move = random.choices(moves, weights=weights, k=1)[0]\n\n    # Helper selectors\n    def pick_add_candidate(cands):\n        if not cands:\n            return None\n        cands.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n        return cands[0] if random.random() < 0.7 else random.choice(cands)\n\n    def finalize(sol_list):\n        sol_list = repair_feasible(sol_list)\n        sol_list = prune_simple(sol_list)\n        return sorted(set(sol_list))\n\n    # ADD\n    if move == \"add\" and out_list:\n        new_sol = base.copy()\n        cand = pick_add_candidate(out_list.copy())\n        if cand is not None:\n            new_sol.append(cand)\n        return finalize(new_sol), \"add\"\n\n    # REMOVE\n    if move == \"remove\" and base:\n        removable = [i for i in base if (cur_cost - costs[i-1]) >= budget]\n        if removable:\n            removable.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]), reverse=True)\n            rem = removable[0] if random.random() < 0.7 else random.choice(removable)\n            new_sol = [i for i in base if i != rem]\n            return finalize(new_sol), \"remove\"\n        # fallthrough to swaps\n\n    # SWAP 1-1\n    if move in (\"swap1-1\", \"remove\", \"add\") and base and out_list:\n        best_pair = None\n        best_delta = math.inf\n        trials = max(40, 3 * len(out_list))\n        for _ in range(trials):\n            a = random.choice(base)\n            b = random.choice(out_list)\n            new_c = cur_cost - costs[a-1] + costs[b-1]\n            if new_c >= budget:\n                dpts = points[b-1] - points[a-1]\n                if (dpts < best_delta) or (dpts == best_delta and random.random() < 0.25):\n                    best_delta = dpts\n                    best_pair = (a, b)\n        if best_pair is not None:\n            new_sol = base.copy()\n            new_sol.remove(best_pair[0])\n            new_sol.append(best_pair[1])\n            return finalize(new_sol), \"swap1-1\"\n\n    # SWAP 2-1 (drop two, add one)\n    if move == \"swap2-1\" and len(base) >= 2 and out_list:\n        best_trip = None\n        best_delta = math.inf\n        for _ in range(60):\n            a, b = random.sample(base, 2)\n            c = random.choice(out_list)\n            new_c = cur_cost - costs[a-1] - costs[b-1] + costs[c-1]\n            if new_c >= budget:\n                dpts = points[c-1] - points[a-1] - points[b-1]\n                if dpts < best_delta:\n                    best_delta = dpts\n                    best_trip = (a, b, c)\n        if best_trip is not None:\n            new_sol = [x for x in base if x not in (best_trip[0], best_trip[1])]\n            new_sol.append(best_trip[2])\n            return finalize(new_sol), \"swap2-1\"\n\n    # SWAP 1-2 (drop one, add two)\n    if move == \"swap1-2\" and base and len(out_list) >= 2:\n        best_trip = None\n        best_delta = math.inf\n        for _ in range(60):\n            a = random.choice(base)\n            b, c = random.sample(out_list, 2)\n            new_c = cur_cost - costs[a-1] + costs[b-1] + costs[c-1]\n            if new_c >= budget:\n                dpts = points[b-1] + points[c-1] - points[a-1]\n                if dpts < best_delta:\n                    best_delta = dpts\n                    best_trip = (a, b, c)\n        if best_trip is not None:\n            new_sol = [x for x in base if x != best_trip[0]]\n            new_sol.extend([best_trip[1], best_trip[2]])\n            return finalize(new_sol), \"swap1-2\"\n\n    # Fallback: return base with a minor adjustment (attempt add or noop)\n    if out_list:\n        cand = pick_add_candidate(out_list.copy())\n        if cand is not None:\n            tmp = base.copy()\n            tmp.append(cand)\n            return finalize(tmp), \"add\"\n    return base.copy(), \"noop\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Diversification with controlled intensity; returns a feasible INDEX_LIST\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    budget = 670\n\n    def sanitize(sol_list):\n        if not isinstance(sol_list, list):\n            return []\n        seen = set()\n        out = []\n        for x in sol_list:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def cost_of(sol_list):\n        return sum(costs[i-1] for i in sol_list)\n\n    def points_of(sol_list):\n        return sum(points[i-1] for i in sol_list)\n\n    # Orders\n    ratio_order = list(range(1, n+1))\n    ratio_order.sort(key=lambda i: (points[i-1] \/ costs[i-1], points[i-1]))\n    min_points_order = list(range(1, n+1))\n    min_points_order.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]))\n\n    def greedy_fill(sol_list):\n        cur_cost = cost_of(sol_list)\n        deficit = max(0, budget - cur_cost)\n        if deficit <= 0:\n            return sol_list\n        in_set = set(sol_list)\n        order = min_points_order if deficit <= 120 else ratio_order\n        for i in order:\n            if i in in_set:\n                continue\n            sol_list.append(i)\n            in_set.add(i)\n            cur_cost += costs[i-1]\n            if cur_cost >= budget:\n                break\n        return sol_list\n\n    def repair_feasible(sol_list):\n        sol_list = sanitize(sol_list)\n        sol_list = greedy_fill(sol_list)\n        in_set = set(sol_list)\n        while cost_of(sol_list) < budget:\n            cand = random.randint(1, n)\n            if cand not in in_set:\n                sol_list.append(cand)\n                in_set.add(cand)\n        return sol_list\n\n    def prune_nonincreasing(sol_list):\n        # Drop high-point items while staying feasible if it does not increase points\n        improved = True\n        while improved and sol_list:\n            improved = False\n            cur_cost = cost_of(sol_list)\n            removable = [i for i in sol_list if (cur_cost - costs[i-1]) >= budget]\n            if not removable:\n                break\n            removable.sort(key=lambda i: (points[i-1], points[i-1] \/ costs[i-1]), reverse=True)\n            cand = removable[0]\n            new_sol = [x for x in sol_list if x != cand]\n            if points_of(new_sol) <= points_of(sol_list):\n                sol_list = new_sol\n                improved = True\n        return sol_list\n\n    # Build a feasible base (if input infeasible, construct via greedy ratio)\n    sol = repair_feasible(solution if isinstance(solution, list) else [])\n\n    # Remove k items with bias towards highest points\n    k_base = 2 if len(sol) < 6 else 3\n    k = min(max(1, k_base), max(1, len(sol) - 1))\n    # Weighted sampling by points\n    weights = [points[i-1] for i in sol]\n    # Normalize and sample without replacement\n    total_w = sum(weights)\n    probs = [w \/ total_w for w in weights]\n    # Create cumulative distribution for sampling without replacement\n    removed = []\n    candidates = sol.copy()\n    for _ in range(k):\n        if not candidates:\n            break\n        # select index by probs proportional to points\n        r = random.random()\n        cum = 0.0\n        chosen = candidates[0]\n        for idx, item in enumerate(candidates):\n            cum += points[item-1] \/ sum(points[j-1] for j in candidates)\n            if cum >= r:\n                chosen = item\n                break\n        removed.append(chosen)\n        candidates = [x for x in candidates if x != chosen]\n    sol = [i for i in sol if i not in removed]\n\n    # Refill to feasibility with randomized greedy, then prune\n    # Randomize tie-breaking by shuffling a small prefix\n    prefix = ratio_order[:]\n    random.shuffle(prefix)\n    refill_order = sorted(prefix[:6], key=lambda i: (points[i-1] \/ costs[i-1], points[i-1])) + ratio_order[6:]\n    in_set = set(sol)\n    cur_cost = cost_of(sol)\n    for i in refill_order:\n        if cur_cost >= budget:\n            break\n        if i in in_set:\n            continue\n        sol.append(i)\n        in_set.add(i)\n        cur_cost += costs[i-1]\n\n    sol = prune_nonincreasing(sol)\n\n    # Do a few first-improvement swaps\n    cur_cost = cost_of(sol)\n    cur_pts = points_of(sol)\n    in_set = set(sol)\n    out_list = [i for i in range(1, n+1) if i not in in_set]\n    attempts = 80\n    for _ in range(attempts):\n        if not sol or not out_list:\n            break\n        a = random.choice(sol)\n        b = random.choice(out_list)\n        new_c = cur_cost - costs[a-1] + costs[b-1]\n        if new_c >= budget and points[b-1] < points[a-1]:\n            sol.remove(a)\n            sol.append(b)\n            out_list.remove(b)\n            out_list.append(a)\n            cur_cost = new_c\n            cur_pts += points[b-1] - points[a-1]\n            if random.random() < 0.3:\n                break\n\n    return sorted(set(repair_feasible(sol)))\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    if total_gallons >= 67:\n        return total_cost\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 24\n    if not isinstance(solution, list):\n        cur = []\n    else:\n        cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        # enforce uniqueness while preserving order\n        seen = set()\n        cur = [x for x in cur if (x not in seen and not seen.add(x))]\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Heuristic bias: if clearly infeasible (few gallons proxy via size), prefer ADD\n    # Otherwise mix moves\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.30, 0.25], k=1)[0]\n\n    nxt = list(cur)\n\n    if move == \"ADD\" and len(available) > 0:\n        nxt.append(random.choice(available))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        nxt.pop(random.randrange(len(nxt)))\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        pos = random.randrange(len(nxt))\n        nxt[pos] = random.choice(available)\n    else:\n        # fallback toggle\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # normalize: unique and sorted for canonical form\n    seen2 = set()\n    nxt = [x for x in nxt if (1 <= x <= n) and (x not in seen2 and not seen2.add(x))]\n    nxt.sort()\n    return nxt, move\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 24\n    if not isinstance(solution, list):\n        cur = []\n    else:\n        cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        s = set()\n        cur = [x for x in cur if (x not in s and not s.add(x))]\n    size = len(cur)\n    k = max(2, min(6, 1 + size \/\/ 3))\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.5, 0.2, 0.3], k=1)[0]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # maintain validity\n        s2 = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in s2 and not s2.add(x))]\n    cur.sort()\n    return cur\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique 1-based indices [1..24]\n    n = 24\n    # Embedded problem data for heuristic bias\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    # sanitize input: keep valid ints, unique, preserve order\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Choose move type with bias\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.5, 0.25, 0.25], k=1)[0]\n\n    nxt = list(cur)\n\n    if move == \"ADD\" and len(available) > 0:\n        # bias by high gallons\/price density\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        # sample top-k to keep randomness\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        cand = [i for i, _ in densities[:k]]\n        nxt.append(random.choice(cand))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        # remove worst density currently selected if possible\n        dens_map = {i: offers_gallons[i - 1] \/ offers_price[i - 1] for i in nxt}\n        worst = min(nxt, key=lambda i: dens_map[i])\n        # with small probability remove random to escape local traps\n        if random.random() < 0.2:\n            nxt.pop(random.randrange(len(nxt)))\n        else:\n            nxt.remove(worst)\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        # swap out low-density for high-density candidate\n        out_i = min(nxt, key=lambda i: offers_gallons[i - 1] \/ offers_price[i - 1])\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        in_i = random.choice([i for i, _ in densities[:k]])\n        # replace first occurrence of out_i\n        for pos, val in enumerate(nxt):\n            if val == out_i:\n                nxt[pos] = in_i\n                break\n    else:\n        # fallback toggle\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # enforce uniqueness and bounds, preserve first occurrence order\n    seen2 = set()\n    cleaned = []\n    for x in nxt:\n        if 1 <= x <= n and x not in seen2:\n            seen2.add(x)\n            cleaned.append(x)\n\n    return cleaned, move\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply k random ADD\/REMOVE\/SWAP moves; maintain validity and uniqueness.\n    n = 24\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    k = max(2, min(6, 1 + len(cur) \/\/ 3))\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.25, 0.30], k=1)[0]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            # toggle fallback\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # enforce uniqueness and bounds after each move\n        seen2 = set()\n        tmp = []\n        for x in cur:\n            if 1 <= x <= n and x not in seen2:\n                seen2.add(x)\n                tmp.append(x)\n        cur = tmp\n    return cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique 1-based indices [1..24]\n    n = 24\n    # Embedded problem data for heuristic bias\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n\n    # sanitize input: keep valid ints, unique, preserve order\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Choose move type with bias\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == n:\n        move = random.choice([\"REMOVE\", \"SWAP\"])  # cannot ADD\n    else:\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.5, 0.25, 0.25], k=1)[0]\n\n    nxt = list(cur)\n\n    if move == \"ADD\" and len(available) > 0:\n        # bias by high gallons\/price density\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        cand = [i for i, _ in densities[:k]]\n        nxt.append(random.choice(cand))\n    elif move == \"REMOVE\" and len(nxt) > 0:\n        # remove worst density currently selected if possible\n        dens_map = {i: offers_gallons[i - 1] \/ offers_price[i - 1] for i in nxt}\n        worst = min(nxt, key=lambda i: dens_map[i])\n        if random.random() < 0.2:\n            nxt.pop(random.randrange(len(nxt)))\n        else:\n            nxt.remove(worst)\n    elif move == \"SWAP\" and len(nxt) > 0 and len(available) > 0:\n        out_i = min(nxt, key=lambda i: offers_gallons[i - 1] \/ offers_price[i - 1])\n        densities = [(i, offers_gallons[i - 1] \/ offers_price[i - 1]) for i in available]\n        densities.sort(key=lambda t: -t[1])\n        k = min(5, len(densities))\n        in_i = random.choice([i for i, _ in densities[:k]])\n        for pos, val in enumerate(nxt):\n            if val == out_i:\n                nxt[pos] = in_i\n                break\n    else:\n        # fallback toggle\n        i = random.randint(1, n)\n        if i in nxt:\n            nxt.remove(i)\n        else:\n            nxt.append(i)\n\n    # enforce uniqueness and bounds, preserve first occurrence order\n    seen2 = set()\n    cleaned = []\n    for x in nxt:\n        if 1 <= x <= n and x not in seen2:\n            seen2.add(x)\n            cleaned.append(x)\n\n    return cleaned, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply k random ADD\/REMOVE\/SWAP moves; maintain validity and uniqueness.\n    n = 24\n    cur = []\n    if isinstance(solution, list):\n        seen = set()\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    k = max(2, min(6, 1 + len(cur) \/\/ 3))\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choices([\"ADD\", \"REMOVE\", \"SWAP\"], weights=[0.45, 0.25, 0.30], k=1)[0]\n        if move == \"ADD\" and len(available) > 0:\n            cur.append(random.choice(available))\n        elif move == \"REMOVE\" and len(cur) > 0:\n            cur.pop(random.randrange(len(cur)))\n        elif move == \"SWAP\" and len(cur) > 0 and len(available) > 0:\n            pos = random.randrange(len(cur))\n            cur[pos] = random.choice(available)\n        else:\n            i = random.randint(1, n)\n            if i in cur:\n                cur.remove(i)\n            else:\n                cur.append(i)\n        # enforce uniqueness and bounds after each move\n        seen2 = set()\n        tmp = []\n        for x in cur:\n            if 1 <= x <= n and x not in seen2:\n                seen2.add(x)\n                tmp.append(x)\n        cur = tmp\n    return cur\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    offers_price = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    offers_gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n    n = len(offers_price)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += offers_price[idx - 1]\n        total_gallons += offers_gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood over INDEX_LIST: random biased add\/drop\/swap, 1-based indices in [1..24]\n    n = 24\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = list(solution)\n    pool = set(range(1, n + 1))\n\n    # Heuristic bias by price-per-gallon for adds (cheaper better) and for drops (worse removed first)\n    prices = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n\n    def ratio(i):\n        return prices[i - 1] \/ float(gallons[i - 1])\n\n    def do_add(sol):\n        choices = list(pool - set(sol))\n        if not choices:\n            return sol\n        # bias towards lower price-per-gallon\n        choices.sort(key=ratio)\n        k = min(5, len(choices))\n        pick = random.choice(choices[:k])\n        return sol + [pick]\n\n    def do_drop(sol):\n        if not sol:\n            return sol\n        # drop item with highest price-per-gallon with some randomness among top-k\n        ranked = sorted(sol, key=ratio, reverse=True)\n        k = min(3, len(ranked))\n        out = random.choice(ranked[:k])\n        idx = sol.index(out)\n        return sol[:idx] + sol[idx + 1:]\n\n    def do_swap(sol):\n        if not sol:\n            return do_add(sol)\n        if len(sol) == n:\n            return do_drop(sol)\n        out_candidates = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(out_candidates[:min(3, len(out_candidates))])\n        remaining = list(pool - set(sol))\n        if not remaining:\n            return sol\n        remaining.sort(key=ratio)\n        inn = random.choice(remaining[:min(5, len(remaining))])\n        new_sol = sol.copy()\n        pos = new_sol.index(out)\n        new_sol[pos] = inn\n        return new_sol\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) >= n:\n        move = \"drop\"\n    else:\n        move = random.choices(move_types, weights=[0.5, 0.2, 0.3], k=1)[0]\n\n    if move == \"add\":\n        neighbor = do_add(current)\n    elif move == \"drop\":\n        neighbor = do_drop(current)\n    else:\n        neighbor = do_swap(current)\n\n    # ensure change\n    attempts = 0\n    while neighbor == current and attempts < 5:\n        move = random.choice(move_types)\n        if move == \"add\":\n            neighbor = do_add(current)\n        elif move == \"drop\":\n            neighbor = do_drop(current)\n        else:\n            neighbor = do_swap(current)\n        attempts += 1\n\n    # deduplicate while preserving order and validity\n    seen = set()\n    cleaned = []\n    for x in neighbor:\n        if x not in seen and 1 <= x <= n:\n            cleaned.append(x)\n            seen.add(x)\n\n    return (cleaned, \"INDEX_LIST\", move)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake: perform k random add\/drop\/swap operations with bias\n    n = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = list(solution)\n\n    prices = [\n        19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9\n    ]\n    gallons = [\n        11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10\n    ]\n\n    def ratio(i):\n        return prices[i - 1] \/ float(gallons[i - 1])\n\n    def add_once(sol):\n        choices = list(set(range(1, n + 1)) - set(sol))\n        if not choices:\n            return sol\n        choices.sort(key=ratio)\n        pick = random.choice(choices[:min(6, len(choices))])\n        return sol + [pick]\n\n    def drop_once(sol):\n        if not sol:\n            return sol\n        ranked = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(ranked[:min(4, len(ranked))])\n        i = sol.index(out)\n        return sol[:i] + sol[i + 1:]\n\n    def swap_once(sol):\n        if not sol:\n            return add_once(sol)\n        if len(sol) == n:\n            return drop_once(sol)\n        out_candidates = sorted(sol, key=ratio, reverse=True)\n        out = random.choice(out_candidates[:min(4, len(out_candidates))])\n        remaining = list(set(range(1, n + 1)) - set(sol))\n        if not remaining:\n            return sol\n        remaining.sort(key=ratio)\n        inn = random.choice(remaining[:min(6, len(remaining))])\n        new_sol = sol.copy()\n        pos = new_sol.index(out)\n        new_sol[pos] = inn\n        return new_sol\n\n    k = random.randint(3, 7)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        if move == \"add\":\n            sol = add_once(sol)\n        elif move == \"drop\":\n            sol = drop_once(sol)\n        else:\n            sol = swap_once(sol)\n\n    # Clean and validate\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if x not in seen and 1 <= x <= n:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    n = len(prices)\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    cost = 0\n    gal = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n            return 10**12\n        seen.add(idx)\n        cost += prices[idx - 1]\n        gal += gallons[idx - 1]\n    if gal >= 67:\n        return cost\n    shortfall = 67 - gal\n    return cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_list, move_type)\n    n = 24\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    cur = list(solution) if isinstance(solution, list) else []\n    pool = set(range(1, n + 1))\n\n    def add_once(sol):\n        rem = list(pool - set(sol))\n        if not rem:\n            return sol\n        rem.sort(key=lambda i: ratio[i - 1])\n        k = min(5, len(rem))\n        pick = random.choice(rem[:k])\n        return sol + [pick]\n\n    def drop_once(sol):\n        if not sol:\n            return sol\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        k = min(3, len(ranked))\n        out = random.choice(ranked[:k])\n        sol2 = sol.copy()\n        sol2.remove(out)\n        return sol2\n\n    def swap_once(sol):\n        if not sol:\n            return add_once(sol)\n        rem = list(pool - set(sol))\n        if not rem:\n            return drop_once(sol)\n        out = max(sol, key=lambda i: ratio[i - 1])\n        inn = min(rem, key=lambda i: ratio[i - 1])\n        sol2 = sol.copy()\n        pos = sol2.index(out)\n        sol2[pos] = inn\n        return sol2\n\n    # Additional mixed operator: drop worst then add best\n    def drop_add(sol):\n        return add_once(drop_once(sol))\n\n    if len(cur) == 0:\n        move = 'add'\n    elif len(cur) >= n:\n        move = 'drop'\n    else:\n        move = random.choices(['add', 'drop', 'swap', 'drop_add'], [0.45, 0.2, 0.25, 0.10])[0]\n\n    if move == 'add':\n        nb = add_once(cur)\n    elif move == 'drop':\n        nb = drop_once(cur)\n    elif move == 'swap':\n        nb = swap_once(cur)\n    else:\n        nb = drop_add(cur)\n\n    # ensure change and validity\n    attempts = 0\n    while nb == cur and attempts < 5:\n        move = random.choice(['add', 'drop', 'swap'])\n        if move == 'add':\n            nb = add_once(cur)\n        elif move == 'drop':\n            nb = drop_once(cur)\n        else:\n            nb = swap_once(cur)\n        attempts += 1\n\n    # deduplicate and clamp\n    seen = set()\n    cleaned = []\n    for x in nb:\n        if 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n\n    return cleaned, move\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    sol = list(solution) if isinstance(solution, list) else []\n\n    k = random.randint(3, 6)\n    # Drop top-k worst ratio items (if exist)\n    if sol:\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        drop_k = min(k, len(ranked))\n        to_keep = set(ranked[drop_k:])\n        sol = [i for i in sol if i in to_keep]\n\n    # Add k best from remaining\n    remaining = sorted(list(set(range(1, n + 1)) - set(sol)), key=lambda i: ratio[i - 1])\n    for i in remaining[:k]:\n        sol.append(i)\n\n    # Final cleanup: dedup and clamp\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return total revenue; infeasible return large penalty.\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    n = len(prices)\n    # Basic structural validation\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_gallons = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        total_cost += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n    # Constraint: at least 67 gallons\n    if total_gallons >= 67:\n        return total_cost\n    # Penalize infeasibility proportional to shortfall (fixed large penalty for comparability)\n    shortfall = 67 - total_gallons\n    return total_cost + 10**9 + shortfall * 10**6\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_list, move_type)\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    n = len(prices)\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    # Defensive copy and clean input\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                cur.append(x)\n                seen.add(x)\n    pool = set(range(1, n + 1))\n\n    def total_gal(sol):\n        return sum(gallons[i - 1] for i in sol)\n\n    def repair_to_feasible(sol):\n        # Add lowest price-per-gallon items until gallons >= 67\n        sset = set(sol)\n        gal = total_gal(sol)\n        if gal >= 67:\n            return sol\n        remaining = sorted([i for i in range(1, n + 1) if i not in sset], key=lambda i: ratio[i - 1])\n        sol2 = list(sol)\n        for i in remaining:\n            sol2.append(i)\n            gal += gallons[i - 1]\n            if gal >= 67:\n                break\n        return sol2\n\n    def prune_redundant(sol):\n        # While feasible, try dropping one element that keeps feasibility and reduces cost.\n        improved = True\n        sol2 = list(sol)\n        while improved:\n            improved = False\n            # candidates to drop: prefer higher ratio (worse) first\n            for i in sorted(sol2, key=lambda j: ratio[j - 1], reverse=True):\n                trial = [x for x in sol2 if x != i]\n                if total_gal(trial) >= 67:\n                    sol2 = trial\n                    improved = True\n                    break\n        return sol2\n\n    def add_move(sol):\n        rem = list(pool - set(sol))\n        if not rem:\n            return list(sol)\n        # bias towards good ratio\n        rem.sort(key=lambda i: ratio[i - 1])\n        k = min(5, len(rem))\n        pick = random.choice(rem[:k])\n        out = list(sol) + [pick]\n        out = repair_to_feasible(out)\n        out = prune_redundant(out)\n        return out\n\n    def drop_move(sol):\n        if not sol:\n            return list(sol)\n        # try dropping one of the worst ratios but keep feasibility via repair\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        k = min(3, len(ranked))\n        candidate = random.choice(ranked[:k])\n        out = [x for x in sol if x != candidate]\n        out = repair_to_feasible(out)\n        out = prune_redundant(out)\n        return out\n\n    def swap_move(sol):\n        if not sol:\n            return add_move(sol)\n        rem = list(pool - set(sol))\n        if not rem:\n            return drop_move(sol)\n        # sample-based stochastic swap: replace a high-ratio selected with a low-ratio unselected\n        sel = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)[:min(3, len(sol))]\n        uns = sorted(rem, key=lambda i: ratio[i - 1])[:min(5, len(rem))]\n        out = list(sol)\n        out_sel = random.choice(sel)\n        in_uns = random.choice(uns)\n        pos = out.index(out_sel)\n        out[pos] = in_uns\n        out = repair_to_feasible(out)\n        out = prune_redundant(out)\n        return out\n\n    def drop_add_move(sol):\n        return add_move(drop_move(sol))\n\n    if len(cur) == 0:\n        move = 'add'\n    elif len(cur) >= n:\n        move = 'drop'\n    else:\n        move = random.choices(['add', 'drop', 'swap', 'drop_add'], [0.45, 0.2, 0.25, 0.10])[0]\n\n    if move == 'add':\n        nb = add_move(cur)\n    elif move == 'drop':\n        nb = drop_move(cur)\n    elif move == 'swap':\n        nb = swap_move(cur)\n    else:\n        nb = drop_add_move(cur)\n\n    # Final cleanup: deduplicate and clamp\n    seen = set()\n    cleaned = []\n    for x in nb:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned, move\n","Perturbacion":"import math\n\n\ndef perturb_solution(solution):\n    # Deterministic, structure-changing perturbation with immediate repair and prune.\n    prices = [19, 21, 22, 13, 1, 9, 7, 10, 4, 11, 11, 12, 6, 15, 17, 8, 13, 11, 24, 10, 8, 18, 8, 9]\n    gallons = [11, 23, 22, 10, 17, 20, 11, 24, 19, 8, 14, 20, 22, 16, 13, 5, 4, 22, 23, 9, 22, 6, 20, 10]\n    n = len(prices)\n    ratio = [p \/ g for p, g in zip(prices, gallons)]\n\n    # Clean input\n    sol = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                sol.append(x)\n                seen.add(x)\n\n    def total_gal(s):\n        return sum(gallons[i - 1] for i in s)\n\n    def repair_to_feasible(s):\n        sset = set(s)\n        gal = total_gal(s)\n        if gal >= 67:\n            return s\n        remaining = sorted([i for i in range(1, n + 1) if i not in sset], key=lambda i: ratio[i - 1])\n        out = list(s)\n        for i in remaining:\n            out.append(i)\n            gal += gallons[i - 1]\n            if gal >= 67:\n                break\n        return out\n\n    def prune_redundant(s):\n        improved = True\n        out = list(s)\n        while improved:\n            improved = False\n            for i in sorted(out, key=lambda j: ratio[j - 1], reverse=True):\n                trial = [x for x in out if x != i]\n                if total_gal(trial) >= 67:\n                    out = trial\n                    improved = True\n                    break\n        return out\n\n    # Drop a fraction of worst-ratio selected items deterministically\n    if sol:\n        drop_k = max(1, min(5, (len(sol) + 2) \/\/ 3))  # ~33% capped at 5, at least 1\n        ranked = sorted(sol, key=lambda i: ratio[i - 1], reverse=True)\n        to_keep = set(ranked[drop_k:])\n        sol = [i for i in sol if i in to_keep]\n\n    # Add best remaining by ratio until feasible\n    sol = repair_to_feasible(sol)\n    # Prune redundant to tighten cost\n    sol = prune_redundant(sol)\n\n    # Final cleanup\n    seen = set()\n    cleaned = []\n    for x in sol:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            cleaned.append(x)\n            seen.add(x)\n    return cleaned\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    # Type check\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    # Count duplicates and invalids\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned: List[int] = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    # Objective components\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    # Constraint and validity penalties\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    # Penalty scheme (dominates any feasible revenue):\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        # Add proportional components for diagnostics and to strictly order infeasible solutions\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    \"\"\"\n    Generate a valid neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\", movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"exchange2-1\"}.\n    Bias: if infeasible (<67 gallons), prefer moves that increase gallons.\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # sanitize to unique valid list\n    base: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n\n    # helper to compute gallons quickly\n    def total_g(lst: List[int]) -> int:\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    cur_g = total_g(base)\n    feasible = cur_g >= 67\n\n    neighbor = list(base)\n    move = \"swap\"\n\n    all_indices = list(range(1, n+1))\n    missing = list(sorted(set(all_indices) - set(base)))\n\n    if len(base) == 0:\n        choice = random.choice(all_indices)\n        neighbor = [choice]\n        move = \"add\"\n    elif len(base) == n:\n        idx = random.randrange(len(base))\n        neighbor.pop(idx)\n        move = \"remove\"\n    else:\n        if not feasible:\n            # Bias to increase gallons: add the best cost-per-gallon missing item or swap in a better one\n            # choose among add or swap with higher gallon gain\n            if missing and (random.random() < 0.7 or not neighbor):\n                # add the missing item with best gallons per cost (maximize gallons, minimize cost)\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                neighbor.append(cand)\n                move = \"add\"\n            else:\n                # swap out the worst item (low gallons per cost) for a better missing one\n                if neighbor and missing:\n                    out_pos = min(range(len(neighbor)), key=lambda p: (gallons[neighbor[p]-1]\/prices[neighbor[p]-1], gallons[neighbor[p]-1]))\n                    in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n        else:\n            # Feasible: try to reduce revenue while keeping feasibility\n            action = random.choices([\"remove\",\"swap\",\"exchange2-1\",\"add\"], weights=[0.45,0.35,0.15,0.05])[0]\n            if action == \"remove\":\n                # remove the worst cost efficiency (highest cost per gallon) if still feasible\n                removable_positions = list(range(len(neighbor)))\n                random.shuffle(removable_positions)\n                removed = False\n                # try more expensive first\n                removable_positions.sort(key=lambda p: prices[neighbor[p]-1]\/gallons[neighbor[p]-1], reverse=True)\n                for p in removable_positions:\n                    cand = neighbor[:p] + neighbor[p+1:]\n                    if total_g(cand) >= 67:\n                        neighbor = cand\n                        move = \"remove\"\n                        removed = True\n                        break\n                if not removed and neighbor:\n                    # fallback remove random (may become infeasible; SA can handle)\n                    idx = random.randrange(len(neighbor))\n                    neighbor.pop(idx)\n                    move = \"remove\"\n            elif action == \"swap\":\n                if neighbor and missing:\n                    # swap out the worst cost-per-gallon for a better missing if keeps feasibility\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/gallons[neighbor[p]-1])\n                    best_in = None\n                    best_delta = None\n                    for m in missing:\n                        new_g = cur_g - gallons[neighbor[out_pos]-1] + gallons[m-1]\n                        if new_g >= 67:\n                            delta_cost = prices[m-1] - prices[neighbor[out_pos]-1]\n                            if best_delta is None or delta_cost < best_delta:\n                                best_delta = delta_cost\n                                best_in = m\n                    if best_in is not None:\n                        neighbor[out_pos] = best_in\n                        move = \"swap\"\n                    else:\n                        # fallback simple swap\n                        out_idx = random.randrange(len(neighbor))\n                        in_val = random.choice(missing)\n                        neighbor[out_idx] = in_val\n                        move = \"swap\"\n            elif action == \"exchange2-1\":\n                # drop up to 2 items and add 1 better item\n                if len(neighbor) >= 2 and missing:\n                    out_positions = random.sample(range(len(neighbor)), 2)\n                    out_positions.sort(reverse=True)\n                    removed = [neighbor[p] for p in out_positions]\n                    temp = [v for i, v in enumerate(neighbor) if i not in out_positions]\n                    # choose an in that keeps feasibility and reduces cost\n                    viable = []\n                    for m in missing:\n                        if total_g(temp + [m]) >= 67:\n                            delta_cost = (prices[m-1]) - sum(prices[r-1] for r in removed)\n                            viable.append((delta_cost, m))\n                    if viable:\n                        viable.sort(key=lambda x: x[0])\n                        neighbor = temp + [viable[0][1]]\n                        move = \"exchange2-1\"\n                    else:\n                        # fallback to simple remove\n                        idx = random.randrange(len(neighbor))\n                        neighbor.pop(idx)\n                        move = \"remove\"\n            else:  # rare add\n                if missing:\n                    neighbor.append(random.choice(missing))\n                    move = \"add\"\n\n    # Ensure uniqueness and validity\n    uniq: List[int] = []\n    seen2 = set()\n    for v in neighbor:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return (uniq, \"INDEX_LIST\", move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 random neighborhood moves while keeping indices in 1..24 and unique.\n    If current is feasible, try to preserve feasibility with biased moves.\n    Returns a new valid INDEX_LIST solution (1-based, unique order preserved as modified).\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # sanitize\n    cur: List[int] = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n\n    def total_g(lst: List[int]) -> int:\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        feasible = total_g(cur) >= 67\n        missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n        if len(cur) == 0:\n            if missing:\n                cur.append(random.choice(missing))\n            continue\n        if len(cur) == n:\n            cur.pop(random.randrange(len(cur)))\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if not feasible:\n            # bias to add\/swap to increase gallons\n            move = random.choices([\"add\",\"swap\",\"remove\"], weights=[0.6,0.3,0.1])[0]\n        if move == \"add\":\n            if missing:\n                # choose high gallons per cost\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                cur.append(cand)\n        elif move == \"remove\":\n            if cur:\n                if feasible:\n                    # remove worst cost-per-gallon first\n                    pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/gallons[cur[p]-1])\n                else:\n                    pos = random.randrange(len(cur))\n                cur.pop(pos)\n        else:  # swap\n            if cur and missing:\n                # swap out worst for best\n                out_pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/gallons[cur[p]-1])\n                in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1]))\n                cur[out_pos] = in_val\n\n    # final cleanup uniqueness\n    seen2 = set()\n    uniq: List[int] = []\n    for v in cur:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return uniq\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\", movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"exchange2-1\",\"one-to-one\"}.\n    Bias: if infeasible (<67 gallons), prefer moves that increase gallons.\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    base = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n\n    def total_g(lst):\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    cur_g = total_g(base)\n    feasible = cur_g >= 67\n\n    neighbor = list(base)\n    move = \"swap\"\n\n    all_indices = list(range(1, n+1))\n    missing = list(sorted(set(all_indices) - set(base)))\n\n    if len(base) == 0:\n        choice = random.choice(all_indices)\n        neighbor = [choice]\n        move = \"add\"\n    elif len(base) == n:\n        idx = random.randrange(len(base))\n        neighbor.pop(idx)\n        move = \"remove\"\n    else:\n        if not feasible:\n            if missing and (random.random() < 0.7 or not neighbor):\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                neighbor.append(cand)\n                move = \"add\"\n            else:\n                if neighbor and missing:\n                    out_pos = min(range(len(neighbor)), key=lambda p: (gallons[neighbor[p]-1]\/prices[neighbor[p]-1], gallons[neighbor[p]-1], -prices[neighbor[p]-1]))\n                    in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n        else:\n            action = random.choices([\"remove\",\"one-to-one\",\"swap\",\"exchange2-1\",\"add\"], weights=[0.4,0.25,0.2,0.1,0.05])[0]\n            if action == \"remove\":\n                removable_positions = list(range(len(neighbor)))\n                removable_positions.sort(key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]), reverse=True)\n                removed = False\n                for p in removable_positions:\n                    cand = neighbor[:p] + neighbor[p+1:]\n                    if total_g(cand) >= 67:\n                        neighbor = cand\n                        move = \"remove\"\n                        removed = True\n                        break\n                if not removed and neighbor:\n                    idx = random.randrange(len(neighbor))\n                    neighbor.pop(idx)\n                    move = \"remove\"\n            elif action == \"one-to-one\":\n                if neighbor and missing:\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                    best_in = None\n                    best_delta = None\n                    for m in missing:\n                        new_g = cur_g - gallons[neighbor[out_pos]-1] + gallons[m-1]\n                        if new_g >= 67:\n                            delta_cost = prices[m-1] - prices[neighbor[out_pos]-1]\n                            if best_delta is None or delta_cost < best_delta:\n                                best_delta = delta_cost\n                                best_in = m\n                    if best_in is not None:\n                        neighbor[out_pos] = best_in\n                        move = \"one-to-one\"\n                    else:\n                        out_idx = random.randrange(len(neighbor))\n                        in_val = random.choice(missing)\n                        neighbor[out_idx] = in_val\n                        move = \"swap\"\n            elif action == \"swap\":\n                if neighbor and missing:\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                    in_val = random.choice(missing)\n                    neighbor[out_pos] = in_val\n                    move = \"swap\"\n            elif action == \"exchange2-1\":\n                if len(neighbor) >= 2 and missing:\n                    out_positions = random.sample(range(len(neighbor)), 2)\n                    out_positions.sort(reverse=True)\n                    removed_vals = [neighbor[p] for p in out_positions]\n                    temp = [v for i, v in enumerate(neighbor) if i not in out_positions]\n                    viable = []\n                    temp_g = total_g(temp)\n                    for m in missing:\n                        if temp_g + gallons[m-1] >= 67:\n                            delta_cost = prices[m-1] - sum(prices[r-1] for r in removed_vals)\n                            viable.append((delta_cost, m))\n                    if viable:\n                        viable.sort(key=lambda x: x[0])\n                        neighbor = temp + [viable[0][1]]\n                        move = \"exchange2-1\"\n                    else:\n                        idx = random.randrange(len(neighbor))\n                        neighbor.pop(idx)\n                        move = \"remove\"\n            else:\n                if missing:\n                    neighbor.append(random.choice(missing))\n                    move = \"add\"\n\n    uniq = []\n    seen2 = set()\n    for v in neighbor:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return (uniq, \"INDEX_LIST\", move)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 biased moves while keeping indices in 1..24 and unique.\n    If current is feasible, try to preserve feasibility with biased moves.\n    Returns a new valid INDEX_LIST solution (1-based, unique order preserved as modified).\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    cur = []\n    if isinstance(solution, (list, tuple)):\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n\n    def total_g(lst):\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        feasible = total_g(cur) >= 67\n        missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n        if len(cur) == 0:\n            if missing:\n                cur.append(random.choice(missing))\n            continue\n        if len(cur) == n:\n            cur.pop(random.randrange(len(cur)))\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if not feasible:\n            move = random.choices([\"add\",\"swap\",\"remove\"], weights=[0.6,0.3,0.1])[0]\n        if move == \"add\":\n            if missing:\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                cur.append(cand)\n        elif move == \"remove\":\n            if cur:\n                if feasible:\n                    pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                else:\n                    pos = random.randrange(len(cur))\n                cur.pop(pos)\n        else:\n            if cur and missing:\n                out_pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                cur[out_pos] = in_val\n\n    seen2 = set()\n    uniq = []\n    for v in cur:\n        iv = int(v)\n        if 1 <= iv <= n and iv not in seen2:\n            seen2.add(iv)\n            uniq.append(iv)\n    return uniq\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"INDEX_LIST_1BASED_UNIQUE_ORDER_IRRELEVANT","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness = total revenue if gallons >= 67 and indices valid & unique; else revenue plus penalties.\n    Lower is better. SOL_TYPE=INDEX_LIST (1-based).\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = len(prices)\n\n    if not isinstance(solution, (list, tuple)):\n        return float('inf')\n\n    seen = set()\n    dup_count = 0\n    invalid_count = 0\n    cleaned = []\n    for idx in solution:\n        if not isinstance(idx, int):\n            invalid_count += 1\n            continue\n        if not (1 <= idx <= n):\n            invalid_count += 1\n            continue\n        if idx in seen:\n            dup_count += 1\n            continue\n        seen.add(idx)\n        cleaned.append(idx)\n\n    revenue = 0\n    total_gallons = 0\n    for idx in cleaned:\n        revenue += prices[idx - 1]\n        total_gallons += gallons[idx - 1]\n\n    required = 67\n    shortage = max(0, required - total_gallons)\n\n    PENALTY_BASE = 10**9\n    penalty = 0\n    if invalid_count > 0 or dup_count > 0 or shortage > 0:\n        penalty += PENALTY_BASE\n        penalty += 10**6 * invalid_count\n        penalty += 10**3 * dup_count\n        penalty += 10**5 * shortage\n\n    return float(revenue + penalty)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a neighboring solution for INDEX_LIST (1-based unique indices for 1..24).\n    Returns: (neighbor_solution, \"INDEX_LIST\").\n    Bias: if infeasible (<67 gallons), prefer moves that increase gallons; if feasible, prefer cost-improving safe removals\/swaps.\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # Normalize current solution to unique, in-range ints\n    base = []\n    seen = set()\n    if isinstance(solution, (list, tuple)):\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                base.append(v)\n    else:\n        base = []\n\n    def total_g(lst):\n        tg = 0\n        for i in lst:\n            tg += gallons[i-1]\n        return tg\n\n    cur_g = total_g(base)\n    feasible = cur_g >= 67\n\n    neighbor = list(base)\n\n    all_indices = list(range(1, n+1))\n    missing = list(sorted(set(all_indices) - set(base)))\n\n    if len(base) == 0:\n        # Start by adding a high value-density item\n        choice = max(all_indices, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n        neighbor = [choice]\n    elif len(base) == n:\n        # Remove the worst value item\n        idx = max(range(len(base)), key=lambda p: prices[base[p]-1]\/max(1, gallons[base[p]-1]))\n        neighbor.pop(idx)\n    else:\n        if not feasible:\n            # Prefer add or improving swap toward feasibility\n            if missing and (random.random() < 0.7 or not neighbor):\n                cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                neighbor.append(cand)\n            else:\n                if neighbor and missing:\n                    # Replace worst by best\n                    out_pos = min(range(len(neighbor)), key=lambda p: (gallons[neighbor[p]-1]\/prices[neighbor[p]-1], gallons[neighbor[p]-1], -prices[neighbor[p]-1]))\n                    in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                    neighbor[out_pos] = in_val\n        else:\n            # Feasible: try safe removal; else cost-improving swap; minor add occasionally to diversify\n            action = random.choices([\"remove\",\"swap\",\"add\"], weights=[0.6,0.35,0.05])[0]\n            if action == \"remove\":\n                removable_positions = list(range(len(neighbor)))\n                removable_positions.sort(key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]), reverse=True)\n                removed = False\n                for p in removable_positions:\n                    cand = neighbor[:p] + neighbor[p+1:]\n                    if total_g(cand) >= 67:\n                        neighbor = cand\n                        removed = True\n                        break\n                if not removed and neighbor:\n                    # If no safe removal exists, attempt best-cost swap\n                    if missing:\n                        out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                        best_in = min(missing, key=lambda i: prices[i-1])\n                        neighbor[out_pos] = best_in\n            elif action == \"swap\":\n                if neighbor and missing:\n                    out_pos = max(range(len(neighbor)), key=lambda p: prices[neighbor[p]-1]\/max(1, gallons[neighbor[p]-1]))\n                    # choose an in that keeps feasibility if possible and reduces cost\n                    cur_g = total_g(neighbor)\n                    best_choice = None\n                    best_delta = None\n                    for m in missing:\n                        new_g = cur_g - gallons[neighbor[out_pos]-1] + gallons[m-1]\n                        if new_g >= 67:\n                            delta_cost = prices[m-1] - prices[neighbor[out_pos]-1]\n                            if best_delta is None or delta_cost < best_delta:\n                                best_delta = delta_cost\n                                best_choice = m\n                    if best_choice is None:\n                        best_choice = min(missing, key=lambda i: prices[i-1])\n                    neighbor[out_pos] = best_choice\n            else:  # add\n                if missing:\n                    neighbor.append(min(missing, key=lambda i: prices[i-1]))\n\n    # Final cleanup to ensure 1-based unique and within range\n    uniq = []\n    seen2 = set()\n    for v in neighbor:\n        if isinstance(v, int):\n            iv = v\n            if 1 <= iv <= n and iv not in seen2:\n                seen2.add(iv)\n                uniq.append(iv)\n\n    return (uniq, \"INDEX_LIST\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: apply 2-5 biased edits while keeping indices in 1..24 and unique.\n    If current is feasible, try to preserve\/repair feasibility; otherwise push toward feasibility.\n    Returns a new valid INDEX_LIST solution (1-based, unique).\n    \"\"\"\n    n = 24\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # Normalize\n    cur = []\n    seen = set()\n    if isinstance(solution, (list, tuple)):\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                cur.append(v)\n\n    def total_g(lst):\n        s = 0\n        for i in lst:\n            s += gallons[i-1]\n        return s\n\n    def add_best(lst):\n        missing = list(sorted(set(range(1, n + 1)) - set(lst)))\n        if missing:\n            cand = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n            lst.append(cand)\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        feasible = total_g(cur) >= 67\n        missing = list(sorted(set(range(1, n + 1)) - set(cur)))\n        if len(cur) == 0:\n            add_best(cur)\n            continue\n        if len(cur) == n:\n            # remove worst\n            pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n            cur.pop(pos)\n            continue\n        move = random.choice([\"add\", \"remove\", \"swap\"]) if feasible else random.choices([\"add\",\"swap\",\"remove\"], weights=[0.6,0.3,0.1])[0]\n        if move == \"add\":\n            add_best(cur)\n        elif move == \"remove\":\n            if cur:\n                if feasible:\n                    pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                    tmp = cur[:pos] + cur[pos+1:]\n                    if total_g(tmp) >= 67:\n                        cur = tmp\n                    else:\n                        # repair immediately\n                        add_best(cur)\n                else:\n                    pos = random.randrange(len(cur))\n                    cur.pop(pos)\n        else:  # swap\n            if cur and missing:\n                out_pos = max(range(len(cur)), key=lambda p: prices[cur[p]-1]\/max(1, gallons[cur[p]-1]))\n                in_val = max(missing, key=lambda i: (gallons[i-1]\/prices[i-1], gallons[i-1], -prices[i-1]))\n                cur[out_pos] = in_val\n\n    # Repair to feasibility if needed\n    while total_g(cur) < 67:\n        add_best(cur)\n        if len(cur) == n:\n            break\n\n    # Deduplicate and clamp\n    uniq = []\n    seen2 = set()\n    for v in cur:\n        if isinstance(v, int):\n            iv = v\n            if 1 <= iv <= n and iv not in seen2:\n                seen2.add(iv)\n                uniq.append(iv)\n    return uniq\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighbour generator for INDEX_LIST representation.\n    Returns (neighbour_solution, movement_type).\n    movement_type in {\"add\",\"remove\",\"swap\",\"repair_add\",\"repair_swap\"}\n    \"\"\"\n    # Local problem data (embedded per critical instructions)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _totals(sol: List[int]) -> Tuple[int,int]:\n        t = 0\n        s = 0\n        for i in sol:\n            t += times[i-1]\n            s += scores[i-1]\n        return t, s\n\n    sol = _normalize(list(solution))\n\n    # Quick handling for empty\n    if not sol:\n        # Add best ratio item to start\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        return ([items[0]], \"add\")\n\n    total_time, _ = _totals(sol)\n\n    # If infeasible, prioritize repair by adding best ratio items or swapping\n    if total_time < 670:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n            # add one best outsider\n            sol.append(outsiders[0])\n            return (_normalize(sol), \"repair_add\")\n        else:\n            # swap random element (should not happen if outsiders empty, but keep safe)\n            idx = random.randrange(len(sol))\n            sol[idx] = random.randint(1, n)\n            return (_normalize(sol)), \"repair_swap\"\n\n    # Feasible: choose move among add\/remove\/swap with simple cost-awareness\n    move = random.random()\n\n    if move < 0.34:\n        # REMOVE: try removing worst ratio (highest score\/time) while staying feasible\n        if len(sol) > 1:\n            # rank insiders by decreasing score\/time, tie by smaller time impact\n            insiders = list(sol)\n            insiders.sort(key=lambda i: (-(scores[i-1]\/times[i-1]), times[i-1]))\n            for cand in insiders:\n                new_sol = [x for x in sol if x != cand]\n                new_time, _ = _totals(new_sol)\n                if new_time >= 670:\n                    return (_normalize(new_sol), \"remove\")\n        # fallback: random remove and then repair if infeasible\n        if len(sol) > 1:\n            new_sol = list(sol)\n            new_sol.pop(random.randrange(len(new_sol)))\n            # If infeasible, add best ratio outsider to repair\n            t, _ = _totals(new_sol)\n            if t < 670:\n                outsiders = [i for i in range(1, n+1) if i not in new_sol]\n                if outsiders:\n                    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(outsiders[0])\n            return (_normalize(new_sol), \"remove\")\n\n    elif move < 0.67:\n        # SWAP: try cost-improving 1-for-1 swap with outsiders by ratio\n        insiders = list(sol)\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            # pick worst insider and best outsider by ratio\n            worst_in = max(insiders, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            pos = new_sol.index(worst_in)\n            new_sol[pos] = best_out\n            # ensure feasibility\n            t, _ = _totals(new_sol)\n            if t < 670:\n                # add next best outsider if needed\n                remaining = [o for o in outsiders if o != best_out]\n                if remaining:\n                    remaining.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(remaining[0])\n            return (_normalize(new_sol), \"swap\")\n\n    # ADD: add best ratio outsider\n    outsiders = [i for i in range(1, n+1) if i not in sol]\n    if outsiders:\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        sol.append(outsiders[0])\n        return (_normalize(sol), \"add\")\n\n    # If no outsiders, perform a random swap within to change composition minimally\n    if len(sol) >= 2:\n        i, j = random.sample(range(len(sol)), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n    return (_normalize(sol), \"swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: greedy rebuild from best ratio, random removals, and refill.\n    Returns a valid INDEX_LIST solution.\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def greedy_build() -> List[int]:\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        sel: List[int] = []\n        tsum = 0\n        for i in items:\n            sel.append(i)\n            tsum += times[i-1]\n            if tsum >= 670:\n                break\n        return sel\n\n    base = greedy_build()\n\n    # Random shake: remove r items\n    if base:\n        r = random.randint(1, min(3, max(1, len(base)\/\/2)))\n        for _ in range(r):\n            if base:\n                base.pop(random.randrange(len(base)))\n\n    # Refill by best outsiders by ratio until feasible, then optionally one extra random add\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i-1] for i in sol)\n\n    t = total_time(base)\n    for i in outsiders:\n        if t >= 670:\n            break\n        base.append(i)\n        t += times[i-1]\n\n    # Small extra shake with probability\n    if random.random() < 0.5 and outsiders:\n        extra = [i for i in range(1, n+1) if i not in base]\n        if extra:\n            base.append(random.choice(extra))\n\n    # Deduplicate and bound\n    uniq = []\n    seen = set()\n    for i in base:\n        if 1 <= i <= n and i not in seen:\n            seen.add(i)\n            uniq.append(i)\n\n    return uniq\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        # Linear penalty scaled by deficit, plus base large penalty to dominate objective\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighbour generator for INDEX_LIST representation.\n    Returns (neighbour_solution, movement_type). movement_type in {\"add\",\"remove\",\"swap\",\"repair_add\",\"repair_swap\"}\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out: List[int] = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _totals(sol: List[int]) -> Tuple[int, int]:\n        t = 0\n        s = 0\n        for i in sol:\n            t += times[i-1]\n            s += scores[i-1]\n        return t, s\n\n    sol = _normalize(list(solution))\n\n    # Handle empty start: seed with best (score\/time, then higher time)\n    if not sol:\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        return ([items[0]], \"add\")\n\n    total_time, _ = _totals(sol)\n\n    # If infeasible, repair by adding low score\/time outsiders until feasible\n    if total_time < 670:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n            new_sol = list(sol)\n            for cand in outsiders:\n                new_sol.append(cand)\n                t, _ = _totals(new_sol)\n                if t >= 670:\n                    return (_normalize(new_sol), \"repair_add\")\n            return (_normalize(new_sol), \"repair_add\")\n        # Fallback: targeted swap to increase time\n        insiders = list(sol)\n        if insiders:\n            worst_in = max(insiders, key=lambda i: scores[i-1]\/times[i-1])\n            outsiders_full = [i for i in range(1, n+1) if i not in sol]\n            if outsiders_full:\n                best_out = min(outsiders_full, key=lambda i: scores[i-1]\/times[i-1])\n                new_sol = list(sol)\n                pos = new_sol.index(worst_in)\n                new_sol[pos] = best_out\n                return (_normalize(new_sol), \"repair_swap\")\n        return (_normalize(sol), \"repair_swap\")\n\n    # Feasible: probabilistically choose a move\n    move = random.random()\n\n    # REMOVE: try removing by smallest (time per score saved) while staying feasible\n    if move < 0.34:\n        insiders = list(sol)\n        # Rank by increasing time per score to remove cost-effectively\n        insiders.sort(key=lambda i: (times[i-1]\/max(1, scores[i-1]), scores[i-1], -times[i-1]))\n        for cand in insiders:\n            new_sol = [x for x in sol if x != cand]\n            new_time, _ = _totals(new_sol)\n            if new_time >= 670:\n                return (_normalize(new_sol), \"remove\")\n        # Fallback: no safe removal; try a mild improving swap\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            worst_in = max(sol, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            new_sol[new_sol.index(worst_in)] = best_out\n            return (_normalize(new_sol), \"swap\")\n        return (_normalize(sol), \"swap\")\n\n    # SWAP: 1-for-1 guided by ratio; ensure feasibility; if infeasible, add best outsider\n    elif move < 0.67:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            worst_in = max(sol, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            pos = new_sol.index(worst_in)\n            new_sol[pos] = best_out\n            t, _ = _totals(new_sol)\n            if t < 670:\n                # Add next best outsider by ratio prioritizing time\n                remaining = [o for o in outsiders if o != best_out]\n                if remaining:\n                    remaining.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(remaining[0])\n            return (_normalize(new_sol), \"swap\")\n        return (_normalize(sol), \"swap\")\n\n    # ADD: add best outsider by ratio\n    outsiders = [i for i in range(1, n+1) if i not in sol]\n    if outsiders:\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        new_sol = list(sol)\n        new_sol.append(outsiders[0])\n        return (_normalize(new_sol), \"add\")\n\n    # If no outsiders, perform a within-swap to diversify\n    if len(sol) >= 2:\n        i, j = random.sample(range(len(sol)), 2)\n        new_sol = list(sol)\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (_normalize(new_sol), \"swap\")\n\n    return (_normalize(sol), \"swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for INDEX_LIST: randomly drop 1-2 items (if possible), then greedily refill\n    with items of lowest score\/time ratio until feasibility is restored. May add one extra random item\n    with small probability to promote diversification.\n    Returns a valid INDEX_LIST solution (deduplicated, 1-based indices within 1..24).\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    # Normalize input\n    def norm(sol: List[int]) -> List[int]:\n        seen = set()\n        out: List[int] = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    base = norm(list(solution))\n\n    # Randomly drop r items\n    if base:\n        r = 1 if len(base) == 1 else random.randint(1, min(2, len(base)))\n        for _ in range(r):\n            if base:\n                base.pop(random.randrange(len(base)))\n\n    # Greedy refill by increasing score\/time and prioritizing higher time on tie\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n\n    def total_time(sol: List[int]) -> int:\n        t = 0\n        for i in sol:\n            t += times[i-1]\n        return t\n\n    t = total_time(base)\n    for i in outsiders:\n        if t >= 670:\n            break\n        base.append(i)\n        t += times[i-1]\n\n    # Small extra random add with probability 0.3 if any outsiders remain\n    if random.random() < 0.3:\n        extra = [i for i in range(1, n+1) if i not in base]\n        if extra:\n            base.append(random.choice(extra))\n\n    # Deduplicate and bound\n    return norm(base)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Validate type\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    # Validate bounds and uniqueness\n    n = 24\n    indices = solution\n    if any(i < 1 or i > n for i in indices):\n        return 10**12\n    if len(set(indices)) != len(indices):\n        return 10**12\n\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for i in indices:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        # Linear penalty scaled by deficit, plus base large penalty to dominate objective\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighbour generator for INDEX_LIST representation.\n    Returns (neighbour_solution, movement_type). movement_type in {\"add\",\"remove\",\"swap\",\"repair_add\",\"repair_swap\"}\n    \"\"\"\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def normalize(sol):\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def totals(sol):\n        t = 0\n        s = 0\n        for i in sol:\n            t += times[i-1]\n            s += scores[i-1]\n        return t, s\n\n    sol = normalize(list(solution))\n\n    # If empty, seed with greedy cover of minimal marginal score until feasible\n    if not sol:\n        items = list(range(1, n+1))\n        # sort by increasing score\/time then by decreasing time\n        items.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        new_sol = []\n        total_t = 0\n        for i in items:\n            new_sol.append(i)\n            total_t += times[i-1]\n            if total_t >= 670:\n                return (normalize(new_sol), \"repair_add\")\n        return (normalize(new_sol), \"repair_add\")\n\n    total_time, _ = totals(sol)\n\n    # If infeasible, repair by adding minimal marginal score to reach boundary\n    if total_time < 670:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        # prioritize low score\/time and higher time\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        new_sol = list(sol)\n        t = total_time\n        for cand in outsiders:\n            new_sol.append(cand)\n            t += times[cand-1]\n            if t >= 670:\n                return (normalize(new_sol), \"repair_add\")\n        return (normalize(new_sol), \"repair_add\")\n\n    # Feasible neighborhood moves\n    move_r = random.random()\n\n    # REMOVE: try removing an item with best time per score while staying feasible\n    if move_r < 0.34:\n        insiders = list(sol)\n        # Rank by increasing time per score (cheap score reduction with minimal time loss)\n        insiders.sort(key=lambda i: (times[i-1]\/max(1, scores[i-1]), scores[i-1], -times[i-1]))\n        for cand in insiders:\n            new_sol = [x for x in sol if x != cand]\n            new_time, _ = totals(new_sol)\n            if new_time >= 670:\n                return (normalize(new_sol), \"remove\")\n        # fallback to swap if no safe removal\n        move_r = 0.5  # force swap branch\n\n    # SWAP (1-1 exchange): replace worst ratio insider with best ratio outsider, ensure feasibility\n    if 0.34 <= move_r < 0.67:\n        outsiders = [i for i in range(1, n+1) if i not in sol]\n        if outsiders:\n            worst_in = max(sol, key=lambda i: scores[i-1]\/times[i-1])\n            best_out = min(outsiders, key=lambda i: scores[i-1]\/times[i-1])\n            new_sol = list(sol)\n            pos = new_sol.index(worst_in)\n            new_sol[pos] = best_out\n            t, _ = totals(new_sol)\n            if t < 670:\n                # add next best outsider by ratio prioritizing time if needed\n                remaining = [o for o in outsiders if o != best_out]\n                if remaining:\n                    remaining.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n                    new_sol.append(remaining[0])\n            return (normalize(new_sol), \"swap\")\n        # if no outsiders, drop to add branch\n        move_r = 0.9\n\n    # ADD: add best outsider by ratio (low score\/time, then higher time)\n    outsiders = [i for i in range(1, n+1) if i not in sol]\n    if outsiders:\n        outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n        new_sol = list(sol)\n        new_sol.append(outsiders[0])\n        return (normalize(new_sol), \"add\")\n\n    # If no outsiders, keep as is\n    return (normalize(sol), \"swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for INDEX_LIST: drop 1-2 worst-ratio insiders (if any), then greedily refill\n    with items of lowest score\/time ratio until feasibility is restored. May add one extra random item\n    with small probability to promote diversification.\n    Returns a valid INDEX_LIST solution (deduplicated, 1-based indices within 1..24).\n    \"\"\"\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def normalize(sol):\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol):\n        t = 0\n        for i in sol:\n            t += times[i-1]\n        return t\n\n    base = normalize(list(solution))\n\n    # Drop 1-2 worst ratio insiders\n    if base:\n        drop_k = 1 if len(base) == 1 else random.randint(1, min(2, len(base)))\n        ranked = sorted(base, key=lambda i: scores[i-1]\/times[i-1], reverse=True)\n        to_drop = set(ranked[:drop_k])\n        base = [i for i in base if i not in to_drop]\n\n    # Greedy refill by increasing score\/time and prioritizing higher time on tie\n    outsiders = [i for i in range(1, n+1) if i not in base]\n    outsiders.sort(key=lambda i: (scores[i-1]\/times[i-1], -times[i-1]))\n\n    t = total_time(base)\n    for i in outsiders:\n        if t >= 670:\n            break\n        base.append(i)\n        t += times[i-1]\n\n    # Small extra random add with probability 0.3 if any outsiders remain\n    if random.random() < 0.3:\n        extra = [i for i in range(1, n+1) if i not in base]\n        if extra:\n            base.append(random.choice(extra))\n\n    return normalize(base)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST; list of unique 1-based indices in [1..24].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Type validation\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return float(10**12)\n\n    n = 24\n    # Bounds and uniqueness\n    if any(i < 1 or i > n for i in solution):\n        return float(10**12)\n    if len(set(solution)) != len(solution):\n        return float(10**12)\n\n    total_time = 0\n    total_score = 0\n    for i in solution:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    if total_time < 670:\n        deficit = 670 - total_time\n        return float(total_score + 10**9 + deficit * 10**6)\n\n    return float(total_score)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel: List[int]) -> List[int]:\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        # maintain order but unique\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def greedy_repair(sel: List[int]) -> List[int]:\n        # Only repair with some probability to allow controlled infeasibility exploration\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        # Lexicographic key: score\/time, score, -time\n        avail.sort(key=lambda i: (scores[i-1] \/ times[i-1], scores[i-1], -times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n    if not cur:\n        # Initialize by adding one random item then repair\n        add = random.randint(1, n)\n        nb = greedy_repair([add])\n        return sanitize(nb), \"INDEX_LIST\", \"init_add_repair\"\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    # Candidate pools\n    in_set = list(cur)\n    out_set = [i for i in range(1, n+1) if i not in cur]\n\n    if move_r < 0.20 and len(in_set) >= 2 and len(out_set) >= 1:\n        # 2->1 exchange: drop two, add one\n        a, b = random.sample(in_set, 2)\n        c = random.choice(out_set)\n        nb = [i for i in cur if i not in (a, b)] + [c]\n        move_type = \"exchange_2_1\"\n    elif move_r < 0.40 and len(in_set) >= 1 and len(out_set) >= 2:\n        # 1->2 exchange: drop one, add two\n        a = random.choice(in_set)\n        b, c = random.sample(out_set, 2)\n        nb = [i for i in cur if i != a] + [b, c]\n        move_type = \"exchange_1_2\"\n    elif move_r < 0.60 and in_set and out_set:\n        # 1-1 swap\n        a = random.choice(in_set)\n        b = random.choice(out_set)\n        nb = [i for i in cur if i != a] + [b]\n        move_type = \"swap_1_1\"\n    elif move_r < 0.80 and out_set:\n        # Add\n        b = random.choice(out_set)\n        nb = cur + [b]\n        move_type = \"add\"\n    else:\n        # Targeted remove or time-tightening: remove worst score\/time if feasible after removal; else fallback swap\n        if in_set:\n            # sort by descending score\/time then score to drop high-cost per time\n            order = sorted(in_set, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in cur if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = \"remove_tighten\"\n                    break\n            else:\n                # fallback: swap\n                if out_set:\n                    a = random.choice(in_set)\n                    b = random.choice(out_set)\n                    nb = [i for i in cur if i != a] + [b]\n                    move_type = \"swap_fallback\"\n                else:\n                    nb = list(cur)\n                    move_type = \"noop\"\n        else:\n            nb = list(cur)\n            move_type = \"noop\"\n\n    # With small probability, repair to feasibility to avoid drifting too far\n    if random.random() < 0.5:\n        nb = greedy_repair(nb)\n\n    nb = sanitize(nb)\n    return nb, \"INDEX_LIST\", move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel: List[int]) -> int:\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel: List[int]) -> List[int]:\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def repair(sel: List[int]) -> List[int]:\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n\n    # Intensity: random number of composite edits\n    m = random.randint(3, 7)\n    sel = set(cur)\n\n    for _ in range(m):\n        r = random.random()\n        if r < 0.33 and sel:\n            # remove random\n            rem = random.choice(list(sel))\n            sel.remove(rem)\n        elif r < 0.66:\n            # add random\n            candidates = [i for i in range(1, n+1) if i not in sel]\n            if candidates:\n                sel.add(random.choice(candidates))\n        else:\n            # targeted swap: replace worst score\/time with a random outsider\n            if sel:\n                worst = max(sel, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                outsiders = [i for i in range(1, n+1) if i not in sel]\n                if outsiders:\n                    sel.remove(worst)\n                    sel.add(random.choice(outsiders))\n\n    nb = sorted(list(sel))\n    nb = repair(nb)\n\n    # Light pruning: drop items (highest score\/time first) while keeping feasibility\n    changed = True\n    while changed and nb:\n        changed = False\n        order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n        for i in order:\n            trial = [j for j in nb if j != i]\n            if total_time(trial) >= 670:\n                nb = trial\n                changed = True\n                break\n\n    return nb\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Type validation\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return float(10**12)\n\n    n = 24\n    # Bounds and uniqueness\n    if any(i < 1 or i > n for i in solution):\n        return float(10**12)\n    if len(set(solution)) != len(solution):\n        return float(10**12)\n\n    total_time = 0\n    total_score = 0\n    for i in solution:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    if total_time < 670:\n        deficit = 670 - total_time\n        return float(total_score + 10**9 + deficit * 10**6)\n\n    return float(total_score)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Representation: INDEX_LIST (list of unique 1-based indices in [1..24])\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel):\n        return sum(times[i-1] for i in sel)\n\n    def total_score(sel):\n        return sum(scores[i-1] for i in sel)\n\n    def sanitize(sel):\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def greedy_construct():\n        # Deterministic feasible constructor: add items by ascending (score\/time, score, time)\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        sel = []\n        cur_t = 0\n        for i in order:\n            sel.append(i)\n            cur_t += times[i-1]\n            if cur_t >= 670:\n                break\n        # Light pruning: remove items with worst score\/time while keeping feasibility\n        changed = True\n        while changed and sel:\n            changed = False\n            order_drop = sorted(sel, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for j in order_drop:\n                trial = [k for k in sel if k != j]\n                if total_time(trial) >= 670:\n                    sel = trial\n                    changed = True\n                    break\n        return sel\n\n    def greedy_repair(sel):\n        cur_t = total_time(sel)\n        if cur_t >= 670:\n            return sel\n        deficit = 670 - cur_t\n        avail = [i for i in range(1, n+1) if i not in sel]\n        # Prefer low score\/time, then low score, then low time\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n    if not cur:\n        nb = greedy_construct()\n        return nb, \"INDEX_LIST\", \"init_greedy_construct\"\n\n    in_set = list(cur)\n    out_set = [i for i in range(1, n+1) if i not in cur]\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    # Slack-aware moves\n    cur_time = total_time(cur)\n\n    if move_r < 0.18 and len(in_set) >= 2 and len(out_set) >= 1:\n        # 2->1 exchange\n        a, b = random.sample(in_set, 2)\n        c = random.choice(out_set)\n        nb = [i for i in cur if i not in (a, b)] + [c]\n        move_type = \"exchange_2_1\"\n    elif move_r < 0.36 and len(in_set) >= 1 and len(out_set) >= 2:\n        # 1->2 exchange\n        a = random.choice(in_set)\n        b, c = random.sample(out_set, 2)\n        nb = [i for i in cur if i != a] + [b, c]\n        move_type = \"exchange_1_2\"\n    elif move_r < 0.54 and in_set and out_set:\n        # 1-1 swap\n        a = random.choice(in_set)\n        b = random.choice(out_set)\n        nb = [i for i in cur if i != a] + [b]\n        move_type = \"swap_1_1\"\n    elif move_r < 0.72 and out_set:\n        # Add\n        b = random.choice(out_set)\n        nb = cur + [b]\n        move_type = \"add\"\n    else:\n        # Feasibility-preserving removal: drop high score\/time if feasible after removal\n        nb = list(cur)\n        if in_set:\n            order = sorted(in_set, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in cur if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = \"remove_tighten\"\n                    break\n            else:\n                # fallback targeted swap based on slack\n                if out_set:\n                    if cur_time < 670:\n                        # prefer adding low ratio\n                        add = min(out_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n                        rem = max(in_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                    else:\n                        add = min(out_set, key=lambda i: (scores[i-1], scores[i-1]\/times[i-1], times[i-1]))\n                        rem = max(in_set, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                    nb = [i for i in cur if i != rem] + [add]\n                    move_type = \"swap_targeted\"\n                else:\n                    move_type = \"noop\"\n\n    # State-dependent repair probability\n    nb_time = total_time(nb)\n    if nb_time < 670:\n        deficit = 670 - nb_time\n        # Probability increases with deficit; ensure within [0.0, 1.0]\n        p_repair = max(0.2, min(1.0, deficit \/ 200.0))\n        if random.random() < p_repair:\n            nb = greedy_repair(nb)\n    else:\n        # Optional light prune to reduce cost while keeping feasibility (small chance)\n        if random.random() < 0.25 and nb:\n            # Try remove a single worst ratio item if feasible\n            order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n            for rem in order:\n                trial = [j for j in nb if j != rem]\n                if total_time(trial) >= 670:\n                    nb = trial\n                    move_type = move_type + \"+prune1\"\n                    break\n\n    nb = sanitize(nb)\n    return nb, \"INDEX_LIST\", move_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel):\n        return sum(times[i-1] for i in sel)\n\n    def sanitize(sel):\n        sel = [i for i in sel if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        out = []\n        for i in sel:\n            if i not in seen:\n                out.append(i)\n                seen.add(i)\n        return out\n\n    def repair(sel):\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n+1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n\n    # If empty or grossly infeasible, construct a deterministic feasible base\n    if not cur or total_time(cur) < 200:\n        # Greedy construct\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], times[i-1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i-1]\n            if t >= 670:\n                break\n        cur = sel\n\n    sel = set(cur)\n    # Intensity: 3 to 7 composite edits\n    m = random.randint(3, 7)\n\n    for _ in range(m):\n        r = random.random()\n        if r < 0.33 and sel:\n            # remove random\n            rem = random.choice(list(sel))\n            sel.remove(rem)\n        elif r < 0.66:\n            # add random outsider\n            candidates = [i for i in range(1, n+1) if i not in sel]\n            if candidates:\n                sel.add(random.choice(candidates))\n        else:\n            # targeted swap: replace worst score\/time with a random outsider\n            if sel:\n                worst = max(sel, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                outsiders = [i for i in range(1, n+1) if i not in sel]\n                if outsiders:\n                    sel.remove(worst)\n                    sel.add(random.choice(outsiders))\n\n    nb = sorted(list(sel))\n    nb = repair(nb)\n\n    # Light multi-step pruning: repeatedly drop highest ratio items while feasible\n    changed = True\n    while changed and nb:\n        changed = False\n        order = sorted(nb, key=lambda i: (-scores[i-1]\/times[i-1], -scores[i-1]))\n        for i in order:\n            trial = [j for j in nb if j != i]\n            if total_time(trial) >= 670:\n                nb = trial\n                changed = True\n                break\n\n    return nb\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Type validation\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**12\n\n    n = 24\n    # Bounds and uniqueness\n    if any(i < 1 or i > n for i in solution):\n        return 10**12\n    if len(set(solution)) != len(solution):\n        return 10**12\n\n    total_time = 0\n    total_score = 0\n    for i in solution:\n        total_time += times[i - 1]\n        total_score += scores[i - 1]\n\n    # Constraint: total_time >= 670\n    if total_time < 670:\n        deficit = 670 - total_time\n        return total_score + 10**9 + deficit * 10**6\n\n    # Feasible: fitness equals objective (minimize)\n    return total_score\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Representation: INDEX_LIST (list of unique 1-based indices in [1..24])\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    def total_time(sel):\n        return sum(times[i - 1] for i in sel)\n\n    def sanitize(sel):\n        out = []\n        seen = set()\n        for i in sel:\n            if isinstance(i, int) and 1 <= i <= n and i not in seen:\n                out.append(i)\n                seen.add(i)\n        out.sort()\n        return out\n\n    def greedy_construct():\n        order = list(range(1, n + 1))\n        order.sort(key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], times[i - 1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i - 1]\n            if t >= 670:\n                break\n        return sel\n\n    def greedy_repair(sel):\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n + 1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], times[i - 1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    cur = sanitize(list(solution))\n    if not cur:\n        nb = sanitize(greedy_construct())\n        return nb, 'INDEX_LIST'\n\n    in_set = list(cur)\n    out_set = [i for i in range(1, n + 1) if i not in cur]\n\n    r = random.random()\n    # Basic diversified move set\n    if r < 0.34 and in_set and out_set:\n        # 1-1 swap\n        a = random.choice(in_set)\n        b = random.choice(out_set)\n        nb = [i for i in cur if i != a] + [b]\n    elif r < 0.67 and out_set:\n        # add\n        nb = cur + [random.choice(out_set)]\n    else:\n        # prune worst ratio if feasible\n        nb = list(cur)\n        if in_set:\n            worst = max(in_set, key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], -times[i - 1]))\n            trial = [j for j in cur if j != worst]\n            if total_time(trial) >= 670:\n                nb = trial\n\n    if total_time(nb) < 670:\n        nb = greedy_repair(nb)\n\n    nb = sanitize(nb)\n    return nb, 'INDEX_LIST'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times =  [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sel):\n        return sum(times[i - 1] for i in sel)\n\n    def repair(sel):\n        if total_time(sel) >= 670:\n            return sel\n        avail = [i for i in range(1, n + 1) if i not in sel]\n        avail.sort(key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], times[i - 1]))\n        for i in avail:\n            sel.append(i)\n            if total_time(sel) >= 670:\n                break\n        return sel\n\n    sol = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    sol = sorted(set(sol))\n\n    if not sol or total_time(sol) < 200:\n        # Greedy construct a feasible base\n        order = list(range(1, n + 1))\n        order.sort(key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], times[i - 1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i - 1]\n            if t >= 670:\n                break\n        sol = sel\n\n    k = max(1, len(sol) \/\/ 5)\n\n    # Try to drop up to k high-ratio items if feasibility is preserved\n    for _ in range(k):\n        if not sol:\n            break\n        worst = max(sol, key=lambda i: (scores[i - 1] \/ times[i - 1], scores[i - 1], -times[i - 1]))\n        trial = [x for x in sol if x != worst]\n        if total_time(trial) >= 670:\n            sol = trial\n\n    # Add up to k random outsiders\n    avail = [i for i in range(1, n + 1) if i not in sol]\n    random.shuffle(avail)\n    for i in avail[:k]:\n        sol.append(i)\n\n    # Final repair to ensure feasibility\n    sol = repair(sol)\n\n    sol = sorted(set(sol))\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    # Accepts empty string for empty set\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None:\n        return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n    sol_str = solution.strip()\n    if sol_str == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != \"\"]\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    return float(total_score) + (float(total_time) * 1e-6)\n","Vecindad":"import random\nfrom typing import List\n\n\ndef _nb_parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= 24:\n                out.append(v)\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _nb_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution, movement_type)\n    n = 24\n    all_indices = set(range(1, n + 1))\n    curr = _nb_parse_sol(solution)\n    curr_set = set(curr)\n\n    move_r = random.random()\n    move_type = \"noop\"\n\n    if move_r < 0.34:\n        # ADD\n        missing = list(all_indices - curr_set)\n        if missing:\n            add_i = random.choice(missing)\n            curr.append(add_i)\n            move_type = \"add\"\n    elif move_r < 0.68:\n        # REMOVE\n        if curr:\n            rem_i = random.choice(curr)\n            curr.remove(rem_i)\n            move_type = \"remove\"\n    else:\n        # SWAP\n        present = list(curr)\n        missing = list(all_indices - curr_set)\n        if present and missing:\n            rem_i = random.choice(present)\n            add_i = random.choice(missing)\n            curr.remove(rem_i)\n            curr.append(add_i)\n            move_type = \"swap\"\n        elif not present:\n            # degrade to add\n            add_i = random.randint(1, n)\n            curr.append(add_i)\n            move_type = \"add\"\n\n    encoded = _nb_encode_sol(curr)\n    return encoded, move_type\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef _pert_parse_sol(sol_str: str) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= 24:\n                out.append(v)\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _pert_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef perturb_solution(solution):\n    # Stronger random shake: apply k random add\/remove\/swap moves\n    n = 24\n    k = random.randint(3, 6)\n    curr = _pert_parse_sol(solution)\n    all_idx = set(range(1, n + 1))\n\n    for _ in range(k):\n        curr_set = set(curr)\n        r = random.random()\n        if r < 0.33:\n            # add\n            missing = list(all_idx - curr_set)\n            if missing:\n                curr.append(random.choice(missing))\n        elif r < 0.66:\n            # remove\n            if curr:\n                rem = random.choice(curr)\n                curr.remove(rem)\n        else:\n            # swap\n            present = list(curr)\n            missing = list(all_idx - curr_set)\n            if present and missing:\n                rem = random.choice(present)\n                add = random.choice(missing)\n                curr.remove(rem)\n                curr.append(add)\n    return _pert_encode_sol(curr)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    # Accepts empty string for empty set\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None:\n        return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n    sol_str = solution.strip()\n    if sol_str == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != \"\"]\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness (consistent policy)\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    return float(total_score) + (float(total_time) * 1e-6)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helpers kept internal to this module\n\ndef _nb_parse_sol(sol_str: str, n: int) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out: List[int] = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        except Exception:\n            return []\n    # ensure ascending unique\n    return sorted(set(out))\n\n\ndef _nb_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef _compute_totals(idx_list: List[int], scores: List[int], times: List[int]) -> Tuple[int, int]:\n    total_s = 0\n    total_t = 0\n    for i in idx_list:\n        j = i - 1\n        total_s += scores[j]\n        total_t += times[j]\n    return total_s, total_t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # State-aware stochastic neighbourhood for INDEX_LIST_ASC_CSV\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    curr = _nb_parse_sol(solution, n)\n    all_idx = list(range(1, n + 1))\n    present = set(curr)\n    missing = [i for i in all_idx if i not in present]\n\n    total_s, total_t = _compute_totals(curr, scores, times)\n\n    # Precompute ratios for guidance\n    ratio = {i: (scores[i-1] \/ max(1, times[i-1])) for i in all_idx}\n\n    move_type = \"noop\"\n    new_list = list(curr)\n\n    if total_t < TIME_REQ:\n        # Infeasible: bias towards ADD of lowest score\/time\n        if missing:\n            missing_sorted = sorted(missing, key=lambda i: (ratio[i], scores[i-1], -times[i-1]))\n            # With 70% choose best, else random among top 5\n            pick_pool = missing_sorted[:min(5, len(missing_sorted))]\n            add_i = random.choice(pick_pool) if random.random() < 0.3 else pick_pool[0]\n            new_list.append(add_i)\n            move_type = \"add-guided\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Feasible: try DROP that keeps feasibility and reduces score\n        droppable = []\n        for i in curr:\n            t_after = total_t - times[i-1]\n            if t_after >= TIME_REQ:\n                droppable.append(i)\n        if droppable and random.random() < 0.6:\n            # Drop the worst by score\/time (i.e., highest score per time) or highest score\n            drop_sorted = sorted(droppable, key=lambda i: (-ratio[i], -scores[i-1], times[i-1]))\n            pick_pool = drop_sorted[:min(5, len(drop_sorted))]\n            rem_i = random.choice(pick_pool) if random.random() < 0.3 else pick_pool[0]\n            new_list.remove(rem_i)\n            move_type = \"remove-guided\"\n        else:\n            # Try 1-1 swap to reduce score while maintaining feasibility\n            improved = False\n            if curr and missing:\n                cand_present = sorted(curr, key=lambda i: (ratio[i], scores[i-1]))\n                cand_missing = sorted(missing, key=lambda i: (ratio[i], scores[i-1]))\n                # Try a few random pairs favoring lower ratio additions\n                trials = 10\n                for _ in range(trials):\n                    i_rem = random.choice(cand_present[:min(6, len(cand_present))])\n                    i_add = random.choice(cand_missing[:min(6, len(cand_missing))])\n                    t_after = total_t - times[i_rem-1] + times[i_add-1]\n                    s_after = total_s - scores[i_rem-1] + scores[i_add-1]\n                    if t_after >= TIME_REQ and s_after <= total_s:\n                        new_list.remove(i_rem)\n                        new_list.append(i_add)\n                        move_type = \"swap1-1\"\n                        improved = True\n                        break\n            if not improved:\n                # Fallback random small move\n                r = random.random()\n                if r < 0.5 and missing:\n                    new_list.append(random.choice(missing))\n                    move_type = \"add\"\n                elif new_list:\n                    rem = random.choice(new_list)\n                    new_list.remove(rem)\n                    move_type = \"remove\"\n\n    encoded = _nb_encode_sol(new_list)\n    return encoded, move_type\n","Perturbacion":"import random\nfrom typing import List\n\n# Helpers duplicated locally to keep function self-contained\n\ndef _pert_parse_sol(sol_str: str, n: int) -> List[int]:\n    if sol_str is None or not isinstance(sol_str, str):\n        return []\n    s = sol_str.strip()\n    if s == \"\":\n        return []\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    out: List[int] = []\n    for p in parts:\n        try:\n            v = int(p)\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        except Exception:\n            return []\n    return sorted(set(out))\n\n\ndef _pert_encode_sol(idx_list: List[int]) -> str:\n    if not idx_list:\n        return \"\"\n    return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n\ndef perturb_solution(solution):\n    # Stronger shake with greedy repair to maintain\/restore feasibility\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    curr = _pert_parse_sol(solution, n)\n    present = set(curr)\n    all_idx = set(range(1, n + 1))\n\n    # Randomly drop 1\u20133 items with lowest time contributions (to shake but not destroy feasibility too much)\n    k = random.randint(1, 3)\n    by_time = sorted(curr, key=lambda i: times[i-1])\n    drops = by_time[:min(k, len(by_time))]\n    for d in drops:\n        if d in curr:\n            curr.remove(d)\n    present = set(curr)\n\n    # Greedy refill by ascending score\/time until feasible\n    total_time = sum(times[i-1] for i in curr)\n    if total_time < TIME_REQ:\n        missing = list(all_idx - present)\n        ratio_sorted = sorted(missing, key=lambda i: (scores[i-1] \/ max(1, times[i-1]), scores[i-1], -times[i-1]))\n        for i in ratio_sorted:\n            curr.append(i)\n            total_time += times[i-1]\n            if total_time >= TIME_REQ:\n                break\n\n    return _pert_encode_sol(curr)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_ASC_CSV","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation: comma-separated ascending list of unique indices in [1,24]\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Parse solution string to list of ints\n    if solution is None or not isinstance(solution, str):\n        return float('inf')\n    s = solution.strip()\n    if s == \"\":\n        idx_list: List[int] = []\n    else:\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        try:\n            idx_list = [int(p) for p in parts]\n        except Exception:\n            return float('inf')\n\n    # Basic validations\n    if any(i < 1 or i > n for i in idx_list):\n        return float('inf')\n    if len(idx_list) != len(set(idx_list)):\n        return float('inf')\n\n    # Compute score and time\n    total_score = 0\n    total_time = 0\n    for i in idx_list:\n        j = i - 1\n        total_score += scores[j]\n        total_time += times[j]\n\n    # Feasibility and fitness\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n    # Feasible: minimize score; tie-break by time\n    return float(total_score) + (float(total_time) * 1e-6)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Self-contained neighbour generator for INDEX_LIST_ASC_CSV\n    # Returns: (encoded_solution_str, move_type)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    def _parse(sol_str):\n        if sol_str is None or not isinstance(sol_str, str):\n            return []\n        s = sol_str.strip()\n        if s == \"\":\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n            except Exception:\n                return []\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        # ascending unique\n        return sorted(set(out))\n\n    def _encode(idx_list):\n        if not idx_list:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n    def _totals(idx_list):\n        ts = 0\n        tt = 0\n        for i in idx_list:\n            j = i - 1\n            ts += scores[j]\n            tt += times[j]\n        return ts, tt\n\n    # Precompute guidance metrics\n    all_idx = list(range(1, n + 1))\n    ratio = {i: (scores[i-1] \/ max(1, times[i-1])) for i in all_idx}  # score per time\n\n    curr = _parse(solution)\n    present = set(curr)\n    missing = [i for i in all_idx if i not in present]\n\n    total_s, total_t = _totals(curr)\n\n    move_type = \"noop\"\n    new_list = list(curr)\n\n    if total_t < TIME_REQ:\n        # Infeasible: add item(s) that give large time per unit score: minimize ratio, tie-break by larger time then smaller score\n        if missing:\n            deficit = TIME_REQ - total_t\n            # Candidates sorted by desirability\n            miss_sorted = sorted(missing, key=lambda i: (ratio[i], -times[i-1], scores[i-1]))\n            # Widen pool as deficit shrinks to increase diversification\n            pool_size = max(3, min(8, len(miss_sorted)))\n            pick = miss_sorted[0] if random.random() < 0.7 else random.choice(miss_sorted[:pool_size])\n            new_list.append(pick)\n            move_type = \"add-guided\"\n    else:\n        # Feasible: prefer dropping items that keep feasibility and reduce score\n        safety_margin = 0  # can be tuned to avoid oscillation\n        droppable = [i for i in curr if (total_t - times[i-1]) >= (TIME_REQ + safety_margin)]\n        if droppable and random.random() < 0.6:\n            # Drop the highest score with lowest time contribution first\n            drop_sorted = sorted(droppable, key=lambda i: (-scores[i-1], times[i-1], ratio[i]))\n            candidate_pool = drop_sorted[:min(6, len(drop_sorted))]\n            rem = candidate_pool[0] if random.random() < 0.7 else random.choice(candidate_pool)\n            new_list.remove(rem)\n            move_type = \"remove-guided\"\n        else:\n            # Try 1-1 swap to keep feasibility and not worsen score; pick improving or equal-score-better-time\n            improved = False\n            if curr and missing:\n                # Favor adding good time per score; consider limited top-k sets\n                pres_sorted = sorted(curr, key=lambda i: (scores[i-1], -times[i-1]))\n                miss_sorted = sorted(missing, key=lambda i: (ratio[i], -times[i-1], scores[i-1]))\n                k = min(8, len(pres_sorted))\n                m = min(8, len(miss_sorted))\n                best_pair = None\n                best_delta = math.inf\n                for i_rem in pres_sorted[:k]:\n                    for i_add in miss_sorted[:m]:\n                        t_after = total_t - times[i_rem-1] + times[i_add-1]\n                        if t_after < TIME_REQ:\n                            continue\n                        s_after = total_s - scores[i_rem-1] + scores[i_add-1]\n                        # Primary: reduce score; secondary: reduce time\n                        delta = (s_after - total_s) + (t_after - total_t) * 1e-6\n                        if delta < best_delta:\n                            best_delta = delta\n                            best_pair = (i_rem, i_add)\n                if best_pair is not None and best_delta <= 0:\n                    new_list.remove(best_pair[0])\n                    new_list.append(best_pair[1])\n                    move_type = \"swap1-1\"\n                    improved = True\n            if not improved:\n                # Small random move for diversification\n                r = random.random()\n                if r < 0.5 and missing:\n                    new_list.append(random.choice(missing))\n                    move_type = \"add\"\n                elif new_list:\n                    rem = random.choice(new_list)\n                    if (total_t - times[rem-1]) >= TIME_REQ:  # avoid breaking feasibility too much\n                        new_list.remove(rem)\n                        move_type = \"remove\"\n                    else:\n                        # fallback no-op if removal breaks feasibility hard\n                        move_type = \"noop\"\n\n    encoded = _encode(new_list)\n    return encoded, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong shake + greedy repair for INDEX_LIST_ASC_CSV\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190, 80,140,200,220,160,130, 50, 40,220,230, 90,220, 60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    def _parse(sol_str):\n        if sol_str is None or not isinstance(sol_str, str):\n            return []\n        s = sol_str.strip()\n        if s == \"\":\n            return []\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n            except Exception:\n                return []\n            if 1 <= v <= n:\n                out.append(v)\n            else:\n                return []\n        return sorted(set(out))\n\n    def _encode(idx_list):\n        if not idx_list:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(set(idx_list)))\n\n    curr = _parse(solution)\n    present = set(curr)\n    all_idx = set(range(1, n + 1))\n\n    # Decide shake strength proportional to solution size\n    k = max(1, len(curr) \/\/ 4)\n    if curr:\n        # Drop k items with lowest time utility (small time per unit score -> higher ratio first is worse, but we want to keep good ones)\n        # Here we drop by smallest time to preserve feasibility helpers\n        by_utility = sorted(curr, key=lambda i: (times[i-1]\/max(1, scores[i-1]), -times[i-1], scores[i-1]))\n        drops = by_utility[:min(k, len(by_utility))]\n        for d in drops:\n            if d in curr:\n                curr.remove(d)\n    present = set(curr)\n\n    # Greedy repair: if infeasible, add items minimizing score\/time and maximizing time\n    total_time = sum(times[i-1] for i in curr)\n    if total_time < TIME_REQ:\n        missing = list(all_idx - present)\n        add_sorted = sorted(missing, key=lambda i: (scores[i-1] \/ max(1, times[i-1]), -times[i-1], scores[i-1]))\n        for i in add_sorted:\n            curr.append(i)\n            total_time += times[i-1]\n            if total_time >= TIME_REQ:\n                break\n    else:\n        # If feasible, try a small additional random modification (swap or remove safe)\n        missing = list(all_idx - present)\n        if random.random() < 0.5 and missing:\n            # swap one\n            i_add = random.choice(missing)\n            i_rem = random.choice(curr)\n            if (total_time - times[i_rem-1] + times[i_add-1]) >= TIME_REQ:\n                curr.remove(i_rem)\n                curr.append(i_add)\n        else:\n            # safe remove if keeps feasible\n            if curr:\n                cand = [i for i in curr if (total_time - times[i-1]) >= TIME_REQ]\n                if cand:\n                    curr.remove(random.choice(cand))\n\n    return _encode(curr)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible cost (negative total value); lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG = 10**9\n    if solution is None:\n        return float(BIG)\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.isdigit() and p[0] != '-'):\n            return float(BIG)\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return float(BIG)\n        idxs.append(idx)\n    if len(set(idxs)) != len(idxs):\n        return float(BIG)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return float(BIG)\n        total_v += values[idx]\n    return float(-total_v)\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic first-improvement with feasibility; falls back to heuristic random move.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_to_set(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.isdigit() and p[0] != '-'):\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def weight_of(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_to_set(solution)\n    curr_w = weight_of(items)\n    curr_v = sum(values[i] for i in items)\n\n    all_idxs = range(1, 25)\n    not_in = [i for i in all_idxs if i not in items]\n\n    # 1) Try best improving ADD (by value density then value)\n    add_cands = [i for i in not_in if curr_w + weights[i] <= CAP]\n    if add_cands:\n        add_cands.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n        best_add = add_cands[0]\n        # Any ADD increases value => improves cost\n        new_items = set(items)\n        new_items.add(best_add)\n        return (to_str(new_items), \"ADD\")\n\n    # 2) Try best improving SWAP (first-improvement by highest delta value)\n    if items:\n        best_pair = None\n        best_delta_v = 0  # require positive improvement\n        for o in items:\n            for i in not_in:\n                new_w = curr_w - weights[o] + weights[i]\n                if new_w <= CAP:\n                    delta_v = values[i] - values[o]\n                    if delta_v > best_delta_v:\n                        best_delta_v = delta_v\n                        best_pair = (o, i)\n        if best_pair is not None:\n            o, i = best_pair\n            new_items = set(items)\n            new_items.remove(o)\n            new_items.add(i)\n            return (to_str(new_items), \"SWAP\")\n\n    # 3) If no improving move, do a diversification: remove lowest-density item if any\n    if items:\n        worst = min(items, key=lambda i: (values[i]\/weights[i], values[i]))\n        new_items = set(items)\n        new_items.remove(worst)\n        return (to_str(new_items), \"REMOVE\")\n\n    # 4) From empty: add best ratio item that fits\n    best_fit = None\n    best_key = None\n    for i in all_idxs:\n        if weights[i] <= CAP:\n            key = (values[i]\/weights[i], values[i])\n            if best_key is None or key > best_key:\n                best_key = key\n                best_fit = i\n    if best_fit is not None:\n        return (str(best_fit), \"ADD\")\n\n    # Fallback: no feasible items\n    return (\"\", \"RESET\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Capacity-preserving multi-step perturbation: drop low-ratio items, then add high-ratio items.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_to_set(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        items = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.isdigit() and p[0] != '-'):\n                continue\n            idx = int(p)\n            if 1 <= idx <= 24:\n                items.add(idx)\n        return items\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def total_weight(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_to_set(solution)\n\n    if not items:\n        # Seed with a decent greedy start\n        candidates = [i for i in range(1,25) if weights[i] <= CAP]\n        candidates.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n        curr = []\n        curr_w = 0\n        for i in candidates:\n            if curr_w + weights[i] <= CAP:\n                curr.append(i)\n                curr_w += weights[i]\n        return to_str(set(curr))\n\n    # Drop k in {1,2} lowest-density items (if available)\n    k = 1 if len(items) == 1 else random.choice([1,2])\n    if items:\n        sorted_items = sorted(list(items), key=lambda i: (values[i]\/weights[i], values[i]))\n        to_drop = sorted_items[:min(k, len(sorted_items))]\n        for d in to_drop:\n            items.remove(d)\n\n    # Greedy refill with high-ratio items\n    curr_w = total_weight(items)\n    add_pool = [i for i in range(1,25) if i not in items]\n    add_pool.sort(key=lambda i: (values[i]\/weights[i], values[i]), reverse=True)\n    for i in add_pool:\n        if curr_w + weights[i] <= CAP:\n            items.add(i)\n            curr_w += weights[i]\n        if curr_w == CAP:\n            break\n\n    return to_str(items)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible: return negative total value for feasible solutions; lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG = 10**9\n    if solution is None:\n        return float(BIG)\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.isdigit() and p[0] != '-'):\n            return float(BIG)\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return float(BIG)\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return float(BIG)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return float(BIG)\n        total_v += values[idx]\n    return float(-total_v)\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Multi-exchange neighbourhood with strict parsing; always returns a feasible neighbour when possible.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return None\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return None\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return None\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return None\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def w(items_set):\n        return sum(weights[i] for i in items_set)\n\n    def v(items_set):\n        return sum(values[i] for i in items_set)\n\n    items = parse_strict(solution)\n    if items is None:\n        # Invalid input -> reset to empty\n        items = set()\n    curr_w = w(items)\n    curr_v = v(items)\n\n    all_idxs = list(range(1,25))\n    not_in = [i for i in all_idxs if i not in items]\n\n    # Helper: randomized tie-breaking key for ratio-based sorts\n    def ratio_key(i):\n        return (values[i]\/weights[i], values[i], random.random())\n\n    # 1) Try best ADD by ratio that fits\n    add_cands = [i for i in not_in if curr_w + weights[i] <= CAP]\n    if add_cands:\n        add_cands.sort(key=ratio_key, reverse=True)\n        i = add_cands[0]\n        new = set(items)\n        new.add(i)\n        return (to_str(new), \"ADD\")\n\n    # 2) Try improving 1-1 SWAP (feasible and increases value)\n    best_pair = None\n    best_delta = 0\n    for o in items:\n        for i in not_in:\n            if curr_w - weights[o] + weights[i] <= CAP:\n                dv = values[i] - values[o]\n                if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                    best_delta = dv\n                    best_pair = (o, i)\n    if best_pair is not None and best_delta > 0:\n        o, i = best_pair\n        new = set(items)\n        new.remove(o)\n        new.add(i)\n        return (to_str(new), \"SWAP_1_1\")\n\n    # 3) Try 1-2 SWAP: remove one, add two\n    best_trip = None\n    best_delta = 0\n    if len(not_in) >= 2 and len(items) >= 1:\n        # Limit candidate list for efficiency using top-L by ratio\n        L = min(10, len(not_in))\n        cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n        for o in items:\n            for i1 in range(len(cand_add)):\n                a = cand_add[i1]\n                for i2 in range(i1+1, len(cand_add)):\n                    b = cand_add[i2]\n                    new_w = curr_w - weights[o] + weights[a] + weights[b]\n                    if new_w <= CAP:\n                        dv = values[a] + values[b] - values[o]\n                        if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                            best_delta = dv\n                            best_trip = (o, a, b)\n    if best_trip is not None and best_delta > 0:\n        o, a, b = best_trip\n        new = set(items)\n        new.remove(o)\n        new.add(a)\n        new.add(b)\n        return (to_str(new), \"SWAP_1_2\")\n\n    # 4) Try 2-1 SWAP: remove two, add one\n    best_move = None\n    best_delta = 0\n    if len(items) >= 2 and len(not_in) >= 1:\n        L = min(10, len(not_in))\n        cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n        it_list = list(items)\n        for i in cand_add:\n            for a_idx in range(len(it_list)):\n                a = it_list[a_idx]\n                for b_idx in range(a_idx+1, len(it_list)):\n                    b = it_list[b_idx]\n                    new_w = curr_w - weights[a] - weights[b] + weights[i]\n                    if new_w <= CAP:\n                        dv = values[i] - values[a] - values[b]\n                        if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                            best_delta = dv\n                            best_move = (i, a, b)\n    if best_move is not None and best_delta > 0:\n        i, a, b = best_move\n        new = set(items)\n        new.discard(a)\n        new.discard(b)\n        new.add(i)\n        return (to_str(new), \"SWAP_2_1\")\n\n    # 5) Diversification: remove lowest-density item if any, else add best fitting single (from empty)\n    if items:\n        worst = min(items, key=lambda i: (values[i]\/weights[i], values[i], random.random()))\n        new = set(items)\n        new.remove(worst)\n        return (to_str(new), \"REMOVE_WORST\")\n\n    # From empty: add best ratio single if any fits\n    best_fit = None\n    best_key = None\n    for i in all_idxs:\n        if weights[i] <= CAP:\n            k = (values[i]\/weights[i], values[i])\n            if best_key is None or k > best_key:\n                best_key = k\n                best_fit = i\n    if best_fit is not None:\n        return (str(best_fit), \"SEED_ADD\")\n\n    return (\"\", \"RESET\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Destroy-repair with variable strength and GRASP-style refill; maintains feasibility.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return set()\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return set()\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return set()\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def total_weight(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_strict(solution)\n\n    # If empty, seed with greedy RCL\n    if not items:\n        # GRASP construction\n        capacity = CAP\n        candidates = [i for i in range(1,25) if weights[i] <= capacity]\n        # RCL parameter\n        alpha = 0.2\n        sol_set = set()\n        curr_w = 0\n        while True:\n            feas = [i for i in candidates if i not in sol_set and curr_w + weights[i] <= capacity]\n            if not feas:\n                break\n            ratios = [values[i]\/weights[i] for i in feas]\n            rmin, rmax = min(ratios), max(ratios)\n            threshold = rmax - alpha*(rmax - rmin)\n            rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n            choice = random.choice(rcl)\n            sol_set.add(choice)\n            curr_w += weights[choice]\n        return to_str(sol_set)\n\n    # Destroy: remove k random items biased towards low ratio\n    k = min(len(items), random.choice([1,1,2,3]))\n    if k > 0:\n        pool = sorted(list(items), key=lambda i: (values[i]\/weights[i], values[i]))\n        remove_set = set(random.sample(pool[:max(1, min(len(pool), 5))], k=min(k, max(1, min(len(pool), 5)))))\n        items.difference_update(remove_set)\n\n    # Repair: GRASP refill with RCL\n    curr_w = total_weight(items)\n    alpha = 0.3\n    while True:\n        feas = [i for i in range(1,25) if i not in items and curr_w + weights[i] <= CAP]\n        if not feas:\n            break\n        ratios = [values[i]\/weights[i] for i in feas]\n        rmin, rmax = min(ratios), max(ratios)\n        threshold = rmax - alpha*(rmax - rmin)\n        rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n        choice = random.choice(rcl)\n        items.add(choice)\n        curr_w += weights[choice]\n        if curr_w == CAP:\n            break\n\n    return to_str(items)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices in [1..24]; empty string \"\" denotes empty set. Example: \"8,4,18\".","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Minimization-compatible: return negative total value for feasible solutions; lower is better.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    BIG = 10**9\n    if solution is None:\n        return float(BIG)\n    s = str(solution).strip()\n    if s == \"\":\n        return 0.0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.isdigit() and p[0] != '-'):\n            return float(BIG)\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return float(BIG)\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return float(BIG)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return float(BIG)\n        total_v += values[idx]\n    return float(-total_v)\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_type_str)\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return None\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return None\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return None\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return None\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def w(items_set):\n        return sum(weights[i] for i in items_set)\n\n    def v(items_set):\n        return sum(values[i] for i in items_set)\n\n    items = parse_strict(solution)\n    if items is None:\n        items = set()\n    curr_w = w(items)\n    curr_v = v(items)\n\n    all_idxs = list(range(1,25))\n    not_in = [i for i in all_idxs if i not in items]\n\n    # Helper keys\n    def ratio_key(i):\n        return (values[i]\/weights[i], values[i], random.random())\n\n    # Randomly select neighborhood class to avoid bias\n    moves_order = [\"ADD\", \"SWAP_1_1\", \"SWAP_1_2\", \"SWAP_2_1\", \"REMOVE_WORST\"]\n    random.shuffle(moves_order)\n\n    for mv in moves_order:\n        if mv == \"ADD\":\n            add_cands = [i for i in not_in if curr_w + weights[i] <= CAP]\n            if add_cands:\n                add_cands.sort(key=ratio_key, reverse=True)\n                i = add_cands[0]\n                new = set(items)\n                new.add(i)\n                return (to_str(new), \"ADD\")\n        elif mv == \"SWAP_1_1\":\n            best_pair = None\n            best_delta = -math.inf\n            for o in items:\n                for i in not_in:\n                    if curr_w - weights[o] + weights[i] <= CAP:\n                        dv = values[i] - values[o]\n                        if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                            best_delta = dv\n                            best_pair = (o, i)\n            if best_pair is not None and best_delta > 0:\n                o, i = best_pair\n                new = set(items)\n                new.remove(o)\n                new.add(i)\n                return (to_str(new), \"SWAP_1_1\")\n        elif mv == \"SWAP_1_2\":\n            if len(not_in) >= 2 and len(items) >= 1:\n                L = max(10, len(not_in))  # broaden search to avoid missing improvements\n                cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n                best_trip = None\n                best_delta = -math.inf\n                for o in items:\n                    for i1 in range(len(cand_add)):\n                        a = cand_add[i1]\n                        for i2 in range(i1+1, len(cand_add)):\n                            b = cand_add[i2]\n                            new_w = curr_w - weights[o] + weights[a] + weights[b]\n                            if new_w <= CAP:\n                                dv = values[a] + values[b] - values[o]\n                                if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                                    best_delta = dv\n                                    best_trip = (o, a, b)\n                if best_trip is not None and best_delta > 0:\n                    o, a, b = best_trip\n                    new = set(items)\n                    new.remove(o)\n                    new.add(a)\n                    new.add(b)\n                    return (to_str(new), \"SWAP_1_2\")\n        elif mv == \"SWAP_2_1\":\n            if len(items) >= 2 and len(not_in) >= 1:\n                it_list = list(items)\n                L = max(10, len(not_in))\n                cand_add = sorted(not_in, key=ratio_key, reverse=True)[:L]\n                best_move = None\n                best_delta = -math.inf\n                for i in cand_add:\n                    for a_idx in range(len(it_list)):\n                        a = it_list[a_idx]\n                        for b_idx in range(a_idx+1, len(it_list)):\n                            b = it_list[b_idx]\n                            new_w = curr_w - weights[a] - weights[b] + weights[i]\n                            if new_w <= CAP:\n                                dv = values[i] - values[a] - values[b]\n                                if dv > best_delta or (dv == best_delta and random.random() < 0.5):\n                                    best_delta = dv\n                                    best_move = (i, a, b)\n                if best_move is not None and best_delta > 0:\n                    i, a, b = best_move\n                    new = set(items)\n                    new.discard(a)\n                    new.discard(b)\n                    new.add(i)\n                    return (to_str(new), \"SWAP_2_1\")\n        elif mv == \"REMOVE_WORST\":\n            if items:\n                worst = min(items, key=lambda i: (values[i]\/weights[i], values[i], random.random()))\n                new = set(items)\n                new.remove(worst)\n                return (to_str(new), \"REMOVE_WORST\")\n\n    # If no move found, seed from empty with best ratio item\n    best_fit = None\n    best_key = None\n    for i in range(1,25):\n        if weights[i] <= CAP:\n            k = (values[i]\/weights[i], values[i])\n            if best_key is None or k > best_key:\n                best_key = k\n                best_fit = i\n    if best_fit is not None:\n        return (str(best_fit), \"SEED_ADD\")\n    return (\"\", \"RESET\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Destroy-repair with GRASP-style refill; maintains feasibility.\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse_strict(sol):\n        if sol is None:\n            return set()\n        s = str(sol).strip()\n        if s == \"\":\n            return set()\n        parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n        items = []\n        for p in parts:\n            if not (p.isdigit() and p[0] != '-'):\n                return set()\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return set()\n            items.append(idx)\n        if len(set(items)) != len(items):\n            return set()\n        return set(items)\n\n    def to_str(items_set):\n        return \",\".join(str(i) for i in sorted(items_set))\n\n    def total_weight(items_set):\n        return sum(weights[i] for i in items_set)\n\n    items = parse_strict(solution)\n\n    # If empty, seed with GRASP construction\n    if not items:\n        capacity = CAP\n        candidates = [i for i in range(1,25) if weights[i] <= capacity]\n        alpha = 0.25\n        sol_set = set()\n        curr_w = 0\n        while True:\n            feas = [i for i in candidates if i not in sol_set and curr_w + weights[i] <= capacity]\n            if not feas:\n                break\n            ratios = [values[i]\/weights[i] for i in feas]\n            rmin, rmax = min(ratios), max(ratios)\n            threshold = rmax - alpha*(rmax - rmin)\n            rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n            choice = random.choice(rcl)\n            sol_set.add(choice)\n            curr_w += weights[choice]\n        return to_str(sol_set)\n\n    # Destroy: remove k random items biased to low ratio\n    k = min(len(items), random.choice([1,1,2]))\n    if k > 0 and items:\n        pool = sorted(list(items), key=lambda i: (values[i]\/weights[i], values[i]))\n        take = min(len(pool), max(1, min(5, len(pool))))\n        remove_set = set(random.sample(pool[:take], k=min(k, take)))\n        items.difference_update(remove_set)\n\n    # Repair: GRASP refill\n    curr_w = total_weight(items)\n    alpha = 0.3\n    while True:\n        feas = [i for i in range(1,25) if i not in items and curr_w + weights[i] <= CAP]\n        if not feas:\n            break\n        ratios = [values[i]\/weights[i] for i in feas]\n        rmin, rmax = min(ratios), max(ratios)\n        threshold = rmax - alpha*(rmax - rmin)\n        rcl = [i for i in feas if (values[i]\/weights[i]) >= threshold]\n        choice = random.choice(rcl)\n        items.add(choice)\n        curr_w += weights[choice]\n        if curr_w == CAP:\n            break\n\n    return to_str(items)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices string denoting selected items, e.g., \"18,4,8\". Order is arbitrary; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated indices string, e.g., \"8,4,18\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-' )):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        idxs.append(idx)\n    # 0\/1 constraint: no duplicates\n    if len(set(idxs)) != len(idxs):\n        return NEG\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple: (new_solution_str, NB_Type, Movement_Type)\n    NB_Type: \"index_list\"\n    Movement_Type in {\"add\",\"remove\",\"swap\",\"two_out_one_in\",\"one_out_two_in\"}\n    Always attempts to return a feasible neighbor under CAP=9.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                return []\n            idx = int(p)\n            if 1 <= idx <= 24 and idx not in seen:\n                S.append(idx)\n                seen.add(idx)\n            else:\n                return []\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n    current_w = total_weight(S)\n\n    # Precompute feasible add candidates\n    add_candidates = [i for i in range(1, 25) if (i not in S) and (current_w + weights[i] <= CAP)]\n\n    moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n    random.shuffle(moves)\n\n    # Try each move type; return on first feasible change\n    for move in moves:\n        if move == \"add\":\n            if add_candidates:\n                i = random.choice(add_candidates)\n                S2 = S + [i]\n                return to_str(S2), \"index_list\", \"add\"\n        elif move == \"remove\":\n            if S:\n                i = random.choice(S)\n                S2 = [x for x in S if x != i]\n                return to_str(S2), \"index_list\", \"remove\"\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                remaining_w = current_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (remaining_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S2 = [x for x in S if x != out_i] + [in_i]\n                    return to_str(S2), \"index_list\", \"swap\"\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                # Try a few random pairs\n                tried = 0\n                S_set = set(S)\n                while tried < 10:\n                    out_i = random.choice(S)\n                    out_j = random.choice(S)\n                    if out_i == out_j:\n                        tried += 1\n                        continue\n                    remaining_w = current_w - weights[out_i] - weights[out_j]\n                    if remaining_w < 0:\n                        tried += 1\n                        continue\n                    candidates = [k for k in range(1, 25) if (k not in S_set) and (remaining_w + weights[k] <= CAP)]\n                    if candidates:\n                        in_k = random.choice(candidates)\n                        S2 = [x for x in S if x not in (out_i, out_j)] + [in_k]\n                        return to_str(S2), \"index_list\", \"two_out_one_in\"\n                    tried += 1\n        elif move == \"one_out_two_in\":\n            if len(S) >= 1:\n                out_i = random.choice(S)\n                remaining_w = current_w - weights[out_i]\n                # Build list of items not in S\n                pool = [k for k in range(1, 25) if k not in S]\n                # Try randomized pairs up to a cap\n                attempts = 0\n                while attempts < 25:\n                    if len(pool) < 2:\n                        break\n                    a, b = random.sample(pool, 2)\n                    if remaining_w + weights[a] + weights[b] <= CAP:\n                        S2 = [x for x in S if x != out_i] + [a, b]\n                        return to_str(S2), \"index_list\", \"one_out_two_in\"\n                    attempts += 1\n    # Fallbacks to ensure a neighbor is returned\n    if add_candidates:\n        i = random.choice(add_candidates)\n        return to_str(S + [i]), \"index_list\", \"add\"\n    if S:\n        i = random.choice(S)\n        return to_str([x for x in S if x != i]), \"index_list\", \"remove\"\n    # As absolute last resort, pick a random single feasible item\n    singles = [i for i in range(1, 25) if weights[i] <= CAP]\n    if singles:\n        return str(random.choice(singles)), \"index_list\", \"add\"\n    return \"\", \"index_list\", \"remove\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-move feasible perturbation (shake). Returns a new feasible solution string.\n    Applies 2-5 random edits among {add, remove, swap, two_out_one_in, one_out_two_in} while respecting capacity.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not p.isdigit():\n                return []\n            idx = int(p)\n            if 1 <= idx <= 24 and idx not in seen:\n                S.append(idx)\n                seen.add(idx)\n            else:\n                return []\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in S)\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n\n    k = random.randint(2, 5)\n    for _ in range(k):\n        cur_w = total_weight(S)\n        moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n        move = random.choice(moves)\n\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if (i not in S) and (cur_w + weights[i] <= CAP)]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move == \"remove\":\n            if S:\n                out_i = random.choice(S)\n                S = [x for x in S if x != out_i]\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S = [x for x in S if x != out_i] + [in_i]\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                out_i = random.choice(S)\n                out_j = random.choice(S)\n                if out_i != out_j:\n                    rem_w = cur_w - weights[out_i] - weights[out_j]\n                    if rem_w >= 0:\n                        candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                        if candidates:\n                            in_i = random.choice(candidates)\n                            S = [x for x in S if x not in (out_i, out_j)] + [in_i]\n        elif move == \"one_out_two_in\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                pool = [k for k in range(1, 25) if k not in S]\n                if len(pool) >= 2:\n                    random.shuffle(pool)\n                    done = False\n                    for a in pool:\n                        if done:\n                            break\n                        for b in pool:\n                            if a == b:\n                                continue\n                            if rem_w + weights[a] + weights[b] <= CAP:\n                                S = [x for x in S if x != out_i] + [a, b]\n                                done = True\n                                break\n    # Deduplicate and canonicalize\n    S = list(dict.fromkeys(S))\n    # Ensure feasibility (drop random items if needed)\n    while total_weight(S) > CAP and S:\n        S.pop(random.randrange(len(S)))\n    return to_str(S)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique item indices string denoting selected items, e.g., \"4,8,18\". Order is canonicalized ascending; duplicates invalid. Empty string \"\" denotes selecting no items. Capacity constraint enforced internally (sum of weights <= 9).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated indices string, e.g., \"8,4,18\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    seen = set()\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        if idx in seen:\n            return NEG\n        seen.add(idx)\n        idxs.append(idx)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += weights[idx]\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple: (new_solution_str, movement_type)\n    movement_type in {\"add\",\"remove\",\"swap\",\"two_out_one_in\",\"one_out_two_in\"}\n    Always returns a feasible neighbour under CAP=9, canonicalized ascending.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values =  [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return []\n            if idx in seen:\n                return []\n            S.append(idx)\n            seen.add(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    def feasible_after_add(S, i):\n        return (i not in S) and (total_weight(S) + weights[i] <= CAP)\n\n    def ratio(i):\n        return values[i] \/ weights[i]\n\n    S = parse(solution)\n    cur_w = total_weight(S)\n\n    # Precompute candidate pools\n    remaining = [i for i in range(1, 25) if i not in S]\n    add_candidates = [i for i in remaining if cur_w + weights[i] <= CAP]\n\n    # Try best-improvement add by ratio\n    if add_candidates:\n        best_i = max(add_candidates, key=lambda i: (ratio(i), values[i]))\n        S2 = S + [best_i]\n        return to_str(S2), \"add\"\n\n    # Try best swap: enumerate 1-out-1-in within capacity, choose best gain in value\n    best_gain = -math.inf\n    best_swap = None\n    for out in S:\n        w_after = cur_w - weights[off := out]\n        for inn in remaining:\n            if w_after + weights[inn] <= CAP:\n                gain = values[inn] - values[out]\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (out, inn)\n    if best_swap is not None and best_gain >= 0:\n        out, inn = best_swap\n        S2 = [x for x in S if x != out] + [inn]\n        return to_str(S2), \"swap\"\n\n    # If no non-worsening swap, try remove the lowest value\/weight ratio item to free space\n    if S:\n        worst = min(S, key=lambda i: (ratio(i), values[i]))\n        S2 = [x for x in S if x != worst]\n        return to_str(S2), \"remove\"\n\n    # If empty and no add feasible (shouldn't happen given singles exist), return empty\n    return \"\", \"remove\"","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Multi-move feasible perturbation (shake). Returns a new feasible solution string.\n    Applies 2-4 random edits among {add, remove, swap, two_out_one_in, one_out_two_in} while respecting capacity.\n    Canonicalizes result and enforces feasibility by dropping random items if overweight.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return []\n            if idx in seen:\n                return []\n            S.append(idx)\n            seen.add(idx)\n        return S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    S = parse(solution)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        cur_w = total_weight(S)\n        moves = [\"add\", \"remove\", \"swap\", \"two_out_one_in\", \"one_out_two_in\"]\n        move = random.choice(moves)\n\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if (i not in S) and (cur_w + weights[i] <= CAP)]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move == \"remove\":\n            if S:\n                S.pop(random.randrange(len(S)))\n        elif move == \"swap\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                if candidates:\n                    in_i = random.choice(candidates)\n                    S = [x for x in S if x != out_i] + [in_i]\n        elif move == \"two_out_one_in\":\n            if len(S) >= 2:\n                out_i, out_j = random.sample(S, 2)\n                rem_w = cur_w - weights[out_i] - weights[out_j]\n                if rem_w >= 0:\n                    candidates = [i for i in range(1, 25) if (i not in S) and (rem_w + weights[i] <= CAP)]\n                    if candidates:\n                        in_i = random.choice(candidates)\n                        S = [x for x in S if x not in (out_i, out_j)] + [in_i]\n        elif move == \"one_out_two_in\":\n            if S:\n                out_i = random.choice(S)\n                rem_w = cur_w - weights[out_i]\n                pool = [k for k in range(1, 25) if k not in S]\n                if len(pool) >= 2:\n                    random.shuffle(pool)\n                    done = False\n                    for a in pool:\n                        if done:\n                            break\n                        for b in pool:\n                            if a == b:\n                                continue\n                            if rem_w + weights[a] + weights[b] <= CAP:\n                                S = [x for x in S if x != out_i] + [a, b]\n                                done = True\n                                break\n    # Deduplicate and canonicalize\n    S = list(dict.fromkeys(S))\n    # Ensure feasibility (drop random items if needed)\n    while total_weight(S) > CAP and S:\n        S.pop(random.randrange(len(S)))\n    return to_str(S)","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated unique ascending indices string of selected items, e.g., \"4,8,18\". Empty string \"\" denotes no items. Feasibility: total weight \u2264 9; indices in 1..24; no duplicates. Canonicalization to ascending order is enforced by components.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a 0\/1 knapsack solution encoded as a comma-separated indices string.\n    Returns total value if feasible, otherwise a large negative number (NEG).\n    Constraints: indices in 1..24, no duplicates, total weight <= 9.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n    NEG = -10**9\n    if solution is None:\n        return NEG\n    s = str(solution).strip()\n    if s == \"\":\n        return 0\n    parts = [p.strip() for p in s.split(',') if p.strip() != \"\"]\n    idxs = []\n    seen = set()\n    for p in parts:\n        if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n            return NEG\n        idx = int(p)\n        if idx < 1 or idx > 24:\n            return NEG\n        if idx in seen:\n            return NEG\n        seen.add(idx)\n        idxs.append(idx)\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        w = weights[idx]\n        total_w += w\n        if total_w > CAP:\n            return NEG\n        total_v += values[idx]\n    return total_v\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a feasible neighbour for the knapsack solution string.\n    Returns (new_solution_str, movement_type) where movement_type in\n    {\"add\",\"remove\",\"swap\",\"two_out_one_in\",\"one_out_two_in\",\"noop\"}.\n    Always preserves feasibility (capacity<=9, no duplicates, valid indices) and canonical order.\n    If input is invalid, returns (original_solution_str, \"noop\").\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return False, []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return True, []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return False, []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return False, []\n            if idx in seen:\n                return False, []\n            seen.add(idx)\n            S.append(idx)\n        return True, S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    ok, S = parse(solution)\n    if not ok:\n        return (str(solution).strip(), \"noop\")\n\n    # Current totals\n    cur_w = sum(weights[i] for i in S)\n    # Helper pools\n    in_set = set(S)\n    remaining = [i for i in range(1, 25) if i not in in_set]\n\n    # Build feasible move candidates with delta-evaluation\n    moves = []  # list of tuples (new_S, move_name)\n\n    # add\n    for i in remaining:\n        if cur_w + weights[i] <= CAP:\n            moves.append((sorted(S + [i]), \"add\"))\n\n    # remove\n    for i in S:\n        new_S = [x for x in S if x != i]\n        moves.append((sorted(new_S), \"remove\"))\n\n    # swap (1-out-1-in)\n    for out in S:\n        rem_w = cur_w - weights[out]\n        for inn in remaining:\n            if rem_w + weights[inn] <= CAP:\n                new_S = [x for x in S if x != out] + [inn]\n                moves.append((sorted(new_S), \"swap\"))\n\n    # two_out_one_in\n    if len(S) >= 2:\n        for a_idx in range(len(S)):\n            for b_idx in range(a_idx + 1, len(S)):\n                out_a, out_b = S[a_idx], S[b_idx]\n                rem_w = cur_w - weights[out_a] - weights[out_b]\n                if rem_w < 0:\n                    continue\n                for inn in remaining:\n                    if inn == out_a or inn == out_b:\n                        continue\n                    if rem_w + weights[inn] <= CAP:\n                        new_S = [x for x in S if x not in (out_a, out_b)] + [inn]\n                        moves.append((sorted(new_S), \"two_out_one_in\"))\n\n    # one_out_two_in\n    if len(remaining) >= 2 and len(S) >= 1:\n        for out in S:\n            rem_w = cur_w - weights[out]\n            pool = [i for i in remaining if i != out]\n            for i_idx in range(len(pool)):\n                a = pool[i_idx]\n                for j_idx in range(i_idx + 1, len(pool)):\n                    b = pool[j_idx]\n                    if rem_w + weights[a] + weights[b] <= CAP:\n                        new_S = [x for x in S if x != out] + [a, b]\n                        moves.append((sorted(new_S), \"one_out_two_in\"))\n\n    if not moves:\n        # No feasible neighbor different from current; return canonical current\n        return (to_str(S), \"noop\")\n\n    # Prefer non-worsening by value; break ties randomly\n    cur_v = sum(values[i] for i in S)\n    best_delta = -math.inf\n    best_moves = []\n    for new_S, mname in moves:\n        # compute delta value\n        new_v = sum(values[i] for i in new_S)\n        delta = new_v - cur_v\n        if delta > best_delta:\n            best_delta = delta\n            best_moves = [(new_S, mname)]\n        elif delta == best_delta:\n            best_moves.append((new_S, mname))\n\n    new_S, mname = random.choice(best_moves)\n    return (to_str(new_S), mname)\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Feasibility-preserving k-move perturbation. Removes a few items (worst by value\/weight),\n    then greedily re-adds best ratio items until no more fit. Returns canonical feasible string.\n    If input invalid, returns empty solution.\n    \"\"\"\n    weights = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [0,15,5, 9,20, 5,16, 4,18,14,13,11, 6,24,5, 6,22,23,21,14, 1, 1,11, 1,17]\n    CAP = 9\n\n    def parse(sol_str):\n        if sol_str is None:\n            return False, []\n        s = str(sol_str).strip()\n        if s == \"\":\n            return True, []\n        S = []\n        seen = set()\n        for p in s.split(','):\n            p = p.strip()\n            if p == \"\":\n                continue\n            if not (p.lstrip('-').isdigit() and (p[0] != '-')):\n                return False, []\n            idx = int(p)\n            if not (1 <= idx <= 24):\n                return False, []\n            if idx in seen:\n                return False, []\n            seen.add(idx)\n            S.append(idx)\n        return True, S\n\n    def to_str(S):\n        return \",\".join(str(i) for i in sorted(S))\n\n    def total_weight(S):\n        return sum(weights[i] for i in S)\n\n    def ratio(i):\n        return values[i] \/ weights[i]\n\n    ok, S = parse(solution)\n    if not ok:\n        S = []\n\n    # 1) Randomly decide number of removals (1..min(3, |S|))\n    if S:\n        r = random.randint(1, min(3, len(S)))\n        # Remove worst-by-ratio items preferentially\n        worst = sorted(S, key=lambda i: (ratio(i), values[i]))[:r]\n        S = [x for x in S if x not in worst]\n\n    # 2) Greedy re-add by best ratio until full\n    cur_w = total_weight(S)\n    candidates = [i for i in range(1, 25) if i not in S]\n    # Shuffle to diversify tie-breaking\n    random.shuffle(candidates)\n    candidates.sort(key=lambda i: (ratio(i), values[i]), reverse=True)\n    for i in candidates:\n        w = weights[i]\n        if cur_w + w <= CAP:\n            S.append(i)\n            cur_w += w\n            if cur_w == CAP:\n                break\n\n    # Ensure feasibility (drop worst ratio if overweight due to any bug)\n    while total_weight(S) > CAP and S:\n        worst_i = min(S, key=lambda i: (ratio(i), values[i]))\n        S.remove(worst_i)\n\n    # Deduplicate and return canonical\n    S = sorted(set(S))\n    return to_str(S)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Cost function (minimize): feasible => -total_value; infeasible\/invalid => large positive penalty\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return None, 'EMPTY_TOKEN'\n            if not p.isdigit():\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list_strict(solution)\n    if err is not None:\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        # Penalty proportional to overweight\n        return 1_000_000.0 + (total_w - C) * 1_000.0\n    # Feasible: minimize negative value\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, movement_type). Representation: comma-separated 1-based indices.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(idxs))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    def remaining_capacity(idxs: List[int]) -> int:\n        return C - total_weight(idxs)\n\n    cur = parse_index_list_strict(solution)\n    cur_set = set(cur)\n    all_items = set(range(1, n+1))\n\n    # Choose move with feasibility-aware bias\n    moves = ['add', 'swap', 'remove']\n    rem_cap = remaining_capacity(cur)\n    if rem_cap <= 0 and cur:\n        move = random.choices(moves, weights=[1, 3, 6], k=1)[0]\n    else:\n        move = random.choices(moves, weights=[6, 3, 1], k=1)[0]\n\n    new = list(cur)\n    movement = move\n\n    if move == 'add':\n        candidates = [k for k in (all_items - cur_set) if weights[k-1] <= rem_cap]\n        if candidates:\n            # Prefer high value density among fitting items\n            k = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.append(k)\n        else:\n            # fallback to remove if nothing fits\n            move = 'remove'\n            movement = move\n    if move == 'remove':\n        if new:\n            # Remove lowest value density item to free capacity\n            out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.remove(out)\n        else:\n            movement = 'add'\n    elif move == 'swap':\n        outside = list(all_items - cur_set)\n        if new and outside:\n            # Try a few random swaps to keep feasibility, prefer improving density\n            best_pair = None\n            best_gain = -10**9\n            for _ in range(10):\n                out = random.choice(new)\n                cap_after_remove = rem_cap + weights[out-1]\n                fit_outside = [i for i in outside if weights[i-1] <= cap_after_remove]\n                if not fit_outside:\n                    continue\n                inn = random.choice(fit_outside)\n                gain = values[inn-1] - values[out-1]\n                if gain > best_gain:\n                    best_gain = gain\n                    best_pair = (out, inn)\n            if best_pair is not None:\n                out, inn = best_pair\n                new.remove(out)\n                new.append(inn)\n            else:\n                # fallback to remove to maintain feasibility\n                if new:\n                    out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.remove(out)\n                movement = 'remove'\n        else:\n            movement = 'remove' if new else 'add'\n\n    # Ensure uniqueness and feasibility (constructed to be feasible already)\n    new = sorted(set(new))\n    # Final guard: if somehow overweight, drop worst density items until feasible\n    while total_weight(new) > C and new:\n        worst = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        new.remove(worst)\n    return to_str(new), movement\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger diversification: random removals then greedy re-adds within capacity.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    C = 9\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(idxs))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    cur = parse_index_list_strict(solution)\n    cur = sorted(set(cur))\n\n    # Phase 1: random removals (1..3)\n    r = random.randint(1, 3) if cur else 0\n    for _ in range(r):\n        if not cur:\n            break\n        rem = random.choice(cur)\n        cur.remove(rem)\n\n    # Phase 2: greedy re-adds by value\/weight among light items that fit\n    remaining = C - total_weight(cur)\n    candidates = [i for i in range(1, n+1) if i not in cur and weights[i-1] <= remaining]\n    # sort by density then value\n    candidates.sort(key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        if weights[i-1] <= remaining:\n            cur.append(i)\n            remaining -= weights[i-1]\n        if remaining == 0:\n            break\n\n    cur = sorted(set(cur))\n    # Final feasibility guard\n    while total_weight(cur) > C and cur:\n        worst = min(cur, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        cur.remove(worst)\n\n    return to_str(cur)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (minimize). Feasible => -total_value (lower is better). Infeasible\/invalid => moderate penalty.\n    Representation: comma-separated list of distinct 1-based indices, strictly digits only.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list_strict(solution)\n    if err is not None:\n        return 10000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        return 10000.0 + 1000.0 * float(total_w - C)\n    return -float(total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-preserving neighborhood with add\/remove\/swap moves.\n    Returns: (new_solution_str, movement_type)\n    Representation: comma-separated list of distinct 1-based indices (digits only).\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def remaining_capacity(idxs):\n        return C - total_weight(idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n    cur_set = set(cur)\n    all_items = set(range(1, n+1))\n\n    rem_cap = remaining_capacity(cur)\n\n    # Choose move adaptively\n    if rem_cap <= 0 and cur:\n        move = random.choices(['remove', 'swap', 'add'], weights=[6, 3, 1], k=1)[0]\n    else:\n        move = random.choices(['add', 'swap', 'remove'], weights=[6, 3, 1], k=1)[0]\n\n    new = list(cur)\n    movement = move\n\n    if move == 'add':\n        candidates = [i for i in (all_items - cur_set) if weights[i-1] <= rem_cap]\n        if candidates:\n            # Best by value density then value\n            k = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.append(k)\n        else:\n            movement = 'remove'\n            move = 'remove'\n\n    if move == 'remove':\n        if new:\n            # Remove worst by density then value\n            out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n            new.remove(out)\n        else:\n            movement = 'add'\n\n    elif move == 'swap':\n        outside = sorted(all_items - cur_set)\n        if new and outside:\n            # Deterministic best 1-1 swap under capacity by gain\n            best_pair = None\n            best_gain = -10**9\n            cur_w = total_weight(new)\n            for out in new:\n                cap_after = C - (cur_w - weights[out-1])\n                for inn in outside:\n                    w_in = weights[inn-1]\n                    if w_in <= cap_after:\n                        gain = values[inn-1] - values[out-1]\n                        if gain > best_gain or (gain == best_gain and (values[inn-1]\/w_in) > (values[out-1]\/weights[out-1])):\n                            best_gain = gain\n                            best_pair = (out, inn)\n            if best_pair is not None and (best_gain >= 0 or random.random() < 0.5):\n                out, inn = best_pair\n                new.remove(out)\n                new.append(inn)\n            else:\n                # Fallback: try add if possible else remove\n                candidates = [i for i in outside if weights[i-1] <= rem_cap]\n                if candidates:\n                    inn = max(candidates, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.append(inn)\n                    movement = 'add'\n                elif new:\n                    out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                    new.remove(out)\n                    movement = 'remove'\n        else:\n            if new:\n                out = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                new.remove(out)\n                movement = 'remove'\n            else:\n                movement = 'add'\n\n    # Ensure feasibility by construction; final guard\n    new = sorted(set(new))\n    while total_weight(new) > C and new:\n        worst = min(new, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        new.remove(worst)\n\n    return to_str(new), movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Diversification: random removals (1..3) followed by greedy re-fill by value density within capacity.\n    Returns perturbed solution string in the same representation.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n\n    # Phase 1: random removals\n    r = random.randint(1, 3) if cur else 0\n    for _ in range(r):\n        if not cur:\n            break\n        rem = random.choice(cur)\n        cur.remove(rem)\n\n    # Phase 2: greedy refill by density within remaining capacity\n    remaining = C - total_weight(cur)\n    candidates = [i for i in range(1, n+1) if i not in cur and weights[i-1] <= remaining]\n    candidates.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]), reverse=True)\n    for i in candidates:\n        w = weights[i-1]\n        if w <= remaining:\n            cur.append(i)\n            remaining -= w\n        if remaining == 0:\n            break\n\n    # Final feasibility guard\n    cur = sorted(set(cur))\n    while total_weight(cur) > C and cur:\n        worst = min(cur, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n        cur.remove(worst)\n\n    return to_str(cur)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (minimize). Representation: comma-separated list of distinct 1-based indices (digits only).\n    Feasible => cost = -total_value (lower is better). Infeasible\/invalid => large positive penalty.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return None, 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                return None, 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return None, 'RANGE'\n            if k in seen:\n                return None, 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list_strict(solution)\n    if err is not None:\n        penalties = {\n            'TYPE': 1_000_000.0,\n            'NAN': 1_000_100.0,\n            'RANGE': 1_000_200.0,\n            'DUP': 1_000_300.0,\n        }\n        return penalties.get(err, 1_000_999.0)\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > C:\n        return 1_000_000.0 + 10_000.0 * float(total_w - C)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-preserving neighborhood with add\/remove\/swap and limited 2-opt (remove-2 add-1).\n    Returns: (new_solution_str, movement_type)\n    Representation: comma-separated list of distinct 1-based indices (digits only).\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        # canonical sorted string to stabilize equality checks\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def total_value(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n    cur_set = set(cur)\n    all_items = set(range(1, n+1))\n\n    cur_w = total_weight(cur)\n    rem_cap = C - cur_w\n\n    # Decide move with bias toward fixing infeasibility and filling capacity\n    if rem_cap < 0:\n        move = 'repair'\n    else:\n        move = random.choices(['add', 'swap', 'remove', 'two_opt'], weights=[6, 2, 1, 1], k=1)[0]\n\n    new = list(cur)\n    movement = move\n\n    if move in ('repair', 'remove'):\n        # Remove item(s) with lowest value density until feasible or a single removal for 'remove'\n        def density(i):\n            w = weights[i-1]\n            v = values[i-1]\n            return (v \/ w) if w > 0 else float('inf')\n        while new and total_weight(new) > C:\n            out = min(new, key=lambda i: (density(i), values[i-1]))\n            new.remove(out)\n        if move == 'remove' and total_weight(new) <= C and new:\n            # optional extra light removal to create room for future adds\n            if random.random() < 0.25:\n                out = min(new, key=lambda i: (density(i), values[i-1]))\n                new.remove(out)\n\n    elif move == 'add':\n        # epsilon-greedy among top-k candidates by density then value\n        candidates = [i for i in (all_items - cur_set) if weights[i-1] <= rem_cap]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]), reverse=True)\n            k = min(3, len(candidates))\n            pick = random.choice(candidates[:k])\n            new.append(pick)\n        else:\n            movement = 'remove'\n            if new:\n                out = min(new, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n                new.remove(out)\n\n    elif move == 'swap':\n        outside = sorted(all_items - cur_set)\n        if new and outside:\n            best_pair = None\n            best_gain = -10**9\n            cur_w = total_weight(new)\n            for out in new:\n                cap_after = C - (cur_w - weights[out-1])\n                feas_in = [inn for inn in outside if weights[inn-1] <= cap_after]\n                for inn in feas_in:\n                    gain = values[inn-1] - values[out-1]\n                    if gain > best_gain or (gain == best_gain and (values[inn-1]\/max(1, weights[inn-1])) > (values[out-1]\/max(1, weights[out-1]))):\n                        best_gain = gain\n                        best_pair = (out, inn)\n            if best_pair is not None and (best_gain >= 0 or random.random() < 0.5):\n                out, inn = best_pair\n                new.remove(out)\n                new.append(inn)\n            else:\n                movement = 'add'\n                candidates = [i for i in outside if weights[i-1] <= (C - total_weight(new))]\n                if candidates:\n                    pick = max(candidates, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n                    new.append(pick)\n                elif new:\n                    movement = 'remove'\n                    out = min(new, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n                    new.remove(out)\n\n    elif move == 'two_opt':\n        # Try remove-2 add-1 improvement\n        if len(new) >= 1:\n            cur_w = total_weight(new)\n            outside = list(all_items - set(new))\n            best_change = 0\n            best_action = None  # (remove_list, add_item)\n            # sample up to m pairs to keep it light\n            candidates_out = new[:]\n            random.shuffle(candidates_out)\n            pairs = []\n            for i in range(min(len(candidates_out), 4)):\n                for j in range(i+1, min(len(candidates_out), 6)):\n                    pairs.append((candidates_out[i], candidates_out[j]))\n            random.shuffle(outside)\n            for out1, out2 in pairs[:6]:\n                freed = weights[out1-1] + weights[out2-1]\n                val_lost = values[out1-1] + values[out2-1]\n                cap_after = C - (cur_w - freed)\n                feas_in = [inn for inn in outside if weights[inn-1] <= cap_after]\n                for inn in feas_in[:6]:\n                    gain = values[inn-1] - val_lost\n                    if gain > best_change:\n                        best_change = gain\n                        best_action = ([out1, out2], inn)\n            if best_action is not None and (best_change > 0 or random.random() < 0.3):\n                outs, inn = best_action\n                for o in outs:\n                    if o in new:\n                        new.remove(o)\n                new.append(inn)\n            else:\n                movement = 'add'\n                rem = C - total_weight(new)\n                candidates = [i for i in (all_items - set(new)) if weights[i-1] <= rem]\n                if candidates:\n                    pick = random.choice(sorted(candidates, key=lambda i: (values[i-1]\/max(1, weights[i-1]), values[i-1]), reverse=True)[:3])\n                    new.append(pick)\n\n    # Final feasibility guard\n    new = sorted(set(new))\n    while total_weight(new) > C and new:\n        # remove item with minimum value-loss per unit overweight preference\n        out = min(new, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n        new.remove(out)\n\n    return to_str(new), movement\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Diversification: random removals (1..3) followed by stochastic greedy refill by value density within capacity.\n    Returns perturbed solution string in the same representation.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    C = 9\n    n = len(values)\n\n    def parse_index_list_strict(sol):\n        if not isinstance(sol, str):\n            return []\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '' or (not p.isdigit()):\n                continue\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n        return idxs\n\n    def to_str(idxs):\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    cur = sorted(set(parse_index_list_strict(solution)))\n\n    # Phase 1: random removals\n    r = random.randint(1, 3) if cur else 0\n    for _ in range(r):\n        if not cur:\n            break\n        rem = random.choice(cur)\n        cur.remove(rem)\n\n    # Ensure feasibility in case input was infeasible\n    while total_weight(cur) > C and cur:\n        # remove lowest density item\n        rem = min(cur, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n        cur.remove(rem)\n\n    # Phase 2: stochastic greedy refill by density within remaining capacity\n    remaining = C - total_weight(cur)\n    candidates = [i for i in range(1, n+1) if i not in cur and weights[i-1] <= remaining]\n    candidates.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]), reverse=True)\n    while remaining > 0 and candidates:\n        top_k = candidates[:min(3, len(candidates))]\n        i = random.choice(top_k)\n        w = weights[i-1]\n        if w <= remaining:\n            cur.append(i)\n            remaining -= w\n        candidates = [j for j in candidates if j != i and weights[j-1] <= remaining]\n        candidates.sort(key=lambda j: (values[j-1] \/ max(1, weights[j-1]), values[j-1]), reverse=True)\n\n    # Final feasibility guard\n    cur = sorted(set(cur))\n    while total_weight(cur) > C and cur:\n        worst = min(cur, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n        cur.remove(worst)\n\n    return to_str(cur)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python-style list in string form, e.g., \"[4,8,18]\".","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Minimization-compatible fitness: feasible -> -total_value; infeasible\/invalid -> large positive penalty\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n = len(values)\n    # Validate\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)\n    else:\n        return float(1e9)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_description)\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    in_set = set(sol)\n    all_indices = set(range(1, n_items + 1))\n    out_list = list(all_indices - in_set)\n\n    curr_cost = total_cost(sol)\n\n    # Choose move type with feasibility awareness\n    move_choices = []\n    # Feasible add candidates within slack\n    slack = max(0, budget - curr_cost)\n    feasible_adds = [i for i in out_list if costs[i - 1] <= slack]\n    if feasible_adds:\n        move_choices.extend([\"add\"] * 3)  # bias toward feasible add\n    if sol:\n        move_choices.extend([\"remove\"] * 2)\n    if sol and out_list:\n        move_choices.append(\"swap\")\n    if not move_choices:\n        return (sol, \"none\")\n\n    move = random.choice(move_choices)\n    neighbor = sol[:]\n    mtype = \"\"\n\n    if move == \"add\" and feasible_adds:\n        # Prefer higher value-to-cost\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i-1]), reverse=True)\n        idx = random.choice(feasible_adds[:min(3, len(feasible_adds))])\n        neighbor = canonicalize(neighbor + [idx])\n        mtype = f\"add:{idx}\"\n    elif move == \"remove\" and sol:\n        # Prefer removing worst ratio\n        rem = min(sol, key=ratio)\n        neighbor = canonicalize([i for i in neighbor if i != rem])\n        mtype = f\"remove:{rem}\"\n    else:  # swap\n        add_idx = random.choice(out_list)\n        rem_idx = random.choice(sol)\n        tmp = [i for i in neighbor if i != rem_idx] + [add_idx]\n        neighbor = canonicalize(tmp)\n        mtype = f\"swap:{rem_idx}->{add_idx}\"\n\n    # Ratio-guided repair if infeasible\n    nb_cost = total_cost(neighbor)\n    if nb_cost > budget:\n        # Remove worst value-to-cost items until feasible\n        keep = neighbor[:]\n        while keep and total_cost(keep) > budget:\n            worst = min(keep, key=ratio)\n            keep.remove(worst)\n            mtype += \"|repair_drop:\" + str(worst)\n        neighbor = canonicalize(keep)\n\n    return (neighbor, mtype if mtype else \"noop\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    rng = random\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    all_indices = set(range(1, n_items + 1))\n\n    k = rng.choice([2, 3])\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = list(all_indices - in_set)\n        moves = []\n        if out_list:\n            moves.append(\"add\")\n        if sol:\n            moves.append(\"remove\")\n        if sol and out_list:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = rng.choice(moves)\n        if mv == \"add\" and out_list:\n            # Prefer high ratio adds\n            out_list.sort(key=lambda i: (ratio(i), values[i-1]), reverse=True)\n            sol.append(rng.choice(out_list[:min(4, len(out_list))]))\n        elif mv == \"remove\" and sol:\n            # Remove worst ratio\n            worst = min(sol, key=ratio)\n            sol = [i for i in sol if i != worst]\n        elif mv == \"swap\" and sol and out_list:\n            add_idx = rng.choice(out_list)\n            rem_idx = rng.choice(sol)\n            sol = [i for i in sol if i != rem_idx] + [add_idx]\n        sol = canonicalize(sol)\n\n    # Greedy feasibility repair: drop worst ratios until within budget\n    if total_cost(sol) > budget:\n        work = sol[:]\n        while work and total_cost(work) > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n        sol = canonicalize(work)\n\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: 1-based unique integer indices of selected items encoded as a Python list string, e.g., \"[4,8,18]\"","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Minimization-compatible fitness: feasible -> -total_value; infeasible\/invalid -> large positive penalty\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n = len(values)\n    # Validate\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)\n    else:\n        return float(1e9)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_description)\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        # Ensure uniqueness and sorted order for deterministic representation\n        return sorted(set(sol))\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    # Start from a valid list or empty\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    in_set = set(sol)\n    all_indices = set(range(1, n_items + 1))\n    out_list = list(all_indices - in_set)\n\n    curr_cost = sum(costs[i - 1] for i in sol)\n    slack = max(0, budget - curr_cost)\n\n    move_choices: List[str] = []\n    feasible_adds = [i for i in out_list if costs[i - 1] <= slack]\n    if feasible_adds:\n        move_choices.extend([\"add\"] * 3)  # bias to feasible adds\n    if sol:\n        move_choices.extend([\"remove\"] * 2)\n    # Consider smart swap where cost(add) - cost(rem) <= slack\n    has_swap = False\n    if sol and out_list:\n        # Pre-check quickly for any pair that fits cost-wise\n        for a in out_list:\n            ca = costs[a - 1]\n            for r in sol:\n                if ca - costs[r - 1] <= slack:\n                    has_swap = True\n                    break\n            if has_swap:\n                break\n        if has_swap:\n            move_choices.append(\"swap\")\n    if not move_choices:\n        return (sol, \"none\")\n\n    move = random.choice(move_choices)\n    neighbor = sol[:]\n    mtype = \"\"\n\n    if move == \"add\" and feasible_adds:\n        # Prefer high value-to-cost items\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n        pick_pool = feasible_adds[:min(3, len(feasible_adds))]\n        idx = random.choice(pick_pool)\n        neighbor.append(idx)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"add:{idx}\"\n    elif move == \"remove\" and sol:\n        # Remove worst ratio to create capacity\n        rem = min(sol, key=ratio)\n        neighbor = [i for i in neighbor if i != rem]\n        neighbor = canonicalize(neighbor)\n        mtype = f\"remove:{rem}\"\n    elif move == \"swap\" and sol and out_list:\n        # Choose pair that fits within slack and improves ratio if possible\n        best_pair = None\n        best_delta = float(\"-inf\")\n        for a in out_list:\n            ca = costs[a - 1]\n            va = values[a - 1]\n            for r in sol:\n                cr = costs[r - 1]\n                if ca - cr <= slack:\n                    delta = (va \/ ca) - (values[r - 1] \/ cr)\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (r, a)\n        if best_pair is None:\n            # fallback random pair (may be infeasible, will be repaired)\n            r = random.choice(sol)\n            a = random.choice(out_list)\n        else:\n            r, a = best_pair\n        neighbor = [i for i in neighbor if i != r]\n        neighbor.append(a)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"swap:{r}->{a}\"\n    else:\n        # default no-op safeguard\n        return (sol, \"noop\")\n\n    # Feasibility repair with running cost maintenance (O(k))\n    nb_cost = sum(costs[i - 1] for i in neighbor)\n    if nb_cost > budget:\n        # Iteratively remove worst ratio items until feasible\n        work = neighbor[:]\n        in_work = set(work)\n        while work and nb_cost > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n            nb_cost -= costs[worst - 1]\n        neighbor = canonicalize(work)\n        mtype += \"|repair\"\n\n    return (neighbor, mtype if mtype else \"noop\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    rng = random\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    all_indices = list(range(1, n_items + 1))\n\n    # Perform k random structural moves\n    k = rng.choice([2, 3])\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = [i for i in all_indices if i not in in_set]\n        moves = []\n        if out_list:\n            moves.append(\"add\")\n        if sol:\n            moves.append(\"remove\")\n        if sol and out_list:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = rng.choice(moves)\n        if mv == \"add\" and out_list:\n            # Prefer high-density additions\n            out_list.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n            pick = rng.choice(out_list[:min(4, len(out_list))])\n            sol.append(pick)\n        elif mv == \"remove\" and sol:\n            worst = min(sol, key=ratio)\n            sol = [i for i in sol if i != worst]\n        elif mv == \"swap\" and sol and out_list:\n            add_idx = rng.choice(out_list)\n            rem_idx = rng.choice(sol)\n            sol = [i for i in sol if i != rem_idx] + [add_idx]\n        sol = canonicalize(sol)\n\n    # Feasibility repair using running cost\n    total_cost = sum(costs[i - 1] for i in sol)\n    if total_cost > budget:\n        work = sol[:]\n        nb_cost = total_cost\n        while work and nb_cost > budget:\n            worst = min(work, key=ratio)\n            work.remove(worst)\n            nb_cost -= costs[worst - 1]\n        sol = canonicalize(work)\n\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST (1-based unique integer indices), e.g., \"[4,8,18]\"","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Minimization-compatible fitness: feasible -> -total_value; infeasible\/invalid -> large positive penalty\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n = len(values)\n    # Validate type\n    if not isinstance(solution, list):\n        return float(1e9)\n    seen = set()\n    total_value = 0\n    total_cost = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e9)\n        if idx < 1 or idx > n:\n            return float(1e9)\n        if idx in seen:\n            return float(1e9)\n        seen.add(idx)\n        total_value += values[idx - 1]\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return float(-total_value)\n    else:\n        return float(1e9)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_INDEX_LIST, movement_description)\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        # Ensure uniqueness and sorted order for deterministic representation\n        return sorted(set(sol))\n\n    def ratio(idx: int) -> float:\n        return values[idx - 1] \/ costs[idx - 1]\n\n    # Start from a valid list or empty\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n    in_set = set(sol)\n    all_indices = list(range(1, n_items + 1))\n    out_list = [i for i in all_indices if i not in in_set]\n\n    curr_cost = sum(costs[i - 1] for i in sol)\n    slack = max(0, budget - curr_cost)\n\n    # Movement options\n    moves = []\n    # Always consider remove if something selected\n    if sol:\n        moves.extend([\"remove\"] * 2)\n    # Adds if slack allows at least one item\n    feasible_adds = [i for i in out_list if costs[i - 1] <= slack]\n    if feasible_adds:\n        moves.extend([\"add\"] * 3)  # bias exploit\n        # Multi-add: try to pack multiple small items within slack\n        moves.append(\"multiadd\")\n    # Swap 1-1 if any may fit using slack\n    if sol and out_list:\n        moves.append(\"swap\")\n        # 1-2 and 2-1 exchanges for diversification\n        if len(out_list) >= 2:\n            moves.append(\"1to2\")\n        if len(sol) >= 2:\n            moves.append(\"2to1\")\n\n    if not moves:\n        return (sol, \"none\")\n\n    move = random.choice(moves)\n    neighbor = sol[:]\n    mtype = \"\"\n\n    if move == \"add\" and feasible_adds:\n        # Epsilon-greedy over top by ratio\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n        if random.random() < 0.8:\n            pick_pool = feasible_adds[:min(3, len(feasible_adds))]\n        else:\n            pick_pool = feasible_adds\n        idx = random.choice(pick_pool)\n        neighbor.append(idx)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"add:{idx}\"\n\n    elif move == \"remove\" and sol:\n        # Remove worst density to free capacity\n        rem = min(sol, key=ratio)\n        neighbor = [i for i in neighbor if i != rem]\n        neighbor = canonicalize(neighbor)\n        mtype = f\"remove:{rem}\"\n\n    elif move == \"swap\" and sol and out_list:\n        # Choose pair that fits and improves ratio if possible\n        best_pair = None\n        best_delta = float(\"-inf\")\n        for a in out_list:\n            ca = costs[a - 1]\n            va = values[a - 1]\n            for r in sol:\n                cr = costs[r - 1]\n                if curr_cost - cr + ca <= budget:\n                    delta = (va \/ ca) - (values[r - 1] \/ cr)\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (r, a)\n        if best_pair is None:\n            r = random.choice(sol)\n            a = random.choice(out_list)\n        else:\n            r, a = best_pair\n        neighbor = [i for i in neighbor if i != r]\n        neighbor.append(a)\n        neighbor = canonicalize(neighbor)\n        mtype = f\"swap:{r}->{a}\"\n\n    elif move == \"multiadd\" and feasible_adds:\n        # Greedy fill slack with best density items\n        feasible_adds.sort(key=lambda i: (ratio(i), values[i - 1]), reverse=True)\n        cap = slack\n        picked = []\n        for i in feasible_adds:\n            ci = costs[i - 1]\n            if ci <= cap:\n                picked.append(i)\n                cap -= ci\n        neighbor = canonicalize(neighbor + picked)\n        mtype = f\"multiadd:{picked}\"\n\n    elif move == \"1to2\" and sol and len(out_list) >= 2:\n        # Replace one selected by two outsiders if fits\n        r = random.choice(sol)\n        candidates = out_list[:]\n        best_pair = None\n        best_gain = float(\"-inf\")\n        for i in range(len(candidates)):\n            a = candidates[i]\n            for j in range(i+1, len(candidates)):\n                b = candidates[j]\n                new_cost = curr_cost - costs[r - 1] + costs[a - 1] + costs[b - 1]\n                if new_cost <= budget:\n                    gain = (values[a - 1] + values[b - 1]) - values[r - 1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (a, b)\n        if best_pair is not None:\n            a, b = best_pair\n            neighbor = [i for i in neighbor if i != r] + [a, b]\n            neighbor = canonicalize(neighbor)\n            mtype = f\"1to2:{r}->{a},{b}\"\n        else:\n            mtype = \"1to2:noop\"\n\n    elif move == \"2to1\" and len(sol) >= 2 and out_list:\n        # Replace two selected by one outsider if fits and beneficial\n        r1, r2 = random.sample(sol, 2)\n        best_a = None\n        best_gain = float(\"-inf\")\n        for a in out_list:\n            new_cost = curr_cost - costs[r1 - 1] - costs[r2 - 1] + costs[a - 1]\n            if new_cost <= budget:\n                gain = values[a - 1] - (values[r1 - 1] + values[r2 - 1])\n                if gain > best_gain:\n                    best_gain = gain\n                    best_a = a\n        if best_a is not None:\n            neighbor = [i for i in neighbor if i not in (r1, r2)] + [best_a]\n            neighbor = canonicalize(neighbor)\n            mtype = f\"2to1:{r1},{r2}->{best_a}\"\n        else:\n            mtype = \"2to1:noop\"\n\n    else:\n        return (sol, \"noop\")\n\n    # Feasibility repair: remove items with minimal value-loss per cost until within budget\n    nb_cost = sum(costs[i - 1] for i in neighbor)\n    if nb_cost > budget:\n        work = neighbor[:]\n        while work and nb_cost > budget:\n            # choose removal minimizing value loss per cost removed\n            worst = min(work, key=lambda i: (values[i - 1] \/ max(1, costs[i - 1]), values[i - 1]))\n            work.remove(worst)\n            nb_cost -= costs[worst - 1]\n        neighbor = canonicalize(work)\n        mtype += \"|repair\"\n\n    return (neighbor, mtype if mtype else \"noop\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    costs: List[int]  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget: int = 90\n    n_items = len(values)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        return sorted(set(sol))\n\n    rng = random\n    sol = canonicalize(solution if isinstance(solution, list) else [])\n\n    all_indices = list(range(1, n_items + 1))\n    # Perform k random structural moves for diversification\n    k = rng.choice([2, 3, 4])\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = [i for i in all_indices if i not in in_set]\n        moves = []\n        if out_list:\n            moves.append(\"add\")\n        if sol:\n            moves.append(\"remove\")\n        if sol and out_list:\n            moves.append(\"swap\")\n        if not moves:\n            break\n        mv = rng.choice(moves)\n        if mv == \"add\" and out_list:\n            # Soft preference towards high-density items\n            out_list.sort(key=lambda i: (values[i - 1]\/costs[i - 1], values[i - 1]), reverse=True)\n            pick_pool = out_list[:min(5, len(out_list))]\n            pick = rng.choice(pick_pool)\n            sol.append(pick)\n        elif mv == \"remove\" and sol:\n            # Remove random or worst density with bias\n            if rng.random() < 0.5:\n                worst = min(sol, key=lambda i: values[i - 1]\/costs[i - 1])\n                sol = [i for i in sol if i != worst]\n            else:\n                rem = rng.choice(sol)\n                sol = [i for i in sol if i != rem]\n        elif mv == \"swap\" and sol and out_list:\n            add_idx = rng.choice(out_list)\n            rem_idx = rng.choice(sol)\n            sol = [i for i in sol if i != rem_idx] + [add_idx]\n        sol = canonicalize(sol)\n\n    # Feasibility repair: remove items minimizing value loss per cost until within budget\n    total_cost = sum(costs[i - 1] for i in sol)\n    if total_cost > budget:\n        work = sol[:]\n        nb_cost = total_cost\n        while work and nb_cost > budget:\n            cand = min(work, key=lambda i: (values[i - 1] \/ max(1, costs[i - 1]), values[i - 1]))\n            work.remove(cand)\n            nb_cost -= costs[cand - 1]\n        sol = canonicalize(work)\n\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects items 4, 8, and 18.","Evaluacion":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    if not isinstance(solution, list):\n        return float('-inf')\n    total_value = 0.0\n    used = set()\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('-inf')\n        if idx < 1 or idx > n:\n            return float('-inf')\n        if idx in used:\n            return float('-inf')\n        used.add(idx)\n        total_value += float(values[idx - 1])\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Return convention: lower is better. For feasible solutions, return -objective_value.\n    # For infeasible or invalid solutions, return a large positive penalty.\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    val = objective_function(solution)\n    if val == float('-inf'):\n        return float(1e9)\n    total_cost = 0\n    for idx in solution:\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return -float(val)\n    else:\n        return float(1e9)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data (embedded)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _total_cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    def _repair_to_budget(sol: List[int]) -> List[int]:\n        sol = _normalize(sol)\n        cur_cost = _total_cost(sol)\n        if cur_cost <= budget:\n            return sol\n        # Compute densities and remove by lowest density first\n        dens = [(values[i-1] \/ costs[i-1], i) for i in sol]\n        dens.sort(key=lambda x: (x[0], values[x[1]-1]))  # increasing density\n        keep = set(sol)\n        for _, idx in dens:\n            if cur_cost <= budget:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                cur_cost -= costs[idx-1]\n        repaired = [i for i in sol if i in keep]\n        if _total_cost(repaired) > budget:\n            return []\n        # Local greedy refill: try to add best density items within budget\n        cand = [i for i in range(1, n+1) if i not in repaired and costs[i-1] <= budget]\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        cur = list(repaired)\n        cur_cost2 = _total_cost(cur)\n        for i in cand:\n            c = costs[i-1]\n            if cur_cost2 + c <= budget:\n                cur.append(i)\n                cur_cost2 += c\n        return _normalize(cur)\n\n    def _guided_add(curr: List[int]) -> List[int]:\n        cand = [i for i in range(1, n+1) if i not in curr and costs[i-1] <= budget]\n        if not cand:\n            return curr\n        # Prefer high value density, then value\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        # sample top-k to add some randomness\n        k = min(5, len(cand))\n        i = random.choice(cand[:k])\n        return curr + [i]\n\n    curr = _normalize(list(solution))\n\n    move_choices = [\"add\", \"remove\", \"swap1_1\", \"swap1_2\", \"swap2_1\"]\n    if not curr:\n        move_choices = [\"add\"] * 3 + [\"swap1_1\"]\n    move = random.choice(move_choices)\n\n    new_sol = list(curr)\n    movement_detail = move\n\n    if move == \"add\":\n        # guided add\n        new_sol = _guided_add(new_sol)\n    elif move == \"remove\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            new_sol.remove(out_i)\n    elif move == \"swap1_1\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if excluded:\n                in_i = random.choice(excluded)\n                new_sol.remove(out_i)\n                new_sol.append(in_i)\n    elif move == \"swap1_2\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if len(excluded) >= 2:\n                in_pair = random.sample(excluded, 2)\n                new_sol.remove(out_i)\n                new_sol.extend(in_pair)\n    elif move == \"swap2_1\":\n        if len(new_sol) >= 2:\n            out_pair = random.sample(new_sol, 2)\n            excluded = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= budget]\n            if excluded:\n                in_i = random.choice(excluded)\n                for o in out_pair:\n                    if o in new_sol:\n                        new_sol.remove(o)\n                new_sol.append(in_i)\n\n    new_sol = _normalize(new_sol)\n    # Budget repair and local improvement\n    before_cost = _total_cost(new_sol)\n    if before_cost > budget:\n        new_sol = _repair_to_budget(new_sol)\n        movement_detail += \"+repair\"\n    else:\n        # If feasible, try a small greedy improvement\n        new_sol = _repair_to_budget(new_sol)\n\n    return (new_sol, movement_detail)","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Problem data (embedded)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _total_cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    def _repair_to_budget(sol: List[int]) -> List[int]:\n        sol = _normalize(sol)\n        cur_cost = _total_cost(sol)\n        if cur_cost <= budget:\n            return sol\n        dens = [(values[i-1] \/ costs[i-1], i) for i in sol]\n        dens.sort(key=lambda x: (x[0], values[x[1]-1]))\n        keep = set(sol)\n        for _, idx in dens:\n            if cur_cost <= budget:\n                break\n            if idx in keep:\n                keep.remove(idx)\n                cur_cost -= costs[idx-1]\n        repaired = [i for i in sol if i in keep]\n        if _total_cost(repaired) > budget:\n            return []\n        # Greedy refill\n        cand = [i for i in range(1, n+1) if i not in repaired and costs[i-1] <= budget]\n        cand.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        cur = list(repaired)\n        cur_cost2 = _total_cost(cur)\n        for i in cand:\n            c = costs[i-1]\n            if cur_cost2 + c <= budget:\n                cur.append(i)\n                cur_cost2 += c\n        return _normalize(cur)\n\n    curr = _normalize(list(solution))\n\n    # k-exchange perturbation: remove t items, add t' random items, then repair\n    t_remove = min(2, len(curr))\n    if t_remove > 0:\n        to_remove = random.sample(curr, t_remove)\n        for r in to_remove:\n            if r in curr:\n                curr.remove(r)\n\n    # Add up to k items randomly from candidates\n    k_add = 3\n    candidates = [i for i in range(1, n+1) if i not in curr and costs[i-1] <= budget]\n    random.shuffle(candidates)\n    for i in candidates[:k_add]:\n        curr.append(i)\n        curr = _normalize(curr)\n\n    curr = _repair_to_budget(curr)\n    return curr","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST of 1-based item indices. Example: [4,8,18] selects those items. Feasibility: sum of costs of listed indices must be <= 90.","Evaluacion":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(values)\n    if not isinstance(solution, list):\n        return float('-inf')\n    seen = set()\n    total_value = 0.0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n:\n            return float('-inf')\n        if idx in seen:\n            return float('-inf')\n        seen.add(idx)\n        total_value += float(values[idx - 1])\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization convention: feasible -> return -objective_value; infeasible\/invalid -> large positive penalty\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    budget = 90\n    val = objective_function(solution)\n    if val == float('-inf'):\n        return float(1e9)\n    total_cost = 0\n    for idx in solution:\n        total_cost += costs[idx - 1]\n    if total_cost <= budget:\n        return -float(val)\n    # dynamic penalty with slight gradient by overflow amount\n    overflow = float(total_cost - budget)\n    return float(1e9 + overflow)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    curr = _normalize(list(solution))\n    curr_cost = _cost(curr)\n\n    moves = [\"add\", \"remove\", \"swap1_1\", \"swap2_1\"]\n    if not curr:\n        moves = [\"add\", \"add\", \"add\", \"swap1_1\"]\n    move = random.choice(moves)\n    movement_detail = move\n\n    new_sol = list(curr)\n    new_cost = curr_cost\n\n    if move == \"add\":\n        residual = budget - new_cost\n        candidates = [i for i in range(1, n+1) if i not in new_sol and costs[i-1] <= residual and costs[i-1] <= budget]\n        if candidates:\n            # bias by value density\n            candidates.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n            k = min(4, len(candidates))\n            pick = random.choice(candidates[:k])\n            new_sol.append(pick)\n            new_cost += costs[pick-1]\n    elif move == \"remove\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            new_sol.remove(out_i)\n            new_cost -= costs[out_i-1]\n    elif move == \"swap1_1\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            residual = budget - (new_cost - costs[out_i-1])\n            candidates = [j for j in range(1, n+1) if j not in new_sol and costs[j-1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda j: (-values[j-1]\/costs[j-1], -values[j-1]))\n                k = min(4, len(candidates))\n                in_j = random.choice(candidates[:k])\n                new_sol.remove(out_i)\n                new_sol.append(in_j)\n                new_cost = new_cost - costs[out_i-1] + costs[in_j-1]\n    elif move == \"swap2_1\":\n        if len(new_sol) >= 2:\n            out_i, out_j = random.sample(new_sol, 2)\n            base_cost = new_cost - costs[out_i-1] - costs[out_j-1]\n            residual = budget - base_cost\n            candidates = [k for k in range(1, n+1) if k not in new_sol and costs[k-1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda k: (-values[k-1]\/costs[k-1], -values[k-1]))\n                t = min(5, len(candidates))\n                in_k = random.choice(candidates[:t])\n                new_sol.remove(out_i)\n                new_sol.remove(out_j)\n                new_sol.append(in_k)\n                new_cost = base_cost + costs[in_k-1]\n\n    # Final normalization (safety)\n    new_sol = _normalize(new_sol)\n    return (new_sol, movement_detail)","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i-1] for i in sol)\n\n    sol = _normalize(list(solution))\n\n    # Remove up to r items\n    r = min(2, len(sol))\n    if r > 0:\n        for rem in random.sample(sol, r):\n            sol.remove(rem)\n\n    # Add up to r+1 items guided by density within residual capacity\n    residual = budget - _cost(sol)\n    candidates = [i for i in range(1, n+1) if i not in sol and costs[i-1] <= residual]\n    candidates.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n    k = min(len(candidates), r + 1)\n    for i in candidates[:k]:\n        if _cost(sol) + costs[i-1] <= budget:\n            sol.append(i)\n\n    # Greedy fill to utilize remaining capacity\n    residual = budget - _cost(sol)\n    if residual > 0:\n        more = [i for i in range(1, n+1) if i not in sol and costs[i-1] <= residual]\n        more.sort(key=lambda i: (-values[i-1]\/costs[i-1], -values[i-1]))\n        for i in more:\n            if _cost(sol) + costs[i-1] <= budget:\n                sol.append(i)\n                residual = budget - _cost(sol)\n                if residual <= 0:\n                    break\n\n    return _normalize(sol)","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST (1-based indices). A solution is a list of distinct integers in [1,24]; its total cost must be <= 90. Example: [4,8,18].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization convention: feasible -> return -objective_value; infeasible\/invalid -> large positive penalty\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = len(values)\n\n    # Validate type\n    if not isinstance(solution, list):\n        return float(1e9)\n    # Validate elements\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > n:\n            return float(1e9)\n    # Check duplicates fast\n    if len(set(solution)) != len(solution):\n        return float(1e9)\n\n    total_cost = 0\n    total_value = 0.0\n    for idx in solution:\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        total_value += float(v)\n\n    if total_cost <= budget:\n        return -float(total_value)\n    overflow = float(total_cost - budget)\n    return float(1e9 + overflow)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    ratios = [values[i] \/ costs[i] if costs[i] > 0 else 0.0 for i in range(n)]\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def _repair_feasible(sol: List[int]) -> List[int]:\n        # If over budget, drop items with lowest ratio until feasible\n        cur = _normalize(sol)\n        while _cost(cur) > budget and cur:\n            cur.sort(key=lambda i: (ratios[i - 1], values[i - 1]))\n            cur.pop(0)\n        return cur\n\n    def _greedy_fill(sol: List[int]) -> List[int]:\n        cur = _normalize(sol)\n        residual = budget - _cost(cur)\n        if residual <= 0:\n            return cur\n        candidates = [i for i in range(1, n + 1) if i not in cur and costs[i - 1] <= residual]\n        candidates.sort(key=lambda i: (-ratios[i - 1], -values[i - 1]))\n        for i in candidates:\n            if _cost(cur) + costs[i - 1] <= budget:\n                cur.append(i)\n        return cur\n\n    curr = _repair_feasible(_normalize(list(solution)))\n    curr_cost = _cost(curr)\n\n    moves = [\"add\", \"remove\", \"swap1_1\", \"swap1_2\", \"swap2_1\", \"swap2_2\", \"drop2_add2\"]\n    if not curr:\n        moves = [\"add\", \"add\", \"add\", \"swap1_1\"]\n    move = random.choice(moves)\n    movement_detail = move\n\n    new_sol = list(curr)\n\n    if move == \"add\":\n        residual = budget - _cost(new_sol)\n        candidates = [i for i in range(1, n + 1) if i not in new_sol and costs[i - 1] <= residual]\n        if candidates:\n            candidates.sort(key=lambda i: (-ratios[i - 1], -values[i - 1]))\n            topk = candidates[: min(5, len(candidates))]\n            pick = random.choice(topk)\n            new_sol.append(pick)\n    elif move == \"remove\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            new_sol.remove(out_i)\n    elif move == \"swap1_1\":\n        if new_sol:\n            out_i = random.choice(new_sol)\n            base_cost = _cost(new_sol) - costs[out_i - 1]\n            residual = budget - base_cost\n            candidates = [j for j in range(1, n + 1) if j not in new_sol and costs[j - 1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda j: (-ratios[j - 1], -values[j - 1]))\n                in_j = random.choice(candidates[: min(5, len(candidates))])\n                new_sol.remove(out_i)\n                new_sol.append(in_j)\n    elif move == \"swap1_2\":\n        if new_sol and len([i for i in range(1, n + 1) if i not in new_sol]) >= 2:\n            out_i = random.choice(new_sol)\n            remaining_cost = _cost(new_sol) - costs[out_i - 1]\n            residual = budget - remaining_cost\n            pool = [k for k in range(1, n + 1) if k not in new_sol]\n            # Try to insert two items fitting in residual\n            pool.sort(key=lambda k: (-ratios[k - 1], -values[k - 1]))\n            added = []\n            for cand in pool:\n                if len(added) == 2:\n                    break\n                if costs[cand - 1] <= residual:\n                    added.append(cand)\n                    residual -= costs[cand - 1]\n            if added:\n                new_sol.remove(out_i)\n                new_sol.extend(added)\n    elif move == \"swap2_1\":\n        if len(new_sol) >= 2:\n            out_i, out_j = random.sample(new_sol, 2)\n            base_cost = _cost(new_sol) - costs[out_i - 1] - costs[out_j - 1]\n            residual = budget - base_cost\n            candidates = [k for k in range(1, n + 1) if k not in new_sol and costs[k - 1] <= residual]\n            if candidates:\n                candidates.sort(key=lambda k: (-ratios[k - 1], -values[k - 1]))\n                in_k = random.choice(candidates[: min(5, len(candidates))])\n                new_sol.remove(out_i)\n                new_sol.remove(out_j)\n                new_sol.append(in_k)\n    elif move == \"swap2_2\":\n        if len(new_sol) >= 2:\n            out_i, out_j = random.sample(new_sol, 2)\n            base_cost = _cost(new_sol) - costs[out_i - 1] - costs[out_j - 1]\n            residual = budget - base_cost\n            pool = [k for k in range(1, n + 1) if k not in new_sol]\n            pool.sort(key=lambda k: (-ratios[k - 1], -values[k - 1]))\n            add = []\n            for cand in pool:\n                if len(add) == 2:\n                    break\n                if costs[cand - 1] <= residual:\n                    add.append(cand)\n                    residual -= costs[cand - 1]\n            if add:\n                new_sol.remove(out_i)\n                new_sol.remove(out_j)\n                new_sol.extend(add)\n    elif move == \"drop2_add2\":\n        if len(new_sol) >= 2:\n            out = random.sample(new_sol, 2)\n            base_cost = _cost(new_sol) - costs[out[0] - 1] - costs[out[1] - 1]\n            residual = budget - base_cost\n            cand = [k for k in range(1, n + 1) if k not in new_sol]\n            cand.sort(key=lambda k: (-ratios[k - 1], -values[k - 1]))\n            add = []\n            for c in cand:\n                if len(add) == 2:\n                    break\n                if costs[c - 1] <= residual:\n                    add.append(c)\n                    residual -= costs[c - 1]\n            if add:\n                for o in out:\n                    new_sol.remove(o)\n                new_sol.extend(add)\n\n    # Final repair and greedy fill ensure feasibility and better utilization\n    new_sol = _repair_feasible(_normalize(new_sol))\n    new_sol = _greedy_fill(new_sol)\n\n    return (new_sol, movement_detail)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def _normalize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def _cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def _repair_feasible(sol: List[int]) -> List[int]:\n        # Drop lowest value-density until feasible\n        cur = _normalize(sol)\n        if not cur:\n            return cur\n        ratios = [values[i - 1] \/ costs[i - 1] if costs[i - 1] > 0 else 0.0 for i in range(1, n + 1)]\n        while _cost(cur) > budget and cur:\n            cur.sort(key=lambda i: (ratios[i - 1], values[i - 1]))\n            cur.pop(0)\n        return cur\n\n    def _greedy_fill(sol: List[int]) -> List[int]:\n        cur = _normalize(sol)\n        ratios = [values[i - 1] \/ costs[i - 1] if costs[i - 1] > 0 else 0.0 for i in range(1, n + 1)]\n        residual = budget - _cost(cur)\n        if residual <= 0:\n            return cur\n        candidates = [i for i in range(1, n + 1) if i not in cur and costs[i - 1] <= residual]\n        candidates.sort(key=lambda i: (-ratios[i - 1], -values[i - 1]))\n        for i in candidates:\n            if _cost(cur) + costs[i - 1] <= budget:\n                cur.append(i)\n        return cur\n\n    sol = _repair_feasible(_normalize(list(solution)))\n\n    # Random multi-kick: remove up to 3 items, biased to lower density\n    kicks = min(3, len(sol))\n    if kicks > 0:\n        # Sort by increasing value density, remove a random number up to kicks from this front\n        ratios_local = {i: (values[i - 1] \/ costs[i - 1]) for i in sol}\n        sorted_sol = sorted(sol, key=lambda i: (ratios_local[i], values[i - 1]))\n        r = random.randint(1, kicks)\n        to_remove = sorted_sol[:r]\n        for rem in to_remove:\n            if rem in sol:\n                sol.remove(rem)\n\n    # Randomized re-add: try up to 4 additions guided by density\n    ratios_global = [values[i] \/ costs[i] if costs[i] > 0 else 0.0 for i in range(n)]\n    residual = budget - _cost(sol)\n    if residual > 0:\n        candidates = [i for i in range(1, n + 1) if i not in sol and costs[i - 1] <= residual]\n        candidates.sort(key=lambda i: (-ratios_global[i - 1], -values[i - 1]))\n        top = candidates[: min(8, len(candidates))]\n        tries = min(4, len(top))\n        for _ in range(tries):\n            if not top:\n                break\n            pick = random.choice(top)\n            if _cost(sol) + costs[pick - 1] <= budget:\n                sol.append(pick)\n            residual = budget - _cost(sol)\n            top = [i for i in top if costs[i - 1] <= residual and i not in sol]\n\n    # Final greedy repair\/fill\n    sol = _repair_feasible(sol)\n    sol = _greedy_fill(sol)\n\n    return _normalize(sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based item indices within [1,24].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Feasibility-first minimization evaluator: return +inf if infeasible, else -total_value\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int) or idx < 1 or idx > 24 or idx in seen:\n            return math.inf\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return math.inf\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbouring feasible solution for INDEX_LIST.\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type is the representation string 'INDEX_LIST'.\n    Movement_Type in {'add','remove','swap'}.\n    \"\"\"\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    # Sanitize and canonicalize input\n    if isinstance(solution, list):\n        base = [i for i in solution if isinstance(i, int) and 1 <= i <= n_items]\n        base = sorted(set(base))\n    else:\n        base = []\n\n    def density(i: int) -> float:\n        c = costs[i-1]\n        v = values[i-1]\n        return (v \/ c) if c > 0 else 0.0\n\n    cur = list(base)\n    cur_cost = sum(costs[i-1] for i in cur)\n    residual = budget - cur_cost\n\n    # Decide move type adaptively\n    min_fit_cost = None\n    for i in range(1, n_items+1):\n        if i not in cur:\n            c = costs[i-1]\n            if c <= residual:\n                min_fit_cost = c if min_fit_cost is None else min(min_fit_cost, c)\n    add_bias = 0.6 if (min_fit_cost is not None) else 0.2\n    remove_bias = 0.6 if (residual < 10 or min_fit_cost is None) and len(cur) > 0 else 0.2\n    swap_bias = 1.0 - min(0.9, add_bias + remove_bias)  # keep probabilities summing to 1 within [0.1,1]\n\n    r = random.random()\n    if len(cur) == 0:\n        move_type = 'add'\n    elif r < add_bias:\n        move_type = 'add'\n    elif r < add_bias + remove_bias:\n        move_type = 'remove'\n    else:\n        move_type = 'swap'\n\n    new_sol = list(cur)\n    new_cost = cur_cost\n\n    if move_type == 'add':\n        # Candidates sorted by density high->low that fit\n        candidates = [i for i in range(1, n_items+1) if i not in new_sol and costs[i-1] <= residual]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            # pick among top-k to diversify\n            k = min(3, len(candidates))\n            choice = random.choice(candidates[:k])\n            new_sol.append(choice)\n            new_sol.sort()\n            new_cost += costs[choice-1]\n        else:\n            # fallback: if cannot add, attempt remove lowest-density\n            if new_sol:\n                worst = min(new_sol, key=density)\n                new_sol.remove(worst)\n                new_cost -= costs[worst-1]\n                move_type = 'remove'\n    elif move_type == 'remove' and new_sol:\n        # remove lowest density item\n        rem = min(new_sol, key=density)\n        new_sol.remove(rem)\n        new_cost -= costs[rem-1]\n    else:  # swap\n        if new_sol:\n            # remove lowest-density, try add highest-density that fits\n            out = min(new_sol, key=density)\n            base_cost = new_cost - costs[out-1]\n            candidates = [i for i in range(1, n_items+1) if i not in new_sol and (base_cost + costs[i-1] <= budget)]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            swapped = False\n            for inn in candidates[:5]:  # try top few\n                if inn == out:\n                    continue\n                new_sol.remove(out)\n                new_sol.append(inn)\n                new_sol.sort()\n                new_cost = base_cost + costs[inn-1]\n                swapped = True\n                break\n            if not swapped:\n                # if cannot swap, just remove the selected item\n                if out in new_sol:\n                    new_sol.remove(out)\n                    new_cost = base_cost\n                move_type = 'remove'\n        else:\n            move_type = 'add'\n\n    # Final feasibility guard (should already hold)\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in new_sol:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx-1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        # Simple repair: drop lowest-density items until feasible\n        new_sol.sort(key=lambda i: density(i))\n        total = sum(costs[i-1] for i in new_sol)\n        while new_sol and total > budget:\n            rem = new_sol.pop(0)\n            total -= costs[rem-1]\n        new_sol.sort()\n\n    return new_sol, 'INDEX_LIST', move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"k-exchange perturbation: remove r in {1..3} low-density items (with noise) then greedy refill by density.\"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    def density(i: int) -> float:\n        c = costs[i-1]\n        v = values[i-1]\n        return (v \/ c) if c > 0 else 0.0\n\n    # Sanitize\n    cur = []\n    if isinstance(solution, list):\n        cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    cur_cost = sum(costs[i-1] for i in cur)\n\n    # Remove phase\n    r = random.randint(1, 3)\n    if cur:\n        # noise: sample r items from a list biased to low density\n        ordered = sorted(cur, key=lambda i: (density(i) + 0.05*random.random()))\n        to_remove = ordered[:min(r, len(ordered))]\n        for idx in to_remove:\n            if idx in cur:\n                cur.remove(idx)\n                cur_cost -= costs[idx-1]\n\n    # Refill phase: greedy by density under residual budget\n    residual = budget - cur_cost\n    candidates = [i for i in range(1, n_items+1) if i not in cur]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n    for i in candidates:\n        c = costs[i-1]\n        if c <= residual:\n            cur.append(i)\n            cur_cost += c\n            residual -= c\n    cur.sort()\n\n    # Final feasibility check and minor repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in cur:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx-1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        cur.sort(key=lambda i: density(i))\n        total = sum(costs[i-1] for i in cur)\n        while cur and total > budget:\n            rem = cur.pop(0)\n            total -= costs[rem-1]\n        cur.sort()\n\n    return cur\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based indices within [1,24], sorted ascending, representing selected items under budget.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Feasibility-first minimization evaluator for INDEX_LIST.\n    Returns +inf if infeasible; otherwise returns -total_value (to minimize).\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if (not isinstance(idx, int)) or idx < 1 or idx > 24 or idx in seen:\n            return math.inf\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return math.inf\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbouring feasible solution for INDEX_LIST.\n    Returns (new_solution, 'INDEX_LIST', move_type) where move_type in {'add','remove','swap'}.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    # Canonicalize input to a sorted unique INDEX_LIST within domain\n    if isinstance(solution, list):\n        base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    else:\n        base = []\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    cur = list(base)\n    cur_cost = sum(costs[i - 1] for i in cur)\n    residual = budget - cur_cost\n\n    # Determine move type adaptively\n    add_possible = any((i not in cur) and (costs[i - 1] <= residual) for i in range(1, n_items + 1))\n    if not cur:\n        move_type = 'add'\n    else:\n        r = random.random()\n        if add_possible and r < 0.5:\n            move_type = 'add'\n        elif r < 0.8:\n            move_type = 'remove'\n        else:\n            move_type = 'swap'\n\n    new_sol = list(cur)\n    new_cost = cur_cost\n\n    if move_type == 'add':\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and costs[i - 1] <= residual]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            k = min(3, len(candidates))\n            choice = random.choice(candidates[:k])\n            new_sol.append(choice)\n            new_sol = sorted(set(new_sol))\n            new_cost += costs[choice - 1]\n        else:\n            move_type = 'remove'\n    if move_type == 'remove' and new_sol:\n        rem = min(new_sol, key=density)\n        new_sol.remove(rem)\n        new_cost -= costs[rem - 1]\n    elif move_type == 'swap' and new_sol:\n        out = min(new_sol, key=density)\n        base_cost = new_cost - costs[out - 1]\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and (base_cost + costs[i - 1] <= budget)]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        if candidates:\n            inn = candidates[0]\n            new_sol.remove(out)\n            new_sol.append(inn)\n            new_sol = sorted(set(new_sol))\n            new_cost = base_cost + costs[inn - 1]\n        else:\n            # fallback to remove\n            new_sol.remove(out)\n            new_cost = base_cost\n            move_type = 'remove'\n\n    # Final feasibility guard and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in new_sol:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        # Drop lowest-density items until feasible\n        new_sol.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in new_sol)\n        while new_sol and total > budget:\n            rem = new_sol.pop(0)\n            total -= costs[rem - 1]\n        new_sol = sorted(set(new_sol))\n\n    return new_sol, 'INDEX_LIST', move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    k-exchange perturbation: remove 1..3 lowest-density (with noise), then greedy refill by density.\n    Returns a repaired feasible INDEX_LIST.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    # Sanitize current solution\n    cur = []\n    if isinstance(solution, list):\n        cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    cur_cost = sum(costs[i - 1] for i in cur)\n\n    # Remove phase\n    if cur:\n        r = random.randint(1, 3)\n        ordered = sorted(cur, key=lambda i: (density(i) + 0.05 * random.random()))\n        to_remove = ordered[:min(r, len(ordered))]\n        for idx in to_remove:\n            if idx in cur:\n                cur.remove(idx)\n                cur_cost -= costs[idx - 1]\n\n    # Refill phase: greedy by density within residual budget\n    residual = budget - cur_cost\n    candidates = [i for i in range(1, n_items + 1) if i not in cur]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n    for i in candidates:\n        c = costs[i - 1]\n        if c <= residual:\n            cur.append(i)\n            cur_cost += c\n            residual -= c\n    cur = sorted(set(cur))\n\n    # Final feasibility check and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in cur:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        cur.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in cur)\n        while cur and total > budget:\n            rem = cur.pop(0)\n            total -= costs[rem - 1]\n        cur = sorted(set(cur))\n\n    return cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based indices within [1,24], sorted ascending. Each index denotes a selected item under the knapsack budget.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Feasibility-first minimization evaluator for INDEX_LIST.\n    Returns +inf if infeasible; otherwise returns -total_value (to minimize).\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if (not isinstance(idx, int)) or idx < 1 or idx > 24 or idx in seen:\n            return math.inf\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return math.inf\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbouring feasible solution for INDEX_LIST.\n    Returns (new_solution, 'INDEX_LIST', move_type) where move_type in {'add','remove','swap'}.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    # Canonicalize input to a sorted unique INDEX_LIST within domain\n    if isinstance(solution, list):\n        base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    else:\n        base = []\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    cur = list(base)\n    cur_cost = sum(costs[i - 1] for i in cur)\n    residual = budget - cur_cost\n\n    # Determine move type adaptively\n    add_possible = any((i not in cur) and (costs[i - 1] <= residual) for i in range(1, n_items + 1))\n    if not cur:\n        move_type = 'add'\n    else:\n        r = random.random()\n        if add_possible and r < 0.5:\n            move_type = 'add'\n        elif r < 0.8:\n            move_type = 'remove'\n        else:\n            move_type = 'swap'\n\n    new_sol = list(cur)\n    new_cost = cur_cost\n\n    if move_type == 'add':\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and costs[i - 1] <= residual]\n        if candidates:\n            # prefer top-k by density then sample to diversify\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            k = min(3, len(candidates))\n            choice = random.choice(candidates[:k])\n            new_sol.append(choice)\n            new_sol = sorted(set(new_sol))\n            new_cost += costs[choice - 1]\n        else:\n            move_type = 'remove'\n\n    if move_type == 'remove' and new_sol:\n        rem = min(new_sol, key=density)\n        new_sol.remove(rem)\n        new_cost -= costs[rem - 1]\n    elif move_type == 'swap' and new_sol:\n        out = min(new_sol, key=density)\n        base_cost = new_cost - costs[out - 1]\n        candidates = [i for i in range(1, n_items + 1) if i not in new_sol and (base_cost + costs[i - 1] <= budget)]\n        if candidates:\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            inn = candidates[0]\n            new_sol.remove(out)\n            new_sol.append(inn)\n            new_sol = sorted(set(new_sol))\n            new_cost = base_cost + costs[inn - 1]\n        else:\n            new_sol.remove(out)\n            new_cost = base_cost\n            move_type = 'remove'\n\n    # Final feasibility guard and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in new_sol:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        new_sol.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in new_sol)\n        while new_sol and total > budget:\n            rem = new_sol.pop(0)\n            total -= costs[rem - 1]\n        new_sol = sorted(set(new_sol))\n\n    return new_sol, 'INDEX_LIST', move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    k-exchange perturbation: remove 1..3 lowest-density (with slight noise), then greedy refill by density.\n    Returns a repaired feasible INDEX_LIST.\n    \"\"\"\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n_items = 24\n\n    def density(i: int) -> float:\n        c = costs[i - 1]\n        v = values[i - 1]\n        return (v \/ c) if c > 0 else 0.0\n\n    # Sanitize current solution\n    cur = []\n    if isinstance(solution, list):\n        cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n_items))\n    cur_cost = sum(costs[i - 1] for i in cur)\n\n    # Remove phase\n    if cur:\n        r = random.randint(1, 3)\n        ordered = sorted(cur, key=lambda i: (density(i) + 0.05 * random.random()))\n        to_remove = ordered[:min(r, len(ordered))]\n        for idx in to_remove:\n            if idx in cur:\n                cur.remove(idx)\n                cur_cost -= costs[idx - 1]\n\n    # Refill phase: greedy by density within residual budget\n    residual = budget - cur_cost\n    candidates = [i for i in range(1, n_items + 1) if i not in cur]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n    for i in candidates:\n        c = costs[i - 1]\n        if c <= residual:\n            cur.append(i)\n            cur_cost += c\n            residual -= c\n    cur = sorted(set(cur))\n\n    # Final feasibility check and repair\n    total = 0\n    seen = set()\n    feasible = True\n    for idx in cur:\n        if (not isinstance(idx, int)) or idx < 1 or idx > n_items or idx in seen:\n            feasible = False\n            break\n        seen.add(idx)\n        total += costs[idx - 1]\n        if total > budget:\n            feasible = False\n            break\n    if not feasible:\n        cur.sort(key=lambda i: density(i))\n        total = sum(costs[i - 1] for i in cur)\n        while cur and total > budget:\n            rem = cur.pop(0)\n            total -= costs[rem - 1]\n        cur = sorted(set(cur))\n\n    return cur\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    if not isinstance(solution, list):\n        return math.inf\n    sel = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    # Return cost (lower is better) using negative profit\n    return -float(profit)","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    # Sanitize and order\n    cur = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n    w_cur = sum(gallons[i] for i in cur)\n    v_cur = sum(values[i] for i in cur)\n    valid = list(range(1, 25))\n    move = random.choice([\"add\", \"drop\", \"swap\"]) if cur else \"add\"\n    # ADD: choose among feasible additions; bias toward higher value density\n    if move == \"add\":\n        feas = [i for i in valid if i not in cur and w_cur + gallons[i] <= CAP]\n        if feas:\n            # pick best among top-k by value\/weight ratio\n            feas_sorted = sorted(feas, key=lambda j: (values[j] \/ gallons[j] if gallons[j] > 0 else values[j]), reverse=True)\n            k = min(3, len(feas_sorted))\n            i = random.choice(feas_sorted[:k])\n            return (sorted(cur + [i]), \"add\")\n        # fallback to drop if no feasible add\n    # DROP: remove a random item\n    if move == \"drop\":\n        if cur:\n            i = random.choice(cur)\n            nxt = [x for x in cur if x != i]\n            return (nxt, \"drop\")\n        # if empty, try best feasible single add\n        feas = [i for i in valid if gallons[i] <= CAP]\n        if feas:\n            i = max(feas, key=lambda j: values[j] \/ gallons[j] if gallons[j] > 0 else values[j])\n            return ([i], \"add\")\n    # SWAP: try feasible swap; prefer improving swaps\n    if move == \"swap\" and cur:\n        outs = list(cur)\n        ins = [i for i in valid if i not in cur]\n        candidates = []\n        for o in outs:\n            for i in ins:\n                new_w = w_cur - gallons[o] + gallons[i]\n                if new_w <= CAP:\n                    delta_v = values[i] - values[o]\n                    candidates.append((delta_v, o, i))\n        if candidates:\n            # prefer improving or neutral swaps; sample among top candidates\n            candidates.sort(key=lambda t: t[0], reverse=True)\n            top = [c for c in candidates if c[0] >= 0] or candidates[:min(5, len(candidates))]\n            _, o, i = random.choice(top)\n            nxt = sorted([x for x in cur if x != o] + [i])\n            return (nxt, \"swap\")\n    # Final fallback: return current as noop\n    return (cur, \"noop\")","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12]\n    CAP = 9\n    # Clean current solution\n    cur = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n    # Step 1: random removals (k in {1,2})\n    if cur:\n        k = 1 if len(cur) == 1 else random.choice([1, 2])\n        to_remove = set(random.sample(cur, min(k, len(cur))))\n        cur = [i for i in cur if i not in to_remove]\n    # Step 2: greedy refill by value\/weight ratio until capacity\n    def total_weight(sol):\n        return sum(gallons[i] for i in sol)\n    def total_value(sol):\n        return sum(values[i] for i in sol)\n    remaining = CAP - total_weight(cur)\n    candidates = [i for i in range(1, 25) if i not in cur and gallons[i] <= remaining]\n    # Greedy iterative fill\n    while candidates:\n        # pick best ratio; if tie, higher value\n        best = max(candidates, key=lambda j: ((values[j] \/ gallons[j]) if gallons[j] > 0 else values[j], values[j]))\n        if gallons[best] <= remaining:\n            cur.append(best)\n            cur = sorted(cur)\n            remaining = CAP - total_weight(cur)\n            candidates = [i for i in range(1, 25) if i not in cur and gallons[i] <= remaining]\n        else:\n            break\n    return cur","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    if not isinstance(solution, list):\n        return math.inf\n    sel = []\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= N and i not in seen:\n            sel.append(i)\n            seen.add(i)\n    total_w = sum(gallons[i] for i in sel)\n    if total_w > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    # Minimization-compatible: lower cost is better; use negative profit\n    return -float(profit)\n","Vecindad":"def generate_neighbour(solution):\n    import random, math\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    # Sanitize current solution to unique, valid indices preserving first occurrence order\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n    else:\n        cur = []\n        seen = set()\n    w_cur = sum(gallons[i] for i in cur)\n    valid = list(range(1, N + 1))\n    move = random.choice(['add', 'drop', 'swap', 'kex']) if cur else 'add'\n    # ADD move: choose a feasible item, biased by value density\n    if move == 'add':\n        feas = [i for i in valid if i not in seen and w_cur + gallons[i] <= CAP]\n        if feas:\n            feas.sort(key=lambda j: (values[j] \/ gallons[j]))\n            pick = random.choice(feas[-min(3, len(feas)):])\n            nxt = sorted(cur + [pick])\n            return (nxt, 'add')\n    # DROP move: remove the lowest density item to free capacity\n    if move == 'drop' and cur:\n        drop = min(cur, key=lambda j: (values[j] \/ max(1, gallons[j])))\n        nxt = [x for x in cur if x != drop]\n        return (nxt, 'drop')\n    # SWAP move: best improving or neutral 1-1 swap within capacity\n    if move == 'swap' and cur:\n        best = None\n        for o in cur:\n            for i in valid:\n                if i in seen:\n                    continue\n                new_w = w_cur - gallons[o] + gallons[i]\n                if new_w <= CAP:\n                    dv = values[i] - values[o]\n                    if (best is None) or (dv > best[0]) or (dv == best[0] and gallons[i] < gallons[o]):\n                        best = (dv, o, i)\n        if best is not None:\n            _, o, i = best\n            nxt = sorted([x for x in cur if x != o] + [i])\n            return (nxt, 'swap')\n    # K-EXCHANGE: try quick 1-2 or 2-1 non-worsening exchanges\n    if move == 'kex' and cur:\n        others = [i for i in valid if i not in seen]\n        # 1 -> 2\n        for o in cur:\n            for idx1 in range(len(others)):\n                i1 = others[idx1]\n                for idx2 in range(idx1 + 1, len(others)):\n                    i2 = others[idx2]\n                    new_w = w_cur - gallons[o] + gallons[i1] + gallons[i2]\n                    if new_w <= CAP:\n                        dv = values[i1] + values[i2] - values[o]\n                        if dv >= 0:\n                            nxt = sorted([x for x in cur if x != o] + [i1, i2])\n                            return (nxt, '1-2')\n        # 2 -> 1\n        if len(cur) >= 2:\n            for a in range(len(cur)):\n                for b in range(a + 1, len(cur)):\n                    o1, o2 = cur[a], cur[b]\n                    for i in others:\n                        new_w = w_cur - gallons[o1] - gallons[o2] + gallons[i]\n                        if new_w <= CAP:\n                            dv = values[i] - (values[o1] + values[o2])\n                            if dv >= 0:\n                                nxt = sorted([x for x in cur if x not in (o1, o2)] + [i])\n                                return (nxt, '2-1')\n    # No change fallback\n    return (sorted(cur), 'noop')\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Encoded problem data (1-based; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    # Clean current solution\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n    # Randomly remove 1-2 items\n    if cur:\n        k = 1 if len(cur) == 1 else random.choice([1, 2])\n        for _ in range(min(k, len(cur))):\n            idx = random.randrange(len(cur))\n            cur.pop(idx)\n    # Greedy refill by value density within capacity\n    def total_w(sol):\n        return sum(gallons[i] for i in sol)\n    remaining = CAP - total_w(cur)\n    candidates = [i for i in range(1, N + 1) if i not in cur and gallons[i] <= remaining]\n    candidates.sort(key=lambda j: (values[j] \/ gallons[j]), reverse=True)\n    for i in candidates:\n        if gallons[i] <= remaining:\n            cur.append(i)\n            remaining -= gallons[i]\n    return sorted(cur)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Encoded problem data (1-based indexing; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n    # Validate type\n    if not isinstance(solution, list):\n        return math.inf\n    # Validate and enforce uniqueness; duplicates => invalid\n    seen = set()\n    sel = []\n    for i in solution:\n        if not isinstance(i, int) or i < 1 or i > N:\n            return math.inf\n        if i in seen:\n            return math.inf\n        seen.add(i)\n        sel.append(i)\n    total_w = sum(gallons[i] for i in sel)\n    if total_w > CAP:\n        return math.inf\n    profit = sum(values[i] for i in sel)\n    # Cost for minimization (lower is better): -profit\n    return -float(profit)\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    import math\n    # Encoded problem data (1-based indexing; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n\n    # Clean and validate current solution into unique valid indices (preserve first occurrence order)\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n    else:\n        cur = []\n        seen = set()\n\n    def weight(sol):\n        return sum(gallons[i] for i in sol)\n\n    def value(sol):\n        return sum(values[i] for i in sol)\n\n    # Repair if overweight: drop items with lowest value-density first\n    w_cur = weight(cur)\n    if w_cur > CAP and cur:\n        cur_sorted = sorted(cur, key=lambda j: (values[j] \/ max(1, gallons[j])))\n        while cur_sorted and weight(cur_sorted) > CAP:\n            cur_sorted.pop(0)\n        cur = cur_sorted\n        seen = set(cur)\n        w_cur = weight(cur)\n\n    residual = CAP - w_cur\n    all_items = list(range(1, N + 1))\n\n    # Choose move type with simple bias by residual capacity\n    moves = []\n    if residual >= 1:\n        moves.extend([\"add\", \"swap\"])  # prefer adding or swapping when capacity available\n    if cur:\n        moves.extend([\"drop\", \"swap\", \"kex\"])  # allow drop\/swap\/k-exchange when we have items\n    if not moves:\n        moves = [\"add\"]\n    move = random.choice(moves)\n\n    # ADD: pick a feasible new item (biased by value density among top candidates)\n    if move == \"add\":\n        candidates = [i for i in all_items if i not in seen and gallons[i] <= residual]\n        if candidates:\n            candidates.sort(key=lambda j: (values[j] \/ gallons[j]))\n            pick = random.choice(candidates[-min(3, len(candidates)):])\n            nxt = cur + [pick]\n            return (nxt, \"add\")\n\n    # DROP: remove one item (prefer dropping lowest value-density)\n    if move == \"drop\" and cur:\n        drop = min(cur, key=lambda j: (values[j] \/ max(1, gallons[j])))\n        nxt = [x for x in cur if x != drop]\n        return (nxt, \"drop\")\n\n    # SWAP: attempt a non-worsening 1-1 swap within capacity; sample limited pairs for efficiency\n    if move == \"swap\" and cur:\n        best = None  # (delta_value, out, inn)\n        samples = 0\n        max_samples = 200\n        cur_val = value(cur)\n        for o in cur:\n            for i in all_items:\n                if i in seen:\n                    continue\n                new_w = w_cur - gallons[o] + gallons[i]\n                if new_w <= CAP:\n                    dv = values[i] - values[o]\n                    if (best is None) or (dv > best[0]) or (dv == best[0] and gallons[i] < gallons[o]):\n                        best = (dv, o, i)\n                samples += 1\n                if samples >= max_samples:\n                    break\n            if samples >= max_samples:\n                break\n        if best is not None:\n            _, o, i = best\n            nxt = [x for x in cur if x != o] + [i]\n            # Accept even if neutral\/worse occasionally handled by SA; here just return neighbor\n            return (nxt, \"swap\")\n\n    # K-EXCHANGE: try quick 1->2 or 2->1 non-worsening exchanges\n    if move == \"kex\" and cur:\n        others = [i for i in all_items if i not in seen]\n        # 1 -> 2\n        for o in cur:\n            for a in range(len(others)):\n                i1 = others[a]\n                for b in range(a + 1, len(others)):\n                    i2 = others[b]\n                    new_w = w_cur - gallons[o] + gallons[i1] + gallons[i2]\n                    if new_w <= CAP:\n                        dv = values[i1] + values[i2] - values[o]\n                        if dv >= 0:\n                            nxt = [x for x in cur if x != o] + [i1, i2]\n                            return (nxt, \"1-2\")\n        # 2 -> 1\n        if len(cur) >= 2:\n            for a in range(len(cur)):\n                for b in range(a + 1, len(cur)):\n                    o1, o2 = cur[a], cur[b]\n                    for i in others:\n                        new_w = w_cur - gallons[o1] - gallons[o2] + gallons[i]\n                        if new_w <= CAP:\n                            dv = values[i] - (values[o1] + values[o2])\n                            if dv >= 0:\n                                nxt = [x for x in cur if x not in (o1, o2)] + [i]\n                                return (nxt, \"2-1\")\n\n    # Fallback: no change\n    return (cur, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Encoded problem data (1-based indexing; index 0 unused)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    CAP = 9\n    N = 24\n\n    # Clean solution to unique valid indices\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= N and i not in seen:\n                cur.append(i)\n                seen.add(i)\n\n    def total_w(sol):\n        return sum(gallons[i] for i in sol)\n\n    # Randomly remove 1-2 items (if available)\n    if cur:\n        k = 1 if len(cur) == 1 else random.choice([1, 2])\n        for _ in range(min(k, len(cur))):\n            idx = random.randrange(len(cur))\n            cur.pop(idx)\n\n    # Greedy refill by value density within remaining capacity\n    remaining = CAP - total_w(cur)\n    candidates = [i for i in range(1, N + 1) if i not in cur and gallons[i] <= remaining]\n    candidates.sort(key=lambda j: (values[j] \/ gallons[j]), reverse=True)\n    for i in candidates:\n        if gallons[i] <= remaining:\n            cur.append(i)\n            remaining -= gallons[i]\n            if remaining == 0:\n                break\n\n    return cur\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of selected customer indices (1-based)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    if not isinstance(solution, list):\n        return float('-inf')\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > 9:\n        return float('-inf')\n    return sum(values[i] for i in sel)\n","Vecindad":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize and canonicalize input\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = sorted(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list: List[int]) -> List[int]:\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list: List[int]) -> List[int]:\n        s = canonical(sol_list)\n        # remove worst ratio (value\/gal), tie-break by larger gallons\n        while total_g(s) > capacity and s:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        # greedy refill by best ratio while possible\n        remaining = [i for i in range(1, 25) if i not in s]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        for i in remaining:\n            if total_g(s) + gallons[i] <= capacity:\n                s.append(i)\n        return canonical(s)\n\n    universe = list(range(1, 25))\n    move_types = [\"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\", \"ADD_BEST_FIT\", \"K_EXCHANGE\"]\n    move = random.choice(move_types)\n\n    new_sol = sol.copy()\n\n    if move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            random.shuffle(candidates)\n            for c in candidates:\n                trial = new_sol + [c]\n                if feasible(trial):\n                    new_sol = trial\n                    break\n            else:\n                new_sol = repair_feasible(new_sol + [random.choice(candidates)])\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            new_sol.pop(random.randrange(len(new_sol)))\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                if feasible(trial):\n                    new_sol = trial\n                else:\n                    # try limited attempts; otherwise repair\n                    ok = False\n                    for _ in range(8):\n                        out_idx = random.choice(new_sol)\n                        in_idx = random.choice(candidates)\n                        trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                        if feasible(trial):\n                            new_sol = trial\n                            ok = True\n                            break\n                    if not ok:\n                        new_sol = repair_feasible(trial)\n\n    elif move == \"TOGGLE\":\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            new_sol = repair_feasible(new_sol + [idx])\n\n    elif move == \"ADD_BEST_FIT\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            # pick highest value\/gal that fits; tie-break by value\n            candidates.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n            for c in candidates:\n                if total_g(new_sol) + gallons[c] <= capacity:\n                    new_sol.append(c)\n                    break\n            else:\n                # if none fits directly, try repair with best candidate\n                new_sol = repair_feasible(new_sol + [candidates[0]])\n\n    else:  # K_EXCHANGE with k in {2,3}\n        if new_sol:\n            k = random.choice([2, 3])\n            remove_count = min(k, len(new_sol))\n            to_remove = random.sample(new_sol, remove_count)\n            remaining = [i for i in new_sol if i not in to_remove]\n            pool = [i for i in universe if i not in remaining]\n            random.shuffle(pool)\n            trial = remaining.copy()\n            for i in pool[:k]:\n                trial.append(i)\n            new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    new_sol = canonical(new_sol)\n\n    return new_sol, move\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    if not isinstance(solution, list):\n        sol_set = set()\n    else:\n        sol_set = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    sol = sorted(sol_set)\n\n    def total_g(sol_list: List[int]) -> int:\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list: List[int]) -> bool:\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list: List[int]) -> List[int]:\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list: List[int]) -> List[int]:\n        s = canonical(sol_list)\n        while total_g(s) > capacity and s:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        remaining = [i for i in range(1, 25) if i not in s]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        for i in remaining:\n            if total_g(s) + gallons[i] <= capacity:\n                s.append(i)\n        return canonical(s)\n\n    universe = list(range(1, 25))\n    k_edits = random.randint(2, 4)\n    new_sol = sol.copy()\n\n    for _ in range(k_edits):\n        op = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # stronger shake\n        if op == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            if feasible(trial):\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n        elif op == \"REMOVE\":\n            if new_sol:\n                new_sol.pop(random.randrange(len(new_sol)))\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    if feasible(trial):\n                        new_sol = trial\n                    else:\n                        new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    return canonical(new_sol)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST (unique 1-based customer indices in [1,24])","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of selected customer indices (1-based)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    if not isinstance(solution, list):\n        return float('-inf')\n    sel = {i for i in solution if isinstance(i, int) and 1 <= i <= 24}\n    total_gallons = sum(gallons[i] for i in sel)\n    if total_gallons > capacity:\n        return float('-inf')\n    return sum(values[i] for i in sel)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize and canonicalize input once\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n\n    def total_g(sol_list):\n        return sum(gallons[i] for i in sol_list)\n\n    def feasible(sol_list):\n        return total_g(sol_list) <= capacity\n\n    def canonical(sol_list):\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list):\n        s = canonical(sol_list)\n        # remove worst by value\/weight until feasible\n        while s and total_g(s) > capacity:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i], values[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[3], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        # greedy refill by best ratio then value then smaller gallon\n        remaining = [i for i in range(1, 25) if i not in s and gallons[i] <= capacity]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i], -gallons[i]), reverse=True)\n        g = total_g(s)\n        for i in remaining:\n            if g + gallons[i] <= capacity:\n                s.append(i)\n                g += gallons[i]\n        return canonical(s)\n\n    universe = [i for i in range(1, 25) if gallons[i] <= capacity]\n\n    # Try a mix of improving exchanges and random local moves\n    move_types = [\"BEST_11\", \"BEST_21\", \"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\", \"K_EXCHANGE\"]\n    move = random.choice(move_types)\n\n    new_sol = sol.copy()\n\n    # Helper: deterministic best 1-1 exchange (first improvement)\n    if move == \"BEST_11\" and new_sol:\n        current_set = set(new_sol)\n        best_delta = 0\n        best_pair = None\n        cur_val = sum(values[i] for i in new_sol)\n        cur_g = total_g(new_sol)\n        outsiders = [i for i in universe if i not in current_set]\n        for out_idx in new_sol:\n            for in_idx in outsiders:\n                g_new = cur_g - gallons[out_idx] + gallons[in_idx]\n                if g_new <= capacity:\n                    delta = values[in_idx] - values[out_idx]\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [i for i in new_sol if i != out_idx]\n            new_sol.append(in_idx)\n            new_sol = canonical(new_sol)\n        else:\n            move = \"NO_IMPROVE_11\"\n\n    # Best 2-1 exchange (replace up to 2 items with 1 better item)\n    elif move == \"BEST_21\" and new_sol:\n        current_set = set(new_sol)\n        best_delta = 0\n        best_trip = None\n        cur_val = sum(values[i] for i in new_sol)\n        cur_g = total_g(new_sol)\n        outsiders = [i for i in universe if i not in current_set]\n        ln = len(new_sol)\n        for a in range(ln):\n            for b in range(a + 1, ln):\n                out_a, out_b = new_sol[a], new_sol[b]\n                g_base = cur_g - gallons[out_a] - gallons[out_b]\n                v_base = cur_val - values[out_a] - values[out_b]\n                for in_idx in outsiders:\n                    if g_base + gallons[in_idx] <= capacity:\n                        delta = values[in_idx] - (values[out_a] + values[out_b])\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_trip = (out_a, out_b, in_idx)\n        if best_trip is not None:\n            out_a, out_b, in_idx = best_trip\n            new_sol = [i for i in new_sol if i not in (out_a, out_b)]\n            new_sol.append(in_idx)\n            new_sol = canonical(new_sol)\n        else:\n            move = \"NO_IMPROVE_21\"\n\n    elif move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            candidates.sort(key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n            for c in candidates:\n                if total_g(new_sol) + gallons[c] <= capacity:\n                    new_sol.append(c)\n                    break\n            else:\n                # try repair with best candidate\n                new_sol = repair_feasible(new_sol + [candidates[0]])\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            new_sol.pop(random.randrange(len(new_sol)))\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                if total_g(trial) <= capacity:\n                    new_sol = trial\n                else:\n                    new_sol = repair_feasible(trial)\n\n    elif move == \"TOGGLE\":\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            trial = new_sol + [idx]\n            if total_g(trial) <= capacity:\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n\n    else:  # K_EXCHANGE strong move\n        k = 2 if len(new_sol) < 3 else random.choice([2, 3])\n        remove_count = min(k, len(new_sol))\n        to_remove = random.sample(new_sol, remove_count) if new_sol else []\n        remaining = [i for i in new_sol if i not in to_remove]\n        pool = [i for i in universe if i not in remaining]\n        random.shuffle(pool)\n        trial = remaining + pool[:k]\n        new_sol = repair_feasible(trial)\n\n    # finalize\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    new_sol = canonical(new_sol)\n\n    return new_sol, move\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n\n    def total_g(sol_list):\n        return sum(gallons[i] for i in sol_list)\n\n    def canonical(sol_list):\n        return sorted({i for i in sol_list if 1 <= i <= 24})\n\n    def repair_feasible(sol_list):\n        s = canonical(sol_list)\n        while s and total_g(s) > capacity:\n            ratios = [(i, values[i] \/ gallons[i], gallons[i], values[i]) for i in s]\n            worst = min(ratios, key=lambda x: (x[1], -x[3], -x[2]))[0]\n            s = [i for i in s if i != worst]\n        remaining = [i for i in range(1, 25) if i not in s and gallons[i] <= capacity]\n        remaining.sort(key=lambda i: (values[i] \/ gallons[i], values[i], -gallons[i]), reverse=True)\n        g = total_g(s)\n        for i in remaining:\n            if g + gallons[i] <= capacity:\n                s.append(i)\n                g += gallons[i]\n        return canonical(s)\n\n    universe = [i for i in range(1, 25) if gallons[i] <= capacity]\n\n    k_edits = random.randint(2, 4)\n    new_sol = sol.copy()\n\n    for _ in range(k_edits):\n        op = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # stronger shake\n        if op == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            if total_g(trial) <= capacity:\n                new_sol = trial\n            else:\n                new_sol = repair_feasible(trial)\n        elif op == \"REMOVE\":\n            if new_sol:\n                new_sol.pop(random.randrange(len(new_sol)))\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    if total_g(trial) <= capacity:\n                        new_sol = trial\n                    else:\n                        new_sol = repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if total_g(new_sol) > capacity:\n        new_sol = repair_feasible(new_sol)\n    return canonical(new_sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"INDEX_LIST: unique 1-based customer indices in [1,24], order ignored","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: INDEX_LIST (unique 1-based indices in [1,24])\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # Type and content validation\n    if not isinstance(solution, list):\n        return float('-inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('-inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('-inf')\n    if len(solution) != len(set(solution)):\n        return float('-inf')\n\n    total_gallons = sum(gallons[i] for i in solution)\n    if total_gallons > capacity:\n        return float('-inf')\n\n    return sum(values[i] for i in solution)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood generator for INDEX_LIST representation\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    # sanitize once; maintain sorted unique list invariant\n    if isinstance(solution, list):\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n    else:\n        sol = []\n\n    # cached helpers\n    w = gallons\n    v = values\n    universe = [i for i in range(1, 25) if w[i] <= capacity]\n\n    def total_w(s):\n        return sum(w[i] for i in s)\n\n    def feasible(s):\n        return total_w(s) <= capacity\n\n    def canonical(s):\n        return sorted({i for i in s if 1 <= i <= 24})\n\n    def repair_feasible(s):\n        s = canonical(s)\n        # drop worst ratio first until feasible\n        while s and total_w(s) > capacity:\n            worst = min(s, key=lambda i: (v[i] \/ w[i], -v[i], -w[i]))\n            s.remove(worst)\n        # probabilistic refill by ratio then value with slight randomness\n        remaining = [i for i in universe if i not in s]\n        random.shuffle(remaining)\n        remaining.sort(key=lambda i: (v[i] \/ w[i], v[i], -w[i]), reverse=True)\n        g = total_w(s)\n        for i in remaining:\n            if g + w[i] <= capacity and random.random() < 0.95:\n                s.append(i)\n                g += w[i]\n        return canonical(s)\n\n    # choose move type\n    move_types = [\"BEST_11\", \"BEST_21\", \"BEST_22\", \"ADD\", \"REMOVE\", \"SWAP\", \"TOGGLE\", \"K_EXCHANGE\"]\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    if move == \"BEST_11\" and new_sol:\n        cur_set = set(new_sol)\n        cur_w = total_w(new_sol)\n        best_delta = 0\n        best_pair = None\n        outsiders = [i for i in universe if i not in cur_set]\n        # prune outsiders to top-k by ratio\/value\n        outsiders.sort(key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n        outsiders = outsiders[:6] if len(outsiders) > 6 else outsiders\n        for out_idx in new_sol:\n            for in_idx in outsiders:\n                if cur_w - w[out_idx] + w[in_idx] <= capacity:\n                    delta = v[in_idx] - v[out_idx]\n                    if delta > best_delta:\n                        best_delta = delta\n                        best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [i for i in new_sol if i != out_idx] + [in_idx]\n        else:\n            move = \"NO_IMPROVE_11\"\n\n    elif move == \"BEST_21\" and new_sol:\n        cur_set = set(new_sol)\n        cur_w = total_w(new_sol)\n        cur_v = sum(v[i] for i in new_sol)\n        best_delta = 0\n        best_trip = None\n        outsiders = [i for i in universe if i not in cur_set]\n        outsiders.sort(key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n        outsiders = outsiders[:6] if len(outsiders) > 6 else outsiders\n        ln = len(new_sol)\n        for a in range(ln):\n            for b in range(a + 1, ln):\n                out_a, out_b = new_sol[a], new_sol[b]\n                base_w = cur_w - w[out_a] - w[out_b]\n                for in_idx in outsiders:\n                    if base_w + w[in_idx] <= capacity:\n                        delta = v[in_idx] - (v[out_a] + v[out_b])\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_trip = (out_a, out_b, in_idx)\n        if best_trip is not None:\n            out_a, out_b, in_idx = best_trip\n            new_sol = [i for i in new_sol if i not in (out_a, out_b)] + [in_idx]\n        else:\n            move = \"NO_IMPROVE_21\"\n\n    elif move == \"BEST_22\" and new_sol:\n        cur_set = set(new_sol)\n        cur_w = total_w(new_sol)\n        best_delta = 0\n        best_quad = None\n        outsiders = [i for i in universe if i not in cur_set]\n        outsiders.sort(key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n        outsiders = outsiders[:6] if len(outsiders) > 6 else outsiders\n        ln = len(new_sol)\n        for a in range(ln):\n            for b in range(a + 1, ln):\n                out_a, out_b = new_sol[a], new_sol[b]\n                base_w = cur_w - w[out_a] - w[out_b]\n                for i_idx in range(len(outsiders)):\n                    for j_idx in range(i_idx + 1, len(outsiders)):\n                        in_i, in_j = outsiders[i_idx], outsiders[j_idx]\n                        if base_w + w[in_i] + w[in_j] <= capacity:\n                            delta = (v[in_i] + v[in_j]) - (v[out_a] + v[out_b])\n                            if delta > best_delta:\n                                best_delta = delta\n                                best_quad = (out_a, out_b, in_i, in_j)\n        if best_quad is not None:\n            out_a, out_b, in_i, in_j = best_quad\n            new_sol = [i for i in new_sol if i not in (out_a, out_b)] + [in_i, in_j]\n        else:\n            move = \"NO_IMPROVE_22\"\n\n    elif move == \"ADD\":\n        candidates = [i for i in universe if i not in new_sol]\n        if candidates:\n            random.shuffle(candidates)\n            candidates.sort(key=lambda i: (v[i] \/ w[i], v[i]), reverse=True)\n            g = total_w(new_sol)\n            for c in candidates:\n                if g + w[c] <= capacity:\n                    new_sol.append(c)\n                    break\n            else:\n                new_sol = repair_feasible(new_sol + [candidates[0]])\n\n    elif move == \"REMOVE\":\n        if new_sol:\n            rem = random.choice(new_sol)\n            new_sol = [i for i in new_sol if i != rem]\n\n    elif move == \"SWAP\":\n        if new_sol:\n            out_idx = random.choice(new_sol)\n            candidates = [i for i in universe if i not in new_sol]\n            if candidates:\n                in_idx = random.choice(candidates)\n                trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                new_sol = trial if feasible(trial) else repair_feasible(trial)\n\n    elif move == \"TOGGLE\":\n        idx = random.choice(universe)\n        if idx in new_sol:\n            new_sol = [i for i in new_sol if i != idx]\n        else:\n            trial = new_sol + [idx]\n            new_sol = trial if feasible(trial) else repair_feasible(trial)\n\n    else:  # K_EXCHANGE\n        k = 2 if len(new_sol) < 3 else random.choice([2, 3])\n        to_remove = random.sample(new_sol, min(k, len(new_sol))) if new_sol else []\n        remaining = [i for i in new_sol if i not in to_remove]\n        pool = [i for i in universe if i not in remaining]\n        random.shuffle(pool)\n        trial = remaining + pool[:k]\n        new_sol = repair_feasible(trial)\n\n    # finalize once\n    new_sol = canonical(new_sol)\n    if not feasible(new_sol):\n        new_sol = repair_feasible(new_sol)\n    new_sol = canonical(new_sol)\n\n    return new_sol, move\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Stronger random shake while keeping\/repairing feasibility\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    if isinstance(solution, list):\n        sol = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24})\n    else:\n        sol = []\n\n    w = gallons\n    v = values\n\n    def total_w(s):\n        return sum(w[i] for i in s)\n\n    def canonical(s):\n        return sorted({i for i in s if 1 <= i <= 24})\n\n    def repair_feasible(s):\n        s = canonical(s)\n        while s and total_w(s) > capacity:\n            worst = min(s, key=lambda i: (v[i] \/ w[i], -v[i], -w[i]))\n            s.remove(worst)\n        # randomized greedy refill\n        candidates = [i for i in range(1, 25) if i not in s and w[i] <= capacity]\n        random.shuffle(candidates)\n        candidates.sort(key=lambda i: (v[i] \/ w[i], v[i], -w[i]), reverse=True)\n        g = total_w(s)\n        for i in candidates:\n            if g + w[i] <= capacity and random.random() < 0.9:\n                s.append(i)\n                g += w[i]\n        return canonical(s)\n\n    universe = [i for i in range(1, 25) if w[i] <= capacity]\n\n    # random edit strength 2..4\n    k_edits = random.randint(2, 4)\n    new_sol = list(sol)\n\n    for _ in range(k_edits):\n        op = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])  # strong shake\n        if op == \"ADD\":\n            candidates = [i for i in universe if i not in new_sol]\n            if not candidates:\n                continue\n            idx = random.choice(candidates)\n            trial = new_sol + [idx]\n            new_sol = trial if total_w(trial) <= capacity else repair_feasible(trial)\n        elif op == \"REMOVE\":\n            if new_sol:\n                rem = random.choice(new_sol)\n                new_sol = [i for i in new_sol if i != rem]\n        else:  # SWAP\n            if new_sol:\n                out_idx = random.choice(new_sol)\n                candidates = [i for i in universe if i not in new_sol]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    trial = [i for i in new_sol if i != out_idx] + [in_idx]\n                    new_sol = trial if total_w(trial) <= capacity else repair_feasible(trial)\n\n    new_sol = canonical(new_sol)\n    if total_w(new_sol) > capacity:\n        new_sol = repair_feasible(new_sol)\n    return canonical(new_sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs (e.g., \"4,8,18\"). Order ignored; always output sorted, no spaces.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns cost (to minimize): cost = -total_value if feasible; large positive penalty if invalid\/infeasible.\n    Representation: CSV of unique IDs in [1,24].\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18  # large positive since we minimize\n    if not isinstance(solution, str):\n        return PENALTY\n    raw_tokens = solution.split(',')\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    ids_list = [int(t) for t in tokens]\n    # duplicates invalid\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    # range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    # minimize cost = -revenue\n    return float(-total_v)","Vecindad":"import random\nfrom typing import Optional\n\ndef generate_neighbour(solution) -> tuple:\n    \"\"\"\n    Returns (new_solution_str, move_type).\n    Representation: CSV of unique indices in [1,24], canonical sorted, no spaces.\n    Moves: add, remove, swap, k_exchange (k in {2,3}); preserves feasibility when possible.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str: Optional[str]):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set(), 0\n        ids = set()\n        w = 0\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24 and i not in ids:\n                    v_i, w_i = offers[i]\n                    if w + w_i <= CAP:\n                        ids.add(i)\n                        w += w_i\n        return ids, w\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    ids, cur_w = parse(solution)\n    universe = list(range(1, 25))\n    not_in = [i for i in universe if i not in ids]\n\n    # Adaptive move probabilities based on slack\n    slack = CAP - cur_w\n    if slack <= 1:\n        probs = [0.15, 0.45, 0.25, 0.15]  # add, remove, swap, k-exchange\n    elif slack <= 3:\n        probs = [0.35, 0.25, 0.25, 0.15]\n    else:\n        probs = [0.50, 0.15, 0.20, 0.15]\n\n    move = random.choices([\"add\",\"remove\",\"swap\",\"k_exchange\"], probs)[0]\n\n    # helper: biased pick by value\/weight ratio\n    def best_fit_candidates(candidates, budget):\n        scored = []\n        for j in candidates:\n            v, w = offers[j]\n            if w <= budget:\n                scored.append((-(v\/max(w,1)), -v, w, j))  # primary: high v\/w, tie: high v, then low w\n        scored.sort()\n        return [j for _,__,___,j in scored]\n\n    # add\n    if move == \"add\":\n        if not_in and cur_w < CAP:\n            cands = best_fit_candidates(not_in, CAP - cur_w)\n            if cands:\n                j = cands[0]\n                ids.add(j)\n                return to_str(ids), \"add\"\n        # fallback to remove if cannot add\n        move = \"remove\"\n\n    # remove\n    if move == \"remove\":\n        if ids:\n            # remove lowest value density first to free capacity\n            rem = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1] > 0 else float('inf')))[0]\n            ids.remove(rem)\n            return to_str(ids), \"remove\"\n        else:\n            # fallback: add lightest feasible item\n            light = min(universe, key=lambda i: offers[i][1])\n            if offers[light][1] <= CAP:\n                ids.add(light)\n            return to_str(ids), \"add\"\n\n    # swap: replace one selected with one outside, maintain feasibility\n    if move == \"swap\":\n        if ids and not_in:\n            out_i = random.choice(tuple(ids))\n            rem_w = cur_w - offers[out_i][1]\n            budget = CAP - rem_w\n            cands = best_fit_candidates(not_in, budget)\n            if cands:\n                in_j = cands[0]\n                ids.remove(out_i)\n                ids.add(in_j)\n                return to_str(ids), \"swap\"\n        # fallback to k-exchange\n        move = \"k_exchange\"\n\n    # k-exchange: drop up to k in {2,3}, insert best-fitting items greedily\n    if move == \"k_exchange\":\n        if ids:\n            k = 3 if len(ids) >= 3 and random.random() < 0.5 else 2\n            drop = random.sample(list(ids), k=min(k, len(ids)))\n            for d in drop:\n                ids.remove(d)\n                cur_w -= offers[d][1]\n            # refill greedily by v\/w\n            candidates = [i for i in universe if i not in ids]\n            while True:\n                budget = CAP - cur_w\n                if budget <= 0:\n                    break\n                cands = best_fit_candidates(candidates, budget)\n                if not cands:\n                    break\n                j = cands[0]\n                wj = offers[j][1]\n                if cur_w + wj <= CAP:\n                    ids.add(j)\n                    cur_w += wj\n                    candidates.remove(j)\n                else:\n                    break\n            return to_str(ids), \"k_exchange\"\n        # fallback: no-op\n    return to_str(ids), \"noop\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multiple random add\/remove\/swap operations with final feasibility repair.\n    Returns a canonical CSV string.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol_str):\n        if not isinstance(sol_str, str) or sol_str.strip() == \"\":\n            return set()\n        ids = set()\n        for t in sol_str.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if s.isdigit():\n                i = int(s)\n                if 1 <= i <= 24:\n                    ids.add(i)\n        return ids\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    ids = parse(solution)\n\n    ops = random.randint(3, 6)\n    for _ in range(ops):\n        move = random.choices([\"add\",\"remove\",\"swap\"], [0.45, 0.2, 0.35])[0]\n        if move == \"add\":\n            candidates = [i for i in range(1,25) if i not in ids]\n            random.shuffle(candidates)\n            # biased by value\/weight\n            candidates.sort(key=lambda j: (-(offers[j][0]\/offers[j][1] if offers[j][1]>0 else offers[j][0]), -offers[j][0]))\n            for j in candidates:\n                if weight(ids) + offers[j][1] <= CAP:\n                    ids.add(j)\n                    break\n        elif move == \"remove\":\n            if ids:\n                # remove lowest value density\n                rem = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1]>0 else float('inf')))[0]\n                ids.remove(rem)\n        else:  # swap\n            if ids:\n                out_i = random.choice(tuple(ids))\n                rem_w = weight(ids) - offers[out_i][1]\n                budget = CAP - rem_w\n                cands = [j for j in range(1,25) if j not in ids and offers[j][1] <= budget]\n                if cands:\n                    # pick best by v\/w\n                    j = max(cands, key=lambda k: (offers[k][0]\/offers[k][1] if offers[k][1]>0 else offers[k][0], offers[k][0]))\n                    ids.remove(out_i)\n                    ids.add(j)\n    # Final repair to ensure feasibility\n    while weight(ids) > CAP:\n        # drop item with worst value density first\n        drop = min(ids, key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1]>0 else float('inf')))\n        ids.remove(drop)\n    return to_str(ids)","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs in ascending order with no spaces (e.g., \"4,8,18\"). Order is canonical and ignored semantically.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric cost to minimize.\n    Feasible: cost = -total_value (maximize value)\n    Infeasible\/invalid: large positive penalty.\n    Representation: canonical CSV of unique IDs in [1,24].\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18\n    if not isinstance(solution, str):\n        return PENALTY\n    # tokenize and basic validation\n    tokens = []\n    for t in solution.split(','):\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    # parse ids\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return PENALTY\n    # check duplicates and range\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    return float(-total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_str, move_type).\n    Representation: CSV of unique indices in [1,24], canonical sorted, no spaces.\n    Moves: add, remove, swap, two_for_one, k_exchange (drop up to 3 then optimal refill via DP).\n    Ensures returned solution is valid and canonical; if unable to improve\/modify, may return the input canonicalized with move 'noop'.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def total_value(ids_set):\n        return sum(offers[i][0] for i in ids_set)\n\n    def best_single_add(cand_ids, budget):\n        best = None\n        best_v = -1\n        for j in cand_ids:\n            vj, wj = offers[j]\n            if wj <= budget and vj > best_v:\n                best = j\n                best_v = vj\n        return best\n\n    def best_pair_fill(cand_ids, budget):\n        # exact best of up to 2 items within budget\n        best = set()\n        best_v = -1\n        c_list = list(cand_ids)\n        n = len(c_list)\n        for idx in range(n):\n            j = c_list[idx]\n            vj, wj = offers[j]\n            if wj <= budget and vj > best_v:\n                best = {j}\n                best_v = vj\n            for k in range(idx+1, n):\n                j2 = c_list[k]\n                v2, w2 = offers[j2]\n                w = wj + w2\n                if w <= budget:\n                    v = vj + v2\n                    if v > best_v:\n                        best = {j, j2}\n                        best_v = v\n        return best, best_v\n\n    def dp_best_subset(cand_ids, budget):\n        # 0-1 knapsack exact DP for small CAP\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        # reconstruct\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            j = items[idx]\n            vj, wj = offers[j]\n            if choose[idx][c]:\n                res.add(j)\n                c -= wj\n        return res, dp[budget]\n\n    ids = parse(solution)\n    cur_w = total_weight(ids)\n\n    universe = set(range(1, 25))\n    outside = universe - ids\n\n    # Ensure feasibility; if infeasible, repair by DP immediately\n    if cur_w > CAP:\n        # drop then refill optimally\n        # drop worst-density items first to reduce quickly, then DP refill\n        ordered = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1] if offers[i][1] > 0 else float('inf')))\n        while cur_w > CAP and ordered:\n            rem = ordered.pop(0)\n            ids.remove(rem)\n            cur_w -= offers[rem][1]\n        # refill\n        budget = CAP - cur_w\n        add_set, _ = dp_best_subset(universe - ids, budget)\n        ids |= add_set\n        return to_str(ids), \"repair\"\n\n    slack = CAP - cur_w\n    moves = [\"add\", \"remove\", \"swap\", \"two_for_one\", \"k_exchange\"]\n    if slack <= 1:\n        probs = [0.15, 0.35, 0.30, 0.10, 0.10]\n    elif slack <= 3:\n        probs = [0.35, 0.20, 0.25, 0.10, 0.10]\n    else:\n        probs = [0.45, 0.15, 0.20, 0.10, 0.10]\n    move = random.choices(moves, probs)[0]\n\n    # ADD\n    if move == \"add\":\n        if slack > 0 and outside:\n            best = best_single_add(outside, slack)\n            if best is not None:\n                ids.add(best)\n                return to_str(ids), \"add\"\n        # fallback to swap if cannot add\n        move = \"swap\"\n\n    # REMOVE\n    if move == \"remove\":\n        if ids:\n            # remove the item with lowest value; simple and fast\n            rem = min(ids, key=lambda i: offers[i][0])\n            ids.remove(rem)\n            return to_str(ids), \"remove\"\n        else:\n            # nothing to remove, try add smallest weight high value\n            best = best_single_add(outside, CAP)\n            if best is not None:\n                ids.add(best)\n            return to_str(ids), \"add\"\n\n    # SWAP 1-1\n    if move == \"swap\":\n        if ids and outside:\n            best_delta = 0  # improvement in value\n            best_pair = None\n            cur_v = total_value(ids)\n            for i in list(ids):\n                wi = offers[i][1]\n                for j in list(outside):\n                    vj, wj = offers[j]\n                    if cur_w - wi + wj <= CAP:\n                        delta = vj - offers[i][0]\n                        if delta > best_delta:\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                ids.remove(i)\n                ids.add(j)\n                return to_str(ids), \"swap\"\n        # fallback\n        move = \"two_for_one\"\n\n    # TWO FOR ONE (drop up to 2, add best single)\n    if move == \"two_for_one\":\n        if len(ids) >= 2:\n            best_gain = 0\n            best_action = None\n            ids_list = list(ids)\n            n = len(ids_list)\n            for a in range(n):\n                i = ids_list[a]\n                wi = offers[i][1]\n                for b in range(a+1, n):\n                    k = ids_list[b]\n                    wk = offers[k][1]\n                    budget = CAP - (cur_w - wi - wk)\n                    if budget <= 0:\n                        continue\n                    j = best_single_add(outside - {i, k}, budget)\n                    if j is not None:\n                        gain = offers[j][0] - (offers[i][0] + offers[k][0])\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_action = (i, k, j)\n            if best_action is not None:\n                i, k, j = best_action\n                ids.remove(i)\n                ids.remove(k)\n                ids.add(j)\n                return to_str(ids), \"two_for_one\"\n        move = \"k_exchange\"\n\n    # K-EXCHANGE with optimal refill (drop up to 3, then DP refill)\n    if move == \"k_exchange\":\n        if ids:\n            k = 3 if len(ids) >= 3 and random.random() < 0.5 else 2\n            drop_cnt = min(k, len(ids))\n            dropped = random.sample(list(ids), drop_cnt)\n            for d in dropped:\n                ids.remove(d)\n            cur_w2 = total_weight(ids)\n            budget = CAP - cur_w2\n            cand = universe - ids\n            add_set, _ = dp_best_subset(cand, budget)\n            ids |= add_set\n            return to_str(ids), \"k_exchange\"\n\n    return to_str(ids), \"noop\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation with random removals and optimal refill via small DP.\n    Ensures final solution is feasible and canonical CSV.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def dp_best_subset(cand_ids, budget):\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            if choose[idx][c]:\n                j = items[idx]\n                _, wj = offers[j]\n                res.add(j)\n                c -= wj\n        return res\n\n    ids = parse(solution)\n\n    # Randomly remove some items (0-3) to escape basin\n    if ids:\n        remove_cnt = random.randint(1, min(3, len(ids)))\n        for _ in range(remove_cnt):\n            if not ids:\n                break\n            rem = random.choice(tuple(ids))\n            ids.remove(rem)\n\n    # Optionally add a random feasible item\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    if budget > 0:\n        candidates = [j for j in range(1,25) if j not in ids and offers[j][1] <= budget]\n        if candidates and random.random() < 0.6:\n            j = random.choice(candidates)\n            ids.add(j)\n\n    # Repair\/refill optimally via DP\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    cand = set(range(1,25)) - ids\n    add_set = dp_best_subset(cand, budget)\n    ids |= add_set\n\n    # Final feasibility guard: if overweight (shouldn't happen), drop random until feasible\n    while total_weight(ids) > CAP and ids:\n        ids.remove(random.choice(tuple(ids)))\n\n    return to_str(ids)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"CSV_INDEX_LIST_STR: comma-separated unique customer IDs in ascending order with no spaces (e.g., \"4,8,18\"). Order is canonical and ignored semantically.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric cost to minimize.\n    Feasible: cost = -total_value (maximize value)\n    Infeasible\/invalid: large positive penalty.\n    Representation: canonical CSV of unique IDs in [1,24].\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    PENALTY = 1e18\n    if not isinstance(solution, str):\n        return PENALTY\n    # tokenize and basic validation\n    tokens = []\n    for t in solution.split(','):\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return PENALTY\n        tokens.append(s)\n    # parse ids\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return PENALTY\n    # check duplicates and range\n    if len(ids_list) != len(set(ids_list)):\n        return PENALTY\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return PENALTY\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return PENALTY\n    return float(-total_v)\n","Vecindad":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_str, move_type).\n    Representation: CSV of unique indices in [1,24], canonical sorted, no spaces.\n    Moves: add, remove (density-based), swap (1-1), two_for_one (drop 2 add best via DP),\n           k_exchange (enumerate drop sets up to size 3 with DP refill; pick a random viable neighbor).\n    Ensures returned solution is feasible and canonical; may return input canonicalized with move 'noop'.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def total_value(ids_set):\n        return sum(offers[i][0] for i in ids_set)\n\n    def dp_best_subset(cand_ids, budget):\n        # 0-1 knapsack exact DP for small CAP\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        # reconstruct\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            if choose[idx][c]:\n                j = items[idx]\n                _, wj = offers[j]\n                res.add(j)\n                c -= wj\n        return res, dp[budget]\n\n    ids = parse(solution)\n    cur_w = total_weight(ids)\n\n    universe = set(range(1, 25))\n    outside = universe - ids\n\n    # Feasibility repair if needed\n    if cur_w > CAP:\n        # Drop worst density until feasible, then optimal refill via DP\n        ordered = sorted(list(ids), key=lambda i: (offers[i][0]\/offers[i][1]))\n        while cur_w > CAP and ordered:\n            rem = ordered.pop(0)\n            ids.remove(rem)\n            cur_w -= offers[rem][1]\n        budget = CAP - cur_w\n        add_set, _ = dp_best_subset(universe - ids, budget)\n        ids |= add_set\n        return to_str(ids), \"repair\"\n\n    slack = CAP - cur_w\n    moves = [\"add\", \"remove\", \"swap\", \"two_for_one\", \"k_exchange\"]\n    if slack <= 1:\n        probs = [0.15, 0.35, 0.30, 0.10, 0.10]\n    elif slack <= 3:\n        probs = [0.35, 0.20, 0.25, 0.10, 0.10]\n    else:\n        probs = [0.45, 0.15, 0.20, 0.10, 0.10]\n    move = random.choices(moves, probs)[0]\n\n    # ADD: add best feasible by value within slack (if any)\n    if move == \"add\":\n        if slack > 0 and outside:\n            best = None\n            best_v = -1\n            for j in outside:\n                vj, wj = offers[j]\n                if wj <= slack and vj > best_v:\n                    best = j\n                    best_v = vj\n            if best is not None:\n                ids.add(best)\n                return to_str(ids), \"add\"\n        move = \"swap\"  # fallback\n\n    # REMOVE: remove worst density to free capacity with minimal value loss\n    if move == \"remove\":\n        if ids:\n            rem = min(ids, key=lambda i: (offers[i][0]\/offers[i][1]))\n            ids.remove(rem)\n            return to_str(ids), \"remove\"\n        else:\n            # Nothing to remove; attempt to add best singleton within CAP from empty\n            best_single, _ = dp_best_subset(universe, CAP)\n            ids |= best_single\n            return to_str(ids), \"add\"\n\n    # SWAP 1-1: choose a random improving or non-improving feasible swap\n    if move == \"swap\":\n        candidates = []\n        for i in ids:\n            wi = offers[i][1]\n            for j in outside:\n                vj, wj = offers[j]\n                if cur_w - wi + wj <= CAP:\n                    candidates.append((i, j))\n        if candidates:\n            i, j = random.choice(candidates)\n            ids.remove(i)\n            ids.add(j)\n            return to_str(ids), \"swap\"\n        move = \"two_for_one\"\n\n    # TWO FOR ONE: drop 2, then refill optimally via DP with freed budget\n    if move == \"two_for_one\":\n        ids_list = list(ids)\n        if len(ids_list) >= 2:\n            # sample a pair or pick the worst-density pair\n            # choose worst-density pair by sum density heuristic\n            worst_pair = None\n            worst_score = float('inf')\n            for a, b in combinations(ids_list, 2):\n                score = (offers[a][0]\/offers[a][1]) + (offers[b][0]\/offers[b][1])\n                if score < worst_score:\n                    worst_score = score\n                    worst_pair = (a, b)\n            if worst_pair is not None:\n                a, b = worst_pair\n                ids.remove(a)\n                ids.remove(b)\n                cur_w2 = total_weight(ids)\n                budget = CAP - cur_w2\n                cand = universe - ids\n                add_set, _ = dp_best_subset(cand, budget)\n                ids |= add_set\n                return to_str(ids), \"two_for_one\"\n        move = \"k_exchange\"\n\n    # K-EXCHANGE: enumerate drop sets up to size 3, pick a random non-empty neighbor after optimal refill\n    if move == \"k_exchange\":\n        ids_list = list(ids)\n        all_neighbors = []\n        max_drop = min(3, len(ids_list))\n        for k in range(1, max_drop+1):\n            for drop_set in combinations(ids_list, k):\n                new_ids = set(ids_list)\n                for d in drop_set:\n                    new_ids.remove(d)\n                cur_w2 = total_weight(new_ids)\n                budget = CAP - cur_w2\n                if budget < 0:\n                    continue\n                cand = universe - new_ids\n                add_set, _ = dp_best_subset(cand, budget)\n                neighbor = new_ids | add_set\n                if neighbor != set(ids_list):\n                    all_neighbors.append(neighbor)\n        if all_neighbors:\n            chosen = random.choice(all_neighbors)\n            return to_str(chosen), \"k_exchange\"\n\n    # Fallback: return canonicalized input\n    return to_str(ids), \"noop\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation with randomized removals (1-3) and optimal DP refill.\n    Ensures final solution is feasible and canonical CSV.\n    \"\"\"\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def to_str(ids_set):\n        if not ids_set:\n            return \"\"\n        return \",\".join(str(i) for i in sorted(ids_set))\n\n    def parse(sol_str):\n        ids = set()\n        if isinstance(sol_str, str) and sol_str.strip() != \"\":\n            for t in sol_str.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if s.isdigit():\n                    i = int(s)\n                    if 1 <= i <= 24:\n                        ids.add(i)\n        return ids\n\n    def total_weight(ids_set):\n        return sum(offers[i][1] for i in ids_set)\n\n    def dp_best_subset(cand_ids, budget):\n        items = list(cand_ids)\n        dp = [0] * (budget + 1)\n        choose = [[False]*(budget+1) for _ in range(len(items))]\n        for idx, j in enumerate(items):\n            vj, wj = offers[j]\n            for c in range(budget, wj-1, -1):\n                if dp[c - wj] + vj > dp[c]:\n                    dp[c] = dp[c - wj] + vj\n                    choose[idx][c] = True\n        res = set()\n        c = budget\n        for idx in range(len(items)-1, -1, -1):\n            if choose[idx][c]:\n                j = items[idx]\n                _, wj = offers[j]\n                res.add(j)\n                c -= wj\n        return res\n\n    ids = parse(solution)\n\n    # Randomly remove 1..min(3, |ids|)\n    if ids:\n        remove_cnt = random.randint(1, min(3, len(ids)))\n        for _ in range(remove_cnt):\n            if not ids:\n                break\n            rem = random.choice(tuple(ids))\n            ids.remove(rem)\n\n    # Optional random feasible add (diversification)\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    if budget > 0:\n        candidates = [j for j in range(1,25) if j not in ids and offers[j][1] <= budget]\n        if candidates and random.random() < 0.6:\n            j = random.choice(candidates)\n            ids.add(j)\n\n    # Optimal refill via DP\n    cur_w = total_weight(ids)\n    budget = max(0, CAP - cur_w)\n    cand = set(range(1,25)) - ids\n    add_set = dp_best_subset(cand, budget)\n    ids |= add_set\n\n    # Final feasibility guard\n    while total_weight(ids) > CAP and ids:\n        ids.remove(random.choice(tuple(ids)))\n\n    return to_str(ids)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST; unique 1-based attraction indices; order irrelevant; duplicates ignored.","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns a cost to minimize: feasible => negative total score; infeasible => large positive with graded penalty\n    def objective_function(sol: List[int]) -> int:\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        if not isinstance(sol, list):\n            return -10**9\n        total = 0\n        seen: Set[int] = set()\n        for idx in sol:\n            if isinstance(idx, int) and 1 <= idx < len(scores) and idx not in seen:\n                total += scores[idx]\n                seen.add(idx)\n        return total\n\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    if not isinstance(solution, list):\n        return 10**9\n    # make unique, filter bounds, preserve first occurrence order\n    seen: Set[int] = set()\n    unique: List[int] = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    capacity = 90\n    if total_time <= capacity:\n        return -objective_function(unique)\n    # graded penalty for infeasible\n    overflow = total_time - capacity\n    base_penalty = 10**6\n    return float(base_penalty + overflow)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Capacity-aware add\/exchange; order-independent unique set representation\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_sorted(sol: List[int]) -> List[int]:\n        s = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in s:\n                s.add(x)\n                out.append(x)\n        return sorted(out)\n\n    cur = make_unique_sorted(solution if isinstance(solution, list) else [])\n    cur_time = sum(times[i] for i in cur)\n    all_idx = list(range(1, 25))\n\n    if not cur:\n        # add one feasible index with best score\/time ratio\n        candidates = [i for i in all_idx if times[i] <= capacity]\n        if not candidates:\n            return (cur, \"SetIndex\", \"NoOp\")\n        # simple bias towards better density using fixed arrays inside\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        densities = sorted(candidates, key=lambda i: (-scores[i]\/times[i], -scores[i]))\n        return (make_unique_sorted(cur + [random.choice(densities[:min(5, len(densities))])]), \"SetIndex\", \"Add\")\n\n    move = random.choice([\"add\", \"remove\", \"exchange\"]) if cur else \"add\"\n\n    if move == \"add\":\n        remaining = capacity - cur_time\n        feas = [i for i in all_idx if i not in cur and times[i] <= remaining]\n        if feas:\n            return (make_unique_sorted(cur + [random.choice(feas)]), \"SetIndex\", \"Add\")\n        # fallback: if no feasible add, try a 1-1 exchange instead\n        move = \"exchange\"\n\n    if move == \"remove\":\n        rem = random.choice(cur)\n        nxt = [x for x in cur if x != rem]\n        return (make_unique_sorted(nxt), \"SetIndex\", \"Remove\")\n\n    if move == \"exchange\":\n        # drop one, add one that fits\n        drop = random.choice(cur)\n        after_drop_time = cur_time - times[drop]\n        remaining = capacity - after_drop_time\n        pool = [i for i in all_idx if i != drop and i not in cur and times[i] <= remaining]\n        if pool:\n            add = random.choice(pool)\n            nxt = [x for x in cur if x != drop] + [add]\n            return (make_unique_sorted(nxt), \"SetIndex\", \"Exchange\")\n        # if no fitting add, fall back to remove\n        nxt = [x for x in cur if x != drop]\n        return (make_unique_sorted(nxt), \"SetIndex\", \"Remove\")\n\n    return (cur, \"SetIndex\", \"NoOp\")","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Stronger shake while keeping feasibility preference\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_sorted(sol: List[int]) -> List[int]:\n        s = set()\n        out = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in s:\n                s.add(x)\n                out.append(x)\n        return sorted(out)\n\n    cur = make_unique_sorted(solution if isinstance(solution, list) else [])\n    cur_time = sum(times[i] for i in cur)\n\n    # Randomly remove up to ceil(n\/2)\n    n = len(cur)\n    r = random.randint(0, (n + 1) \/\/ 2)\n    if r > 0 and n > 0:\n        to_remove = set(random.sample(cur, min(r, n)))\n        cur = [x for x in cur if x not in to_remove]\n        cur_time = sum(times[i] for i in cur)\n\n    # Add up to k new feasible elements\n    k = random.randint(1, 3)\n    for _ in range(k):\n        remaining = capacity - cur_time\n        if remaining <= 0:\n            break\n        pool = [i for i in range(1,25) if i not in cur and times[i] <= remaining]\n        if not pool:\n            break\n        pick = random.choice(pool)\n        cur.append(pick)\n        cur = make_unique_sorted(cur)\n        cur_time += times[pick]\n\n    return make_unique_sorted(cur)","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Cost to minimize: feasible => negative total score; infeasible => large positive with graded penalty\n    def objective_function(sol: List[int]) -> int:\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        if not isinstance(sol, list):\n            return -10**9\n        total = 0\n        seen: Set[int] = set()\n        for idx in sol:\n            if isinstance(idx, int) and 1 <= idx < len(scores) and idx not in seen:\n                total += scores[idx]\n                seen.add(idx)\n        return total\n\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    if not isinstance(solution, list):\n        return 10**9\n\n    # make unique, filter bounds, preserve first occurrence order\n    seen: Set[int] = set()\n    unique: List[int] = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n\n    total_time = sum(times[i] for i in unique)\n    capacity = 90\n    if total_time <= capacity:\n        # feasible: minimize negative score\n        return float(-objective_function(unique))\n\n    # infeasible: large positive penalty with overflow component\n    overflow = total_time - capacity\n    base_penalty = 10**6\n    return float(base_penalty + overflow)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"SetIndex\", Movement_Type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 90\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n    cur_time = total_time(cur)\n    all_idx = [i for i in range(1, 25) if times[i] <= capacity]\n\n    if not cur:\n        # Seed with a density-guided feasible add\n        candidates = [i for i in all_idx if times[i] <= capacity]\n        if not candidates:\n            return (cur, \"SetIndex\", \"NoOp\")\n        dens_sorted = sorted(candidates, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n        pick = random.choice(dens_sorted[:min(5, len(dens_sorted))])\n        return ([pick], \"SetIndex\", \"Add\")\n\n    move = random.choice([\"add\", \"remove\", \"exchange\"]) if cur else \"add\"\n\n    if move == \"add\":\n        remaining = capacity - cur_time\n        feas = [i for i in all_idx if i not in cur and times[i] <= remaining]\n        if feas:\n            # bias by density\n            feas_sorted = sorted(feas, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n            add = random.choice(feas_sorted[:min(5, len(feas_sorted))])\n            return (cur + [add], \"SetIndex\", \"Add\")\n        move = \"exchange\"  # fallback\n\n    if move == \"remove\":\n        rem = random.choice(cur)\n        nxt = [x for x in cur if x != rem]\n        return (nxt, \"SetIndex\", \"Remove\")\n\n    if move == \"exchange\":\n        drop = random.choice(cur)\n        after_drop_time = cur_time - times[drop]\n        remaining = capacity - after_drop_time\n        pool = [i for i in all_idx if i not in cur and i != drop and times[i] <= remaining]\n        if pool:\n            pool_sorted = sorted(pool, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n            add = random.choice(pool_sorted[:min(5, len(pool_sorted))])\n            nxt = [x for x in cur if x != drop] + [add]\n            return (nxt, \"SetIndex\", \"Exchange\")\n        # If nothing fits, remove the drop\n        nxt = [x for x in cur if x != drop]\n        return (nxt, \"SetIndex\", \"Remove\")\n\n    return (cur, \"SetIndex\", \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake while favoring feasibility\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n    n = len(cur)\n\n    # Randomly remove up to ceil(n\/2)\n    if n > 0:\n        r = random.randint(0, (n + 1) \/\/ 2)\n        if r > 0:\n            to_remove = set(random.sample(cur, min(r, n)))\n            cur = [x for x in cur if x not in to_remove]\n\n    # Try to add 1-3 feasible indices guided by density\n    cur_time = total_time(cur)\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    for _ in range(random.randint(1, 3)):\n        remaining = capacity - cur_time\n        if remaining <= 0:\n            break\n        pool = [i for i in range(1, 25) if i not in cur and times[i] <= remaining]\n        if not pool:\n            break\n        pool_sorted = sorted(pool, key=lambda i: (-scores[i] \/ times[i], -scores[i]))\n        pick = random.choice(pool_sorted[:min(5, len(pool_sorted))])\n        cur.append(pick)\n        cur_time += times[pick]\n\n    return make_unique_in_order(cur)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost to minimize\n    # Feasible => negative total score (higher score => more negative => better)\n    # Infeasible => large positive penalty increasing with overflow\n    def objective_function(sol_list):\n        scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        total = 0\n        seen = set()\n        for idx in sol_list if isinstance(sol_list, list) else []:\n            if isinstance(idx, int) and 1 <= idx < len(scores) and idx not in seen:\n                total += scores[idx]\n                seen.add(idx)\n        return total\n\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    if not isinstance(solution, list):\n        return float(10**9)\n\n    # Canonical unique-in-order representation\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx < len(times) and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n\n    total_time = sum(times[i] for i in unique)\n    if total_time <= capacity:\n        return float(-objective_function(unique))\n\n    # Infeasible penalty\n    overflow = total_time - capacity\n    base_penalty = 1e4\n    weight = 100.0\n    return float(base_penalty + weight * overflow)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"SetIndex\", Movement_Type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 90\n    n_items = 24\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n    cur_time = total_time(cur)\n\n    if not cur:\n        # Seed by density-guided add (can be infeasible; evaluator will penalize if so)\n        candidates = [i for i in range(1, n_items + 1)]\n        dens_sorted = sorted(candidates, key=lambda i: (-(scores[i] \/ max(1, times[i])), -scores[i]))\n        pick = random.choice(dens_sorted[:min(5, len(dens_sorted))])\n        return ([pick], \"SetIndex\", \"Add\")\n\n    moves = [\n        \"add\", \"remove\", \"exchange1-1\", \"exchange2-1\", \"exchange1-2\", \"exchange2-2\", \"kick\"\n    ]\n    move = random.choice(moves)\n\n    all_idx = list(range(1, n_items + 1))\n    available = [i for i in all_idx if i not in cur]\n\n    if move == \"add\":\n        if available:\n            # Allow infeasible add; evaluation handles penalty\n            pool = available\n            pool_sorted = sorted(pool, key=lambda i: (-(scores[i] \/ max(1, times[i])), -scores[i]))\n            add = random.choice(pool_sorted[:min(6, len(pool_sorted))])\n            return (cur + [add], \"SetIndex\", \"Add\")\n        return (cur, \"SetIndex\", \"NoOp\")\n\n    if move == \"remove\":\n        rem = random.choice(cur)\n        nxt = [x for x in cur if x != rem]\n        return (nxt, \"SetIndex\", \"Remove\")\n\n    if move == \"exchange1-1\":\n        drop = random.choice(cur)\n        add_pool = [i for i in available if i != drop]\n        if add_pool:\n            add = random.choice(add_pool)\n            nxt = [x for x in cur if x != drop] + [add]\n            return (nxt, \"SetIndex\", \"Exchange1-1\")\n        return (cur, \"SetIndex\", \"NoOp\")\n\n    if move == \"exchange2-1\" and len(cur) >= 2 and available:\n        drops = random.sample(cur, 2)\n        add = random.choice(available)\n        nxt = [x for x in cur if x not in drops] + [add]\n        return (nxt, \"SetIndex\", \"Exchange2-1\")\n\n    if move == \"exchange1-2\" and len(available) >= 2:\n        drop = random.choice(cur)\n        adds = random.sample([i for i in available if i != drop], 2)\n        nxt = [x for x in cur if x != drop] + adds\n        return (nxt, \"SetIndex\", \"Exchange1-2\")\n\n    if move == \"exchange2-2\" and len(cur) >= 2 and len(available) >= 2:\n        drops = random.sample(cur, 2)\n        adds = random.sample([i for i in available if i not in drops], 2)\n        nxt = [x for x in cur if x not in drops] + adds\n        return (nxt, \"SetIndex\", \"Exchange2-2\")\n\n    if move == \"kick\":\n        # Remove k low-density indices then add m high-density indices (may be infeasible)\n        k = 1 if len(cur) == 1 else random.randint(1, min(2, len(cur)))\n        dens_cur = sorted(cur, key=lambda i: (scores[i] \/ max(1, times[i])))\n        to_remove = set(dens_cur[:k])\n        base = [x for x in cur if x not in to_remove]\n        m = random.randint(1, 2)\n        add_pool = [i for i in all_idx if i not in base]\n        dens_sorted = sorted(add_pool, key=lambda i: (-(scores[i] \/ max(1, times[i])), -scores[i]))\n        adds = []\n        for _ in range(min(m, len(dens_sorted))):\n            cand = random.choice(dens_sorted[:min(6, len(dens_sorted))])\n            adds.append(cand)\n            dens_sorted = [x for x in dens_sorted if x != cand]\n        return (base + adds, \"SetIndex\", \"Kick\")\n\n    return (cur, \"SetIndex\", \"NoOp\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation favoring feasibility via greedy refill by density\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 90\n    n_items = 24\n\n    def make_unique_in_order(sol):\n        seen = set()\n        out = []\n        for x in sol if isinstance(sol, list) else []:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def total_time(sol_list):\n        return sum(times[i] for i in sol_list)\n\n    cur = make_unique_in_order(solution)\n\n    # Remove up to ceil(n\/2), biased by low density\n    n = len(cur)\n    if n > 0:\n        r = random.randint(1, max(1, (n + 1) \/\/ 2))\n        dens_sorted = sorted(cur, key=lambda i: (scores[i] \/ max(1, times[i])))\n        to_remove = set(dens_sorted[:min(r, n)])\n        cur = [x for x in cur if x not in to_remove]\n\n    # Greedy refill within capacity by density\n    cur = make_unique_in_order(cur)\n    cur_time = total_time(cur)\n    candidates = [i for i in range(1, n_items + 1) if i not in cur]\n    dens_sorted = sorted(candidates, key=lambda i: (-(scores[i] \/ max(1, times[i])), -scores[i]))\n\n    for i in dens_sorted:\n        if cur_time + times[i] <= capacity:\n            cur.append(i)\n            cur_time += times[i]\n        # small randomization to avoid determinism\n        if random.random() < 0.05:\n            break\n\n    return make_unique_in_order(cur)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower cost is better. Feasible: cost = -total_score. Infeasible: large positive penalty.\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    PENALTY = 10**9\n    if not isinstance(solution, list):\n        return PENALTY\n    max_idx = len(times) - 1\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= max_idx and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return PENALTY\n    total_score = sum(scores[i] for i in unique)\n    return -int(total_score)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n# NB_Type is the representation identifier; Movement_Type in {ADD, REMOVE, EXCHANGE, REPAIR, IDENTITY}\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Embedded problem data\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    time_limit = 90\n    max_idx = len(times) - 1\n    rng = random.Random()\n\n    def normalize(sol: List[int]) -> List[int]:\n        # keep order of first occurrence, remove invalids\n        out = []\n        seen = set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= time_limit\n\n    def score(sol: List[int]) -> int:\n        return sum(scores[i] for i in sol)\n\n    base = normalize(list(solution))\n\n    # Candidate move selection with informed heuristics\n    in_set = set(base)\n    remaining_cap = time_limit - total_time(base)\n\n    # If infeasible, repair by dropping worst density items\n    if remaining_cap < 0:\n        # drop lowest score\/time until feasible\n        items = sorted(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        cand = base[:]\n        for i in items:\n            if total_time(cand) <= time_limit:\n                break\n            cand.remove(i)\n        return (normalize(cand), \"INDEX_LIST\", \"REPAIR\")\n\n    # Build candidate pools\n    add_candidates = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining_cap]\n    remove_candidates = base[:]\n\n    # Evaluate move types priority: best improvement among small random subsets\n    move_options = []\n\n    # ADD: choose best ratio item that fits\n    if add_candidates:\n        sample_add = rng.sample(add_candidates, k=min(len(add_candidates), 8))\n        best_add = max(sample_add, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        add_sol = normalize(base + [best_add])\n        if feasible(add_sol):\n            move_options.append((add_sol, \"ADD\", score(add_sol)))\n\n    # REMOVE: drop worst density item\n    if remove_candidates:\n        worst = min(remove_candidates, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        rem = base[:]\n        rem.remove(worst)\n        rem = normalize(rem)\n        if feasible(rem):\n            move_options.append((rem, \"REMOVE\", score(rem)))\n\n    # EXCHANGE: try one-out one-in within capacity, pick best gain from small samples\n    if remove_candidates:\n        out_i = rng.choice(remove_candidates)\n        cap_after = time_limit - (total_time(base) - times[out_i])\n        exch_pool = [j for j in range(1, max_idx + 1) if j not in in_set or j == out_i]\n        # restrict to those that fit\n        exch_pool = [j for j in exch_pool if times[j] <= cap_after]\n        if exch_pool:\n            sample_ex = rng.sample(exch_pool, k=min(len(exch_pool), 12))\n            best_j = max(sample_ex, key=lambda j: (scores[j] - scores[out_i], scores[j] \/ max(1, times[j])))\n            exch = base[:]\n            idx = exch.index(out_i)\n            exch[idx] = best_j\n            exch = normalize(exch)\n            if feasible(exch):\n                move_options.append((exch, \"EXCHANGE\", score(exch)))\n\n    if not move_options:\n        return (base, \"INDEX_LIST\", \"IDENTITY\")\n\n    # Choose best by objective (score), tie-break randomly\n    best_score = max(m[2] for m in move_options)\n    best_moves = [m for m in move_options if m[2] == best_score]\n    chosen = rng.choice(best_moves)\n    return (chosen[0], \"INDEX_LIST\", chosen[1])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Multi-move shake within feasibility; returns a normalized feasible solution\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    time_limit = 90\n    max_idx = len(times) - 1\n    rng = random.Random()\n\n    def normalize(sol: List[int]) -> List[int]:\n        out = []\n        seen = set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= time_limit\n\n    # Start from normalized input\n    sol = normalize(list(solution))\n\n    # If infeasible, repair by dropping lowest ratio items first\n    if not feasible(sol):\n        sol_sorted = sorted(sol, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        for i in sol_sorted:\n            if feasible(sol):\n                break\n            sol.remove(i)\n        sol = normalize(sol)\n\n    # Determine shake intensity\n    k = rng.randint(2, 5)\n\n    for _ in range(k):\n        in_set = set(sol)\n        used_time = total_time(sol)\n        remaining = time_limit - used_time\n        move = rng.choice([\"ADD\", \"REMOVE\", \"EXCHANGE\"]) if sol else \"ADD\"\n        if move == \"ADD\":\n            candidates = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n            if candidates:\n                j = rng.choice(candidates)\n                sol.append(j)\n                sol = normalize(sol)\n        elif move == \"REMOVE\" and sol:\n            ridx = rng.randrange(len(sol))\n            sol.pop(ridx)\n            sol = normalize(sol)\n        else:  # EXCHANGE\n            if sol:\n                ridx = rng.randrange(len(sol))\n                out_i = sol[ridx]\n                cap_after = time_limit - (used_time - times[out_i])\n                pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n                if pool:\n                    sol[ridx] = rng.choice(pool)\n                    sol = normalize(sol)\n        # Ensure feasibility via quick repair if needed (should rarely be needed due to checks)\n        if not feasible(sol):\n            # drop items with lowest score\/time first\n            order = sorted(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n            for idx in order:\n                if feasible(sol):\n                    break\n                sol.pop(idx)\n            sol = normalize(sol)\n\n    # Final normalization and feasibility guard\n    sol = normalize(sol)\n    # If still infeasible for any reason, greedily drop lowest density until feasible\n    while sum(times[i] for i in sol) > time_limit and sol:\n        worst_idx = min(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n        sol.pop(worst_idx)\n        sol = normalize(sol)\n\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower cost is better. Feasible => -total_score; Infeasible => large positive penalty.\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    PENALTY = 10**9\n    if not isinstance(solution, list):\n        return PENALTY\n    max_idx = len(times) - 1\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= max_idx and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > 90:\n        return PENALTY\n    total_score = sum(scores[i] for i in unique)\n    return -int(total_score)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbour_solution, \"INDEX_LIST\", Movement_Type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def tt(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return tt(sol) <= CAP\n\n    def score(sol: List[int]) -> int:\n        return sum(scores[i] for i in sol)\n\n    base = normalize(list(solution))\n    used = tt(base)\n    if used > CAP:\n        # Repair by dropping lowest density first (single pass update of used time)\n        order = sorted(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        cand = base[:]\n        used_c = used\n        for i in order:\n            if used_c <= CAP:\n                break\n            cand.remove(i)\n            used_c -= times[i]\n        return (normalize(cand), \"INDEX_LIST\", \"REPAIR\")\n\n    in_set = set(base)\n    remaining = CAP - used\n\n    move_options = []  # (sol, moveType, score)\n\n    # ADD: best ratio item that fits\n    add_cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    if add_cands:\n        sample_add = add_cands if len(add_cands) <= 8 else rng.sample(add_cands, 8)\n        best_add = max(sample_add, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        add_sol = normalize(base + [best_add])\n        if feasible(add_sol):\n            move_options.append((add_sol, \"ADD\", score(add_sol)))\n\n    # REMOVE: drop worst density item\n    if base:\n        worst = min(base, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        rem = base[:]\n        rem.remove(worst)\n        rem = normalize(rem)\n        if feasible(rem):\n            move_options.append((rem, \"REMOVE\", score(rem)))\n\n    # EXCHANGE: one-out one-in within capacity\n    if base:\n        out_i = rng.choice(base)\n        cap_after = CAP - (used - times[out_i])\n        exch_pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n        if exch_pool:\n            sample_ex = exch_pool if len(exch_pool) <= 12 else rng.sample(exch_pool, 12)\n            best_j = max(sample_ex, key=lambda j: (scores[j] - scores[out_i], scores[j] \/ max(1, times[j])))\n            exch = base[:]\n            idx = exch.index(out_i)\n            exch[idx] = best_j\n            exch = normalize(exch)\n            if feasible(exch):\n                move_options.append((exch, \"EXCHANGE\", score(exch)))\n\n    # TWO-ADD: try adding up to two items if they fit\n    if remaining > 0:\n        cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n        cands.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n        if cands:\n            # pick top-2 that fit sequentially\n            two_add = base[:]\n            used2 = used\n            taken = 0\n            for i in cands:\n                if used2 + times[i] <= CAP:\n                    two_add.append(i)\n                    used2 += times[i]\n                    taken += 1\n                    if taken == 2:\n                        break\n            two_add = normalize(two_add)\n            if two_add != base and feasible(two_add):\n                move_options.append((two_add, \"TWO_ADD\", score(two_add)))\n\n    if not move_options:\n        return (base, \"INDEX_LIST\", \"IDENTITY\")\n\n    # Choose best by score, tie-break by lower time then random\n    best_score = max(m[2] for m in move_options)\n    best_moves = [m for m in move_options if m[2] == best_score]\n    if len(best_moves) > 1:\n        def ttime(m):\n            return sum(times[i] for i in m[0])\n        best_moves.sort(key=lambda m: (ttime(m)))\n    chosen = best_moves[0]\n    return (chosen[0], \"INDEX_LIST\", chosen[1])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Random shake with feasibility-aware refill\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= CAP\n\n    sol = normalize(list(solution))\n\n    # If infeasible, repair by dropping lowest density first\n    if not feasible(sol):\n        order = sorted(sol, key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]))\n        used = total_time(sol)\n        for i in order:\n            if used <= CAP:\n                break\n            sol.remove(i)\n            used -= times[i]\n        sol = normalize(sol)\n\n    # Shake intensity\n    k = rng.randint(2, 5) if sol else rng.randint(1, 3)\n\n    for _ in range(k):\n        if sol and rng.random() < 0.4:\n            # REMOVE random\n            ridx = rng.randrange(len(sol))\n            sol.pop(ridx)\n            sol = normalize(sol)\n        elif sol and rng.random() < 0.5:\n            # EXCHANGE within capacity\n            used = total_time(sol)\n            ridx = rng.randrange(len(sol))\n            out_i = sol[ridx]\n            cap_after = CAP - (used - times[out_i])\n            in_set = set(sol)\n            pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and times[j] <= cap_after]\n            if pool:\n                sol[ridx] = rng.choice(pool)\n                sol = normalize(sol)\n        else:\n            # ADD if fits\n            used = total_time(sol)\n            in_set = set(sol)\n            remaining = CAP - used\n            cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n            if cands:\n                # bias toward higher density\n                cands.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n                top = cands[:min(5, len(cands))]\n                sol.append(rng.choice(top))\n                sol = normalize(sol)\n        # Quick guard\n        if not feasible(sol):\n            order = sorted(range(len(sol)), key=lambda idx: scores[sol[idx]] \/ max(1, times[sol[idx]]))\n            for idx in order:\n                if feasible(sol):\n                    break\n                sol.pop(idx)\n            sol = normalize(sol)\n\n    # Greedy refill by ratio\n    used = total_time(sol)\n    remaining = CAP - used\n    in_set = set(sol)\n    refill = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    refill.sort(key=lambda i: (scores[i] \/ max(1, times[i]), scores[i]), reverse=True)\n    for i in refill:\n        if used + times[i] <= CAP:\n            sol.append(i)\n            used += times[i]\n    return normalize(sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST (1-based unique indices). Feasible iff sum(times[i]) <= 90.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Minimization cost: feasible => -total_score; infeasible => large positive penalty\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    PENALTY = 10**9\n    if not isinstance(solution, list):\n        return PENALTY\n    max_idx = len(times) - 1\n    seen = set()\n    unique = []\n    for idx in solution:\n        if isinstance(idx, int) and 1 <= idx <= max_idx and idx not in seen:\n            seen.add(idx)\n            unique.append(idx)\n    total_time = sum(times[i] for i in unique)\n    if total_time > CAP:\n        return PENALTY\n    total_score = sum(scores[i] for i in unique)\n    return -int(total_score)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, \"INDEX_LIST\", move_type)\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= CAP\n\n    def score(sol: List[int]) -> int:\n        return sum(scores[i] for i in sol)\n\n    def density(i: int) -> float:\n        return scores[i] \/ max(1, times[i])\n\n    base = normalize(list(solution))\n\n    # If infeasible, iteratively repair by removing worst density until feasible\n    while not feasible(base) and base:\n        worst = min(base, key=lambda i: (density(i), scores[i]))\n        base.remove(worst)\n        base = normalize(base)\n\n    used = total_time(base)\n    in_set = set(base)\n    remaining = CAP - used\n\n    move_options: List[Tuple[List[int], str, int, int, int]] = []\n    # Each tuple: (sol, move_type, cost, total_time, n_items). cost is -score for minimization consistency\n\n    # ADD: choose best density item that fits\n    add_cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    if add_cands:\n        sample_add = add_cands if len(add_cands) <= 8 else rng.sample(add_cands, 8)\n        best_add = max(sample_add, key=lambda i: (density(i), scores[i]))\n        add_sol = normalize(base + [best_add])\n        if feasible(add_sol) and add_sol != base:\n            sc = score(add_sol)\n            move_options.append((add_sol, \"ADD\", -sc, total_time(add_sol), len(add_sol)))\n\n    # REMOVE: drop worst density item\n    if base:\n        worst = min(base, key=lambda i: (density(i), scores[i]))\n        rem = base[:]\n        rem.remove(worst)\n        rem = normalize(rem)\n        if feasible(rem) and rem != base:\n            sc = score(rem)\n            move_options.append((rem, \"REMOVE\", -sc, total_time(rem), len(rem)))\n\n    # EXCHANGE: one-out one-in, avoid identity and enforce feasibility\n    if base:\n        out_i = rng.choice(base)\n        cap_after = CAP - (used - times[out_i])\n        exch_pool = [j for j in range(1, max_idx + 1) if (j not in in_set or j == out_i) and j != out_i and times[j] <= cap_after]\n        if exch_pool:\n            sample_ex = exch_pool if len(exch_pool) <= 12 else rng.sample(exch_pool, 12)\n            # Prefer improvement by delta score, tie by density\n            best_j = max(sample_ex, key=lambda j: (scores[j] - scores[out_i], density(j)))\n            exch = base[:]\n            idx = exch.index(out_i)\n            exch[idx] = best_j\n            exch = normalize(exch)\n            if feasible(exch) and exch != base:\n                sc = score(exch)\n                move_options.append((exch, \"EXCHANGE\", -sc, total_time(exch), len(exch)))\n\n    # TWO_ADD: greedily add up to two high-density items if they fit\n    if remaining > 0:\n        cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n        cands.sort(key=lambda i: (density(i), scores[i]), reverse=True)\n        two_add = base[:]\n        used2 = used\n        taken = 0\n        for i in cands:\n            if used2 + times[i] <= CAP:\n                two_add.append(i)\n                used2 += times[i]\n                taken += 1\n                if taken == 2:\n                    break\n        two_add = normalize(two_add)\n        if two_add != base and feasible(two_add):\n            sc = score(two_add)\n            move_options.append((two_add, \"TWO_ADD\", -sc, total_time(two_add), len(two_add)))\n\n    # REMOVE2_ADD1: drop two worst densities, try add best fitting\n    if len(base) >= 2:\n        sorted_by_bad = sorted(base, key=lambda i: (density(i), scores[i]))\n        cand = base[:]\n        drop1 = sorted_by_bad[0]\n        drop2 = sorted_by_bad[1]\n        cand.remove(drop1)\n        cand.remove(drop2)\n        used_c = total_time(cand)\n        in_set_c = set(cand)\n        space = CAP - used_c\n        add_pool = [i for i in range(1, max_idx + 1) if i not in in_set_c and times[i] <= space]\n        if add_pool:\n            best = max(add_pool, key=lambda i: (density(i), scores[i]))\n            cand2 = normalize(cand + [best])\n            if feasible(cand2) and cand2 != base:\n                sc = score(cand2)\n                move_options.append((cand2, \"REMOVE2_ADD1\", -sc, total_time(cand2), len(cand2)))\n\n    # REMOVE1_ADD2: drop worst and add up to two best density items\n    if base:\n        worst = min(base, key=lambda i: (density(i), scores[i]))\n        cand = base[:]\n        cand.remove(worst)\n        used_c = total_time(cand)\n        in_set_c = set(cand)\n        space = CAP - used_c\n        pool = [i for i in range(1, max_idx + 1) if i not in in_set_c and times[i] <= space]\n        pool.sort(key=lambda i: (density(i), scores[i]), reverse=True)\n        add_list = []\n        for i in pool:\n            if sum(times[x] for x in add_list) + times[i] <= space:\n                add_list.append(i)\n                if len(add_list) == 2:\n                    break\n        cand2 = normalize(cand + add_list)\n        if feasible(cand2) and cand2 != base:\n            sc = score(cand2)\n            move_options.append((cand2, \"REMOVE1_ADD2\", -sc, total_time(cand2), len(cand2)))\n\n    if not move_options:\n        return (base, \"INDEX_LIST\", \"STUCK\")\n\n    # Select best by minimization cost; tiebreak by lower time, fewer items, then random stable order\n    best_cost = min(m[2] for m in move_options)\n    best_moves = [m for m in move_options if m[2] == best_cost]\n    best_moves.sort(key=lambda m: (m[3], m[4]))\n    chosen = best_moves[0]\n    return (chosen[0], \"INDEX_LIST\", chosen[1])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Capacity-aware shake: drop k worst-density items, then greedily refill by density\n    times = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    scores = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    CAP = 90\n    max_idx = len(times) - 1\n    rng = random\n\n    def normalize(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for i in sol:\n            if isinstance(i, int) and 1 <= i <= max_idx and i not in seen:\n                seen.add(i)\n                out.append(i)\n        return out\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    def feasible(sol: List[int]) -> bool:\n        return total_time(sol) <= CAP\n\n    def density(i: int) -> float:\n        return scores[i] \/ max(1, times[i])\n\n    sol = normalize(list(solution))\n\n    # Ensure feasibility first via iterative removal of worst density\n    while not feasible(sol) and sol:\n        worst = min(sol, key=lambda i: (density(i), scores[i]))\n        sol.remove(worst)\n        sol = normalize(sol)\n\n    # Determine shake intensity k\n    k = rng.randint(2, 4) if sol else rng.randint(1, 2)\n\n    # Drop k worst-density items (or as many as available)\n    for _ in range(min(k, len(sol))):\n        if not sol:\n            break\n        worst = min(sol, key=lambda i: (density(i), scores[i]))\n        sol.remove(worst)\n    sol = normalize(sol)\n\n    # Greedy refill by density while respecting capacity\n    used = total_time(sol)\n    remaining = CAP - used\n    in_set = set(sol)\n    cands = [i for i in range(1, max_idx + 1) if i not in in_set and times[i] <= remaining]\n    cands.sort(key=lambda i: (density(i), scores[i]), reverse=True)\n    for i in cands:\n        if used + times[i] <= CAP:\n            sol.append(i)\n            used += times[i]\n    return normalize(sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Cost-based evaluation (lower is better). Infeasible => large positive penalty.\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        total_time += times[idx]\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    # Convert maximization to minimization by negating value\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    # Sanitize input: list, ints, bounds, uniqueness\n    src = list(solution) if isinstance(solution, list) else []\n    src = [i for i in src if isinstance(i, int) and 1 <= i <= n]\n    src = list(dict.fromkeys(src))\n    cur_time = total_time(src)\n\n    def feasible_add(sol: List[int], item: int) -> bool:\n        return (item not in sol) and (total_time(sol) + times[item] <= capacity)\n\n    # Attempt up to K tries to realize a non-noop move\n    K = 20\n    for _ in range(K):\n        move = random.choice([\"insert\", \"remove\", \"swap\", \"drop_greedy_add\"])  # diversified moves\n        new_sol = src.copy()\n        cur_time = total_time(new_sol)\n\n        if move == \"remove\":\n            if new_sol:\n                rem = random.choice(new_sol)\n                new_sol.remove(rem)\n                return new_sol, \"local\", \"remove\"\n\n        elif move == \"insert\":\n            candidates = [i for i in range(1, n + 1) if i not in new_sol]\n            if candidates:\n                random.shuffle(candidates)\n                # try up to M candidates\n                inserted = False\n                for cand in candidates[:10]:\n                    if cur_time + times[cand] <= capacity:\n                        new_sol.append(cand)\n                        inserted = True\n                        break\n                if not inserted:\n                    # density-guided try\n                    best = None\n                    best_ratio = -1.0\n                    for cand in candidates:\n                        if cur_time + times[cand] <= capacity:\n                            ratio = values[cand] \/ times[cand]\n                            if ratio > best_ratio:\n                                best_ratio = ratio\n                                best = cand\n                    if best is not None:\n                        new_sol.append(best)\n                        inserted = True\n                if inserted:\n                    return new_sol, \"local\", \"insert\"\n\n        elif move == \"swap\":\n            if new_sol:\n                inside = random.choice(new_sol)\n                outside_candidates = [j for j in range(1, n + 1) if j not in new_sol]\n                random.shuffle(outside_candidates)\n                swapped = False\n                for outside in outside_candidates[:10]:\n                    t_new = cur_time - times[inside] + times[outside]\n                    if t_new <= capacity:\n                        tentative = [i for i in new_sol if i != inside] + [outside]\n                        new_sol = tentative\n                        swapped = True\n                        break\n                if swapped:\n                    return new_sol, \"local\", \"swap\"\n\n        elif move == \"drop_greedy_add\":\n            if new_sol:\n                # drop one random item then greedily add by value density\n                rem = random.choice(new_sol)\n                new_sol.remove(rem)\n                cur_time2 = total_time(new_sol)\n                remaining = [i for i in range(1, n + 1) if i not in new_sol]\n                remaining.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n                for cand in remaining:\n                    if cur_time2 + times[cand] <= capacity:\n                        new_sol.append(cand)\n                        cur_time2 += times[cand]\n                if new_sol != src:\n                    return new_sol, \"local\", \"drop-greedy-add\"\n\n    # As a last resort, if no change was possible, try to remove if exists; else return same\n    if src:\n        rem = random.choice(src)\n        fallback = src.copy()\n        fallback.remove(rem)\n        return fallback, \"local\", \"remove-fallback\"\n    return src, \"local\", \"noop\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def t(sol: List[int]) -> int:\n        return sum(times[i] for i in sol)\n\n    # Sanitize\n    sol = list(solution) if isinstance(solution, list) else []\n    sol = [i for i in sol if isinstance(i, int) and 1 <= i <= n]\n    sol = list(dict.fromkeys(sol))\n\n    # Strong shake: remove k items\n    if sol:\n        k = random.randint(1, min(3, len(sol)))\n        random.shuffle(sol)\n        sol = sol[k:]\n\n    # Greedy refill by value density then value\n    remaining = [i for i in range(1, n + 1) if i not in sol]\n    remaining.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n\n    cur_time = t(sol)\n    for i in remaining:\n        if cur_time + times[i] <= capacity:\n            sol.append(i)\n            cur_time += times[i]\n        if cur_time >= capacity:\n            break\n\n    # Repair (safety): trim largest-time items if any overflow (shouldn't happen but defensive)\n    while t(sol) > capacity and sol:\n        worst = max(sol, key=lambda i: times[i])\n        sol.remove(worst)\n\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimization cost: feasible => -total_value; infeasible => large positive penalty\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Sanitize input: list, ints, bounds, uniqueness\n    if isinstance(solution, list):\n        src = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        # preserve order of first occurrence to keep deterministic pruning\n        seen = set()\n        src = [x for x in src if (x not in seen and not seen.add(x))]\n    else:\n        src = []\n\n    # Helper: compute current time once and maintain incrementally\n    cur_time = sum(times[i] for i in src)\n\n    def add_if_feasible(sol, ct, item):\n        if item in sol:\n            return None\n        tnew = ct + times[item]\n        if tnew <= capacity:\n            ns = sol + [item]\n            return ns, tnew\n        return None\n\n    def remove_item(sol, ct, item):\n        if item not in sol:\n            return None\n        ns = [x for x in sol if x != item]\n        return ns, ct - times[item]\n\n    def swap_item(sol, ct, out_item, in_item):\n        if out_item not in sol or in_item in sol:\n            return None\n        tnew = ct - times[out_item] + times[in_item]\n        if tnew <= capacity:\n            ns = [x for x in sol if x != out_item] + [in_item]\n            return ns, tnew\n        return None\n\n    # Candidate outsiders\n    outsiders = [i for i in range(1, n + 1) if i not in src]\n\n    # Move types pool (diversified)\n    moves = [\"insert\", \"remove\", \"swap\", \"one_to_two\", \"two_to_one\", \"drop_greedy_add\"]\n\n    # Try up to K attempts to produce a non-noop feasible neighbor\n    K = 40\n    for _ in range(K):\n        move = random.choice(moves)\n        sol = list(src)\n        t = cur_time\n\n        if move == \"remove\":\n            if sol:\n                rem = random.choice(sol)\n                ns, nt = remove_item(sol, t, rem)\n                return ns, \"local\", \"remove\"\n\n        elif move == \"insert\":\n            if outsiders:\n                # Prefer best ratio among feasible outsiders\n                feasible_cands = [j for j in outsiders if t + times[j] <= capacity]\n                if feasible_cands:\n                    best = max(feasible_cands, key=lambda j: (values[j] \/ times[j], values[j]))\n                    ns, nt = add_if_feasible(sol, t, best)\n                    if ns is not None:\n                        return ns, \"local\", \"insert\"\n\n        elif move == \"swap\":\n            if sol and outsiders:\n                out_item = random.choice(sol)\n                # Try a few promising outsiders by ratio\n                cand_outs = sorted(outsiders, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:8]\n                for j in cand_outs:\n                    res = swap_item(sol, t, out_item, j)\n                    if res is not None:\n                        ns, nt = res\n                        return ns, \"local\", \"swap\"\n\n        elif move == \"one_to_two\":\n            if sol and outsiders:\n                out_item = random.choice(sol)\n                remaining_cap = capacity - (t - times[out_item])\n                # choose two outsiders that fit jointly\n                cand = [j for j in outsiders if j != out_item]\n                if cand:\n                    # prioritize by ratio\n                    cand = sorted(cand, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:10]\n                    for i1 in range(len(cand)):\n                        for i2 in range(i1 + 1, len(cand)):\n                            a, b = cand[i1], cand[i2]\n                            if times[a] + times[b] <= remaining_cap and a not in sol and b not in sol:\n                                ns = [x for x in sol if x != out_item] + [a, b]\n                                return ns, \"local\", \"1-2-exchange\"\n\n        elif move == \"two_to_one\":\n            if len(sol) >= 2 and outsiders:\n                out_items = random.sample(sol, 2)\n                freed = times[out_items[0]] + times[out_items[1]]\n                # best outsider within freed capacity\n                feasible_cands = [j for j in outsiders if times[j] <= freed]\n                if feasible_cands:\n                    best = max(feasible_cands, key=lambda j: (values[j] \/ times[j], values[j]))\n                    ns = [x for x in sol if x not in out_items] + [best]\n                    # always feasible by construction\n                    return ns, \"local\", \"2-1-exchange\"\n\n        elif move == \"drop_greedy_add\":\n            if sol:\n                rem = random.choice(sol)\n                sol.remove(rem)\n                t = t - times[rem]\n                # Greedy refill by ratio\n                cand = [j for j in range(1, n + 1) if j not in sol]\n                cand.sort(key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)\n                for j in cand:\n                    if t + times[j] <= capacity:\n                        sol.append(j)\n                        t += times[j]\n                if sol != src:\n                    return sol, \"local\", \"drop-greedy-add\"\n\n    # Fallback: if no change, remove a random element when possible\n    if src:\n        rem = random.choice(src)\n        ns = [x for x in src if x != rem]\n        return ns, \"local\", \"remove-fallback\"\n    return src, \"local\", \"noop\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Sanitize and deduplicate\n    if isinstance(solution, list):\n        sol = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n        seen = set()\n        sol = [x for x in sol if (x not in seen and not seen.add(x))]\n    else:\n        sol = []\n\n    # Destroy: remove k random items (1..min(3, |sol|))\n    if sol:\n        k = random.randint(1, min(3, len(sol)))\n        random.shuffle(sol)\n        sol = sol[k:]\n\n    # Repair\/Refill: greedy by value density, then by value\n    cur_time = sum(times[i] for i in sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol]\n    candidates.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n    for i in candidates:\n        ti = times[i]\n        if cur_time + ti <= capacity:\n            sol.append(i)\n            cur_time += ti\n        if cur_time >= capacity:\n            break\n\n    # Safety repair (should be unnecessary): trim by worst density if overflow\n    while cur_time > capacity and sol:\n        worst = max(sol, key=lambda i: times[i] \/ max(values[i], 1e-9))\n        cur_time -= times[worst]\n        sol.remove(worst)\n\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"INDEX_LIST_UNORDERED_UNIQUE_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float(1e15)\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float(1e15)\n        if idx < 1 or idx > n:\n            return float(1e15)\n        if idx in seen:\n            return float(1e15)\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return float(1e15)\n        total_value += values[idx]\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # sanitize input\n    if isinstance(solution, list):\n        sol = []\n        seen = set()\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n and i not in seen:\n                sol.append(i)\n                seen.add(i)\n    else:\n        sol = []\n\n    cur_time = sum(times[i] for i in sol)\n    present = set(sol)\n    outsiders = [i for i in range(1, n + 1) if i not in present]\n\n    def add_if_feasible(s, ct, j):\n        if j in s:\n            return None\n        tnew = ct + times[j]\n        if tnew <= capacity:\n            return s + [j], tnew\n        return None\n\n    def remove_item(s, ct, j):\n        if j not in s:\n            return None\n        ns = [x for x in s if x != j]\n        return ns, ct - times[j]\n\n    def swap_item(s, ct, out_j, in_j):\n        if out_j not in s or in_j in s:\n            return None\n        tnew = ct - times[out_j] + times[in_j]\n        if tnew <= capacity:\n            ns = [x for x in s if x != out_j] + [in_j]\n            return ns, tnew\n        return None\n\n    moves = [\"insert\", \"remove\", \"swap\", \"one_to_two\", \"two_to_one\", \"two_to_two\", \"drop_greedy_add\"]\n    K = 60\n\n    for _ in range(K):\n        move = random.choice(moves)\n        s = list(sol)\n        ct = cur_time\n        pres = set(s)\n        outs = [i for i in range(1, n + 1) if i not in pres]\n\n        if move == \"remove\":\n            if s:\n                rem = random.choice(s)\n                res = remove_item(s, ct, rem)\n                if res is not None:\n                    ns, _ = res\n                    return ns, \"local\", \"remove\"\n\n        elif move == \"insert\":\n            feas = [j for j in outs if ct + times[j] <= capacity]\n            if feas:\n                best = max(feas, key=lambda j: (values[j] \/ times[j], values[j]))\n                res = add_if_feasible(s, ct, best)\n                if res is not None:\n                    ns, _ = res\n                    return ns, \"local\", \"insert\"\n\n        elif move == \"swap\":\n            if s and outs:\n                out_j = random.choice(s)\n                cand = sorted(outs, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:8]\n                for j in cand:\n                    res = swap_item(s, ct, out_j, j)\n                    if res is not None:\n                        ns, _ = res\n                        return ns, \"local\", \"swap\"\n\n        elif move == \"one_to_two\":\n            if s and outs:\n                out_j = random.choice(s)\n                freed_ct = ct - times[out_j]\n                cand = sorted(outs, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:10]\n                L = len(cand)\n                for a in range(L):\n                    for b in range(a + 1, L):\n                        i1, i2 = cand[a], cand[b]\n                        if i1 in pres or i2 in pres:\n                            continue\n                        if freed_ct + times[i1] + times[i2] <= capacity:\n                            ns = [x for x in s if x != out_j] + [i1, i2]\n                            return ns, \"local\", \"1-2-exchange\"\n\n        elif move == \"two_to_one\":\n            if len(s) >= 2 and outs:\n                out_pair = random.sample(s, 2)\n                freed = times[out_pair[0]] + times[out_pair[1]]\n                feas = [j for j in outs if times[j] <= freed]\n                if feas:\n                    # net gain criterion relative to worst of the two removed\n                    best = max(feas, key=lambda j: (values[j] - 0.5 * (values[out_pair[0]] + values[out_pair[1]]), values[j] \/ times[j]))\n                    ns = [x for x in s if x not in out_pair] + [best]\n                    return ns, \"local\", \"2-1-exchange\"\n\n        elif move == \"two_to_two\":\n            if len(s) >= 1 and len(outs) >= 1:\n                out_j = random.choice(s)\n                out2 = None\n                if len(s) >= 2 and random.random() < 0.7:\n                    # pick second different item\n                    tmp = [x for x in s if x != out_j]\n                    out2 = random.choice(tmp)\n                cand = sorted(outs, key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)[:10]\n                if out2 is None:\n                    # degrade to single swap if only one out\n                    for j in cand:\n                        res = swap_item(s, ct, out_j, j)\n                        if res is not None:\n                            ns, _ = res\n                            return ns, \"local\", \"swap\"\n                else:\n                    freed_ct = ct - times[out_j] - times[out2]\n                    L = len(cand)\n                    for a in range(L):\n                        for b in range(a + 1, L):\n                            i1, i2 = cand[a], cand[b]\n                            if freed_ct + times[i1] + times[i2] <= capacity and i1 not in pres and i2 not in pres:\n                                ns = [x for x in s if x not in (out_j, out2)] + [i1, i2]\n                                return ns, \"local\", \"2-2-exchange\"\n\n        elif move == \"drop_greedy_add\":\n            if s:\n                rem = random.choice(s)\n                s.remove(rem)\n                ct -= times[rem]\n                cand = [j for j in range(1, n + 1) if j not in s]\n                cand.sort(key=lambda j: (values[j] \/ times[j], values[j]), reverse=True)\n                for j in cand:\n                    if ct + times[j] <= capacity:\n                        s.append(j)\n                        ct += times[j]\n                if s != sol:\n                    return s, \"local\", \"drop-greedy-add\"\n\n    if sol:\n        rem = random.choice(sol)\n        ns = [x for x in sol if x != rem]\n        return ns, \"local\", \"remove-fallback\"\n    return sol, \"local\", \"noop\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    if isinstance(solution, list):\n        sol = []\n        seen = set()\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= n and i not in seen:\n                sol.append(i)\n                seen.add(i)\n    else:\n        sol = []\n\n    if sol:\n        k = random.randint(1, min(3, len(sol)))\n        random.shuffle(sol)\n        sol = sol[k:]\n\n    cur_time = sum(times[i] for i in sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol]\n    candidates.sort(key=lambda i: (values[i] \/ times[i], values[i]), reverse=True)\n    for i in candidates:\n        ti = times[i]\n        if cur_time + ti <= capacity:\n            sol.append(i)\n            cur_time += ti\n        if cur_time >= capacity:\n            break\n\n    while cur_time > capacity and sol:\n        worst = max(sol, key=lambda i: times[i] \/ max(values[i], 1e-9))\n        cur_time -= times[worst]\n        sol.remove(worst)\n\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","Evaluacion":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return math.inf\n        if 1 <= idx <= 24 and idx not in seen:\n            total_value += values[idx-1]\n            seen.add(idx)\n    return total_value\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    BIG = 10**9\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i-1]\n    if total_weight < 275:\n        return BIG\n    return objective_function(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _repair_feasibility_nb(solution: List[int]) -> List[int]:\n    # Repair to satisfy weight >= 275 by greedy fill using best weight per value\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    if len(in_set) == 0:\n        move_type = \"add\"\n    elif len(in_set) == n:\n        move_type = \"remove\"\n    else:\n        move_type = random.choice([\"add\", \"remove\", \"swap\", \"two_swap\"])  # add diversity\n\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in in_set]\n        if candidates:\n            sol.append(random.choice(candidates))\n    elif move_type == \"remove\":\n        if sol:\n            rem = random.choice(sol)\n            sol = [i for i in sol if i != rem]\n    elif move_type == \"swap\":\n        if sol and len(in_set) < n:\n            out_idx = random.choice(sol)\n            sol = [i for i in sol if i != out_idx]\n            in_set.discard(out_idx)\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            if candidates:\n                in_idx = random.choice(candidates)\n                if in_idx not in sol:\n                    sol.append(in_idx)\n    else:  # two_swap: remove two add two\n        if len(sol) >= 1:\n            k_out = 2 if len(sol) >= 2 else 1\n            remove_items = random.sample(sol, k_out)\n            sol = [i for i in sol if i not in remove_items]\n            for r in remove_items:\n                in_set.discard(r)\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            k_in = min(k_out, len(candidates))\n            add_items = random.sample(candidates, k_in) if k_in > 0 else []\n            sol.extend(add_items)\n\n    sol = _repair_feasibility_nb(sol)\n    nb_label = {\n        \"add\": \"Add+Repair\",\n        \"remove\": \"Remove+Repair\",\n        \"swap\": \"Swap+Repair\",\n        \"two_swap\": \"2-Swap+Repair\",\n    }[move_type]\n    return sol, \"Feasible-Repair\", nb_label\n","Perturbacion":"import random\nfrom typing import List\n\ndef _repair_feasibility_pert(solution: List[int]) -> List[int]:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in solution if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1,25) if i not in sel]\n    remaining.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Apply a randomized multi-move shake then repair\n    n = 24\n    sol = list(solution)\n    in_set = set(sol)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        if 0 < len(in_set) < n:\n            move = random.choice([\"add\", \"remove\", \"swap\"]) \n        else:\n            move = \"add\" if len(in_set) == 0 else \"remove\"\n        if move == \"add\":\n            candidates = [i for i in range(1, n+1) if i not in in_set]\n            if candidates:\n                pick = random.choice(candidates)\n                sol.append(pick)\n                in_set.add(pick)\n        elif move == \"remove\":\n            if sol:\n                rem = random.choice(sol)\n                sol = [i for i in sol if i != rem]\n                in_set.discard(rem)\n        else:  # swap\n            if sol and len(in_set) < n:\n                out_idx = random.choice(sol)\n                sol = [i for i in sol if i != out_idx]\n                in_set.discard(out_idx)\n                candidates = [i for i in range(1, n+1) if i not in in_set]\n                if candidates:\n                    in_idx = random.choice(candidates)\n                    sol.append(in_idx)\n                    in_set.add(in_idx)\n    sol = _repair_feasibility_pert(sol)\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","Evaluacion":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> int:\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return math.inf\n    seen = set()\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return math.inf\n        if 1 <= idx <= 24 and idx not in seen:\n            total_value += values[idx-1]\n            seen.add(idx)\n    return total_value\n\n\ndef evaluate_solution(solution: List[int]) -> int:\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    BIG = 10**9\n    if not isinstance(solution, list):\n        return BIG\n    if any((not isinstance(i, int)) for i in solution):\n        return BIG\n    if len(set(solution)) != len(solution):\n        return BIG\n    if any(i < 1 or i > 24 for i in solution):\n        return BIG\n    total_weight = 0\n    for i in solution:\n        total_weight += weights[i-1]\n    if total_weight < 275:\n        return BIG\n    return objective_function(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef _repair_to_feasible(sol: List[int]) -> List[int]:\n    # Minimal-bias completion to reach weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in sol if 1 <= i <= 24]))\n    current_w = sum(weights[i-1] for i in sel)\n    if current_w >= W_MIN:\n        return sel\n    remaining = [i for i in range(1, 25) if i not in sel]\n    # Prefer low value and good value\/weight\n    remaining.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n    for i in remaining:\n        sel.append(i)\n        current_w += weights[i-1]\n        if current_w >= W_MIN:\n            break\n    return sel\n\n\ndef _feasible_exchange(sol: List[int]) -> List[int]:\n    # Try feasibility-preserving exchanges before resorting to repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = 24\n    W_MIN = 275\n    sel = list(dict.fromkeys([i for i in sol if 1 <= i <= n]))\n    in_set = set(sel)\n    total_w = sum(weights[i-1] for i in sel)\n\n    # Attempt 1-1 exchange maintaining feasibility\n    if sel and len(in_set) < n:\n        out_idx = random.choice(sel)\n        candidates = [j for j in range(1, n+1) if j not in in_set]\n        random.shuffle(candidates)\n        for j in candidates:\n            new_w = total_w - weights[out_idx-1] + weights[j-1]\n            if new_w >= W_MIN:\n                new_sel = [i for i in sel if i != out_idx]\n                new_sel.append(j)\n                return new_sel\n\n    # Attempt 2-1 and 1-2 stochastic exchanges\n    candidates_out = sel[:]\n    candidates_in = [j for j in range(1, n+1) if j not in in_set]\n    random.shuffle(candidates_out)\n    random.shuffle(candidates_in)\n\n    # 2-1\n    if len(candidates_out) >= 2 and candidates_in:\n        tries = 0\n        for a in range(len(candidates_out)):\n            for b in range(a+1, len(candidates_out)):\n                out_a = candidates_out[a]\n                out_b = candidates_out[b]\n                for j in candidates_in:\n                    new_w = total_w - weights[out_a-1] - weights[out_b-1] + weights[j-1]\n                    if new_w >= W_MIN:\n                        new_sel = [i for i in sel if i not in (out_a, out_b)]\n                        new_sel.append(j)\n                        return new_sel\n                tries += 1\n                if tries > 16:\n                    break\n            if tries > 16:\n                break\n\n    # 1-2\n    if candidates_out and len(candidates_in) >= 2:\n        tries = 0\n        for out_idx in candidates_out:\n            for a in range(len(candidates_in)):\n                for b in range(a+1, len(candidates_in)):\n                    j = candidates_in[a]\n                    k = candidates_in[b]\n                    new_w = total_w - weights[out_idx-1] + weights[j-1] + weights[k-1]\n                    if new_w >= W_MIN:\n                        new_sel = [i for i in sel if i != out_idx]\n                        new_sel.extend([j, k])\n                        return new_sel\n                tries += 1\n                if tries > 16:\n                    break\n            if tries > 16:\n                break\n\n    return sel\n\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, \"Feasible-Repair\", move_label)\n    n = 24\n    sel = list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n    # Ensure feasibility first (light repair)\n    sel = _repair_to_feasible(sel)\n\n    move = random.choice([\"1-1\", \"2-1\", \"1-2\", \"add\", \"remove\"]) if sel else \"add\"\n\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    W_MIN = 275\n    in_set = set(sel)\n    total_w = sum(weights[i-1] for i in sel)\n    new_sel = sel[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in in_set]\n        if candidates:\n            pick = random.choice(candidates)\n            new_sel.append(pick)\n        move_label = \"Add\"\n    elif move == \"remove\":\n        removable = [i for i in sel if total_w - weights[i-1] >= W_MIN]\n        if removable:\n            rem = random.choice(removable)\n            new_sel = [i for i in sel if i != rem]\n            move_label = \"Remove(feasible)\"\n        else:\n            new_sel = _feasible_exchange(sel)\n            move_label = \"Exchange-Repair\"\n    elif move == \"1-1\":\n        new_sel = _feasible_exchange(sel)\n        move_label = \"1-1\/Repair\"\n    elif move == \"2-1\":\n        new_sel = _feasible_exchange(sel)\n        move_label = \"2-1\/Repair\"\n    else:  # \"1-2\"\n        new_sel = _feasible_exchange(sel)\n        move_label = \"1-2\/Repair\"\n\n    new_sel = _repair_to_feasible(new_sel)\n    return new_sel, \"Feasible-Repair\", move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Multi-move shake with feasibility preservation and final repair\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    W_MIN = 275\n\n    def repair(sel: List[int]) -> List[int]:\n        sel = list(dict.fromkeys([i for i in sel if 1 <= i <= n]))\n        total_w = sum(weights[i-1] for i in sel)\n        if total_w >= W_MIN:\n            return sel\n        rem = [i for i in range(1, n+1) if i not in sel]\n        rem.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1]))\n        for i in rem:\n            sel.append(i)\n            total_w += weights[i-1]\n            if total_w >= W_MIN:\n                break\n        return sel\n\n    sel = repair(list(dict.fromkeys([i for i in solution if isinstance(i, int) and 1 <= i <= n])))\n\n    k_moves = random.randint(3, 6)\n    for _ in range(k_moves):\n        in_set = set(sel)\n        total_w = sum(weights[i-1] for i in sel)\n        move = random.choice([\"swap\", \"dropadd\", \"rotate\"]) if sel else \"add\"\n\n        if move == \"swap\":\n            if sel and len(in_set) < n:\n                out_idx = random.choice(sel)\n                candidates = [j for j in range(1, n+1) if j not in in_set]\n                if candidates:\n                    j = random.choice(candidates)\n                    new_w = total_w - weights[out_idx-1] + weights[j-1]\n                    if new_w >= W_MIN:\n                        sel = [i for i in sel if i != out_idx] + [j]\n        elif move == \"dropadd\":\n            # Try remove if feasible, else add\n            removable = [i for i in sel if total_w - weights[i-1] >= W_MIN]\n            if removable:\n                rem = random.choice(removable)\n                sel = [i for i in sel if i != rem]\n            else:\n                candidates = [i for i in range(1, n+1) if i not in in_set]\n                if candidates:\n                    sel.append(random.choice(candidates))\n        else:  # rotate: remove one, add two if feasible, else skip\n            if sel:\n                out_idx = random.choice(sel)\n                rest = [i for i in range(1, n+1) if i not in in_set or i == out_idx]\n                if len(rest) >= 2:\n                    a, b = random.sample(rest, 2)\n                    new_sel = [i for i in sel if i != out_idx]\n                    new_sel.extend([a, b])\n                    if sum(weights[i-1] for i in new_sel) >= W_MIN:\n                        sel = list(dict.fromkeys(new_sel))\n\n    sel = repair(sel)\n    return sel\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: list of distinct 1-based item indices selected from {1,...,24}; duplicates not allowed.","Evaluacion":"# Imports and constants\nimport math\n\n_VALUES = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n_WEIGHTS = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n_N = 24\n_MIN_W = 275\n_PENALTY_LAMBDA = 100  # additive penalty per unit of missing weight\n_BIG = 10**12\n\n\ndef _validate_index_list(solution):\n    if not isinstance(solution, list):\n        return False\n    if any((not isinstance(i, int)) for i in solution):\n        return False\n    if len(set(solution)) != len(solution):\n        return False\n    if any(i < 1 or i > _N for i in solution):\n        return False\n    return True\n\n\ndef _objective_value(solution):\n    # Strict: assumes validated indices\n    total = 0\n    for idx in solution:\n        total += _VALUES[idx-1]\n    return total\n\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns a scalar fitness to minimize.\n    - Valid INDEX_LIST required; invalid returns large penalty.\n    - Feasible solutions (sum weights >= 275): returns total value.\n    - Infeasible: returns value + lambda * deficit.\n    \"\"\"\n    if not _validate_index_list(solution):\n        return _BIG\n\n    total_weight = 0\n    for i in solution:\n        total_weight += _WEIGHTS[i-1]\n    total_value = _objective_value(solution)\n\n    if total_weight >= _MIN_W:\n        return total_value\n    deficit = _MIN_W - total_weight\n    return total_value + _PENALTY_LAMBDA * deficit\n","Vecindad":"# Neighborhood generator with light repair and cost-aware moves\nimport random\n\n_VALUES = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n_WEIGHTS = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n_N = 24\n_MIN_W = 275\n\n\ndef _clean(sol):\n    # deduplicate, clamp to domain, preserve order of first occurrence\n    seen = set()\n    out = []\n    for i in sol:\n        if isinstance(i, int) and 1 <= i <= _N and i not in seen:\n            seen.add(i)\n            out.append(i)\n    return out\n\n\ndef _repair(sel):\n    # Greedy completion maximizing weight per unit value to hit feasibility tightly\n    total_w = sum(_WEIGHTS[i-1] for i in sel)\n    if total_w >= _MIN_W:\n        return sel\n    remaining = [i for i in range(1, _N+1) if i not in sel]\n    remaining.sort(key=lambda i: (_WEIGHTS[i-1]\/max(1,_VALUES[i-1]), -_WEIGHTS[i-1]), reverse=True)\n    for i in remaining:\n        sel.append(i)\n        total_w += _WEIGHTS[i-1]\n        if total_w >= _MIN_W:\n            break\n    return sel\n\n\ndef _total_weight(sel):\n    return sum(_WEIGHTS[i-1] for i in sel)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type fixed: \"Feasible-Repair\"; Movement_Type describes move.\n    \"\"\"\n    sel = _clean(solution)\n    sel = _repair(sel)\n\n    in_set = set(sel)\n    total_w = _total_weight(sel)\n\n    # Precompute ratios\n    ratio_bad = [(i, _VALUES[i-1]\/_WEIGHTS[i-1]) for i in sel]\n    ratio_bad.sort(key=lambda x: x[1], reverse=True)  # worse value\/weight first\n    candidates_in = [j for j in range(1, _N+1) if j not in in_set]\n    ratio_good = [(j, _WEIGHTS[j-1]\/max(1,_VALUES[j-1])) for j in candidates_in]\n    ratio_good.sort(key=lambda x: x[1], reverse=True)\n\n    move = None\n    new_sel = sel[:]\n\n    # Try 1-1 exchange (best-of-k)\n    if sel and candidates_in:\n        k_out = min(4, len(ratio_bad))\n        k_in = min(8, len(ratio_good))\n        best_delta = None\n        best_pair = None\n        for oi in range(k_out):\n            i_out = ratio_bad[oi][0]\n            w_out = _WEIGHTS[i_out-1]\n            v_out = _VALUES[i_out-1]\n            for ji in range(k_in):\n                j_in = ratio_good[ji][0]\n                if j_in == i_out:\n                    continue\n                w_in = _WEIGHTS[j_in-1]\n                v_in = _VALUES[j_in-1]\n                if total_w - w_out + w_in >= _MIN_W:\n                    delta = v_in - v_out  # objective change\n                    if (best_delta is None) or (delta < best_delta):\n                        best_delta = delta\n                        best_pair = (i_out, j_in)\n        if best_pair is not None and best_delta is not None and best_delta <= 0:\n            i_out, j_in = best_pair\n            new_sel = [i for i in sel if i != i_out] + [j_in]\n            move = \"1-1(best-improving)\"\n\n    # If no improving 1-1, try add best beneficial candidate\n    if move is None and candidates_in:\n        # Prefer adding heavy\/cheap item\n        j_in = ratio_good[0][0]\n        new_sel = sel + [j_in]\n        move = \"Add\"\n\n    # If addition chosen but overstuffed exploration needed, attempt feasible removal of worst\n    new_w = _total_weight(new_sel)\n    if move == \"Add\" and new_w >= _MIN_W:\n        # Try remove worst if still feasible and reduces value\n        worst_i = ratio_bad[0][0] if ratio_bad else None\n        if worst_i is not None:\n            if new_w - _WEIGHTS[worst_i-1] >= _MIN_W and _VALUES[worst_i-1] >= _VALUES[new_sel[-1]-1]:\n                new_sel = [i for i in new_sel if i != worst_i]\n                move = \"Add-Remove(boundary-tighten)\"\n\n    new_sel = _repair(_clean(new_sel))\n    return new_sel, \"Feasible-Repair\", move if move is not None else \"NoOp\"\n","Perturbacion":"# Multi-move perturbation with final repair\nimport random\n\n_VALUES = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n_WEIGHTS = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n_N = 24\n_MIN_W = 275\n\n\ndef _clean(sel):\n    seen = set()\n    out = []\n    for i in sel:\n        if isinstance(i, int) and 1 <= i <= _N and i not in seen:\n            seen.add(i)\n            out.append(i)\n    return out\n\n\ndef _repair(sel):\n    total_w = sum(_WEIGHTS[i-1] for i in sel)\n    if total_w >= _MIN_W:\n        return sel\n    remaining = [i for i in range(1, _N+1) if i not in sel]\n    remaining.sort(key=lambda i: (_WEIGHTS[i-1]\/max(1,_VALUES[i-1]), -_WEIGHTS[i-1]), reverse=True)\n    for i in remaining:\n        sel.append(i)\n        total_w += _WEIGHTS[i-1]\n        if total_w >= _MIN_W:\n            break\n    return sel\n\n\ndef perturb_solution(solution):\n    sel = _repair(_clean(solution))\n\n    k_moves = 5\n    for _ in range(k_moves):\n        in_set = set(sel)\n        total_w = sum(_WEIGHTS[i-1] for i in sel)\n        move = random.randrange(3)  # 0: swap, 1: drop, 2: add\n\n        if move == 0:  # swap: random 1-1 maintaining feasibility\n            if sel and len(in_set) < _N:\n                i_out = random.choice(sel)\n                candidates = [j for j in range(1, _N+1) if j not in in_set]\n                if candidates:\n                    j_in = random.choice(candidates)\n                    if total_w - _WEIGHTS[i_out-1] + _WEIGHTS[j_in-1] >= _MIN_W:\n                        sel = [i for i in sel if i != i_out] + [j_in]\n        elif move == 1:  # drop if feasible\n            removable = [i for i in sel if total_w - _WEIGHTS[i-1] >= _MIN_W]\n            if removable:\n                rem = random.choice(removable)\n                sel = [i for i in sel if i != rem]\n        else:  # add random\n            candidates = [j for j in range(1, _N+1) if j not in in_set]\n            if candidates:\n                sel = sel + [random.choice(candidates)]\n\n    sel = _repair(_clean(sel))\n    return sel\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total value subject to total weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return float(BIG)\n    if any((not isinstance(i, int)) for i in solution):\n        return float(BIG)\n    if len(set(solution)) != len(solution):\n        return float(BIG)\n    if any(i < 1 or i > 24 for i in solution):\n        return float(BIG)\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    if total_weight < 275:\n        return float(BIG)\n\n    return float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution: List[int], movement_label: str)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    # Precompute ranking for repair: ascending by value\/weight then by -weight\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        if w >= target_w:\n            return sorted(current)\n        # stochastic repair among top-k to diversify\n        k = 4\n        for i in order_add:\n            if i in current:\n                continue\n            current.add(i)\n            w += weights[i-1]\n            if w >= target_w:\n                break\n        return sorted(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        # Try removing items while keeping feasibility; prioritize worst ratios\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            if w - weights[i-1] >= target_w:\n                current.remove(i)\n                w -= weights[i-1]\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n    base = repair_to_feasible(base)\n    base = prune_redundant(base)\n\n    # Choose move type\n    op = \"SWAP\" if base else \"ADD\"\n    if random.random() < 0.5:\n        op = \"TOGGLE\"\n\n    if op == \"TOGGLE\":\n        nb = list(base)\n        if random.random() < 0.5 and nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        else:\n            available = [i for i in range(1, n+1) if i not in nb]\n            if available:\n                nb.append(random.choice(available))\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"TOGGLE\"\n    else:  # SWAP\n        nb = list(base)\n        if nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            # ratio-aware addition: prefer best by value\/weight\n            add = min(available, key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1]))\n            nb.append(add)\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, \"SWAP\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ weights[i-1], -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = set(sol)\n        w = total_w(sol)\n        if w >= target_w:\n            return sorted(current)\n        for i in order_add:\n            if i in current:\n                continue\n            current.add(i)\n            w += weights[i-1]\n            if w >= target_w:\n                break\n        return sorted(current)\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        # Greedy prune\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ weights[i-1], values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            if w - weights[i-1] >= target_w:\n                current.remove(i)\n                w -= weights[i-1]\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Strong perturbation: k random toggles\n    k = random.randint(3, 6)\n    current = set(base)\n    for _ in range(k):\n        if random.random() < 0.5 and current:\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            avail = [i for i in range(1, n+1) if i not in current]\n            if avail:\n                current.add(random.choice(avail))\n\n    pert = sorted(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Minimize total value subject to total weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return float(BIG)\n    if any((not isinstance(i, int)) for i in solution):\n        return float(BIG)\n    if len(set(solution)) != len(solution):\n        return float(BIG)\n    if any(i < 1 or i > 24 for i in solution):\n        return float(BIG)\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    if total_weight < 275:\n        return float(BIG)\n\n    return float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution: List[int], movement_label: str)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    # Precompute ranking for repair: ascending by value\/weight then by -weight\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = list(sorted(set(sol)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        # stochastic repair among top-k to diversify\n        k = 5\n        cand_idx = 0\n        available = [i for i in order_add if i not in current]\n        while w < target_w and available:\n            # choose among top-k remaining by ratio\n            topk = available[:k] if len(available) >= k else available\n            add = random.choice(topk)\n            current.append(add)\n            w += weights[add-1]\n            # remove chosen from available\n            available = [i for i in available if i != add]\n        return sorted(set(current))\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        # Try removing items while keeping feasibility; prioritize worst ratios\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n    base = repair_to_feasible(base)\n    base = prune_redundant(base)\n\n    # Choose move type\n    r = random.random()\n    if r < 0.5:\n        # TOGGLE: add or remove one item, then repair\/prune\n        nb = list(base)\n        if random.random() < 0.5 and nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n            move_label = f\"TOGGLE_REM_{rem}\"\n        else:\n            available = [i for i in range(1, n+1) if i not in nb]\n            if available:\n                add = random.choice(available)\n                nb.append(add)\n                move_label = f\"TOGGLE_ADD_{add}\"\n            else:\n                move_label = \"TOGGLE_NOOP\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n    else:\n        # SWAP: remove one selected and add one unselected (ratio-aware add)\n        nb = list(base)\n        if nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        else:\n            rem = None\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            add = min(available, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1]))\n            nb.append(add)\n            move_label = f\"SWAP_{rem}_TO_{add}\" if rem is not None else f\"ADD_{add}\"\n        else:\n            move_label = \"SWAP_NOOP\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol: List[int]) -> int:\n        return sum(weights[i-1] for i in sol)\n\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), -weights[i-1], values[i-1]))\n\n    def repair_to_feasible(sol: List[int]) -> List[int]:\n        current = list(sorted(set(sol)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        available = [i for i in order_add if i not in current]\n        idx = 0\n        while w < target_w and idx < len(available):\n            add = available[idx]\n            current.append(add)\n            w += weights[add-1]\n            idx += 1\n        return sorted(set(current))\n\n    def prune_redundant(sol: List[int]) -> List[int]:\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Strong perturbation: r random toggles\n    r = random.randint(3, 6)\n    current = set(base)\n    for _ in range(r):\n        if random.random() < 0.5 and current:\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            avail = [i for i in range(1, n+1) if i not in current]\n            if avail:\n                current.add(random.choice(avail))\n\n    pert = sorted(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Minimize total value subject to total weight >= 275\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    BIG = 10**9\n    PEN = 1000.0  # graduated penalty per unit shortfall\n\n    # Type and validity checks for SOL_TYPE=INDEX_LIST\n    if not isinstance(solution, list):\n        return float(BIG)\n    if any((not isinstance(i, int)) for i in solution):\n        return float(BIG)\n    if len(set(solution)) != len(solution):\n        return float(BIG)\n    if any(i < 1 or i > 24 for i in solution):\n        return float(BIG)\n\n    total_weight = 0\n    total_value = 0\n    for i in solution:\n        idx = i - 1\n        total_weight += weights[idx]\n        total_value += values[idx]\n\n    shortfall = 275 - total_weight\n    if shortfall > 0:\n        return float(BIG + PEN * shortfall)\n\n    return float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution: List[int], movement_label: str)\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol):\n        return sum(weights[i-1] for i in sol)\n\n    # Precompute ranking for add\/remove: ascending by value\/weight, then by value, then by -weight\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]))\n\n    def repair_to_feasible(sol):\n        current = list(sorted(set(x for x in sol if isinstance(x, int) and 1 <= x <= n)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        available = [i for i in order_add if i not in current]\n        idx = 0\n        # Deterministic greedy completion to avoid stochastic inflation near threshold\n        while w < target_w and idx < len(available):\n            add = available[idx]\n            current.append(add)\n            w += weights[add-1]\n            idx += 1\n        return sorted(set(current))\n\n    def prune_redundant(sol):\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        # Remove worst ratio items while maintaining feasibility\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = repair_to_feasible(solution if isinstance(solution, list) else [])\n    base = prune_redundant(base)\n\n    # Choose move type\n    r = random.random()\n    if r < 0.5:\n        # TOGGLE: add or remove one item, then repair\/prune\n        nb = list(base)\n        move_label = \"TOGGLE_NOOP\"\n        if random.random() < 0.5 and nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n            move_label = f\"TOGGLE_REM_{rem}\"\n        else:\n            available = [i for i in range(1, n+1) if i not in nb]\n            if available:\n                add = random.choice(available)\n                nb.append(add)\n                move_label = f\"TOGGLE_ADD_{add}\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n    else:\n        # SWAP: remove one selected and add one unselected (ratio-aware add)\n        nb = list(base)\n        move_label = \"SWAP_NOOP\"\n        rem = None\n        if nb:\n            rem = random.choice(nb)\n            nb.remove(rem)\n        available = [i for i in range(1, n+1) if i not in nb]\n        if available:\n            add = min(available, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]))\n            nb.append(add)\n            move_label = f\"SWAP_{rem}_TO_{add}\" if rem is not None else f\"ADD_{add}\"\n        nb = repair_to_feasible(nb)\n        nb = prune_redundant(nb)\n        return nb, move_label\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    n = 24\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_w = 275\n\n    def total_w(sol):\n        return sum(weights[i-1] for i in sol)\n\n    order_add = list(range(1, n+1))\n    order_add.sort(key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]))\n\n    def repair_to_feasible(sol):\n        current = list(sorted(set(x for x in sol if isinstance(x, int) and 1 <= x <= n)))\n        w = total_w(current)\n        if w >= target_w:\n            return current\n        available = [i for i in order_add if i not in current]\n        idx = 0\n        while w < target_w and idx < len(available):\n            add = available[idx]\n            current.append(add)\n            w += weights[add-1]\n            idx += 1\n        return sorted(set(current))\n\n    def prune_redundant(sol):\n        current = sorted(set(sol))\n        w = total_w(current)\n        if w < target_w:\n            return current\n        order_rem = sorted(current, key=lambda i: (values[i-1] \/ max(1, weights[i-1]), values[i-1], -weights[i-1]), reverse=True)\n        for i in order_rem:\n            wi = weights[i-1]\n            if w - wi >= target_w:\n                current.remove(i)\n                w -= wi\n        return current\n\n    base = list(sorted(set(x for x in solution if isinstance(x, int) and 1 <= x <= n)))\n\n    # Strong perturbation: k random toggles\n    k = random.randint(4, 7)\n    current = set(base)\n    for _ in range(k):\n        if current and random.random() < 0.5:\n            rem = random.choice(list(current))\n            current.remove(rem)\n        else:\n            avail = [i for i in range(1, n+1) if i not in current]\n            if avail:\n                current.add(random.choice(avail))\n\n    pert = sorted(current)\n    pert = repair_to_feasible(pert)\n    pert = prune_redundant(pert)\n    return pert\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Ensure canonical form: sorted, unique, in 1..24\n    def _canonicalize(sol: List[int]) -> List[int]:\n        return sorted({int(x) for x in sol if isinstance(x, int) and 1 <= int(x) <= 24})\n\n    def _random_not_in(current_set, domain_set):\n        remaining = list(domain_set - current_set)\n        if not remaining:\n            return None\n        return random.choice(remaining)\n\n    sol = _canonicalize(solution if isinstance(solution, list) else [])\n    n = 24\n    domain = set(range(1, n + 1))\n    cur = set(sol)\n\n    # Bias moves depending on feasibility estimate using lightweight weight check\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    total_w = sum(W[i] for i in sol)\n    TARGET = 275\n\n    r = random.random()\n    # If infeasible (underweight), prefer ADD; if overweight or barely feasible, prefer DROP; else SWAP\n    if (total_w < TARGET and r < 0.7) or (len(cur) == 0):\n        cand = _random_not_in(cur, domain)\n        if cand is None:\n            return (sol, \"noop\", \"0-0\")\n        nb = sol + [cand]\n        return (_canonicalize(nb), \"add\", \"0-1\")\n    elif (total_w >= TARGET and r < 0.5 and len(cur) > 0):\n        idx = random.choice(sol)\n        nb = [x for x in sol if x != idx]\n        return (_canonicalize(nb), \"drop\", \"1-0\")\n    else:\n        if len(cur) == 0 or len(cur) == n:\n            # fallback paths\n            if len(cur) == 0:\n                cand = _random_not_in(cur, domain)\n                nb = sol + ([cand] if cand is not None else [])\n                return (_canonicalize(nb), \"add\", \"0-1\")\n            idx = random.choice(sol)\n            nb = [x for x in sol if x != idx]\n            return (_canonicalize(nb), \"drop\", \"1-0\")\n        drop_idx = random.choice(sol)\n        rem = list(domain - cur)\n        add_idx = random.choice(rem) if rem else None\n        if add_idx is None:\n            nb = [x for x in sol if x != drop_idx]\n            return (_canonicalize(nb), \"drop\", \"1-0\")\n        nb = [x for x in sol if x != drop_idx] + [add_idx]\n        return (_canonicalize(nb), \"swap\", \"1-1\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-edit shake with feasibility bias to escape local minima\n    sol = list(solution) if isinstance(solution, list) else []\n    n = 24\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    TARGET = 275\n\n    def canonicalize(s: List[int]) -> List[int]:\n        return sorted({int(x) for x in s if isinstance(x, int) and 1 <= int(x) <= n})\n\n    sol = canonicalize(sol)\n    total_w = sum(W[i] for i in sol)\n\n    # Intensity: around 20% of domain\n    k = max(3, 5 + random.randint(-2, 2))\n    for _ in range(k):\n        r = random.random()\n        if total_w < TARGET:\n            # favor adds\/swaps that increase weight\n            if r < 0.6:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = random.choice(candidates)\n                    sol.append(addi)\n                    total_w += W[addi]\n            elif r < 0.85 and sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = random.choice(sol)\n                    addi = random.choice(candidates)\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        else:\n            # favor drops\/swaps that reduce value\/weight\n            if r < 0.5 and sol:\n                rem = random.choice(sol)\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            elif r < 0.8:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = random.choice(candidates)\n                    sol.append(addi)\n                    total_w += W[addi]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = random.choice(sol)\n                    addi = random.choice(candidates)\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        sol = canonicalize(sol)\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices (e.g., \"1,3,5,12\").","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Ensure canonical form: sorted, unique, in 1..24\n    def _canonicalize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list):\n            return []\n        filt = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                filt.append(x)\n        return sorted(filt)\n\n    sol = _canonicalize(solution)\n    n = 24\n    domain = set(range(1, n + 1))\n    cur = set(sol)\n\n    # Lightweight feasibility check\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    # Ratio guidance: prefer adding items with low v\/w when underweight; when feasible, prefer dropping high v\/w\n    def add_move(current):\n        remaining = list(domain - set(current))\n        if not remaining:\n            return current\n        # Choose candidate with minimal v\/w among a random subset for speed\n        k = min(5, len(remaining))\n        sample = random.sample(remaining, k)\n        best = min(sample, key=lambda i: (V[i]\/W[i], V[i], i))\n        return _canonicalize(current + [best])\n\n    def drop_move(current):\n        if not current:\n            return current\n        # Drop the worst ratio (high v\/w); tie-break by higher value then larger index\n        worst = max(current, key=lambda i: (V[i]\/W[i], V[i], i))\n        return _canonicalize([x for x in current if x != worst])\n\n    def swap_move(current):\n        if not current or len(current) == n:\n            return current\n        remaining = list(domain - set(current))\n        # pick a drop biased to high v\/w and an add biased to low v\/w\n        drop_idx = max(current, key=lambda i: (V[i]\/W[i], V[i], i))\n        add_idx = min(remaining, key=lambda i: (V[i]\/W[i], V[i], i))\n        nxt = [x for x in current if x != drop_idx] + [add_idx]\n        return _canonicalize(nxt)\n\n    r = random.random()\n    if total_w < TARGET:\n        # Prefer add; sometimes swap\n        if r < 0.75:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n        else:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = add_move(sol)\n            return (nb, \"swap\", \"1-1\")\n    else:\n        # Prefer drop; sometimes swap\/add for diversification\n        if r < 0.6:\n            nb = drop_move(sol)\n            return (nb, \"drop\", \"1-0\")\n        elif r < 0.85:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = drop_move(sol)\n            return (nb, \"swap\", \"1-1\")\n        else:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasibility-aware multi-edit shake\n    n = 24\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n\n    def canonicalize(s: List[int]) -> List[int]:\n        if not isinstance(s, list):\n            return []\n        seen = set()\n        out = []\n        for x in s:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return sorted(out)\n\n    sol = canonicalize(solution)\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    # Perturbation intensity\n    k = max(6, 8 + random.randint(-3, 3))\n\n    for _ in range(k):\n        r = random.random()\n        if total_w < TARGET:\n            # Favor adds and beneficial swaps\n            if r < 0.6:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n            elif r < 0.85 and sol:\n                # occasional drop of worst ratio to recompose\n                rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        else:\n            # Favor drops and improving swaps\n            if r < 0.55 and sol:\n                rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            elif r < 0.85:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i]\/W[i], V[i], i))\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    addi = min(random.sample(candidates, min(4, len(candidates))), key=lambda i: (V[i]\/W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n        sol = canonicalize(sol)\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"INDEX_LIST: comma-separated 1-based strictly increasing unique item indices (e.g., \"1,3,5,12\").","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness to minimize, encoding: objective then constraint and tie-breakers\n    # Feasible: primary=min total value; ties: min total weight; then lexicographically smallest list\n    # Infeasible: heavy penalty that decreases with higher weight toward 275, then lower value, then lex key\n    if not isinstance(solution, list):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and value checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Sort to enforce canonical representation for lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: encode the sorted index list as a base-32 integer; 0 acts as an end marker < any index\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness\n    if total_w >= TARGET:\n        # Minimize value, then weight, then lex key\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible: heavy penalty; closer to feasibility is better (higher weight), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Ensure canonical form: sorted, unique, in 1..24\n    def _canonicalize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list):\n            return []\n        filt = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                seen.add(x)\n                filt.append(x)\n        return sorted(filt)\n\n    sol = _canonicalize(solution)\n    n = 24\n    domain = set(range(1, n + 1))\n\n    # Data for guidance\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    def add_move(current: List[int]) -> List[int]:\n        remaining = list(domain - set(current))\n        if not remaining:\n            return current\n        k = min(10, len(remaining))\n        sample = random.sample(remaining, k)\n        best = min(sample, key=lambda i: (V[i] \/ W[i], V[i], i))\n        return _canonicalize(current + [best])\n\n    def drop_move(current: List[int]) -> List[int]:\n        if not current:\n            return current\n        worst = max(current, key=lambda i: (V[i] \/ W[i], V[i], i))\n        return _canonicalize([x for x in current if x != worst])\n\n    def swap_move(current: List[int]) -> List[int]:\n        if not current or len(current) == n:\n            return current\n        remaining = list(domain - set(current))\n        drop_idx = max(current, key=lambda i: (V[i] \/ W[i], V[i], i))\n        add_idx = min(remaining, key=lambda i: (V[i] \/ W[i], V[i], i))\n        nxt = [x for x in current if x != drop_idx] + [add_idx]\n        return _canonicalize(nxt)\n\n    r = random.random()\n    if total_w < TARGET:\n        if r < 0.75:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n        else:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = add_move(sol)\n            return (nb, \"swap\", \"1-1\")\n    else:\n        if r < 0.6:\n            nb = drop_move(sol)\n            return (nb, \"drop\", \"1-0\")\n        elif r < 0.85:\n            nb = swap_move(sol)\n            if nb == sol:\n                nb = drop_move(sol)\n            return (nb, \"swap\", \"1-1\")\n        else:\n            nb = add_move(sol)\n            return (nb, \"add\", \"0-1\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasibility-aware multi-edit shake\n    n = 24\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    TARGET = 275\n\n    def canonicalize(s: List[int]) -> List[int]:\n        if not isinstance(s, list):\n            return []\n        seen = set()\n        out = []\n        for x in s:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return sorted(out)\n\n    sol = canonicalize(solution)\n    total_w = 0\n    for i in sol:\n        total_w += W[i]\n\n    # Perturbation intensity with slight randomness\n    k = max(6, 8 + random.randint(-3, 3))\n\n    for _ in range(k):\n        r = random.random()\n        if total_w < TARGET:\n            if r < 0.6:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    pick_pool = random.sample(candidates, min(6, len(candidates)))\n                    addi = min(pick_pool, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n            elif r < 0.85 and sol:\n                rem = max(sol, key=lambda i: (V[i] \/ W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    pick_pool = random.sample(candidates, min(6, len(candidates)))\n                    addi = min(pick_pool, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n        else:\n            if r < 0.55 and sol:\n                rem = max(sol, key=lambda i: (V[i] \/ W[i], V[i], i))\n                sol = [x for x in sol if x != rem]\n                total_w -= W[rem]\n            elif r < 0.85:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if sol and candidates:\n                    rem = max(sol, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    pick_pool = random.sample(candidates, min(6, len(candidates)))\n                    addi = min(pick_pool, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    sol = [x for x in sol if x != rem] + [addi]\n                    total_w += W[addi] - W[rem]\n            else:\n                candidates = [i for i in range(1, n + 1) if i not in sol]\n                if candidates:\n                    pick_pool = random.sample(candidates, min(6, len(candidates)))\n                    addi = min(pick_pool, key=lambda i: (V[i] \/ W[i], V[i], i))\n                    sol.append(addi)\n                    total_w += W[addi]\n        sol = canonicalize(sol)\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24","Evaluacion":"import math\nfrom typing import List\n\ndef objective_function(solution: List[int]) -> float:\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24:\n            total_points += points[i]\n    return total_points\n\n\ndef evaluate_solution(solution: List[int]) -> float:\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set([i for i in solution if isinstance(i, int) and 1 <= i <= 24]))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    unique_valid = []\n    seen = set()\n    if isinstance(solution, list):\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n                unique_valid.append(i)\n                seen.add(i)\n\n    obj = objective_function(solution)\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-preserving neighbor generator with light repair to ensure cost >= 2750.\n    Returns (neighbor_solution_list, movement_type_str)\n    \"\"\"\n    def normalize_preserve_order(sol: List[int]) -> List[int]:\n        out = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                out.append(x)\n                seen.add(x)\n        return out\n\n    def compute_cost(sol: List[int]) -> int:\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        return sum(c[i] for i in sol)\n\n    def repair_feasible(sol: List[int]) -> List[int]:\n        # Ensure cost >= 2750 by adding lowest point-per-cost items\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        need = 2750 - compute_cost(sol)\n        if need <= 0:\n            # Try to trim if heavily over by removing worst point-per-cost while keeping feasible\n            # Single-pass greedy trimming\n            changed = True\n            while changed:\n                changed = False\n                # candidates to remove that keep feasibility\n                worst = None\n                worst_ratio = -1\n                for i in list(sol):\n                    new_cost = compute_cost([x for x in sol if x != i])\n                    if new_cost >= 2750:\n                        ratio = p[i] \/ c[i]\n                        if ratio > worst_ratio:\n                            worst_ratio = ratio\n                            worst = i\n                if worst is not None:\n                    sol = [x for x in sol if x != worst]\n                    changed = True\n            return sol\n        # Need to add items\n        remaining = [i for i in range(1,25) if i not in sol]\n        remaining.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        idx = 0\n        while compute_cost(sol) < 2750 and idx < len(remaining):\n            sol.append(remaining[idx])\n            idx += 1\n        return normalize_preserve_order(sol)\n\n    sol = normalize_preserve_order(solution if isinstance(solution, list) else [])\n    all_items = list(range(1,25))\n\n    # Movement selection with cost-awareness\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n    if 1 < len(sol) < 24:\n        move_types.append(\"exchange_2for1\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    # Data for cost-aware choices\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    if move == \"add\":\n        candidates = [i for i in all_items if i not in new_sol]\n        if candidates:\n            # pick among lowest point-per-cost items\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            k = min(3, len(candidates))\n            chosen = random.choice(candidates[:k])\n            new_sol.append(chosen)\n    elif move == \"remove\":\n        # remove highest point-per-cost item if feasibility stays\n        if new_sol:\n            removable = []\n            for i in new_sol:\n                tmp = [x for x in new_sol if x != i]\n                if compute_cost(tmp) >= 2750:\n                    removable.append(i)\n            if removable:\n                removable.sort(key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n                # choose among top-2 worst\n                k = min(2, len(removable))\n                out = random.choice(removable[:k])\n                new_sol = [x for x in new_sol if x != out]\n            else:\n                # fallback: no feasible removal, switch to add\n                candidates = [i for i in all_items if i not in new_sol]\n                if candidates:\n                    candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                    new_sol.append(candidates[0])\n                    move = \"add\"\n    elif move == \"swap\":\n        if new_sol and len(new_sol) < 24:\n            out = random.choice(new_sol)\n            candidates = [i for i in all_items if i not in new_sol]\n            if candidates:\n                # prefer better ratio items\n                candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                k = min(4, len(candidates))\n                in_item = random.choice(candidates[:k])\n                tmp = [x for x in new_sol if x != out] + [in_item]\n                new_sol = tmp\n    else:  # exchange_2for1: remove worst two (if feasible) and add one good\n        if len(new_sol) >= 2 and len(new_sol) < 24:\n            # choose two worst by ratio, but ensure feasibility after removal\n            sorted_by_worst = sorted(new_sol, key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n            removed = []\n            trial = list(new_sol)\n            for cand in sorted_by_worst:\n                if len(removed) == 2:\n                    break\n                tmp = [x for x in trial if x != cand]\n                if compute_cost(tmp) >= 2750:\n                    trial = tmp\n                    removed.append(cand)\n            if removed:\n                add_cands = [i for i in all_items if i not in trial]\n                if add_cands:\n                    add_cands.sort(key=lambda i: (p[i]\/c[i], p[i]))\n                    trial.append(add_cands[0])\n                    new_sol = trial\n                    move = \"exchange_2for1\"\n\n    new_sol = normalize_preserve_order(new_sol)\n    new_sol = repair_feasible(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Budget-feasible strong perturbation: perform t guided 1-1 swaps and optional trims,\n    always keeping cost >= 2750. Returns a valid solution list.\n    \"\"\"\n    def normalize_preserve_order(sol: List[int]) -> List[int]:\n        out, seen = [], set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= 24 and x not in seen:\n                out.append(x)\n                seen.add(x)\n        return out\n\n    def compute_cost(sol: List[int]) -> int:\n        c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        return sum(c[i] for i in sol)\n\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    sol = normalize_preserve_order(solution if isinstance(solution, list) else [])\n    all_items = list(range(1,25))\n\n    # Ensure feasibility before perturb\n    if compute_cost(sol) < 2750:\n        # add cheapest ratios first\n        missing = [i for i in all_items if i not in sol]\n        missing.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        idx = 0\n        while compute_cost(sol) < 2750 and idx < len(missing):\n            sol.append(missing[idx])\n            idx += 1\n        sol = normalize_preserve_order(sol)\n\n    # t guided swaps\n    t = random.randint(3, 6)\n    for _ in range(t):\n        if not sol:\n            break\n        out = random.choice(sol)\n        candidates = [i for i in all_items if i not in sol]\n        if not candidates:\n            break\n        candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        in_item = random.choice(candidates[:min(5, len(candidates))])\n        tmp = [x for x in sol if x != out] + [in_item]\n        # If infeasible, add more cheap items until feasible\n        if compute_cost(tmp) < 2750:\n            missing = [i for i in all_items if i not in tmp]\n            missing.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            j = 0\n            while compute_cost(tmp) < 2750 and j < len(missing):\n                tmp.append(missing[j])\n                j += 1\n        sol = normalize_preserve_order(tmp)\n\n    # Optional trim of worst ratios while keeping feasibility\n    changed = True\n    while changed:\n        changed = False\n        worst = None\n        worst_ratio = -1\n        for i in list(sol):\n            new_list = [x for x in sol if x != i]\n            if compute_cost(new_list) >= 2750:\n                ratio = p[i]\/c[i]\n                if ratio > worst_ratio:\n                    worst_ratio = ratio\n                    worst = i\n        if worst is not None:\n            sol = [x for x in sol if x != worst]\n            changed = True\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24_SORTED","Evaluacion":"import math\nimport random\n\ndef objective_function(solution):\n    # solution: list of unique item indices (1-based)\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n            total_points += points[i]\n            seen.add(i)\n    return total_points\n\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicates\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(solution))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # consider only unique valid indices for cost and objective\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    # compute objective over provided solution (objective handles validity\/uniqueness internally)\n    obj = objective_function(solution)\n\n    # compute cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget constraint: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Canonicalize input\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n        return s\n\n    # Static data\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def feasible(sol):\n        return cost_of(sol) >= 2750\n\n    def add_best_by_ratio(sol, k_pick=1):\n        current = set(sol)\n        candidates = [i for i in range(1,25) if i not in current]\n        candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        for i in candidates[:k_pick]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    def trim_worst_while_feasible(sol):\n        changed = True\n        sol = list(sol)\n        while changed:\n            changed = False\n            best_remove = None\n            best_ratio = -1.0\n            for i in sol:\n                if cost_of(sol) - c[i] >= 2750:\n                    ratio = p[i] \/ c[i]\n                    if ratio > best_ratio:\n                        best_ratio = ratio\n                        best_remove = i\n            if best_remove is not None:\n                sol.remove(best_remove)\n                changed = True\n        return normalize_sorted(sol)\n\n    sol = normalize_sorted(solution)\n    total_cost = cost_of(sol)\n\n    # If infeasible, first repair by adding low ratio items\n    if total_cost < 2750:\n        while total_cost < 2750:\n            prev = list(sol)\n            sol = add_best_by_ratio(sol, 1)\n            if sol == prev:\n                break\n            total_cost = cost_of(sol)\n        sol = normalize_sorted(sol)\n        total_cost = cost_of(sol)\n\n    # Define feasible-aware moves\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n    if len(sol) >= 2 and len(sol) < 24:\n        move_types.append(\"exchange_2for1\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    if move == \"add\":\n        # prefer items that increase cost efficiently with low points\n        new_sol = add_best_by_ratio(new_sol, 1)\n    elif move == \"remove\":\n        # remove worst ratio item only if remains feasible\n        worst = None\n        worst_ratio = -1.0\n        for i in new_sol:\n            if cost_of(new_sol) - c[i] >= 2750:\n                r = p[i]\/c[i]\n                if r > worst_ratio:\n                    worst_ratio = r\n                    worst = i\n        if worst is not None:\n            new_sol.remove(worst)\n            new_sol = normalize_sorted(new_sol)\n        else:\n            move = \"add\"\n            new_sol = add_best_by_ratio(new_sol, 1)\n    elif move == \"swap\":\n        # replace one item by a better ratio candidate, keep feasibility (try a few)\n        if new_sol:\n            out = random.choice(new_sol)\n            candidates = [i for i in range(1,25) if i not in new_sol]\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            chosen = None\n            for cand in candidates[:5]:\n                # Try swap and check feasibility; if infeasible, consider also adding one best item\n                tmp = sorted(set([x for x in new_sol if x != out] + [cand]))\n                if cost_of(tmp) >= 2750:\n                    chosen = cand\n                    new_sol = tmp\n                    break\n            if chosen is None and candidates:\n                # fallback: just add\n                move = \"add\"\n                new_sol = add_best_by_ratio(new_sol, 1)\n    else:  # exchange_2for1\n        # remove up to two worst ratio items while staying feasible, then add one good item\n        removable_sorted = sorted(new_sol, key=lambda i: (p[i]\/c[i], p[i]), reverse=True)\n        trial = list(new_sol)\n        removed_any = False\n        for r_item in removable_sorted:\n            if cost_of(trial) - c[r_item] >= 2750 and len(trial) > 1:\n                trial.remove(r_item)\n                removed_any = True\n                if len(trial) <= 1:\n                    break\n                # remove at most two\n                if len(removable_sorted) >= 2:\n                    continue\n        if removed_any:\n            # add one good item\n            trial = add_best_by_ratio(trial, 1)\n            new_sol = trial\n        else:\n            move = \"add\"\n            new_sol = add_best_by_ratio(new_sol, 1)\n\n    # Final canonicalization and light trim\n    new_sol = normalize_sorted(new_sol)\n    if cost_of(new_sol) >= 2750:\n        new_sol = trim_worst_while_feasible(new_sol)\n    else:\n        # ensure feasibility in rare cases\n        while cost_of(new_sol) < 2750:\n            new_sol = add_best_by_ratio(new_sol, 1)\n    return (new_sol, move)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        s = sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n        return s\n\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def add_best_by_ratio(sol, count=1):\n        cur = set(sol)\n        pool = [i for i in range(1,25) if i not in cur]\n        pool.sort(key=lambda i: (p[i]\/c[i], p[i]))\n        for i in pool[:count]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    sol = normalize_sorted(solution)\n\n    # Ensure feasibility first\n    while cost_of(sol) < 2750:\n        sol = add_best_by_ratio(sol, 1)\n\n    # Perform t guided random swaps\/adds\/removes while preserving feasibility\n    t = random.randint(4, 7)\n    for _ in range(t):\n        move = random.choice([\"swap\",\"add\",\"remove\"])  # diversify\n        if move == \"swap\" and sol:\n            out = random.choice(sol)\n            candidates = [i for i in range(1,25) if i not in sol]\n            if not candidates:\n                continue\n            candidates.sort(key=lambda i: (p[i]\/c[i], p[i]))\n            in_item = random.choice(candidates[:min(6, len(candidates))])\n            tmp = sorted(set([x for x in sol if x != out] + [in_item]))\n            if cost_of(tmp) >= 2750:\n                sol = tmp\n        elif move == \"add\" and len(sol) < 24:\n            sol = add_best_by_ratio(sol, 1)\n        elif move == \"remove\" and sol:\n            # remove a worst ratio item if remains feasible\n            worst = None\n            worst_ratio = -1.0\n            for i in sol:\n                if cost_of(sol) - c[i] >= 2750:\n                    r = p[i]\/c[i]\n                    if r > worst_ratio:\n                        worst_ratio = r\n                        worst = i\n            if worst is not None:\n                sol.remove(worst)\n                sol = normalize_sorted(sol)\n\n    # Final trimming pass to move closer to boundary\n    changed = True\n    while changed:\n        changed = False\n        best_remove = None\n        best_ratio = -1.0\n        for i in sol:\n            if cost_of(sol) - c[i] >= 2750:\n                r = p[i]\/c[i]\n                if r > best_ratio:\n                    best_ratio = r\n                    best_remove = i\n        if best_remove is not None:\n            sol.remove(best_remove)\n            changed = True\n    return normalize_sorted(sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"JSON_LIST_OF_UNIQUE_INTS_1_TO_24_SORTED","Evaluacion":"import math\nimport random\n\ndef objective_function(solution):\n    # solution: list of unique item indices (1-based)\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n            total_points += points[i]\n            seen.add(i)\n    return total_points\n\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicates\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(solution))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # consider only unique valid indices for cost and objective\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    # compute objective over provided solution (objective handles validity\/uniqueness internally)\n    obj = objective_function(solution)\n\n    # compute cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget constraint: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize once\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        return sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n\n    # Static data\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def feasible(sol):\n        return cost_of(sol) >= 2750\n\n    def add_best_by_ratio(sol, k_pick=1):\n        current = set(sol)\n        candidates = [i for i in range(1, 25) if i not in current]\n        # ascending p\/c then by p\n        candidates.sort(key=lambda i: (p[i] \/ c[i], p[i]))\n        for i in candidates[:k_pick]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    def add_min_point_feasible(sol):\n        # fallback add: minimal point item that achieves feasibility if possible by 1 add; else just minimal point\n        cur = set(sol)\n        candidates = [i for i in range(1, 25) if i not in cur]\n        need = 2750 - cost_of(sol)\n        feasibles = [i for i in candidates if c[i] >= need]\n        pick_pool = feasibles if feasibles else candidates\n        if pick_pool:\n            pick = min(pick_pool, key=lambda i: (p[i], p[i] \/ c[i]))\n            sol = normalize_sorted(sol + [pick])\n        return sol\n\n    def trim_boundary_dp(sol):\n        # Try to remove items while staying feasible with a small DP over removable set (size <= 15)\n        # Build candidate removable set (higher p\/c first)\n        base = list(sol)\n        base_cost = cost_of(base)\n        if base_cost < 2750:\n            return normalize_sorted(base)\n        removable = sorted(base, key=lambda i: (p[i] \/ c[i], p[i]), reverse=True)[:15]\n        budget = base_cost - 2750  # we can remove cost up to this\n        # 0\/1 knapsack to maximize removed points with total cost <= budget\n        # discretize costs exactly small (<= 2840); here budget <= 2840\n        dp = [(-1, [])] * (budget + 1)\n        dp[0] = (0, [])\n        for it in removable:\n            ci, pi = c[it], p[it]\n            for b in range(budget, ci - 1, -1):\n                if dp[b - ci][0] != -1:\n                    cand_pts = dp[b - ci][0] + pi\n                    if cand_pts > dp[b][0]:\n                        dp[b] = (cand_pts, dp[b - ci][1] + [it])\n        # select best\n        best_pts = -1\n        best_set = []\n        for b in range(budget + 1):\n            if dp[b][0] > best_pts:\n                best_pts = dp[b][0]\n                best_set = dp[b][1]\n        if best_set:\n            new_sol = [i for i in base if i not in set(best_set)]\n            return normalize_sorted(new_sol)\n        return normalize_sorted(base)\n\n    sol = normalize_sorted(solution)\n\n    # Repair to feasibility if needed with robust fallback\n    if not feasible(sol):\n        attempts = 0\n        while not feasible(sol) and attempts < 30:\n            before = sol[:]\n            sol = add_best_by_ratio(sol, 1)\n            if sol == before:\n                sol = add_min_point_feasible(sol)\n            attempts += 1\n        sol = normalize_sorted(sol)\n\n    # Candidate move types\n    move_types = []\n    if len(sol) < 24:\n        move_types.append(\"add\")\n    if len(sol) > 0:\n        move_types.append(\"remove\")\n    if 0 < len(sol) < 24:\n        move_types.append(\"swap\")\n    if len(sol) >= 2 and len(sol) < 24:\n        move_types.append(\"exchange_2for1\")\n\n    if not move_types:\n        return (sol, \"noop\")\n\n    move = random.choice(move_types)\n    new_sol = list(sol)\n\n    if move == \"add\":\n        # Prefer low p\/c; if stuck, fallback to minimal-point feasible add\n        before = new_sol[:]\n        new_sol = add_best_by_ratio(new_sol, 1)\n        if new_sol == before:\n            new_sol = add_min_point_feasible(new_sol)\n\n    elif move == \"remove\":\n        # remove worst ratio item only if remains feasible\n        worst = None\n        worst_ratio = -1.0\n        base_cost = cost_of(new_sol)\n        for i in new_sol:\n            if base_cost - c[i] >= 2750:\n                r = p[i] \/ c[i]\n                if r > worst_ratio:\n                    worst_ratio = r\n                    worst = i\n        if worst is not None:\n            new_sol.remove(worst)\n            new_sol = normalize_sorted(new_sol)\n        else:\n            move = \"add\"\n            new_sol = add_best_by_ratio(new_sol, 1)\n            if not feasible(new_sol):\n                new_sol = add_min_point_feasible(new_sol)\n\n    elif move == \"swap\":\n        if new_sol:\n            out = random.choice(new_sol)\n            candidates = [i for i in range(1, 25) if i not in new_sol]\n            # broaden candidate set adaptively: top alpha fraction by ratio\n            candidates.sort(key=lambda i: (p[i] \/ c[i], p[i]))\n            k = max(5, int(0.2 * max(1, len(candidates))))\n            pool = candidates[:k]\n            # include a few low-point but higher-cost items to cross feasibility fronts\n            low_point_pool = sorted(candidates, key=lambda i: (p[i], p[i] \/ c[i]))[:min(5, len(candidates))]\n            pool = list(dict.fromkeys(pool + low_point_pool))\n            chosen = None\n            for cand in pool:\n                tmp = sorted(set([x for x in new_sol if x != out] + [cand]))\n                if feasible(tmp):\n                    chosen = cand\n                    new_sol = tmp\n                    break\n            if chosen is None and len(new_sol) < 24:\n                new_sol = add_best_by_ratio(new_sol, 1)\n                if not feasible(new_sol):\n                    new_sol = add_min_point_feasible(new_sol)\n\n    else:  # exchange_2for1\n        # Remove at most two worst ratio items while staying feasible after each removal\n        trial = list(new_sol)\n        removed = 0\n        # sort descending by ratio\n        removable_sorted = sorted(trial, key=lambda i: (p[i] \/ c[i], p[i]), reverse=True)\n        for r_item in removable_sorted:\n            if removed >= 2:\n                break\n            if cost_of(trial) - c[r_item] >= 2750:\n                trial.remove(r_item)\n                removed += 1\n        # add one good item\n        if removed > 0 and len(trial) < 24:\n            trial = add_best_by_ratio(trial, 1)\n            if not feasible(trial):\n                trial = add_min_point_feasible(trial)\n            new_sol = trial\n        else:\n            # fallback to swap\/add\n            if len(new_sol) < 24:\n                new_sol = add_best_by_ratio(new_sol, 1)\n                if not feasible(new_sol):\n                    new_sol = add_min_point_feasible(new_sol)\n\n    # Final canonicalization and exact boundary trim via small DP\n    new_sol = normalize_sorted(new_sol)\n    if feasible(new_sol):\n        new_sol = trim_boundary_dp(new_sol)\n    else:\n        # safety repair\n        attempts = 0\n        while not feasible(new_sol) and attempts < 30:\n            new_sol = add_min_point_feasible(new_sol)\n            attempts += 1\n        new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Normalize\n    def normalize_sorted(sol):\n        if not isinstance(sol, list):\n            return []\n        return sorted(set(i for i in sol if isinstance(i, int) and 1 <= i <= 24))\n\n    c = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    p = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    def cost_of(sol):\n        return sum(c[i] for i in sol)\n\n    def feasible(sol):\n        return cost_of(sol) >= 2750\n\n    def add_best_by_ratio(sol, count=1):\n        cur = set(sol)\n        pool = [i for i in range(1, 25) if i not in cur]\n        pool.sort(key=lambda i: (p[i] \/ c[i], p[i]))\n        for i in pool[:count]:\n            sol.append(i)\n        return normalize_sorted(sol)\n\n    def add_min_point_feasible(sol):\n        cur = set(sol)\n        pool = [i for i in range(1, 25) if i not in cur]\n        if not pool:\n            return normalize_sorted(sol)\n        need = 2750 - cost_of(sol)\n        feas = [i for i in pool if c[i] >= need]\n        pick_pool = feas if feas else pool\n        pick = min(pick_pool, key=lambda i: (p[i], p[i] \/ c[i]))\n        return normalize_sorted(sol + [pick])\n\n    def trim_boundary_dp(sol):\n        base = list(sol)\n        base_cost = cost_of(base)\n        if base_cost < 2750:\n            return normalize_sorted(base)\n        removable = sorted(base, key=lambda i: (p[i] \/ c[i], p[i]), reverse=True)[:15]\n        budget = base_cost - 2750\n        dp = [(-1, [])] * (budget + 1)\n        dp[0] = (0, [])\n        for it in removable:\n            ci, pi = c[it], p[it]\n            for b in range(budget, ci - 1, -1):\n                if dp[b - ci][0] != -1:\n                    cand_pts = dp[b - ci][0] + pi\n                    if cand_pts > dp[b][0]:\n                        dp[b] = (cand_pts, dp[b - ci][1] + [it])\n        best_pts = -1\n        best_set = []\n        for b in range(budget + 1):\n            if dp[b][0] > best_pts:\n                best_pts = dp[b][0]\n                best_set = dp[b][1]\n        if best_set:\n            return normalize_sorted([i for i in base if i not in set(best_set)])\n        return normalize_sorted(base)\n\n    sol = normalize_sorted(solution)\n\n    # Ensure feasibility first\n    attempts = 0\n    while not feasible(sol) and attempts < 50:\n        before = sol[:]\n        sol = add_best_by_ratio(sol, 1)\n        if sol == before:\n            sol = add_min_point_feasible(sol)\n        attempts += 1\n\n    # Strength-adaptive k-exchange with feasibility-preserving add-back\n    n = len(sol)\n    k = random.randint(2, min(5, max(2, n))) if n > 0 else 2\n    current = set(sol)\n\n    # Remove up to k items biased toward high p\/c\n    removable = sorted(sol, key=lambda i: (p[i] \/ c[i], p[i]), reverse=True)\n    to_remove = removable[:min(k, len(removable))]\n    for r in to_remove:\n        if len(sol) > 0 and (cost_of(sol) - c[r] >= 2750 or len(sol) > len(to_remove)):\n            if r in sol:\n                sol.remove(r)\n    sol = normalize_sorted(sol)\n\n    # Add back up to k items biased to low p\/c and low p\n    add_pool = [i for i in range(1, 25) if i not in set(sol)]\n    add_pool.sort(key=lambda i: (p[i] \/ c[i], p[i]))\n    adds = random.randint(1, min(k, len(add_pool))) if add_pool else 0\n    for i in add_pool[:adds]:\n        sol.append(i)\n    sol = normalize_sorted(sol)\n\n    # Repair feasibility if broken\n    attempts = 0\n    while not feasible(sol) and attempts < 50:\n        before = sol[:]\n        sol = add_best_by_ratio(sol, 1)\n        if sol == before:\n            sol = add_min_point_feasible(sol)\n        attempts += 1\n\n    # Final boundary trim to push down points\n    sol = trim_boundary_dp(sol)\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    # type check\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices penalty\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicate penalty\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(i for i in solution if isinstance(i, int)))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # objective (sum of points over unique valid indices)\n    if isinstance(solution, list):\n        seen = set()\n        obj = 0\n        for i in solution:\n            if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n                obj += points[i]\n                seen.add(i)\n    else:\n        obj = float('inf')\n\n    # unique valid set for cost and feasibility check\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # feasibility: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        # ensure unique and valid\n        sol = sanitize(sol)\n        current_cost = total_cost(sol)\n        # if under budget, add items with best point density\n        if current_cost < BUDGET:\n            available = [i for i in range(1, n_items + 1) if i not in sol]\n            # sort by increasing points per cost, then by points\n            available.sort(key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            for i in available:\n                if current_cost >= BUDGET:\n                    break\n                sol.append(i)\n                current_cost += costs[i]\n        # if still somehow under (e.g., empty available), just return sanitized\n        sol = sanitize(sol)\n        # ensure we don't overshoot feasibility downward; do not remove if it breaks budget\n        return sol\n\n    sol = repair_to_feasible(sanitize(solution))\n    in_set = set(sol)\n    out_set = set(range(1, n_items + 1)) - in_set\n\n    move_type = None\n    new_sol = list(sol)\n\n    # Decide movement focusing on maintaining feasibility via repair\n    r = random.random()\n    if r < 0.33 and len(new_sol) > 0:\n        # try remove of high point-density while preserving budget\n        candidates = sorted(new_sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n        for i in candidates:\n            if total_cost(new_sol) - costs[i] >= BUDGET:\n                new_sol.remove(i)\n                move_type = \"remove\"\n                break\n        if move_type is None and len(new_sol) > 0:\n            # fallback: remove worst-density then repair\n            i = candidates[0]\n            new_sol.remove(i)\n            move_type = \"remove\"\n    elif r < 0.66 and len(out_set) > 0:\n        # add best available by lowest points per cost\n        cand = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n        pick = cand[0]\n        new_sol.append(pick)\n        move_type = \"add\"\n    else:\n        # swap: replace a worse-density in-set with better-density out-set while keeping feasibility\n        if len(new_sol) > 0 and len(out_set) > 0:\n            # rank sets\n            in_ranked = sorted(new_sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n            out_ranked = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            performed = False\n            base_cost = total_cost(new_sol)\n            for i in in_ranked[:min(8, len(in_ranked))]:\n                for j in out_ranked[:min(8, len(out_ranked))]:\n                    new_cost = base_cost - costs[i] + costs[j]\n                    if new_cost >= BUDGET and (points[j] <= points[i]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.append(j)\n                        new_sol = tmp\n                        performed = True\n                        break\n                if performed:\n                    break\n            if performed:\n                move_type = \"swap\"\n            else:\n                # fallback random swap then repair\n                i = random.choice(list(in_set))\n                j = random.choice(list(out_set))\n                tmp = list(new_sol)\n                tmp.remove(i)\n                tmp.append(j)\n                new_sol = tmp\n                move_type = \"swap\"\n        else:\n            move_type = \"identity\"\n\n    new_sol = repair_to_feasible(new_sol)\n    new_sol = sanitize(new_sol)\n    return new_sol, \"set\", (move_type if move_type is not None else \"identity\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        uniq = []\n        seen = set()\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                uniq.append(x)\n                seen.add(x)\n        return uniq\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        current_cost = total_cost(sol)\n        if current_cost < BUDGET:\n            avail = [i for i in range(1, n_items + 1) if i not in sol]\n            avail.sort(key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            for i in avail:\n                if current_cost >= BUDGET:\n                    break\n                sol.append(i)\n                current_cost += costs[i]\n        sol = sanitize(sol)\n        return sol\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # perform k feasible-biased moves then repair\n    k = random.randint(2, 5)\n    for _ in range(k):\n        in_set = set(sol)\n        out_set = set(range(1, n_items + 1)) - in_set\n        r = random.random()\n        if r < 0.4 and len(sol) > 0:\n            # remove worst density if feasible after removal\n            worst = sorted(sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n            for i in worst:\n                if total_cost(sol) - costs[i] >= BUDGET:\n                    sol.remove(i)\n                    break\n        elif r < 0.8 and len(out_set) > 0:\n            # add best density\n            best = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            sol.append(best[0])\n        else:\n            # swap worst in with best out if keeps feasibility\n            if len(sol) > 0 and len(out_set) > 0:\n                in_rank = sorted(sol, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]), reverse=True)\n                out_rank = sorted(list(out_set), key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n                for i in in_rank[:min(6, len(in_rank))]:\n                    for j in out_rank[:min(6, len(out_rank))]:\n                        if total_cost(sol) - costs[i] + costs[j] >= BUDGET:\n                            sol.remove(i)\n                            sol.append(j)\n                            break\n                    else:\n                        continue\n                    break\n        sol = sanitize(sol)\n\n    sol = repair_to_feasible(sol)\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**2\n    PENALTY_BUDGET_PER_DOLLAR = 100\n\n    penalty = 0\n\n    # type check\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n        # still attempt to continue with empty for robustness\n        solution = [] if not isinstance(solution, list) else [i for i in solution if isinstance(i, int)]\n\n    # invalid indices penalty\n    invalid = [i for i in solution if not (1 <= i <= n_items)]\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicate penalty (mild, objective uses unique)\n    dup_count = len(solution) - len(set(i for i in solution if 1 <= i <= n_items))\n    penalty += PENALTY_DUP * max(0, dup_count)\n\n    # unique valid indices for objective and cost\n    unique_valid = sorted({i for i in solution if 1 <= i <= n_items})\n\n    # objective: sum of points (minimize)\n    obj = sum(points[i] for i in unique_valid)\n\n    # total cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget feasibility: must spend at least BUDGET\n    if total_cost < BUDGET:\n        penalty += (BUDGET - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost >= BUDGET:\n            return sol\n        # add items by increasing points per cost, tie-break by higher cost to reach budget faster\n        available = [i for i in range(1, n_items + 1) if i not in sol]\n        available.sort(key=lambda i: (points[i] \/ max(1, costs[i]), -costs[i], points[i]))\n        for i in available:\n            if cur_cost >= BUDGET:\n                break\n            sol.append(i)\n            cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # Precompute sets\n    in_set = set(sol)\n    out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n\n    move_type = \"identity\"\n    new_sol = list(sol)\n\n    # Choose a neighborhood: remove, add, 1-1 swap, 1-2, 2-1\n    r = random.random()\n\n    def density(i):\n        return points[i] \/ max(1, costs[i])\n\n    base_cost = total_cost(new_sol)\n\n    if r < 0.2 and len(new_sol) > 0:\n        # Remove: try removing worst density if still feasible\n        candidates = sorted(new_sol, key=lambda i: density(i), reverse=True)\n        for i in candidates:\n            if base_cost - costs[i] >= BUDGET:\n                new_sol.remove(i)\n                move_type = \"remove\"\n                break\n        # if none feasible, fallback to swap below\n        if move_type == \"remove\":\n            new_sol = repair_to_feasible(new_sol)\n            return sanitize(new_sol), move_type\n\n    if r < 0.5 and len(out_list) > 0:\n        # Add: add lowest density available\n        pick = min(out_list, key=lambda i: (density(i), points[i]))\n        new_sol.append(pick)\n        move_type = \"add\"\n        new_sol = repair_to_feasible(new_sol)\n        return sanitize(new_sol), move_type\n\n    # Swap neighborhoods\n    in_ranked = sorted(new_sol, key=lambda i: density(i), reverse=True)\n    out_ranked = sorted(out_list, key=lambda i: (density(i), points[i]))\n\n    # Try 1-1 improving\/feasible swap\n    for i in in_ranked[:min(8, len(in_ranked))]:\n        for j in out_ranked[:min(8, len(out_ranked))] if len(out_ranked) > 0 else []:\n            new_cost = base_cost - costs[i] + costs[j]\n            if new_cost >= BUDGET:\n                if points[j] < points[i]:\n                    tmp = list(new_sol)\n                    tmp.remove(i)\n                    tmp.append(j)\n                    new_sol = tmp\n                    move_type = \"swap1-1\"\n                    new_sol = repair_to_feasible(new_sol)\n                    return sanitize(new_sol), move_type\n    # Try 1-2\n    if len(out_ranked) >= 2:\n        for i in in_ranked[:min(6, len(in_ranked))]:\n            for a in range(min(6, len(out_ranked))):\n                for b in range(a + 1, min(6, len(out_ranked))):\n                    j = out_ranked[a]\n                    k = out_ranked[b]\n                    new_cost = base_cost - costs[i] + costs[j] + costs[k]\n                    if new_cost >= BUDGET and (points[j] + points[k] < points[i]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.extend([j, k])\n                        new_sol = tmp\n                        move_type = \"swap1-2\"\n                        new_sol = repair_to_feasible(new_sol)\n                        return sanitize(new_sol), move_type\n    # Try 2-1\n    if len(in_ranked) >= 2 and len(out_ranked) >= 1:\n        for a in range(min(6, len(in_ranked))):\n            for b in range(a + 1, min(6, len(in_ranked))):\n                i = in_ranked[a]\n                j = in_ranked[b]\n                for k in out_ranked[:min(6, len(out_ranked))]:\n                    new_cost = base_cost - costs[i] - costs[j] + costs[k]\n                    if new_cost >= BUDGET and (points[k] < points[i] + points[j]):\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.remove(j)\n                        tmp.append(k)\n                        new_sol = tmp\n                        move_type = \"swap2-1\"\n                        new_sol = repair_to_feasible(new_sol)\n                        return sanitize(new_sol), move_type\n\n    # Fallback: random swap then repair\n    if len(new_sol) > 0 and len(out_list) > 0:\n        i = random.choice(list(new_sol))\n        j = random.choice(out_list)\n        tmp = list(new_sol)\n        tmp.remove(i)\n        tmp.append(j)\n        new_sol = repair_to_feasible(tmp)\n        move_type = \"swap-rand\"\n    else:\n        move_type = \"identity\"\n\n    return sanitize(new_sol), move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost < BUDGET:\n            avail = [i for i in range(1, n_items + 1) if i not in sol]\n            avail.sort(key=lambda i: (points[i] \/ max(1, costs[i]), -costs[i], points[i]))\n            for i in avail:\n                if cur_cost >= BUDGET:\n                    break\n                sol.append(i)\n                cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # Apply k random feasible-biased moves\n    k = random.randint(3, 6)\n    for _ in range(k):\n        in_set = set(sol)\n        out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n        r = random.random()\n        if r < 0.3 and len(sol) > 0:\n            # remove worst density if feasible\n            worst = sorted(sol, key=lambda i: points[i] \/ max(1, costs[i]), reverse=True)\n            for i in worst:\n                if total_cost(sol) - costs[i] >= BUDGET:\n                    sol.remove(i)\n                    break\n        elif r < 0.7 and len(out_list) > 0:\n            # add best available by lowest density\n            j = min(out_list, key=lambda i: (points[i] \/ max(1, costs[i]), points[i]))\n            sol.append(j)\n        else:\n            # swap variants\n            if len(sol) > 0 and len(out_list) > 0:\n                choice = random.random()\n                if choice < 0.5:\n                    # 1-1\n                    i = random.choice(sol)\n                    j = random.choice(out_list)\n                    sol.remove(i)\n                    sol.append(j)\n                elif choice < 0.8 and len(out_list) >= 2:\n                    # 1-2\n                    i = random.choice(sol)\n                    j, k = random.sample(out_list, 2)\n                    sol.remove(i)\n                    sol.extend([j, k])\n                elif len(sol) >= 2:\n                    # 2-1\n                    i, j = random.sample(sol, 2)\n                    k = random.choice(out_list)\n                    sol.remove(i)\n                    sol.remove(j)\n                    sol.append(k)\n        sol = repair_to_feasible(sol)\n\n    sol = repair_to_feasible(sol)\n    return sanitize(sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef objective_function(solution):\n    # solution: list of unique item indices (1-based)\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    if not isinstance(solution, list):\n        return float('inf')\n    total_points = 0\n    seen = set()\n    for i in solution:\n        if isinstance(i, int) and 1 <= i <= 24 and i not in seen:\n            total_points += points[i]\n            seen.add(i)\n    return total_points\n\ndef evaluate_solution(solution):\n    # solution: list of item indices (1-based)\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    # penalties\n    PENALTY_TYPE = 10**9\n    PENALTY_INVALID_IDX = 10**6\n    PENALTY_DUP = 10**5\n    PENALTY_BUDGET_PER_DOLLAR = 1000\n\n    penalty = 0\n    if not isinstance(solution, list) or not all(isinstance(i, int) for i in solution):\n        penalty += PENALTY_TYPE\n\n    # invalid indices\n    invalid = [i for i in solution if not (isinstance(i, int) and 1 <= i <= 24)] if isinstance(solution, list) else []\n    penalty += PENALTY_INVALID_IDX * len(invalid)\n\n    # duplicates\n    if isinstance(solution, list):\n        dup_count = len(solution) - len(set(solution))\n        penalty += PENALTY_DUP * max(0, dup_count)\n    else:\n        dup_count = 0\n\n    # consider only unique valid indices for cost and objective\n    unique_valid = sorted({i for i in solution if isinstance(i, int) and 1 <= i <= 24}) if isinstance(solution, list) else []\n\n    # compute objective over provided solution (objective handles validity\/uniqueness internally)\n    obj = objective_function(solution)\n\n    # compute cost\n    total_cost = sum(costs[i] for i in unique_valid)\n\n    # budget constraint: must spend at least 2750\n    if total_cost < 2750:\n        penalty += (2750 - total_cost) * PENALTY_BUDGET_PER_DOLLAR\n\n    return obj + penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def total_points(sol):\n        return sum(points[i] for i in sol)\n\n    def density(i):\n        return points[i] \/ max(1, costs[i])\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost >= BUDGET:\n            return sol\n        available = [i for i in range(1, n_items + 1) if i not in sol]\n        available.sort(key=lambda i: (density(i), -costs[i], points[i]))\n        for i in available:\n            if cur_cost >= BUDGET:\n                break\n            sol.append(i)\n            cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    in_set = set(sol)\n    out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n\n    base_cost = total_cost(sol)\n    move_type = \"identity\"\n    new_sol = list(sol)\n\n    r = random.random()\n\n    # Attempt removal of worst density if remains feasible\n    if r < 0.15 and len(new_sol) > 0:\n        for i in sorted(new_sol, key=lambda x: density(x), reverse=True):\n            if base_cost - costs[i] >= BUDGET:\n                new_sol.remove(i)\n                move_type = \"remove\"\n                return sanitize(new_sol), move_type\n\n    # Attempt add of best low-density item\n    if r < 0.45 and len(out_list) > 0:\n        j = min(out_list, key=lambda x: (density(x), points[x]))\n        new_sol.append(j)\n        move_type = \"add\"\n        new_sol = repair_to_feasible(new_sol)\n        return sanitize(new_sol), move_type\n\n    # Swap neighborhoods with bounded candidate lists and feasibility pruning\n    in_ranked = sorted(new_sol, key=lambda i: density(i), reverse=True)\n    out_ranked = sorted(out_list, key=lambda i: (density(i), points[i]))\n\n    # 1-1 swap\n    tried = 0\n    for i in in_ranked[:min(10, len(in_ranked))]:\n        for j in out_ranked[:min(10, len(out_ranked))]:\n            tried += 1\n            new_cost = base_cost - costs[i] + costs[j]\n            if new_cost >= BUDGET and points[j] < points[i]:\n                tmp = list(new_sol)\n                tmp.remove(i)\n                tmp.append(j)\n                move_type = \"swap1-1\"\n                return sanitize(tmp), move_type\n    # 1-2 swap\n    if len(out_ranked) >= 2:\n        for i in in_ranked[:min(8, len(in_ranked))]:\n            for a in range(min(8, len(out_ranked))):\n                for b in range(a + 1, min(8, len(out_ranked))):\n                    j = out_ranked[a]\n                    k = out_ranked[b]\n                    new_cost = base_cost - costs[i] + costs[j] + costs[k]\n                    if new_cost >= BUDGET and points[j] + points[k] < points[i]:\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.extend([j, k])\n                        move_type = \"swap1-2\"\n                        return sanitize(tmp), move_type\n    # 2-1 swap\n    if len(in_ranked) >= 2 and len(out_ranked) >= 1:\n        for a in range(min(8, len(in_ranked))):\n            for b in range(a + 1, min(8, len(in_ranked))):\n                i = in_ranked[a]\n                j = in_ranked[b]\n                for k in out_ranked[:min(8, len(out_ranked))]:\n                    new_cost = base_cost - costs[i] - costs[j] + costs[k]\n                    if new_cost >= BUDGET and points[k] < points[i] + points[j]:\n                        tmp = list(new_sol)\n                        tmp.remove(i)\n                        tmp.remove(j)\n                        tmp.append(k)\n                        move_type = \"swap2-1\"\n                        return sanitize(tmp), move_type\n\n    # Fallback random shake (swap or add) then repair\n    if len(new_sol) > 0 and len(out_list) > 0:\n        i = random.choice(list(new_sol))\n        j = random.choice(out_list)\n        tmp = list(new_sol)\n        tmp.remove(i)\n        tmp.append(j)\n        move_type = \"swap-rand\"\n        tmp = repair_to_feasible(tmp)\n        return sanitize(tmp), move_type\n\n    return sanitize(new_sol), move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    costs = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n_items = 24\n    BUDGET = 2750\n\n    def sanitize(sol):\n        if not isinstance(sol, list):\n            return []\n        seen = set()\n        clean = []\n        for x in sol:\n            if isinstance(x, int) and 1 <= x <= n_items and x not in seen:\n                seen.add(x)\n                clean.append(x)\n        return clean\n\n    def total_cost(sol):\n        return sum(costs[i] for i in sol)\n\n    def density(i):\n        return points[i] \/ max(1, costs[i])\n\n    def repair_to_feasible(sol):\n        sol = sanitize(sol)\n        cur_cost = total_cost(sol)\n        if cur_cost < BUDGET:\n            avail = [i for i in range(1, n_items + 1) if i not in sol]\n            avail.sort(key=lambda i: (density(i), -costs[i], points[i]))\n            for i in avail:\n                if cur_cost >= BUDGET:\n                    break\n                sol.append(i)\n                cur_cost += costs[i]\n        return sanitize(sol)\n\n    sol = repair_to_feasible(sanitize(solution))\n\n    # Adaptive k-exchange perturbation\n    k = random.choice([2, 3, 4])\n\n    # Remove k worst-density items while remaining feasible if possible\n    for i in sorted(sol, key=lambda x: density(x), reverse=True):\n        if k == 0:\n            break\n        if total_cost(sol) - costs[i] >= BUDGET:\n            sol.remove(i)\n            k -= 1\n\n    # Add up to k best low-density items from complement\n    complement = [i for i in range(1, n_items + 1) if i not in sol]\n    complement.sort(key=lambda x: (density(x), points[x]))\n    add_count = random.randint(1, 3)\n    for j in complement[:add_count]:\n        sol.append(j)\n\n    # Random shake: perform a few random feasible-biased moves\n    moves = random.randint(2, 4)\n    for _ in range(moves):\n        sol = repair_to_feasible(sol)\n        in_set = set(sol)\n        out_list = [i for i in range(1, n_items + 1) if i not in in_set]\n        r = random.random()\n        if r < 0.4 and len(sol) > 0:\n            # try remove worst if feasible\n            for i in sorted(sol, key=lambda x: density(x), reverse=True):\n                if total_cost(sol) - costs[i] >= BUDGET:\n                    sol.remove(i)\n                    break\n        elif r < 0.8 and len(out_list) > 0:\n            # add best low-density\n            j = min(out_list, key=lambda x: (density(x), points[x]))\n            sol.append(j)\n        else:\n            # random 1-1 swap\n            if len(sol) > 0 and len(out_list) > 0:\n                i = random.choice(sol)\n                j = random.choice(out_list)\n                sol.remove(i)\n                sol.append(j)\n        sol = repair_to_feasible(sol)\n\n    sol = repair_to_feasible(sol)\n    return sanitize(sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _sanitize(solution: List[int], n: int) -> List[int]:\n    if not isinstance(solution, list):\n        return []\n    seen = set()\n    cleaned = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            seen.add(x)\n            cleaned.append(x)\n    return cleaned\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embed problem data to enable feasibility-aware moves\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    cur = _sanitize(solution, n)\n    # Compute current totals\n    total_cost = sum(costs[i] for i in cur)\n    # Decide state: under, near, or over budget\n    state = \"feasible\" if total_cost >= B else \"under\"\n    # Movement probabilities tuned by state\n    p_add, p_remove, p_replace, p_swap2 = (0.55, 0.15, 0.20, 0.10) if state == \"under\" else (0.25, 0.45, 0.20, 0.10)\n    r = random.random()\n    new_sol = list(cur)\n    move = \"noop\"\n    # Helper sets\n    have = set(new_sol)\n    missing = [i for i in range(1, n+1) if i not in have]\n    # Biased candidate orderings\n    # Prefer adding low-point high-cost items when under budget\n    add_candidates = sorted(missing, key=lambda i: (points[i], -costs[i]))\n    # Prefer removing high point-per-cost items when over budget\n    remove_candidates = sorted(new_sol, key=lambda i: (-points[i]\/costs[i], -points[i]))\n    if r < p_add and add_candidates:\n        cand = random.choice(add_candidates[:max(1, min(5, len(add_candidates)))])\n        new_sol.append(cand)\n        move = \"add\"\n    elif r < p_add + p_remove and new_sol:\n        cand = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n        new_sol = [x for x in new_sol if x != cand]\n        move = \"remove\"\n    elif r < p_add + p_remove + p_replace:\n        if new_sol and missing:\n            # Replace worst in-set by best missing\n            out_idx = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n            in_idx = random.choice(add_candidates[:max(1, min(5, len(add_candidates)))])\n            if out_idx != in_idx:\n                new_sol = [x for x in new_sol if x != out_idx]\n                new_sol.append(in_idx)\n                move = \"replace\"\n            else:\n                move = \"noop\"\n        elif missing:\n            new_sol.append(random.choice(add_candidates))\n            move = \"add\"\n        else:\n            move = \"noop\"\n    else:\n        # Swap two: remove one and add one (or two small edits)\n        if new_sol:\n            out_idx = random.choice(remove_candidates[:max(1, min(5, len(remove_candidates)))])\n            new_sol = [x for x in new_sol if x != out_idx]\n            have2 = set(new_sol)\n            missing2 = [i for i in range(1, n+1) if i not in have2]\n            if missing2:\n                in_idx = random.choice(sorted(missing2, key=lambda i: (points[i], -costs[i]))[:max(1, min(5, len(missing2)))])\n                new_sol.append(in_idx)\n                move = \"swap_one\"\n            else:\n                move = \"remove\"\n        else:\n            if missing:\n                new_sol.append(random.choice(add_candidates))\n                move = \"add\"\n            else:\n                move = \"noop\"\n    # Preserve order of appearance, ensure uniqueness\n    seen = set()\n    ordered = []\n    for x in new_sol:\n        if x not in seen:\n            seen.add(x)\n            ordered.append(x)\n    return (ordered, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # sanitize\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    total_cost = sum(costs[i] for i in cur)\n    # Number of edits based on state\n    if total_cost < B:\n        K = random.randint(4, 7)\n    elif total_cost > B:\n        K = random.randint(3, 6)\n    else:\n        K = random.randint(2, 4)\n    s = list(cur)\n    for _ in range(K):\n        total_cost = sum(costs[i] for i in s)\n        have = set(s)\n        missing = [i for i in range(1, n+1) if i not in have]\n        if total_cost < B:\n            # add best low-point high-cost item\n            if missing:\n                cand = min(missing, key=lambda i: (points[i], -costs[i]))\n                s.append(cand)\n            else:\n                # replace worst item with better missing (if any)\n                worst = max(s, key=lambda i: (points[i], -costs[i]))\n                s.remove(worst)\n                s.append(worst)\n        elif total_cost > B:\n            # remove worst point-per-cost item\n            if s:\n                rem = max(s, key=lambda i: (points[i] \/ costs[i], points[i]))\n                s.remove(rem)\n        else:\n            # cost exactly at B: perform a swap aimed to reduce points if possible\n            if s and missing:\n                out = max(s, key=lambda i: (points[i] \/ costs[i], points[i]))\n                inn = min(missing, key=lambda i: (points[i], -costs[i]))\n                if inn != out:\n                    s.remove(out)\n                    s.append(inn)\n            else:\n                # fallback random tweak\n                if missing and (not s or random.random() < 0.5):\n                    s.append(random.choice(missing))\n                elif s:\n                    s.pop(random.randrange(len(s)))\n        # deduplicate while preserving order\n        seen2 = set()\n        s2 = []\n        for v in s:\n            if v not in seen2:\n                seen2.add(v)\n                s2.append(v)\n        s = s2\n    return s\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _sanitize_idx_list(solution: List[int], n: int) -> List[int]:\n    if not isinstance(solution, list):\n        return []\n    seen = set()\n    cleaned = []\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n and x not in seen:\n            seen.add(x)\n            cleaned.append(x)\n    return cleaned\n\ndef _fitness(sol: List[int]) -> int:\n    # Mirror of evaluate_solution (embedded, no external refs)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in sol):\n        return 10**15\n    if len(set(sol)) != len(sol):\n        return 10**15\n    total_cost = 0\n    total_points = 0\n    for idx in sol:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(sol)\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embed problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    cur = _sanitize_idx_list(solution, n)\n    # Greedy fill if clearly under budget to diversify\n    total_cost = sum(costs[i] for i in cur)\n    if total_cost + 300 <= B:\n        have = set(cur)\n        missing = [i for i in range(1, n+1) if i not in have]\n        # Add items by (points asc, cost desc) until close to B\n        for i in sorted(missing, key=lambda i: (points[i], -costs[i])):\n            if total_cost >= B:\n                break\n            cur.append(i)\n            total_cost += costs[i]\n    # Recompute state\n    total_cost = sum(costs[i] for i in cur)\n    overspend = max(0, total_cost - B)\n    state = \"under\" if total_cost < B else (\"far\" if overspend > 200 else \"near\")\n    # Movement probabilities\n    if state == \"under\":\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.55, 0.10, 0.20, 0.10, 0.05\n    elif state == \"far\":\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.10, 0.55, 0.15, 0.15, 0.05\n    else:  # near\n        p_add, p_remove, p_replace, p_swap, p_2swap = 0.20, 0.35, 0.25, 0.15, 0.05\n    r = random.random()\n    new_sol = list(cur)\n    move = \"noop\"\n    have = set(new_sol)\n    missing = [i for i in range(1, n+1) if i not in have]\n    # Helper: delta-based removal ordering aligned with fitness\n    def removal_delta(idx: int) -> int:\n        s = [x for x in new_sol if x != idx]\n        return _fitness(s)\n    def addition_gain(idx: int) -> int:\n        s = list(new_sol) + [idx]\n        return _fitness(s)\n    if (r < p_add) and missing:\n        # choose among top-k low-point high-cost missing\n        cand_pool = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(6, len(missing))]\n        # pick the one with best resulting fitness\n        best_cand = None\n        best_fit = 10**18\n        for c in cand_pool:\n            f = addition_gain(c)\n            if f < best_fit:\n                best_fit = f\n                best_cand = c\n        if best_cand is not None:\n            new_sol.append(best_cand)\n            move = \"add\"\n    elif (r < p_add + p_remove) and new_sol:\n        # remove the item with smallest resulting fitness after removal\n        cand_pool = new_sol if len(new_sol) <= 8 else random.sample(new_sol, 8)\n        best_out = None\n        best_fit = 10**18\n        for idx in cand_pool:\n            f = removal_delta(idx)\n            if f < best_fit:\n                best_fit = f\n                best_out = idx\n        if best_out is not None:\n            new_sol = [x for x in new_sol if x != best_out]\n            move = \"remove\"\n    elif (r < p_add + p_remove + p_replace) and new_sol and missing:\n        # replace: try few candidates and pick best\n        out_pool = new_sol if len(new_sol) <= 6 else random.sample(new_sol, 6)\n        in_pool = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(6, len(missing))]\n        best_pair = None\n        best_fit = 10**18\n        for out_idx in out_pool:\n            for in_idx in in_pool:\n                if in_idx == out_idx:\n                    continue\n                s = [x for x in new_sol if x != out_idx]\n                s.append(in_idx)\n                f = _fitness(s)\n                if f < best_fit:\n                    best_fit = f\n                    best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [x for x in new_sol if x != out_idx]\n            new_sol.append(in_idx)\n            move = \"replace\"\n    elif (r < p_add + p_remove + p_replace + p_swap) and new_sol:\n        # swap one out, one in\n        if missing:\n            out_idx = random.choice(new_sol)\n            in_cands = sorted(missing, key=lambda i: (points[i], -costs[i]))[:min(8, len(missing))]\n            best_in = None\n            best_fit = 10**18\n            base = [x for x in new_sol if x != out_idx]\n            for in_idx in in_cands:\n                s = list(base)\n                s.append(in_idx)\n                f = _fitness(s)\n                if f < best_fit:\n                    best_fit = f\n                    best_in = in_idx\n            if best_in is not None:\n                new_sol = base\n                new_sol.append(best_in)\n                move = \"swap_one\"\n    else:\n        # 2-swap: remove two, add up to two\n        if len(new_sol) >= 1:\n            out_pool = new_sol if len(new_sol) <= 6 else random.sample(new_sol, 6)\n            in_pool_all = sorted([i for i in range(1, n+1) if i not in set(new_sol)], key=lambda i: (points[i], -costs[i]))\n            best_variant = None\n            best_fit = 10**18\n            for out_idx in out_pool:\n                base = [x for x in new_sol if x != out_idx]\n                # Try add one\n                for in_idx in in_pool_all[:min(8, len(in_pool_all))]:\n                    s1 = list(base) + [in_idx]\n                    f1 = _fitness(s1)\n                    if f1 < best_fit:\n                        best_fit = f1\n                        best_variant = s1\n                # Try add two (if possible)\n                if len(in_pool_all) >= 2:\n                    for in_idx1 in in_pool_all[:min(6, len(in_pool_all))]:\n                        for in_idx2 in in_pool_all[:min(6, len(in_pool_all))]:\n                            if in_idx1 == in_idx2:\n                                continue\n                            s2 = list(base) + [in_idx1, in_idx2]\n                            f2 = _fitness(s2)\n                            if f2 < best_fit:\n                                best_fit = f2\n                                best_variant = s2\n            if best_variant is not None:\n                new_sol = _sanitize_idx_list(best_variant, n)\n                move = \"2swap\"\n    # Final sanitize preserving order\n    seen = set()\n    ordered = []\n    for x in new_sol:\n        if x not in seen:\n            seen.add(x)\n            ordered.append(x)\n    return (ordered, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Embed problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # Sanitize\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n    # Helper fitness (same as evaluator) for internal guidance\n    def fitness(sol: List[int]) -> int:\n        if any((i < 1) or (i > n) for i in sol):\n            return 10**15\n        if len(set(sol)) != len(sol):\n            return 10**15\n        total_cost = 0\n        total_points = 0\n        for idx in sol:\n            total_cost += costs[idx]\n            total_points += points[idx]\n        count = len(sol)\n        if total_cost < B:\n            deficit = B - total_cost\n            return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n        overspend = total_cost - B\n        return total_points * 10**6 + overspend * 10**3 + count\n    total_cost = sum(costs[i] for i in cur)\n    # Choose diversification strength\n    if total_cost < B:\n        k_remove = random.randint(2, 5)\n    elif total_cost > B:\n        k_remove = random.randint(3, 6)\n    else:\n        k_remove = random.randint(2, 4)\n    s = list(cur)\n    # Remove k items with highest points per cost (and points)\n    for _ in range(min(k_remove, len(s))):\n        if not s:\n            break\n        out = max(s, key=lambda i: (points[i]\/costs[i], points[i], -costs[i]))\n        s.remove(out)\n    # Greedily add low-point high-cost items until reaching feasibility\n    have = set(s)\n    missing = [i for i in range(1, n+1) if i not in have]\n    missing_sorted = sorted(missing, key=lambda i: (points[i], -costs[i]))\n    idx = 0\n    while True:\n        total_cost = sum(costs[i] for i in s)\n        if total_cost >= B or idx >= len(missing_sorted):\n            break\n        s.append(missing_sorted[idx])\n        idx += 1\n    # Local repair: if still under, add random low-point items\n    if sum(costs[i] for i in s) < B:\n        extra = [i for i in range(1, n+1) if i not in set(s)]\n        extra_sorted = sorted(extra, key=lambda i: (points[i], -costs[i]))\n        for i in extra_sorted:\n            if sum(costs[j] for j in s) >= B:\n                break\n            s.append(i)\n    # Deduplicate while preserving order\n    seen2 = set()\n    s2 = []\n    for v in s:\n        if v not in seen2 and 1 <= v <= n:\n            seen2.add(v)\n            s2.append(v)\n    # If perturbation worsened fitness drastically, keep better of original and perturbed\n    return s2 if fitness(s2) <= fitness(cur) else cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Type check\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    # Data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    n = 24\n    B = 2750\n    # Bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Fitness construction (lower is better)\n    # Infeasible: large penalty prioritized by budget deficit, then points, then count\n    if total_cost < B:\n        deficit = B - total_cost\n        return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n    # Feasible: primary minimize points, then minimize overspend, then item count\n    overspend = total_cost - B\n    return total_points * 10**6 + overspend * 10**3 + count\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    def sanitize(sol: List[int]) -> List[int]:\n        seen = set()\n        out = []\n        if isinstance(sol, list):\n            for x in sol:\n                if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                    seen.add(x)\n                    out.append(x)\n        return out\n\n    def fitness(sol: List[int]) -> int:\n        # Mirror of evaluate_solution\n        if any((i < 1) or (i > n) for i in sol):\n            return 10**15\n        if len(set(sol)) != len(sol):\n            return 10**15\n        total_cost = 0\n        total_points = 0\n        for idx in sol:\n            total_cost += costs[idx]\n            total_points += points[idx]\n        count = len(sol)\n        if total_cost < B:\n            deficit = B - total_cost\n            return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n        overspend = total_cost - B\n        return total_points * 10**6 + overspend * 10**3 + count\n\n    cur = sanitize(solution)\n    have = set(cur)\n    base_cost = sum(costs[i] for i in cur)\n    # State classification\n    overspend = base_cost - B\n    state = \"under\" if base_cost < B else (\"far\" if overspend > 200 else \"near\")\n    # Movement distribution\n    if state == \"under\":\n        probs = (0.55, 0.15, 0.20, 0.10, 0.00)  # add, remove, replace, swap, two_op\n    elif state == \"far\":\n        probs = (0.10, 0.55, 0.25, 0.10, 0.00)\n    else:\n        probs = (0.20, 0.30, 0.35, 0.15, 0.00)\n\n    r = random.random()\n    p_add, p_remove, p_replace, p_swap, p_two = probs\n    new_sol = list(cur)\n    move = \"noop\"\n\n    # Precomputed static ordering by (points asc, -cost desc)\n    idx_by_pc = [i for i in range(1, n+1)]\n    idx_by_pc.sort(key=lambda i: (points[i], -costs[i]))\n\n    # Candidate helpers\n    missing = [i for i in idx_by_pc if i not in have]\n\n    if (r < p_add) and missing:\n        # Add the candidate that yields best fitness among top-k low point items\n        k = min(8, len(missing))\n        best_c = None\n        best_f = 10**18\n        for c in missing[:k]:\n            s = new_sol + [c]\n            f = fitness(s)\n            if f < best_f:\n                best_f = f\n                best_c = c\n        if best_c is not None:\n            new_sol.append(best_c)\n            move = \"add\"\n\n    elif (r < p_add + p_remove) and new_sol:\n        # Remove item that improves fitness most\n        samp = new_sol if len(new_sol) <= 10 else random.sample(new_sol, 10)\n        best_out = None\n        best_f = 10**18\n        for idx in samp:\n            s = [x for x in new_sol if x != idx]\n            f = fitness(s)\n            if f < best_f:\n                best_f = f\n                best_out = idx\n        if best_out is not None:\n            new_sol = [x for x in new_sol if x != best_out]\n            move = \"remove\"\n\n    elif (r < p_add + p_remove + p_replace) and new_sol and missing:\n        # Replace: try limited out\/in pools\n        out_pool = new_sol if len(new_sol) <= 8 else random.sample(new_sol, 8)\n        in_pool = missing[:min(10, len(missing))]\n        best_pair = None\n        best_f = 10**18\n        for out_idx in out_pool:\n            base = [x for x in new_sol if x != out_idx]\n            for in_idx in in_pool:\n                s = base + [in_idx]\n                f = fitness(s)\n                if f < best_f:\n                    best_f = f\n                    best_pair = (out_idx, in_idx)\n        if best_pair is not None:\n            out_idx, in_idx = best_pair\n            new_sol = [x for x in new_sol if x != out_idx]\n            new_sol.append(in_idx)\n            move = \"replace\"\n\n    elif (r < p_add + p_remove + p_replace + p_swap) and new_sol:\n        # Swap one out for best in among top-k missing\n        if missing:\n            out_idx = random.choice(new_sol)\n            base = [x for x in new_sol if x != out_idx]\n            best_in = None\n            best_f = 10**18\n            for in_idx in missing[:min(10, len(missing))]:\n                s = base + [in_idx]\n                f = fitness(s)\n                if f < best_f:\n                    best_f = f\n                    best_in = in_idx\n            if best_in is not None:\n                new_sol = base + [best_in]\n                move = \"swap_one\"\n\n    else:\n        # Local 2-change (remove one, add two or remove two, add one) to adjust budget tightness\n        if len(new_sol) >= 1 and missing:\n            best_variant = None\n            best_f = 10**18\n            # remove one, add two\n            out_pool = new_sol if len(new_sol) <= 6 else random.sample(new_sol, 6)\n            in_pool = missing[:min(10, len(missing))]\n            for out_idx in out_pool:\n                base = [x for x in new_sol if x != out_idx]\n                # add one\n                for a in in_pool:\n                    s1 = base + [a]\n                    f1 = fitness(s1)\n                    if f1 < best_f:\n                        best_f = f1\n                        best_variant = s1\n                # add two\n                for i1 in range(min(6, len(in_pool))):\n                    for i2 in range(i1+1, min(6, len(in_pool))):\n                        s2 = base + [in_pool[i1], in_pool[i2]]\n                        f2 = fitness(s2)\n                        if f2 < best_f:\n                            best_f = f2\n                            best_variant = s2\n            if best_variant is not None:\n                # sanitize and set\n                seen = set()\n                ordered = []\n                for x in best_variant:\n                    if x not in seen and 1 <= x <= n:\n                        seen.add(x)\n                        ordered.append(x)\n                new_sol = ordered\n                move = \"2change\"\n\n    # Final sanitize preserving order\n    seen = set()\n    ordered = []\n    for x in new_sol:\n        if x not in seen and 1 <= x <= n:\n            seen.add(x)\n            ordered.append(x)\n    return (ordered, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 24\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4, 18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    def fitness(sol: List[int]) -> int:\n        if any((i < 1) or (i > n) for i in sol):\n            return 10**15\n        if len(set(sol)) != len(sol):\n            return 10**15\n        total_cost = 0\n        total_points = 0\n        for idx in sol:\n            total_cost += costs[idx]\n            total_points += points[idx]\n        count = len(sol)\n        if total_cost < B:\n            deficit = B - total_cost\n            return 10**12 + deficit * 10**6 + total_points * 10**3 + count\n        overspend = total_cost - B\n        return total_points * 10**6 + overspend * 10**3 + count\n\n    # Sanitize\n    cur = []\n    seen = set()\n    if isinstance(solution, list):\n        for x in solution:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                cur.append(x)\n\n    # Decide removal count based on feasibility\n    total_cost = sum(costs[i] for i in cur)\n    if total_cost < B:\n        k_remove = 3\n    elif total_cost > B:\n        k_remove = 4\n    else:\n        k_remove = 2\n\n    s = list(cur)\n    # Remove up to k_remove with worst (points, -cost) contribution\n    for _ in range(min(k_remove, len(s))):\n        if not s:\n            break\n        out = max(s, key=lambda i: (points[i], -costs[i]))\n        s.remove(out)\n\n    # Greedy add low-point high-cost until reaching budget\n    in_set = set(s)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    candidates.sort(key=lambda i: (points[i], -costs[i]))\n    for i in candidates:\n        if sum(costs[j] for j in s) >= B:\n            break\n        s.append(i)\n\n    # If overspent heavily, try targeted removals while keeping feasibility\n    while sum(costs[j] for j in s) - B > 300 and s:\n        # remove item with highest points per cost, prefer high points\n        out = max(s, key=lambda i: (points[i] \/ costs[i], points[i], -costs[i]))\n        tmp = [x for x in s if x != out]\n        if sum(costs[j] for j in tmp) >= B:\n            s = tmp\n        else:\n            break\n\n    # Deduplicate preserve order\n    seen2 = set()\n    s2 = []\n    for v in s:\n        if v not in seen2 and 1 <= v <= n:\n            seen2.add(v)\n            s2.append(v)\n\n    return s2 if fitness(s2) <= fitness(cur) else cur\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nfrom typing import Optional\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a 24-length binary string for the fuel offer selection problem.\n    Returns total price if gallons >= demand; otherwise adds an adaptive penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    # Adaptive penalty scaled by mean price per gallon and deficit\n    mean_ppg = sum(prices) \/ max(1, sum(gallons))\n    deficit = demand - total_gallons\n    # lambda factor scales to about two orders of magnitude larger than typical prices\n    lam = 50.0\n    penalty = lam * mean_ppg * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n\ndef _repair_feasible(s: str) -> str:\n    \"\"\"Greedy repair to meet demand with minimal added cost; then prune redundant costly ones.\"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    n = len(s)\n    sel = [1 if c == '1' else 0 for c in s]\n    total_g = sum(gallons[i] for i in range(n) if sel[i])\n    total_p = sum(prices[i] for i in range(n) if sel[i])\n\n    if total_g < demand:\n        # Add cheapest by price-per-gallon among zeros until feasible\n        candidates = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 0]\n        candidates.sort()\n        for _, i in candidates:\n            sel[i] = 1\n            total_g += gallons[i]\n            total_p += prices[i]\n            if total_g >= demand:\n                break\n\n    # Try pruning redundant 1s starting from worst price efficiency while staying feasible\n    ones = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 1]\n    ones.sort(reverse=True)\n    for _, i in ones:\n        if total_g - gallons[i] >= demand:\n            sel[i] = 0\n            total_g -= gallons[i]\n            total_p -= prices[i]\n\n    return ''.join('1' if b else '0' for b in sel)\n\n\ndef _biased_index_by_density(s: str) -> int:\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(s)\n    # Higher probability to flip items with poor value density if currently selected,\n    # or high value density if currently unselected (to encourage feasibility)\n    weights = []\n    for i in range(n):\n        dens = gallons[i] \/ prices[i]\n        if s[i] == '1':\n            w = 1.0 \/ max(1e-9, dens)\n        else:\n            w = dens\n        weights.append(max(1e-6, w))\n    total = sum(weights)\n    r = random.random() * total\n    acc = 0.0\n    for i, w in enumerate(weights):\n        acc += w\n        if acc >= r:\n            return i\n    return n - 1\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighbour solution for a binary string.\n    Returns a tuple: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type in {BIT_FLIP, TWO_BIT_FLIP, EXCHANGE}\n    Movement_Type is 'LOCAL'\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.5:\n        # Single biased bit flip\n        idx = _biased_index_by_density(solution)\n        nb = _flip_bit(solution, idx)\n        nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n    elif move_kind < 0.85:\n        # Two-bit flip (distinct indices)\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i and n > 1:\n            j = random.randrange(n)\n        s = _flip_bit(solution, i)\n        s = _flip_bit(s, j)\n        nb = _repair_feasible(s)\n        return (nb, \"TWO_BIT_FLIP\", \"LOCAL\")\n    else:\n        # 1-1 exchange: turn off one 1, turn on one 0, then repair\n        ones = [i for i,c in enumerate(solution) if c == '1']\n        zeros = [i for i,c in enumerate(solution) if c == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s = solution\n            s = _flip_bit(s, i)\n            s = _flip_bit(s, j)\n            nb = _repair_feasible(s)\n            return (nb, \"EXCHANGE\", \"LOCAL\")\n        # Fallback to single flip\n        idx = random.randrange(n)\n        nb = _repair_feasible(_flip_bit(solution, idx))\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n","Perturbacion":"import random\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n\ndef _repair_feasible(s: str) -> str:\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    n = len(s)\n    sel = [1 if c == '1' else 0 for c in s]\n    total_g = sum(gallons[i] for i in range(n) if sel[i])\n    total_p = sum(prices[i] for i in range(n) if sel[i])\n\n    if total_g < demand:\n        candidates = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 0]\n        candidates.sort()\n        for _, i in candidates:\n            sel[i] = 1\n            total_g += gallons[i]\n            total_p += prices[i]\n            if total_g >= demand:\n                break\n\n    ones = [(prices[i]\/gallons[i], i) for i in range(n) if sel[i] == 1]\n    ones.sort(reverse=True)\n    for _, i in ones:\n        if total_g - gallons[i] >= demand:\n            sel[i] = 0\n            total_g -= gallons[i]\n            total_p -= prices[i]\n\n    return ''.join('1' if b else '0' for b in sel)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [3,6]), then repair.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(3, 6))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    s = _repair_feasible(s)\n    return s\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    \"\"\"\n    Evaluate a 24-length binary string for the offer selection problem.\n    Returns total price if gallons >= demand; otherwise returns price + large static penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a neighbour for a 24-length binary string.\n    Returns a tuple: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type in {BIT_FLIP, TWO_BIT_FLIP, EXCHANGE}\n    Movement_Type is 'LOCAL'\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _totals(s: str) -> Tuple[int, int]:\n        tp = tg = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                tp += prices[i]\n                tg += gallons[i]\n        return tp, tg\n\n    def _repair_feasible(s: str) -> str:\n        # Greedy add by best price-per-gallon, then prune worst while feasible\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        # prune\n        changed = True\n        while changed:\n            changed = False\n            ones = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                # break early to re-evaluate list after a successful removal\n                if changed:\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    def _biased_index_by_density(s: str) -> int:\n        n = len(s)\n        weights = []\n        for i in range(n):\n            dens = gallons[i] \/ prices[i]\n            w = (1.0 \/ max(1e-9, dens)) if s[i] == '1' else dens\n            weights.append(max(1e-6, w))\n        total = sum(weights)\n        r = random.random() * total\n        acc = 0.0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                return i\n        return n - 1\n\n    if not _valid(solution):\n        return (solution, \"INVALID\", \"NONE\")\n\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.5:\n        # Single biased bit flip\n        idx = _biased_index_by_density(solution)\n        nb = _flip_bit(solution, idx)\n        # Repair with probability 0.7 to keep some infeasible exploration\n        if random.random() < 0.7:\n            nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n    elif move_kind < 0.85:\n        # Two-bit flip\n        if n == 1:\n            nb = _flip_bit(solution, 0)\n            if random.random() < 0.7:\n                nb = _repair_feasible(nb)\n            return (nb, \"TWO_BIT_FLIP\", \"LOCAL\")\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s = _flip_bit(solution, i)\n        s = _flip_bit(s, j)\n        if random.random() < 0.7:\n            s = _repair_feasible(s)\n        return (s, \"TWO_BIT_FLIP\", \"LOCAL\")\n    else:\n        # Exchange: turn off one 1 and turn on one 0\n        ones = [i for i, c in enumerate(solution) if c == '1']\n        zeros = [i for i, c in enumerate(solution) if c == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s = _flip_bit(solution, i)\n            s = _flip_bit(s, j)\n            if random.random() < 0.7:\n                s = _repair_feasible(s)\n            return (s, \"EXCHANGE\", \"LOCAL\")\n        # Fallback: single random flip\n        idx = random.randrange(n)\n        nb = _flip_bit(solution, idx)\n        if random.random() < 0.7:\n            nb = _repair_feasible(nb)\n        return (nb, \"BIT_FLIP\", \"LOCAL\")\n","Perturbacion":"import random\nfrom typing import Any\n\ndef perturb_solution(solution: Any):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [5,8]), then greedy repair to feasible.\n    Returns the perturbed solution string (same length as input) or the original if invalid.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _repair_feasible(s: str) -> str:\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        changed = True\n        while changed:\n            changed = False\n            ones = [(prices[i] \/ gallons[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                if changed:\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    if not _valid(solution):\n        return solution\n\n    n = len(solution)\n    k = min(n, random.randint(5, 8))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    s = _repair_feasible(s)\n    return s\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    \"\"\"\n    Evaluate a 24-length binary string for the offer selection problem.\n    Returns total price if gallons >= demand; otherwise returns price + large static penalty.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n\n    if total_gallons >= demand:\n        return float(total_price)\n\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Generate a feasible neighbour for a 24-length binary string.\n    Returns a tuple: (neighbour_solution, NB_Type, Movement_Type)\n    NB_Type in {BIT_FLIP, TWO_BIT_FLIP, EXCHANGE}\n    Movement_Type is 'LOCAL'\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _repair_feasible(s: str) -> str:\n        # Greedy add by best price-per-gallon, then prune worst while feasible\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        ratios = [prices[i] \/ gallons[i] for i in range(n)]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(ratios[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        changed = True\n        while changed:\n            changed = False\n            ones = [(ratios[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    if not _valid(solution):\n        return (solution, 'INVALID', 'LOCAL')\n\n    n = len(solution)\n    move_kind = random.random()\n\n    if move_kind < 0.5:\n        # Single biased bit flip\n        densities = [gallons[i] \/ prices[i] for i in range(n)]\n        # Prefer turning on high-density zeros and turning off low-density ones\n        weights = []\n        for i, c in enumerate(solution):\n            if c == '1':\n                w = max(1e-6, 1.0 \/ max(1e-9, densities[i]))\n            else:\n                w = max(1e-6, densities[i])\n            weights.append(w)\n        total = sum(weights)\n        r = random.random() * total\n        acc = 0.0\n        idx = n - 1\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                idx = i\n                break\n        nb = _flip_bit(solution, idx)\n        nb = _repair_feasible(nb)\n        return (nb, 'BIT_FLIP', 'LOCAL')\n    elif move_kind < 0.85:\n        # Two-bit flip\n        if n == 1:\n            nb = _flip_bit(solution, 0)\n            nb = _repair_feasible(nb)\n            return (nb, 'TWO_BIT_FLIP', 'LOCAL')\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s = _flip_bit(solution, i)\n        s = _flip_bit(s, j)\n        s = _repair_feasible(s)\n        return (s, 'TWO_BIT_FLIP', 'LOCAL')\n    else:\n        # Exchange: turn off one 1 and turn on one 0\n        ones = [i for i, c in enumerate(solution) if c == '1']\n        zeros = [i for i, c in enumerate(solution) if c == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s = _flip_bit(solution, i)\n            s = _flip_bit(s, j)\n            s = _repair_feasible(s)\n            return (s, 'EXCHANGE', 'LOCAL')\n        # Fallback: single flip\n        idx = random.randrange(n)\n        nb = _flip_bit(solution, idx)\n        nb = _repair_feasible(nb)\n        return (nb, 'BIT_FLIP', 'LOCAL')\n","Perturbacion":"import random\nfrom typing import Any\n\ndef perturb_solution(solution: Any):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits (k in [5,8]), then greedy repair to feasible.\n    Returns the perturbed solution string (same length as input) or the original if invalid.\n    \"\"\"\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    def _valid(s: str) -> bool:\n        return isinstance(s, str) and len(s) == 24 and all(c in '01' for c in s)\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('1' if s[idx] == '0' else '0') + s[idx+1:]\n\n    def _repair_feasible(s: str) -> str:\n        n = len(s)\n        sel = [1 if c == '1' else 0 for c in s]\n        ratios = [prices[i] \/ gallons[i] for i in range(n)]\n        total_g = sum(gallons[i] for i in range(n) if sel[i])\n        if total_g < demand:\n            candidates = [(ratios[i], i) for i in range(n) if sel[i] == 0]\n            candidates.sort()\n            for _, i in candidates:\n                sel[i] = 1\n                total_g += gallons[i]\n                if total_g >= demand:\n                    break\n        changed = True\n        while changed:\n            changed = False\n            ones = [(ratios[i], i) for i in range(n) if sel[i] == 1]\n            ones.sort(reverse=True)\n            for _, i in ones:\n                if total_g - gallons[i] >= demand:\n                    sel[i] = 0\n                    total_g -= gallons[i]\n                    changed = True\n                    break\n        return ''.join('1' if b else '0' for b in sel)\n\n    if not _valid(solution):\n        return solution\n\n    n = len(solution)\n    k = min(n, random.randint(5, 8))\n    idxs = random.sample(range(n), k)\n    s = solution\n    for idx in idxs:\n        s = _flip_bit(s, idx)\n    s = _repair_feasible(s)\n    return s\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, None]):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nimport math\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    def total_gallons_and_cost(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n    move_r = random.random()\n\n    if move_r < 0.4:\n        # 1-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bit\")\n    elif move_r < 0.7:\n        # 2-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        return (''.join(s), \"NB_BitFlip\", \"Move_2bit\")\n    elif move_r < 0.9:\n        # Greedy add\/remove based on ratio\n        g_now, _ = total_gallons_and_cost(s)\n        if g_now < demand:\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                best_i = min(zero_idxs, key=lambda i: ratios[i])\n                s[best_i] = '1'\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBest\")\n        else:\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                worst_i = max(one_idxs, key=lambda i: ratios[i])\n                s[worst_i] = '0'\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorst\")\n    else:\n        # Drop-Add swap: remove worst '1' and add best '0'\n        one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n        zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n        if not one_idxs or not zero_idxs:\n            return (''.join(s), \"NB_NoSwap\", \"Move_NoOp\")\n        worst_one = max(one_idxs, key=lambda i: ratios[i])\n        best_zero = min(zero_idxs, key=lambda i: ratios[i])\n        s[worst_one] = '0'\n        s[best_zero] = '1'\n        return (''.join(s), \"NB_Swap\", \"Move_DropAdd\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution: str):\n    # Multi-flip stochastic perturbation with ratio guidance and occasional swap bursts\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def current_gallons(sol_list):\n        g = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n        return g\n\n    k = random.randint(3, 6)\n    for _ in range(k):\n        g_now = current_gallons(s)\n        r = random.random()\n        if g_now < demand and r < 0.6:\n            zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n            if zero_idxs:\n                i = min(zero_idxs, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and r < 0.6:\n            one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n            if one_idxs:\n                i = max(one_idxs, key=lambda i: ratios[i])\n                s[i] = '0'\n                continue\n        # Random flip fallback\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Occasional swap burst to diversify\n    if random.random() < 0.5:\n        one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n        zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n        if one_idxs and zero_idxs:\n            t = min(2, len(one_idxs), len(zero_idxs))\n            for _ in range(t):\n                i = max(one_idxs, key=lambda i: ratios[i])\n                j = min(zero_idxs, key=lambda j: ratios[j])\n                s[i] = '0'\n                s[j] = '1'\n                one_idxs.remove(i)\n                zero_idxs.remove(j)\n\n    return ''.join(s)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    def totals(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n    move_r = random.random()\n\n    # Helper: feasibility-preserving remove if possible\n    def try_remove_worst_feasible(sol_list):\n        g_now, _ = totals(sol_list)\n        one_idxs = [i for i, ch in enumerate(sol_list) if ch == '1']\n        if not one_idxs:\n            return False\n        # Sort ones by descending ratio (worst first)\n        for i in sorted(one_idxs, key=lambda i: ratios[i], reverse=True):\n            if g_now - gallons[i] >= demand:\n                sol_list[i] = '0'\n                return True\n        return False\n\n    # Helper: greedy add best zero\n    def add_best_zero(sol_list):\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        if not zero_idxs:\n            return False\n        j = min(zero_idxs, key=lambda i: ratios[i])\n        sol_list[j] = '1'\n        return True\n\n    # Helper: greedy repair to feasibility\n    def repair_to_feasible(sol_list):\n        g_now, _ = totals(sol_list)\n        if g_now >= demand:\n            return True\n        # Greedily add best zeros until feasible or no zeros left\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        zero_idxs.sort(key=lambda i: ratios[i])\n        for i in zero_idxs:\n            sol_list[i] = '1'\n            g_now += gallons[i]\n            if g_now >= demand:\n                return True\n        return g_now >= demand\n\n    # Move selection\n    if move_r < 0.35:\n        # 1-bit flip with repair\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        if not repair_to_feasible(s):\n            # fallback force add best\n            add_best_zero(s)\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bitRepair\")\n    elif move_r < 0.6:\n        # 2-bit flip (one drop, one add) aiming to keep feasibility\n        if not try_remove_worst_feasible(s):\n            # if cannot remove feasibly, just add\n            add_best_zero(s)\n        else:\n            add_best_zero(s)\n        if not repair_to_feasible(s):\n            repair_to_feasible(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAdd1\")\n    elif move_r < 0.85:\n        # Greedy direction: if infeasible add best, else remove worst feasibly\n        g_now, _ = totals(s)\n        if g_now < demand:\n            add_best_zero(s)\n            repair_to_feasible(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBest\")\n        else:\n            # feasibility-preserving removal\n            if not try_remove_worst_feasible(s):\n                # if cannot, attempt small swap\n                one_idxs = [i for i, ch in enumerate(s) if ch == '1']\n                zero_idxs = [i for i, ch in enumerate(s) if ch == '0']\n                if one_idxs and zero_idxs:\n                    i = max(one_idxs, key=lambda i: ratios[i])\n                    j = min(zero_idxs, key=lambda j: ratios[j])\n                    s[i] = '0'\n                    s[j] = '1'\n                    if not repair_to_feasible(s):\n                        repair_to_feasible(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorstFeas\")\n    else:\n        # Drop-Add-k swap for k in {2,3,4}\n        k = min(random.randint(2, 4), s.count('1'), s.count('0'))\n        if k <= 0:\n            # Fallback random flip\n            i = random.randrange(n)\n            s[i] = '1' if s[i] == '0' else '0'\n            repair_to_feasible(s)\n            return (''.join(s), \"NB_Fallback\", \"Move_1bitRepair\")\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones.sort(key=lambda i: ratios[i], reverse=True)\n        zeros.sort(key=lambda i: ratios[i])\n        drop = ones[:k]\n        add = zeros[:k]\n        for i in drop:\n            s[i] = '0'\n        for j in add:\n            s[j] = '1'\n        repair_to_feasible(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAddK\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-flip stochastic perturbation with feasibility repair and guided swaps\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def total_g(sol_list):\n        g = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n        return g\n\n    def repair_to_feasible(sol_list):\n        g_now = total_g(sol_list)\n        if g_now >= demand:\n            return True\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        zero_idxs.sort(key=lambda i: ratios[i])\n        for i in zero_idxs:\n            sol_list[i] = '1'\n            g_now += gallons[i]\n            if g_now >= demand:\n                return True\n        return g_now >= demand\n\n    # Random burst flips with bias\n    k = random.randint(4, 8)\n    for _ in range(k):\n        r = random.random()\n        g_now = total_g(s)\n        if g_now < demand and r < 0.65:\n            # add a good zero\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                i = min(zeros, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and r < 0.65:\n            # drop a bad one if feasible\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            for i in ones:\n                if g_now - gallons[i] >= demand:\n                    s[i] = '0'\n                    g_now -= gallons[i]\n                    break\n            continue\n        # fallback random flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Swap burst diversification\n    if random.random() < 0.7:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if ones and zeros:\n            t = min(3, len(ones), len(zeros))\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            zeros.sort(key=lambda i: ratios[i])\n            for _ in range(t):\n                i = ones.pop(0)\n                j = zeros.pop(0)\n                s[i] = '0'\n                s[j] = '1'\n\n    repair_to_feasible(s)\n    return ''.join(s)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BINARY_STRING","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: BINARY_STRING of length 24, characters in {'0','1'}\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n    if not isinstance(solution, str):\n        return float('inf')\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_price = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_price += prices[i]\n            total_gallons += gallons[i]\n    if total_gallons >= demand:\n        return float(total_price)\n    deficit = demand - total_gallons\n    penalty = 1_000_000 + 1_000 * deficit\n    return float(total_price + penalty)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"NB_Invalid\", \"NoOp\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_Empty\", \"NoOp\")\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n\n    # Precompute ratios once\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def totals(sol_list):\n        g = 0\n        c = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n                c += prices[i]\n        return g, c\n\n    # Feasibility-preserving remove if possible (drop worst ratio but keep feasibility)\n    def try_remove_worst_feasible(sol_list):\n        g_now, _ = totals(sol_list)\n        one_idxs = [i for i, ch in enumerate(sol_list) if ch == '1']\n        if not one_idxs:\n            return False\n        for i in sorted(one_idxs, key=lambda i: ratios[i], reverse=True):\n            if g_now - gallons[i] >= demand:\n                sol_list[i] = '0'\n                return True\n        return False\n\n    # Greedy add the best ratio zero\n    def add_best_zero(sol_list):\n        zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n        if not zero_idxs:\n            return False\n        j = min(zero_idxs, key=lambda i: ratios[i])\n        sol_list[j] = '1'\n        return True\n\n    # Repair to feasibility by adding best zeros, then trim worst ones if possible\n    def repair_then_trim(sol_list):\n        # Repair\n        g_now, _ = totals(sol_list)\n        if g_now < demand:\n            zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zero_idxs.sort(key=lambda i: ratios[i])\n            for i in zero_idxs:\n                sol_list[i] = '1'\n                g_now += gallons[i]\n                if g_now >= demand:\n                    break\n        # Trim\n        improved = True\n        while improved:\n            improved = False\n            g_now, _ = totals(sol_list)\n            one_idxs = [i for i, ch in enumerate(sol_list) if ch == '1']\n            one_idxs.sort(key=lambda i: ratios[i], reverse=True)\n            for i in one_idxs:\n                if g_now - gallons[i] >= demand:\n                    sol_list[i] = '0'\n                    improved = True\n                    break\n        return True\n\n    move_r = random.random()\n\n    if move_r < 0.35:\n        # 1-bit flip with repair+trim\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        repair_then_trim(s)\n        return (''.join(s), \"NB_BitFlip\", \"Move_1bitRepairTrim\")\n    elif move_r < 0.6:\n        # 2-bit swap (drop worst feasibly, add best), then repair+trim\n        if not try_remove_worst_feasible(s):\n            add_best_zero(s)\n        else:\n            add_best_zero(s)\n        repair_then_trim(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAdd1\")\n    elif move_r < 0.85:\n        # Greedy direction: add best if infeasible, else remove worst feasibly\n        g_now, _ = totals(s)\n        if g_now < demand:\n            add_best_zero(s)\n            repair_then_trim(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_AddBestRepairTrim\")\n        else:\n            if not try_remove_worst_feasible(s):\n                # Small guided swap (remove worst, add best)\n                ones = [i for i, ch in enumerate(s) if ch == '1']\n                zeros = [i for i, ch in enumerate(s) if ch == '0']\n                if ones and zeros:\n                    i = max(ones, key=lambda i: ratios[i])\n                    j = min(zeros, key=lambda j: ratios[j])\n                    s[i] = '0'\n                    s[j] = '1'\n            repair_then_trim(s)\n            return (''.join(s), \"NB_Greedy\", \"Move_RemoveWorstOrSwap\")\n    else:\n        # Drop-Add-k guided swap for k in {2,3,4}\n        k = random.randint(2, 4)\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback\n            i = random.randrange(n)\n            s[i] = '1' if s[i] == '0' else '0'\n            repair_then_trim(s)\n            return (''.join(s), \"NB_Fallback\", \"Move_1bitRepairTrim\")\n        ones.sort(key=lambda i: ratios[i], reverse=True)\n        zeros.sort(key=lambda i: ratios[i])\n        k = min(k, len(ones), len(zeros))\n        for i in ones[:k]:\n            s[i] = '0'\n        for j in zeros[:k]:\n            s[j] = '1'\n        repair_then_trim(s)\n        return (''.join(s), \"NB_Swap\", \"Move_DropAddKRepairTrim\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-flip stochastic perturbation with feasibility repair and guided swaps\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    prices = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    demand = 275\n\n    s = list(solution)\n    ratios = [prices[i] \/ gallons[i] for i in range(n)]\n\n    def total_g(sol_list):\n        g = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                g += gallons[i]\n        return g\n\n    def repair_then_trim(sol_list):\n        # Repair feasibility by adding best zeros, then trim worst ones\n        g_now = total_g(sol_list)\n        if g_now < demand:\n            zero_idxs = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zero_idxs.sort(key=lambda i: ratios[i])\n            for i in zero_idxs:\n                sol_list[i] = '1'\n                g_now += gallons[i]\n                if g_now >= demand:\n                    break\n        # Trim phase\n        improved = True\n        while improved:\n            improved = False\n            g_now = total_g(sol_list)\n            one_idxs = [i for i, ch in enumerate(sol_list) if ch == '1']\n            one_idxs.sort(key=lambda i: ratios[i], reverse=True)\n            for i in one_idxs:\n                if g_now - gallons[i] >= demand:\n                    sol_list[i] = '0'\n                    improved = True\n                    break\n        return True\n\n    # Random burst flips with feasibility-aware bias\n    k = random.randint(4, 8)\n    for _ in range(k):\n        r = random.random()\n        g_now = total_g(s)\n        if g_now < demand and r < 0.65:\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                i = min(zeros, key=lambda i: ratios[i])\n                s[i] = '1'\n                continue\n        if g_now >= demand and r < 0.65:\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            for i in ones:\n                if g_now - gallons[i] >= demand:\n                    s[i] = '0'\n                    g_now -= gallons[i]\n                    break\n            continue\n        # fallback random flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Swap burst diversification (guided by ratios)\n    if random.random() < 0.7:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if ones and zeros:\n            t = min(3, len(ones), len(zeros))\n            ones.sort(key=lambda i: ratios[i], reverse=True)\n            zeros.sort(key=lambda i: ratios[i])\n            for _ in range(t):\n                i = ones.pop(0)\n                j = zeros.pop(0)\n                s[i] = '0'\n                s[j] = '1'\n\n    repair_then_trim(s)\n    return ''.join(s)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC: Python list of distinct integers in 1..24, sorted ascending. Example: [1,3,5].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Internal static data (1-indexed via offset arrays)\n    prices = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,12,9]\n    n = 24\n    # Validate input\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > n for i in idxs):\n        return 10**12\n    # Compute aggregates\n    cost = 0\n    gals = 0\n    for i in idxs:\n        cost += prices[i]\n        gals += gallons[i]\n    # Feasibility target\n    req = 275\n    if gals < req:\n        deficit = req - gals\n        # Moderated penalty to keep search gradients informative\n        base_penalty = 10000\n        per_gallon_penalty = 100.0\n        return base_penalty + per_gallon_penalty * deficit + cost\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _normalize_index_list(sol):\n    try:\n        idxs = sorted(set(int(i) for i in (sol if isinstance(sol, list) else [])))\n    except Exception:\n        idxs = []\n    # Clamp to domain 1..24\n    idxs = [i for i in idxs if 1 <= i <= 24]\n    return idxs\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    cur = _normalize_index_list(solution)\n    all_idx = list(range(1, 25))\n    move_types = [\"Toggle\", \"Swap\", \"Add\", \"Remove\", \"TwoToggle\"]\n    move = random.choice(move_types)\n    s = set(cur)\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    elif move == \"Swap\":\n        if 0 < len(s) < 24:\n            out = random.choice(tuple(s))\n            ins = random.choice(tuple(set(all_idx) - s))\n            s.remove(out)\n            s.add(ins)\n        else:\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - s)\n        if candidates:\n            s.add(random.choice(candidates))\n    elif move == \"Remove\":\n        if s:\n            s.remove(random.choice(tuple(s)))\n    else:  # TwoToggle\n        k = 2\n        for _ in range(k):\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    new_list = sorted(s)\n    return (new_list, \"Local\", move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data for repair\/prune\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price = {i: p for (i, p, g) in offers}\n    gallon = {i: g for (i, p, g) in offers}\n    cpg = {i: price[i] \/ gallon[i] for (i, p, g) in offers}\n    # Normalize\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n    s = set(cur)\n    all_idx = list(range(1, 25))\n    # Random multi-toggle shake\n    k = random.randint(3, 6)\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    # Fast feasibility repair (\u2265275 gallons)\n    def total_g(idxset):\n        return sum(gallon[i] for i in idxset)\n    req = 275\n    if total_g(s) < req:\n        remaining = sorted([i for i in all_idx if i not in s], key=lambda i: (cpg[i], price[i]))\n        for i in remaining:\n            if total_g(s) >= req:\n                break\n            s.add(i)\n    # Light pruning of worst cost-per-gallon while maintaining feasibility\n    pruned = True\n    while pruned:\n        pruned = False\n        for i in sorted(list(s), key=lambda i: (-cpg[i], price[i])):\n            if total_g(s) - gallon[i] >= req:\n                s.remove(i)\n                pruned = True\n                break\n    return sorted(s)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Static data (1-indexed with dummy 0th entry)\n    prices = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,1,17]\n    gallons = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,12,9]\n    n = 24\n    # Validate input type\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > n for i in idxs):\n        return 10**12\n    # Compute aggregates\n    cost = 0\n    gals = 0\n    for i in idxs:\n        cost += prices[i]\n        gals += gallons[i]\n    # Feasibility: require at least 275 gallons\n    req = 275\n    if gals < req:\n        return 10**9 + (req - gals)\n    return cost\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to a sorted unique index list within 1..24\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n\n    all_idx = list(range(1, 25))\n    s = set(cur)\n\n    # Adaptive, feasibility-aware move selection needs local data\n    prices = {1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons = {1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n\n    def total_g(idxset):\n        return sum(gallons[i] for i in idxset)\n\n    req = 275\n    gals = total_g(s)\n\n    move_types = []\n    if gals < req:\n        move_types = [\"Add\", \"Toggle\", \"Swap\"]\n    elif gals > req + 12:  # allow some pruning slack\n        move_types = [\"Remove\", \"Swap\", \"TwoToggle\"]\n    else:\n        move_types = [\"Swap\", \"Toggle\", \"Add\", \"Remove\"]\n\n    move = random.choice(move_types)\n\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - s)\n        if candidates:\n            # Bias by cost-per-gallon\n            cpg = {i: prices[i] \/ gallons[i] for i in candidates}\n            best = min(candidates, key=lambda i: (cpg[i], prices[i]))\n            s.add(best)\n        else:\n            # fallback\n            j = random.choice(all_idx)\n            s.add(j)\n    elif move == \"Remove\":\n        if s:\n            # Remove worst cost-per-gallon while staying within domain\n            cpg = {i: prices[i] \/ gallons[i] for i in s}\n            ordered = sorted(list(s), key=lambda i: (-cpg[i], prices[i]))\n            # Try remove while keeping at least some gallons (not strictly enforcing feasibility here)\n            s.remove(ordered[0])\n        else:\n            j = random.choice(all_idx)\n            s.add(j)\n    elif move == \"Swap\":\n        if s and len(s) < 24:\n            out = random.choice(tuple(s))\n            ins_pool = list(set(all_idx) - s)\n            # Prefer low cpg insertions\n            if ins_pool:\n                cpg_ins = {i: prices[i] \/ gallons[i] for i in ins_pool}\n                ins = min(ins_pool, key=lambda i: (cpg_ins[i], prices[i]))\n                s.remove(out)\n                s.add(ins)\n        else:\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n    else:  # TwoToggle\n        k = 2\n        for _ in range(k):\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n\n    new_list = sorted(s)\n    return (new_list, \"Local\", move)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Data\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price = {i: p for (i, p, g) in offers}\n    gallon = {i: g for (i, p, g) in offers}\n    cpg = {i: price[i] \/ gallon[i] for (i, p, g) in offers}\n\n    # Normalize input\n    try:\n        cur = sorted(set(int(i) for i in (solution if isinstance(solution, list) else [])))\n    except Exception:\n        cur = []\n    cur = [i for i in cur if 1 <= i <= 24]\n    s = set(cur)\n    all_idx = list(range(1, 25))\n\n    # Random multi-toggle shake\n    k = random.randint(4, 7)\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n\n    # Feasibility repair to reach at least 275 gallons\n    def total_g(idxset):\n        return sum(gallon[i] for i in idxset)\n\n    req = 275\n    if total_g(s) < req:\n        remaining = sorted([i for i in all_idx if i not in s], key=lambda i: (cpg[i], price[i]))\n        for i in remaining:\n            if total_g(s) >= req:\n                break\n            s.add(i)\n\n    # Prune worst ratios while keeping feasibility\n    pruned = True\n    while pruned:\n        pruned = False\n        for i in sorted(list(s), key=lambda i: (-cpg[i], price[i])):\n            if total_g(s) - gallon[i] >= req:\n                s.remove(i)\n                pruned = True\n                break\n\n    return sorted(s)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"INDEX_LIST_ASC","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Offers: (index, price, gallons)\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    # Parse\/validate input solution\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > 24 for i in idxs):\n        return 10**12\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    cost = sum(price_map[i] for i in idxs)\n    gallons = sum(gallon_map[i] for i in idxs)\n    # Feasibility: at least 275 gallons required\n    if gallons < 275:\n        return 10**9 + (275 - gallons)\n    # Feasible: objective is total cost (minimize)\n    return cost\n","Vecindad":"import math\nimport random\nfrom typing import Tuple, Dict, Any\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    prices = {1:15,2:5,3:9,4:20,5:5,6:16,7:4,8:18,9:14,10:13,11:11,12:6,13:24,14:5,15:6,16:22,17:23,18:21,19:14,20:1,21:1,22:11,23:1,24:17}\n    gallons = {1:11,2:2,3:24,4:3,5:15,6:9,7:12,8:1,9:21,10:19,11:22,12:22,13:9,14:1,15:13,16:16,17:21,18:5,19:6,20:10,21:13,22:8,23:12,24:9}\n    req = 275\n\n    def normalize(sol):\n        try:\n            cur = sorted(set(int(i) for i in (sol if isinstance(sol, list) else [])))\n        except Exception:\n            cur = []\n        return [i for i in cur if 1 <= i <= 24]\n\n    def total_g(idxset):\n        return sum(gallons[i] for i in idxset)\n\n    cur_list = normalize(solution)\n    s = set(cur_list)\n    all_idx = list(range(1, 25))\n\n    gals = total_g(s)\n    if gals < req:\n        move_pool = [\"Add\", \"Toggle\", \"Swap\"]\n    elif gals > req + 12:\n        move_pool = [\"Remove\", \"Swap\", \"Toggle\"]\n    else:\n        move_pool = [\"Swap\", \"Toggle\", \"Add\", \"Remove\"]\n\n    move = random.choice(move_pool)\n\n    if move == \"Toggle\":\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n    elif move == \"Add\":\n        candidates = list(set(all_idx) - s)\n        if candidates:\n            ins = min(candidates, key=lambda i: (prices[i] \/ gallons[i], prices[i]))\n            s.add(ins)\n    elif move == \"Remove\":\n        if s:\n            worst = max(list(s), key=lambda i: (prices[i] \/ gallons[i], prices[i]))\n            s.remove(worst)\n    else:  # Swap\n        if s and len(s) < 24:\n            out = random.choice(tuple(s))\n            ins_pool = list(set(all_idx) - s)\n            if ins_pool:\n                ins = min(ins_pool, key=lambda i: (prices[i] \/ gallons[i], prices[i]))\n                s.remove(out)\n                s.add(ins)\n        else:\n            j = random.choice(all_idx)\n            if j in s:\n                s.remove(j)\n            else:\n                s.add(j)\n\n    # Light repair toward feasibility (greedy add by best cost-per-gallon)\n    while total_g(s) < req:\n        cand = list(set(all_idx) - s)\n        if not cand:\n            break\n        ins = min(cand, key=lambda i: (prices[i] \/ gallons[i], prices[i]))\n        s.add(ins)\n\n    new_list = sorted(s)\n    meta: Dict[str, Any] = {\"nb_type\": \"Local\", \"move\": move}\n    return new_list, meta\n","Perturbacion":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    price = {i: p for (i, p, g) in offers}\n    gallon = {i: g for (i, p, g) in offers}\n    req = 275\n\n    def normalize(sol):\n        try:\n            cur = sorted(set(int(i) for i in (sol if isinstance(sol, list) else [])))\n        except Exception:\n            cur = []\n        return [i for i in cur if 1 <= i <= 24]\n\n    def gals(idxset):\n        return sum(gallon[i] for i in idxset)\n\n    s = set(normalize(solution))\n    all_idx = list(range(1, 25))\n\n    # Random multi-toggle shake\n    k = random.randint(4, 7)\n    for _ in range(k):\n        j = random.choice(all_idx)\n        if j in s:\n            s.remove(j)\n        else:\n            s.add(j)\n\n    # Repair to feasibility by greedy insertions (best cost-per-gallon)\n    while gals(s) < req:\n        remaining = list(set(all_idx) - s)\n        if not remaining:\n            break\n        best = min(remaining, key=lambda i: (price[i] \/ gallon[i], price[i]))\n        s.add(best)\n\n    # Prune worst ratios while keeping feasibility\n    improved = True\n    while improved:\n        improved = False\n        ordered = sorted(list(s), key=lambda i: (-(price[i] \/ gallon[i]), price[i]))\n        for i in ordered:\n            if gals(s) - gallon[i] >= req:\n                s.remove(i)\n                improved = True\n                break\n\n    return sorted(s)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    # validate and deduplicate\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    # infeasible: add large penalty proportional to deficit\n    deficit = 2750 - total_time\n    return 10**6 + deficit + obj\n","Vecindad":"import math\nimport random\n\n# Neighbour generator producing a concrete neighbouring solution and movement meta.\n# It performs add\/drop\/swap on a 1-based index set and repairs feasibility if needed.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    # sanitize input into a valid set within domain\n    try:\n        cur = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        cur = set()\n    cur = set(i for i in cur if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        # add items by ascending score\/time until feasible\n        tt, ts = totals(S)\n        if tt >= 2750:\n            return S\n        items = list(range(1, n+1))\n        ratio_sorted = sorted(items, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n        for i in ratio_sorted:\n            if tt >= 2750:\n                break\n            if i in S:\n                continue\n            S.add(i)\n            tt += times[i-1]\n            ts += scores[i-1]\n        # prune any redundant worst-ratio items while keeping feasibility\n        drop_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in drop_order:\n            if tt - times[i-1] >= 2750:\n                S.remove(i)\n                tt -= times[i-1]\n        return S\n\n    # if empty or infeasible, construct\/repair first\n    cur = greedy_repair(set(cur))\n\n    # choose a move type: 0=drop,1=add,2=swap\n    move = random.randint(0, 2)\n    S = set(cur)\n\n    if move == 0 and len(S) > 0:\n        # drop worst-ratio item if feasible after drop; else fall back to swap\n        worst = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        dropped = False\n        tt, ts = totals(S)\n        for j in worst:\n            if tt - times[j-1] >= 2750:\n                S.remove(j)\n                dropped = True\n                break\n        if not dropped:\n            move = 2  # fallback to swap\n    if move == 1:\n        # add best-ratio item not in S\n        candidates = [i for i in range(1, n+1) if i not in S]\n        if candidates:\n            i = min(candidates, key=lambda k: (scores[k-1]\/times[k-1], scores[k-1], -times[k-1]))\n            S.add(i)\n    if move == 2:\n        # swap: remove one (prefer higher ratio), add one (prefer lower ratio)\n        if len(S) > 0:\n            out = max(S, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n            S.remove(out)\n            candidates = [i for i in range(1, n+1) if i not in S]\n            if candidates:\n                inn = min(candidates, key=lambda k: (scores[k-1]\/times[k-1], scores[k-1], -times[k-1]))\n                S.add(inn)\n            else:\n                S.add(out)\n\n    # final feasibility repair and minor clean-up\n    S = greedy_repair(S)\n\n    neighbour = sorted(S)\n    return (neighbour, (\"LocalToggle\", \"AddDropSwap\"))\n","Perturbacion":"import math\nimport random\n\n# Ruin-and-recreate perturbation with greedy repair and clean-up, preserving feasibility.\n\ndef perturb_solution(solution):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        tt, ts = totals(S)\n        if tt >= 2750:\n            pass\n        else:\n            items = list(range(1, n+1))\n            ratio_sorted = sorted(items, key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n            for i in ratio_sorted:\n                if tt >= 2750:\n                    break\n                if i in S:\n                    continue\n                S.add(i)\n                tt += times[i-1]\n                ts += scores[i-1]\n        # clean-up: drop redundant worst-ratio items while feasible\n        drop_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in drop_order:\n            if tt - times[i-1] >= 2750:\n                S.remove(i)\n                tt -= times[i-1]\n        return S\n\n    # Ensure starting point feasible\n    S = greedy_repair(S)\n\n    # Ruin: remove k items biased to worst ratios\n    k_min, k_max = 3, 6\n    k = random.randint(k_min, k_max)\n    if len(S) > 0:\n        remove_order = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n        for i in remove_order[:min(k, len(remove_order))]:\n            S.discard(i)\n\n    # Recreate: greedy add by best ratio, then diversify with a few random toggles\n    S = greedy_repair(S)\n\n    # Diversification toggles (safe drops or beneficial adds followed by repair)\n    toggles = random.randint(1, 3)\n    for _ in range(toggles):\n        if random.random() < 0.5 and len(S) > 0:\n            # attempt safe drop\n            tt, ts = totals(S)\n            droplist = sorted(list(S), key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]), reverse=True)\n            for j in droplist:\n                if tt - times[j-1] >= 2750:\n                    S.remove(j)\n                    break\n        else:\n            # add a random candidate with decent ratio\n            candidates = [i for i in range(1, n+1) if i not in S]\n            if candidates:\n                # bias toward better ratios\n                candidates.sort(key=lambda i: (scores[i-1]\/times[i-1], scores[i-1], -times[i-1]))\n                pick = candidates[min(len(candidates)-1, random.randint(0, max(0, len(candidates)\/\/4)))]\n                S.add(pick)\n        S = greedy_repair(S)\n\n    return sorted(S)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices (set semantics; duplicates ignored)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= T:\n        return total_score\n    deficit = T - total_time\n    return 10**6 + deficit + total_score\n","Vecindad":"import math\nimport random\n\n# Neighbour generator with add\/drop\/swap and limited k-exchanges.\n# Always returns a feasible solution via greedy repair and safe-drop clean-up.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n\n    # sanitize input\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    # Greedy repair: add by (score asc, time desc) to reach feasibility\n    def greedy_repair(S):\n        tt, _ = totals(S)\n        if tt >= T:\n            return S\n        cand = [i for i in range(1, n+1) if i not in S]\n        cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n        for i in cand:\n            if tt >= T:\n                break\n            S.add(i)\n            tt += times[i-1]\n        return S\n\n    # Safe-drop clean-up: repeatedly remove any removable item with max score\n    def safe_drop_cleanup(S):\n        changed = True\n        while changed:\n            changed = False\n            tt, _ = totals(S)\n            removable = [i for i in S if tt - times[i-1] >= T]\n            if not removable:\n                break\n            # drop the one with highest score; tie-break by smaller time to enable further drops\n            i = max(removable, key=lambda k: (scores[k-1], -times[k-1]))\n            S.remove(i)\n            changed = True\n        return S\n\n    # Ensure feasibility before neighborhood moves\n    S = greedy_repair(set(S))\n    S = safe_drop_cleanup(S)\n\n    # Precomputed orders\n    best_add_order = [i for i in range(1, n+1) if i not in S]\n    best_add_order.sort(key=lambda i: (scores[i-1], -times[i-1]))\n    worst_drop_order = sorted(list(S), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)\n\n    move_type = \"AddDropSwap\"\n    move = random.randint(0, 4)  # 0=drop,1=add,2=swap,3=2-swap,4=1-2 or 2-1\n    R = set(S)\n\n    if move == 0 and len(R) > 0:\n        # Try dropping highest-score item while staying feasible; else fallback\n        tt, _ = totals(R)\n        dropped = False\n        for j in worst_drop_order:\n            if tt - times[j-1] >= T:\n                R.remove(j)\n                dropped = True\n                break\n        if not dropped:\n            move = 2\n    if move == 1:\n        # Add best (score asc, time desc)\n        if best_add_order:\n            R.add(best_add_order[0])\n    if move == 2:\n        # 1-1 swap: remove a higher-score item, add a lower-score candidate\n        if len(R) > 0:\n            out = max(R, key=lambda i: (scores[i-1], -times[i-1]))\n            R.remove(out)\n            candidates = [i for i in range(1, n+1) if i not in R]\n            if candidates:\n                inn = min(candidates, key=lambda k: (scores[k-1], -times[k-1]))\n                R.add(inn)\n            else:\n                R.add(out)\n    if move == 3:\n        # 2-swap: remove up to 2 high-score items and add up to 2 low-score items\n        outs = sorted(list(R), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)[:2]\n        for o in outs:\n            R.discard(o)\n        candidates = [i for i in range(1, n+1) if i not in R]\n        candidates.sort(key=lambda i: (scores[i-1], -times[i-1]))\n        for inn in candidates[:2]:\n            R.add(inn)\n    if move == 4:\n        # 1-2 or 2-1 exchange chosen randomly\n        if random.random() < 0.5 and len(R) >= 1:\n            # 1-2: remove 1 high-score, add 2 low-score\n            out = max(R, key=lambda i: (scores[i-1], -times[i-1]))\n            R.remove(out)\n            cand = [i for i in range(1, n+1) if i not in R]\n            cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n            for inn in cand[:2]:\n                R.add(inn)\n        else:\n            # 2-1: remove 2 high-score, add 1 low-score\n            outs = sorted(list(R), key=lambda i: (scores[i-1], -times[i-1]), reverse=True)[:2]\n            for o in outs:\n                R.discard(o)\n            cand = [i for i in range(1, n+1) if i not in R]\n            if cand:\n                inn = min(cand, key=lambda i: (scores[i-1], -times[i-1]))\n                R.add(inn)\n\n    # Final repair and clean-up\n    R = greedy_repair(R)\n    R = safe_drop_cleanup(R)\n\n    neighbour = sorted(R)\n    return (neighbour, (\"LocalToggle\", move_type))\n","Perturbacion":"import math\nimport random\n\n# Ruin-and-repair perturbation: remove a block biased by (score\/time) density and repair.\n\ndef perturb_solution(solution):\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    def totals(S):\n        tt = 0; ts = 0\n        for i in S:\n            tt += times[i-1]\n            ts += scores[i-1]\n        return tt, ts\n\n    def greedy_repair(S):\n        tt, _ = totals(S)\n        if tt < T:\n            cand = [i for i in range(1, n+1) if i not in S]\n            cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n            for i in cand:\n                if tt >= T:\n                    break\n                S.add(i)\n                tt += times[i-1]\n        # safe-drop loop: drop removable items with highest score first\n        changed = True\n        while changed:\n            changed = False\n            tt, _ = totals(S)\n            removable = [i for i in S if tt - times[i-1] >= T]\n            if not removable:\n                break\n            i = max(removable, key=lambda k: (scores[k-1], -times[k-1]))\n            S.remove(i)\n            changed = True\n        return S\n\n    # Ensure feasibility\n    S = greedy_repair(S)\n\n    # Determine ruin size by covering ~15%-30% of time or 3..6 items\n    tt, _ = totals(S)\n    target_cover = max(int(0.15 * T), 300)\n    k_min, k_max = 3, 6\n\n    # Order by density (score\/time) descending for removal bias\n    order = sorted(list(S), key=lambda i: (scores[i-1]\/max(1, times[i-1]), scores[i-1], -times[i-1]), reverse=True)\n\n    removed = 0\n    covered = 0\n    R = set(S)\n    for i in order:\n        if removed >= k_max and covered >= target_cover:\n            break\n        R.discard(i)\n        removed += 1\n        covered += times[i-1]\n        if removed >= k_min and covered >= target_cover:\n            break\n\n    # Random toggles for diversification\n    toggles = random.randint(1, 3)\n    for _ in range(toggles):\n        if random.random() < 0.5 and len(R) > 0:\n            # attempt safe drop\n            tt2, _ = totals(R)\n            droplist = [i for i in R if tt2 - times[i-1] >= T]\n            if droplist:\n                j = max(droplist, key=lambda k: (scores[k-1], -times[k-1]))\n                R.discard(j)\n        else:\n            # biased add\n            cand = [i for i in range(1, n+1) if i not in R]\n            if cand:\n                cand.sort(key=lambda i: (scores[i-1], -times[i-1]))\n                pick = cand[min(len(cand)-1, random.randint(0, max(0, len(cand)\/\/4)))]\n                R.add(pick)\n\n    R = greedy_repair(R)\n    return sorted(R)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"PY_LIST_INT_1BASED_SET_SEMANTICS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # solution: list of 1-based indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n    if not isinstance(solution, list):\n        return 10**9\n    try:\n        idx_set = set(int(x) for x in solution)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= T:\n        return total_score\n    deficit = T - total_time\n    return 10**6 + deficit + total_score\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Exact global optimizer via 0\/1 knapsack DP on time to minimize score with time >= T.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n    sumT = sum(times)\n    INF = 10**9\n    # dp[i][t] = min score using first i items to reach time exactly t\n    dp = [[INF]*(sumT+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    for i in range(1, n+1):\n        ti = times[i-1]\n        si = scores[i-1]\n        row_prev = dp[i-1]\n        row_cur = dp[i]\n        for tt in range(sumT+1):\n            # not take\n            if row_prev[tt] < row_cur[tt]:\n                row_cur[tt] = row_prev[tt]\n            # take\n            if tt >= ti:\n                val = row_prev[tt - ti] + si\n                if val < row_cur[tt]:\n                    row_cur[tt] = val\n    # choose best feasible time >= T\n    best_score = INF\n    best_time = -1\n    last = dp[n]\n    for tt in range(T, sumT+1):\n        if last[tt] < best_score:\n            best_score = last[tt]\n            best_time = tt\n    # reconstruct indices (1-based)\n    res = []\n    tt = best_time\n    i = n\n    while i > 0 and tt >= 0:\n        if dp[i][tt] == dp[i-1][tt]:\n            i -= 1\n        else:\n            res.append(i)\n            tt -= times[i-1]\n            i -= 1\n    res.sort()\n    return (res, (\"ExactDP\", \"Global\"))\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Returns a diversified-but-optimized solution: apply small random toggles then exact DP repair to global optimum.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    T = 2750\n    n = len(scores)\n\n    # sanitize\n    try:\n        S = set(int(x) for x in (solution if isinstance(solution, list) else []))\n    except Exception:\n        S = set()\n    S = set(i for i in S if 1 <= i <= n)\n\n    # light random toggles\n    k = random.randint(1, 4)\n    for _ in range(k):\n        if random.random() < 0.5 and len(S) > 0:\n            S.discard(random.choice(tuple(S)))\n        else:\n            cand = [i for i in range(1, n+1) if i not in S]\n            if cand:\n                S.add(random.choice(cand))\n\n    # exact DP optimization to ensure feasibility with minimal score\n    sumT = sum(times)\n    INF = 10**9\n    dp = [[INF]*(sumT+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    for i in range(1, n+1):\n        ti = times[i-1]\n        si = scores[i-1]\n        row_prev = dp[i-1]\n        row_cur = dp[i]\n        for tt in range(sumT+1):\n            if row_prev[tt] < row_cur[tt]:\n                row_cur[tt] = row_prev[tt]\n            if tt >= ti:\n                val = row_prev[tt - ti] + si\n                if val < row_cur[tt]:\n                    row_cur[tt] = val\n    best_score = INF\n    best_time = -1\n    last = dp[n]\n    for tt in range(T, sumT+1):\n        if last[tt] < best_score:\n            best_score = last[tt]\n            best_time = tt\n    res = []\n    tt = best_time\n    i = n\n    while i > 0 and tt >= 0:\n        if dp[i][tt] == dp[i-1][tt]:\n            i -= 1\n        else:\n            res.append(i)\n            tt -= times[i-1]\n            i -= 1\n    res.sort()\n    return res\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"INDEX_LIST_STR_COMMA_SEPARATED_1BASED","Evaluacion":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution):\n    # Accepts either a list of 1-based indices or a comma-separated string of indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    idx_list = parse_solution(solution)\n    if not isinstance(idx_list, list):\n        return 10**9\n    # validate and deduplicate within range\n    try:\n        idx_set: Set[int] = set(int(x) for x in idx_list)\n    except Exception:\n        return 10**9\n    if any((i < 1 or i > n) for i in idx_set):\n        return 10**9\n    total_time = 0\n    for i in idx_set:\n        total_time += times[i-1]\n    obj = 0\n    for i in idx_set:\n        obj += scores[i-1]\n    if total_time >= 2750:\n        return obj\n    # Calibrated penalty to preserve neighborhood sensitivity\n    mean_time = sum(times) \/ len(times)\n    deficit = 2750 - total_time\n    penalty = 10000 * math.ceil(deficit \/ max(1, int(mean_time)))\n    return penalty + obj\n","Vecindad":"import math\nimport random\nfrom typing import List, Set, Tuple\n\ndef generate_neighbour(solution):\n    # Representation: comma-separated string of 1-based indices.\n    # Returns (new_solution_str, \"NB_SET\", movement_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset: Set[int]) -> int:\n        return sum(times[i-1] for i in idxset)\n\n    def total_score(idxset: Set[int]) -> int:\n        return sum(scores[i-1] for i in idxset)\n\n    def greedy_cover() -> Set[int]:\n        # Build an initial feasible set by descending time\/score ratio\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n        sel: Set[int] = set()\n        T = 0\n        for i in items:\n            if T >= 2750:\n                break\n            sel.add(i)\n            T += times[i-1]\n        return sel\n\n    def prune_best_improvement(idxset: Set[int]) -> Set[int]:\n        # Iteratively remove the single item whose removal keeps feasibility and yields the largest score decrease.\n        changed = True\n        while changed:\n            changed = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in list(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                changed = True\n        return idxset\n\n    def pairwise_prune(idxset: Set[int]) -> Set[int]:\n        # Try one round of best pair removal for additional improvement\n        T = total_time(idxset)\n        if T < 2750:\n            return idxset\n        items = list(idxset)\n        best_pair = None\n        best_gain = 0\n        m = len(items)\n        for a in range(m):\n            i = items[a]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - times[i-1] - times[j-1] >= 2750:\n                    gain = scores[i-1] + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    def repair(idxset: Set[int]) -> Set[int]:\n        # Ensure feasibility and reduce score\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        idxset = prune_best_improvement(idxset)\n        idxset = pairwise_prune(idxset)\n        return idxset\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n\n    if len(base) == 0:\n        base = greedy_cover()\n        base = repair(base)\n        return serialize_solution(list(base)), \"NB_SET\", \"seed\"\n\n    move_type = random.choice([\"add\", \"remove\", \"swap\", \"dropadd\", \"two_swap\"])\n\n    if move_type == \"add\":\n        candidates = [i for i in range(1, n+1) if i not in base]\n        if candidates:\n            i = random.choice(candidates)\n            base.add(i)\n    elif move_type == \"remove\":\n        rem = [i for i in base]\n        if len(rem) > 0:\n            i = random.choice(rem)\n            base.remove(i)\n    elif move_type == \"swap\":\n        if len(base) >= 1:\n            out_i = random.choice(list(base))\n            base.remove(out_i)\n            candidates = [i for i in range(1, n+1) if i not in base]\n            if candidates:\n                in_i = random.choice(candidates)\n                base.add(in_i)\n            else:\n                base.add(out_i)\n                move_type = \"remove\"\n    elif move_type == \"dropadd\":\n        # Drop the worst ratio item, add best ratio outside\n        if base:\n            worst = max(base, key=lambda i: (scores[i-1] \/ times[i-1]))\n            base.remove(worst)\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            best = max(outside, key=lambda i: (times[i-1] \/ scores[i-1]))\n            base.add(best)\n    else:  # two_swap\n        if len(base) >= 2:\n            outs = random.sample(list(base), 2)\n            for o in outs:\n                base.remove(o)\n            outside = [i for i in range(1, n+1) if i not in base]\n            random.shuffle(outside)\n            for i in outside[:2]:\n                base.add(i)\n\n    base = repair(base)\n    return serialize_solution(list(base)), \"NB_SET\", move_type\n","Perturbacion":"import math\nimport random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong shake: random removals\/additions followed by greedy repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()':\n                s = s.replace(ch, ' ')\n            parts = [p for p in s.replace('\\n',' ').replace('\\t',' ').split(',')]\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    return []\n            return out\n        return []\n\n    def serialize_solution(idxs: List[int]) -> str:\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset: Set[int]) -> int:\n        return sum(times[i-1] for i in idxset)\n\n    def repair(idxset: Set[int]) -> Set[int]:\n        # Add phase to reach feasibility\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ scores[i-1]), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        # Greedy prune best-improvement, then one pass of pairwise prune\n        # Best single removal loop\n        changed = True\n        while changed:\n            changed = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in list(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                changed = True\n        # Pairwise prune single pass\n        T = total_time(idxset)\n        items = list(idxset)\n        m = len(items)\n        best_pair = None\n        best_gain = 0\n        for a in range(m):\n            i = items[a]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - times[i-1] - times[j-1] >= 2750:\n                    gain = scores[i-1] + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    idx_list = parse_solution(solution)\n    base: Set[int] = set(int(x) for x in idx_list if 1 <= int(x) <= n)\n\n    # Randomly remove k items and add up to k random new items, then repair\n    k = max(1, len(base)\/\/3) if len(base) > 0 else 4\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(list(base)))\n    # Add up to k random items not in base\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    base = repair(base)\n    return serialize_solution(list(base))\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"Comma-separated string of unique 1-based indices (e.g., \"3,5,7\"). Order ignored; duplicates removed during parsing\/validation.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Accepts either a list of 1-based indices or a comma-separated string of indices\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        # Returns list[int] robustly; never raises; empty if unparseable\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    idx_list = parse_solution(solution)\n    # validate and clamp to range, deduplicate\n    idx_set = set(i for i in idx_list if 1 <= int(i) <= n)\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= 2750:\n        return total_score\n    # Smooth penalty: lambda ~= max_i (score_i\/time_i)\n    lam = max(scores[i]\/times[i] for i in range(n))\n    deficit = 2750 - total_time\n    penalty = 1_000_000 + lam * deficit\n    return penalty + total_score\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, \"NB_SET\", movement_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def total_score(idxset):\n        return sum(scores[i-1] for i in idxset)\n\n    def greedy_cover():\n        items = list(range(1, n+1))\n        items.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n        sel = set()\n        T = 0\n        for i in items:\n            if T >= 2750:\n                break\n            sel.add(i)\n            T += times[i-1]\n        return sel\n\n    def prune_single(idxset):\n        # Remove best-improvement singles until no improvement feasible\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise_iter(idxset, max_rounds=5):\n        rounds = 0\n        while rounds < max_rounds:\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            items = list(idxset)\n            m = len(items)\n            best_pair = None\n            best_gain = 0\n            for a in range(m):\n                i = items[a]\n                ti = times[i-1]\n                si = scores[i-1]\n                for b in range(a+1, m):\n                    j = items[b]\n                    if T - ti - times[j-1] >= 2750:\n                        gain = si + scores[j-1]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_pair = (i, j)\n            if best_pair is None:\n                break\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n            rounds += 1\n        return idxset\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T >= 2750:\n            return idxset\n        # Greedy add by best time\/score\n        remaining = [i for i in range(1, n+1) if i not in idxset]\n        remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n        for i in remaining:\n            idxset.add(i)\n            T += times[i-1]\n            if T >= 2750:\n                break\n        return idxset\n\n    def repair(idxset):\n        idxset = augment_to_feasible(idxset)\n        idxset = prune_single(idxset)\n        idxset = prune_pairwise_iter(idxset, max_rounds=8)\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n    if len(base) == 0:\n        base = greedy_cover()\n        base = repair(base)\n        return serialize_solution(list(base)), \"NB_SET\", \"seed\"\n\n    # Informed move selection\n    T = total_time(base)\n    if T < 2750:\n        move_space = [\"add\", \"dropadd\", \"swap\"]\n    else:\n        move_space = [\"remove\", \"swap\", \"two_swap\", \"dropadd\"]\n    move_type = random.choice(move_space)\n\n    if move_type == \"add\":\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            # pick best marginal time\/score\n            i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(i)\n    elif move_type == \"remove\":\n        if base:\n            # remove worst time\/score\n            i = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(i)\n    elif move_type == \"swap\":\n        if base:\n            out_i = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(out_i)\n            outside = [i for i in range(1, n+1) if i not in base]\n            if outside:\n                in_i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n                base.add(in_i)\n            else:\n                base.add(out_i)\n    elif move_type == \"two_swap\":\n        if len(base) >= 2:\n            outs = sorted(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))[:2]\n            for o in outs:\n                base.remove(o)\n            outside = [i for i in range(1, n+1) if i not in base]\n            outside.sort(key=lambda k: (times[k-1] \/ max(1, scores[k-1])), reverse=True)\n            for i in outside[:2]:\n                base.add(i)\n    else:  # dropadd\n        if base:\n            worst = min(base, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.remove(worst)\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            best = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(best)\n\n    base = repair(base)\n    return serialize_solution(list(base)), \"NB_SET\", move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong shake followed by repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        return idxset\n\n    def prune_single(idxset):\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = 0\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise(idxset):\n        T = total_time(idxset)\n        items = list(idxset)\n        m = len(items)\n        best_pair = None\n        best_gain = 0\n        for a in range(m):\n            i = items[a]\n            ti = times[i-1]\n            si = scores[i-1]\n            for b in range(a+1, m):\n                j = items[b]\n                if T - ti - times[j-1] >= 2750:\n                    gain = si + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n\n    k = max(1, len(base)\/\/3) if len(base) > 0 else 4\n    # Random removals\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(tuple(base)))\n    # Random additions\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    # Repair\n    base = augment_to_feasible(base)\n    base = prune_single(base)\n    base = prune_pairwise(base)\n\n    return serialize_solution(list(base))\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"Comma-separated string of unique 1-based indices in ascending order, e.g., \"1,3,5\". Order ignored by evaluation; duplicates removed during parsing.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Accepts list[int] or comma-separated string; returns integer fitness (lower is better)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    idx_set = set(i for i in parse_solution(solution) if 1 <= int(i) <= n)\n    total_time = 0\n    total_score = 0\n    for i in idx_set:\n        total_time += times[i-1]\n        total_score += scores[i-1]\n    if total_time >= 2750:\n        return int(total_score)\n    # infeasible: strong integer penalty proportional to deficit with integer lambda\n    deficit = 2750 - total_time\n    lam_num = 0\n    for i in range(n):\n        # ceil(scores[i]\/times[i]) without floats\n        a = scores[i]\n        b = max(1, times[i])\n        lam = (a + b - 1) \/\/ b\n        if lam > lam_num:\n            lam_num = lam\n    penalty = 1_000_000 + lam_num * deficit\n    return int(penalty + total_score)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, move_type)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def total_score(idxset):\n        return sum(scores[i-1] for i in idxset)\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T >= 2750:\n            return idxset\n        remaining = [i for i in range(1, n+1) if i not in idxset]\n        remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n        for i in remaining:\n            idxset.add(i)\n            T += times[i-1]\n            if T >= 2750:\n                break\n        return idxset\n\n    def prune_single(idxset):\n        # Iteratively remove the highest-score item that keeps feasibility\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = -1\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise(idxset):\n        # Best-improvement pair removal while keeping feasibility\n        while True:\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            items = list(idxset)\n            m = len(items)\n            best_pair = None\n            best_gain = 0\n            for a in range(m):\n                i = items[a]\n                ti = times[i-1]\n                si = scores[i-1]\n                for b in range(a+1, m):\n                    j = items[b]\n                    tj = times[j-1]\n                    if T - ti - tj >= 2750:\n                        gain = si + scores[j-1]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_pair = (i, j)\n            if best_pair is None:\n                break\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    def repair(idxset):\n        idxset = augment_to_feasible(idxset)\n        idxset = prune_single(idxset)\n        idxset = prune_pairwise(idxset)\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n\n    if len(base) == 0:\n        # Greedy low-score to reach feasibility\n        order = list(range(1, n+1))\n        order.sort(key=lambda i: (scores[i-1] \/ max(1, times[i-1])))\n        T = 0\n        for i in order:\n            if T >= 2750:\n                break\n            base.add(i)\n            T += times[i-1]\n        base = repair(base)\n        return serialize_solution(base), \"seed\"\n\n    T = total_time(base)\n    move_space = []\n    if T < 2750:\n        move_space = [\"add\", \"dropadd\", \"swap\"]\n    else:\n        move_space = [\"best_remove\", \"swap\", \"two_swap\", \"dropadd\"]\n    move_type = random.choice(move_space)\n\n    if move_type == \"add\":\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(i)\n    elif move_type == \"best_remove\":\n        # remove a single item only if feasibility is preserved; pick highest score\n        T0 = total_time(base)\n        candidate = None\n        best_gain = -1\n        for i in base:\n            if T0 - times[i-1] >= 2750:\n                if scores[i-1] > best_gain:\n                    best_gain = scores[i-1]\n                    candidate = i\n        if candidate is not None:\n            base.remove(candidate)\n    elif move_type == \"swap\":\n        if base:\n            out_i = max(base, key=lambda k: scores[k-1])  # try to drop high-score\n            base.remove(out_i)\n            outside = [i for i in range(1, n+1) if i not in base]\n            if outside:\n                in_i = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n                base.add(in_i)\n            else:\n                base.add(out_i)\n    elif move_type == \"two_swap\":\n        if len(base) >= 2:\n            outs = sorted(base, key=lambda k: scores[k-1], reverse=True)[:2]\n            for o in outs:\n                base.remove(o)\n            outside = [i for i in range(1, n+1) if i not in base]\n            outside.sort(key=lambda k: (times[k-1] \/ max(1, scores[k-1])), reverse=True)\n            for i in outside[:2]:\n                base.add(i)\n    else:  # dropadd\n        if base:\n            worst = max(base, key=lambda k: scores[k-1])\n            base.remove(worst)\n        outside = [i for i in range(1, n+1) if i not in base]\n        if outside:\n            best = max(outside, key=lambda k: (times[k-1] \/ max(1, scores[k-1])))\n            base.add(best)\n\n    base = repair(base)\n    return serialize_solution(base), move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong random shake followed by repair; returns comma-separated string\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = len(scores)\n\n    def parse_solution(sol):\n        if isinstance(sol, list):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except Exception:\n                    continue\n            return out\n        if isinstance(sol, str):\n            s = sol.strip()\n            for ch in '[]{}()\\n\\t':\n                s = s.replace(ch, ' ')\n            parts = s.split(',')\n            out = []\n            for p in parts:\n                p = p.strip()\n                if p == '':\n                    continue\n                try:\n                    out.append(int(p))\n                except Exception:\n                    continue\n            return out\n        return []\n\n    def serialize_solution(idxs):\n        uniq = sorted(set(int(x) for x in idxs if 1 <= int(x) <= n))\n        return \",\".join(str(x) for x in uniq)\n\n    def total_time(idxset):\n        return sum(times[i-1] for i in idxset)\n\n    def augment_to_feasible(idxset):\n        T = total_time(idxset)\n        if T < 2750:\n            remaining = [i for i in range(1, n+1) if i not in idxset]\n            remaining.sort(key=lambda i: (times[i-1] \/ max(1, scores[i-1])), reverse=True)\n            for i in remaining:\n                idxset.add(i)\n                T += times[i-1]\n                if T >= 2750:\n                    break\n        return idxset\n\n    def prune_single(idxset):\n        improved = True\n        while improved:\n            improved = False\n            T = total_time(idxset)\n            if T < 2750:\n                break\n            best_gain = -1\n            best_i = None\n            for i in tuple(idxset):\n                if T - times[i-1] >= 2750:\n                    gain = scores[i-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_i = i\n            if best_i is not None:\n                idxset.remove(best_i)\n                improved = True\n        return idxset\n\n    def prune_pairwise(idxset):\n        T = total_time(idxset)\n        items = list(idxset)\n        m = len(items)\n        best_pair = None\n        best_gain = 0\n        for a in range(m):\n            i = items[a]\n            ti = times[i-1]\n            si = scores[i-1]\n            for b in range(a+1, m):\n                j = items[b]\n                tj = times[j-1]\n                if T - ti - tj >= 2750:\n                    gain = si + scores[j-1]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (i, j)\n        if best_pair is not None:\n            idxset.remove(best_pair[0])\n            idxset.remove(best_pair[1])\n        return idxset\n\n    base = set(int(x) for x in parse_solution(solution) if 1 <= int(x) <= n)\n\n    # Shake: random removals and additions\n    k = max(2, max(1, len(base)\/\/3)) if len(base) > 0 else 5\n    for _ in range(k):\n        if base:\n            base.remove(random.choice(tuple(base)))\n    candidates = [i for i in range(1, n+1) if i not in base]\n    random.shuffle(candidates)\n    for i in candidates[:k]:\n        base.add(i)\n\n    # Repair to a feasible, pruned solution\n    base = augment_to_feasible(base)\n    base = prune_single(base)\n    base = prune_pairwise(base)\n\n    return serialize_solution(base)\n","Version":2}
