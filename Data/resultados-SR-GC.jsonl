{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k. Encoding: solution is a list of 9 positive integers [c1,...,c9] where ci is color of vertex i and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Base objective\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_description)\n    # Safe copy and validate minimal structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        # produce a simple valid seed neighbor\n        base = [1]*9\n        return (base, \"seed\")\n    nbr = list(solution)\n    # Determine current k\n    k = 1\n    for x in nbr:\n        if x > k:\n            k = x\n    # Choose a random vertex to recolor\n    idx = random.randrange(9)\n    # With small probability, allow exploring k+1 to escape local minima\n    allow_new = (random.random() < 0.2)\n    max_color = k + 1 if allow_new else k\n    # Choose a color different from current\n    current = nbr[idx]\n    if max_color == 1:\n        new_color = 1\n    else:\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        new_color = random.choice(choices)\n    nbr[idx] = new_color\n    # Normalize labels to keep them contiguous starting at 1\n    # Relabel according to first-appearance order\n    mapping = {}\n    next_label = 1\n    for x in nbr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    for i in range(9):\n        nbr[i] = mapping[nbr[i]]\n    return (nbr, \"recolor-normalize\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: apply several recolors and a random color compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,1,1,1,1,1,1,1,1]\n    s = list(solution)\n    # Determine current k\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    steps = 3 + random.randrange(3)  # 3..5 random recolors\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Sometimes allow k+1 to diversify\n        allow_new = (random.random() < 0.3)\n        max_color = k + 1 if allow_new else k\n        current = s[idx]\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        s[idx] = random.choice(choices)\n        # Update k lazily\n        if s[idx] > k:\n            k = s[idx]\n    # Normalize labels to contiguous 1..k' via sorted order to stabilize\n    unique = sorted(set(s))\n    mapping = {c:i+1 for i,c in enumerate(unique)}\n    for i in range(9):\n        s[i] = mapping[s[i]]\n    return s\n","Resultados":[[1,2,3,4,2,3,4,4,3],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001152012}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k. Encoding: solution is a list of 9 positive integers [c1,...,c9] where ci is color of vertex i and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Base objective\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_description)\n    # Safe copy and validate minimal structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        # produce a simple valid seed neighbor\n        base = [1]*9\n        return (base, \"seed\")\n    nbr = list(solution)\n    # Determine current k\n    k = 1\n    for x in nbr:\n        if x > k:\n            k = x\n    # Choose a random vertex to recolor\n    idx = random.randrange(9)\n    # With small probability, allow exploring k+1 to escape local minima\n    allow_new = (random.random() < 0.2)\n    max_color = k + 1 if allow_new else k\n    # Choose a color different from current\n    current = nbr[idx]\n    if max_color == 1:\n        new_color = 1\n    else:\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        new_color = random.choice(choices)\n    nbr[idx] = new_color\n    # Normalize labels to keep them contiguous starting at 1\n    # Relabel according to first-appearance order\n    mapping = {}\n    next_label = 1\n    for x in nbr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    for i in range(9):\n        nbr[i] = mapping[nbr[i]]\n    return (nbr, \"recolor-normalize\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: apply several recolors and a random color compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,1,1,1,1,1,1,1,1]\n    s = list(solution)\n    # Determine current k\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    steps = 3 + random.randrange(3)  # 3..5 random recolors\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Sometimes allow k+1 to diversify\n        allow_new = (random.random() < 0.3)\n        max_color = k + 1 if allow_new else k\n        current = s[idx]\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        s[idx] = random.choice(choices)\n        # Update k lazily\n        if s[idx] > k:\n            k = s[idx]\n    # Normalize labels to contiguous 1..k' via sorted order to stabilize\n    unique = sorted(set(s))\n    mapping = {c:i+1 for i,c in enumerate(unique)}\n    for i in range(9):\n        s[i] = mapping[s[i]]\n    return s\n","Resultados":[[1,2,3,1,2,3,2,1,4],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000910679}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k. Encoding: solution is a list of 9 positive integers [c1,...,c9] where ci is color of vertex i and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Base objective\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_description)\n    # Safe copy and validate minimal structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        # produce a simple valid seed neighbor\n        base = [1]*9\n        return (base, \"seed\")\n    nbr = list(solution)\n    # Determine current k\n    k = 1\n    for x in nbr:\n        if x > k:\n            k = x\n    # Choose a random vertex to recolor\n    idx = random.randrange(9)\n    # With small probability, allow exploring k+1 to escape local minima\n    allow_new = (random.random() < 0.2)\n    max_color = k + 1 if allow_new else k\n    # Choose a color different from current\n    current = nbr[idx]\n    if max_color == 1:\n        new_color = 1\n    else:\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        new_color = random.choice(choices)\n    nbr[idx] = new_color\n    # Normalize labels to keep them contiguous starting at 1\n    # Relabel according to first-appearance order\n    mapping = {}\n    next_label = 1\n    for x in nbr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    for i in range(9):\n        nbr[i] = mapping[nbr[i]]\n    return (nbr, \"recolor-normalize\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: apply several recolors and a random color compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,1,1,1,1,1,1,1,1]\n    s = list(solution)\n    # Determine current k\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    steps = 3 + random.randrange(3)  # 3..5 random recolors\n    for _ in range(steps):\n        idx = random.randrange(9)\n        # Sometimes allow k+1 to diversify\n        allow_new = (random.random() < 0.3)\n        max_color = k + 1 if allow_new else k\n        current = s[idx]\n        choices = list(range(1, max_color+1))\n        if current in choices and len(choices) > 1:\n            choices.remove(current)\n        s[idx] = random.choice(choices)\n        # Update k lazily\n        if s[idx] > k:\n            k = s[idx]\n    # Normalize labels to contiguous 1..k' via sorted order to stabilize\n    unique = sorted(set(s))\n    mapping = {c:i+1 for i,c in enumerate(unique)}\n    for i in range(9):\n        s[i] = mapping[s[i]]\n    return s\n","Resultados":[[1,2,3,1,2,3,2,1,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000855949}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is a Python list [c1,...,c9] with ci in positive integers and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and k\n    try:\n        k = 0\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n            if x > k:\n                k = x\n    except Exception:\n        return float(HARD_PEN)\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    used = set(solution)\n    if len(used) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in used:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-guided min-conflicts recolor; occasional exploration to k+1\n    # If input invalid, return a robust DSATUR seed\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        # degrees for tie-breaking\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            # compute saturation: number of distinct neighbor colors\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            # pick uncolored vertex with max saturation, break ties by degree\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            # smallest feasible color starting from 1\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        # normalize (already contiguous 1..used_colors)\n        return colors\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    k = max(s) if s else 1\n\n    # Identify conflicting vertices\n    conflicting_vertices = [u for u in range(1, 10) if any(s[u-1] == s[v-1] for v in adj[u])]\n    if conflicting_vertices and random.random() < 0.6:\n        u = random.choice(conflicting_vertices)\n        move_type = \"conflict-minconf\"\n    else:\n        u = random.randint(1, 9)\n        move_type = \"random-minconf\"\n\n    allow_new = (random.random() < 0.05)\n    max_color = k + (1 if allow_new else 0)\n    cur = s[u-1]\n\n    bestc = None\n    best_cost = 10**9\n    for c in range(1, max_color+1):\n        if c == cur and max_color > 1:\n            continue\n        cost = 0\n        for v in adj[u]:\n            if s[v-1] == c:\n                cost += 1\n        if cost < best_cost:\n            best_cost = cost\n            bestc = c\n    if bestc is None:\n        bestc = cur\n    s[u-1] = bestc\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n        move_type += \"-norm\"\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex kick focusing on high-conflict vertices; normalization if gaps\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return [1,2,3,1,2,3,2,1,3]\n    if any(x < 1 for x in s):\n        return [1,2,3,1,2,3,2,1,3]\n\n    n = 9\n    k = max(s)\n\n    # Compute conflict counts per vertex\n    conf = [0]*(n+1)\n    for u in range(1, n+1):\n        cu = s[u-1]\n        for v in adj[u]:\n            if v > u and s[v-1] == cu:\n                conf[u] += 1\n                conf[v] += 1\n\n    # Select up to m most conflicting vertices\n    m = 3 + random.randrange(3)  # 3..5\n    order = list(range(1, n+1))\n    order.sort(key=lambda u: conf[u], reverse=True)\n    idxs = order[:m]\n\n    # Recolor each selected vertex with min-conflicts among 1..k and sometimes k+1\n    for u in idxs:\n        allow_new = (random.random() < 0.25)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = None\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = 0\n            for v in adj[u]:\n                if s[v-1] == c:\n                    cost += 1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        if bestc is None:\n            bestc = cur\n        s[u-1] = bestc\n        if s[u-1] > k:\n            k = s[u-1]\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n\n    return s\n","Resultados":[[2,1,3,1,2,3,1,1,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00199187}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is a Python list [c1,...,c9] with ci in positive integers and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and k\n    try:\n        k = 0\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n            if x > k:\n                k = x\n    except Exception:\n        return float(HARD_PEN)\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    used = set(solution)\n    if len(used) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in used:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-guided min-conflicts recolor; occasional exploration to k+1\n    # If input invalid, return a robust DSATUR seed\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        # degrees for tie-breaking\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            # compute saturation: number of distinct neighbor colors\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            # pick uncolored vertex with max saturation, break ties by degree\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            # smallest feasible color starting from 1\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        # normalize (already contiguous 1..used_colors)\n        return colors\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    k = max(s) if s else 1\n\n    # Identify conflicting vertices\n    conflicting_vertices = [u for u in range(1, 10) if any(s[u-1] == s[v-1] for v in adj[u])]\n    if conflicting_vertices and random.random() < 0.6:\n        u = random.choice(conflicting_vertices)\n        move_type = \"conflict-minconf\"\n    else:\n        u = random.randint(1, 9)\n        move_type = \"random-minconf\"\n\n    allow_new = (random.random() < 0.05)\n    max_color = k + (1 if allow_new else 0)\n    cur = s[u-1]\n\n    bestc = None\n    best_cost = 10**9\n    for c in range(1, max_color+1):\n        if c == cur and max_color > 1:\n            continue\n        cost = 0\n        for v in adj[u]:\n            if s[v-1] == c:\n                cost += 1\n        if cost < best_cost:\n            best_cost = cost\n            bestc = c\n    if bestc is None:\n        bestc = cur\n    s[u-1] = bestc\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n        move_type += \"-norm\"\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex kick focusing on high-conflict vertices; normalization if gaps\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return [1,2,3,1,2,3,2,1,3]\n    if any(x < 1 for x in s):\n        return [1,2,3,1,2,3,2,1,3]\n\n    n = 9\n    k = max(s)\n\n    # Compute conflict counts per vertex\n    conf = [0]*(n+1)\n    for u in range(1, n+1):\n        cu = s[u-1]\n        for v in adj[u]:\n            if v > u and s[v-1] == cu:\n                conf[u] += 1\n                conf[v] += 1\n\n    # Select up to m most conflicting vertices\n    m = 3 + random.randrange(3)  # 3..5\n    order = list(range(1, n+1))\n    order.sort(key=lambda u: conf[u], reverse=True)\n    idxs = order[:m]\n\n    # Recolor each selected vertex with min-conflicts among 1..k and sometimes k+1\n    for u in idxs:\n        allow_new = (random.random() < 0.25)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = None\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = 0\n            for v in adj[u]:\n                if s[v-1] == c:\n                    cost += 1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        if bestc is None:\n            bestc = cur\n        s[u-1] = bestc\n        if s[u-1] > k:\n            k = s[u-1]\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n\n    return s\n","Resultados":[[4,1,1,2,4,3,2,1,3],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001704448}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is a Python list [c1,...,c9] with ci in positive integers and labels must be exactly {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower-is-better fitness: k + penalties (gap, edge conflicts, malformed)\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and k\n    try:\n        k = 0\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n            if x > k:\n                k = x\n    except Exception:\n        return float(HARD_PEN)\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity check\n    used = set(solution)\n    if len(used) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in used:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-guided min-conflicts recolor; occasional exploration to k+1\n    # If input invalid, return a robust DSATUR seed\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        # degrees for tie-breaking\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            # compute saturation: number of distinct neighbor colors\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            # pick uncolored vertex with max saturation, break ties by degree\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            # smallest feasible color starting from 1\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        # normalize (already contiguous 1..used_colors)\n        return colors\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    k = max(s) if s else 1\n\n    # Identify conflicting vertices\n    conflicting_vertices = [u for u in range(1, 10) if any(s[u-1] == s[v-1] for v in adj[u])]\n    if conflicting_vertices and random.random() < 0.6:\n        u = random.choice(conflicting_vertices)\n        move_type = \"conflict-minconf\"\n    else:\n        u = random.randint(1, 9)\n        move_type = \"random-minconf\"\n\n    allow_new = (random.random() < 0.05)\n    max_color = k + (1 if allow_new else 0)\n    cur = s[u-1]\n\n    bestc = None\n    best_cost = 10**9\n    for c in range(1, max_color+1):\n        if c == cur and max_color > 1:\n            continue\n        cost = 0\n        for v in adj[u]:\n            if s[v-1] == c:\n                cost += 1\n        if cost < best_cost:\n            best_cost = cost\n            bestc = c\n    if bestc is None:\n        bestc = cur\n    s[u-1] = bestc\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n        move_type += \"-norm\"\n\n    return (s, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex kick focusing on high-conflict vertices; normalization if gaps\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return [1,2,3,1,2,3,2,1,3]\n    if any(x < 1 for x in s):\n        return [1,2,3,1,2,3,2,1,3]\n\n    n = 9\n    k = max(s)\n\n    # Compute conflict counts per vertex\n    conf = [0]*(n+1)\n    for u in range(1, n+1):\n        cu = s[u-1]\n        for v in adj[u]:\n            if v > u and s[v-1] == cu:\n                conf[u] += 1\n                conf[v] += 1\n\n    # Select up to m most conflicting vertices\n    m = 3 + random.randrange(3)  # 3..5\n    order = list(range(1, n+1))\n    order.sort(key=lambda u: conf[u], reverse=True)\n    idxs = order[:m]\n\n    # Recolor each selected vertex with min-conflicts among 1..k and sometimes k+1\n    for u in idxs:\n        allow_new = (random.random() < 0.25)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = None\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = 0\n            for v in adj[u]:\n                if s[v-1] == c:\n                    cost += 1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        if bestc is None:\n            bestc = cur\n        s[u-1] = bestc\n        if s[u-1] > k:\n            k = s[u-1]\n\n    # Normalize only if gaps exist\n    used = sorted(set(s))\n    if used != list(range(1, max(s)+1)):\n        remap = {c: i+1 for i, c in enumerate(used)}\n        s = [remap[c] for c in s]\n\n    return s\n","Resultados":[[1,2,2,4,1,3,4,4,3],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001641936}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is [c1,...,c9] with ci>=1 integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return colors\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    n = 9\n    k = max(s) if s else 1\n\n    def conflict_count_of_color(u, c, arr):\n        cnt = 0\n        for v in adj[u]:\n            if arr[v-1] == c:\n                cnt += 1\n        return cnt\n\n    move_choice = random.random()\n\n    # 1) Conflict-guided single-vertex min-conflicts recolor (with occasional k+1)\n    if move_choice < 0.5:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if any(s[u-1] == s[v-1] for v in adj[u])]\n        if conflicting_vertices and random.random() < 0.7:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            u = random.randint(1, n)\n            move_type = \"random-minconf\"\n        allow_new = (random.random() < 0.05)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            # Align with evaluator: conflicts dominate; slight bias against introducing a new color\n            if c > k:\n                cost += 0.1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        return (s, move_type)\n\n    # 2) Kempe-chain style color-pair swap along a connected component of colors (a,b)\n    if move_choice < 0.8:\n        if k == 1:\n            return (s, \"noop\")\n        a, b = random.sample(range(1, k+1), 2)\n        # Pick a seed vertex having color a or b\n        candidates = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if not candidates:\n            return (s, \"noop\")\n        seed = random.choice(candidates)\n        # BFS in subgraph induced by colors {a,b}\n        comp = []\n        seen = set()\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            if s[u-1] not in (a, b):\n                continue\n            seen.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if s[v-1] in (a, b) and v not in seen:\n                    stack.append(v)\n        # Swap colors within this component\n        for u in comp:\n            s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n        return (s, f\"kempe-swap-{a}-{b}\")\n\n    # 3) Global color label swap (exploration, keeps conflicts unchanged but helps search symmetry)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        return (s, f\"label-swap-{a}-{b}\")\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback seed if invalid input\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    n = 9\n    s = s[:]\n    k = max(s) if s else 1\n\n    # Color elimination: choose least-used color and try to recolor its vertices into remaining colors\n    cnt = Counter(s)\n    tgt = min(cnt, key=cnt.get)\n    verts = [i+1 for i,c in enumerate(s) if c == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            if conf < bestconf:\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = random.choice(remaining) if remaining else s[u-1]\n        s[u-1] = bestc\n\n    # Optional single Kempe-chain swap between two non-target colors to diversify\n    if k >= 2 and len(remaining) >= 2 and random.random() < 0.8:\n        a, b = random.sample(remaining, 2)\n        # Trigger only if there is visible tension in both color classes\n        tension_a = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == a)\n        tension_b = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == b)\n        if tension_a or tension_b:\n            # Swap a<->b across entire graph (simple Kempe move variant)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n\n    # Normalize contiguity to {1..k'} to avoid label gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":[[3,2,1,2,3,1,2,2,1],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002431715}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is [c1,...,c9] with ci>=1 integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return colors\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    n = 9\n    k = max(s) if s else 1\n\n    def conflict_count_of_color(u, c, arr):\n        cnt = 0\n        for v in adj[u]:\n            if arr[v-1] == c:\n                cnt += 1\n        return cnt\n\n    move_choice = random.random()\n\n    # 1) Conflict-guided single-vertex min-conflicts recolor (with occasional k+1)\n    if move_choice < 0.5:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if any(s[u-1] == s[v-1] for v in adj[u])]\n        if conflicting_vertices and random.random() < 0.7:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            u = random.randint(1, n)\n            move_type = \"random-minconf\"\n        allow_new = (random.random() < 0.05)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            # Align with evaluator: conflicts dominate; slight bias against introducing a new color\n            if c > k:\n                cost += 0.1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        return (s, move_type)\n\n    # 2) Kempe-chain style color-pair swap along a connected component of colors (a,b)\n    if move_choice < 0.8:\n        if k == 1:\n            return (s, \"noop\")\n        a, b = random.sample(range(1, k+1), 2)\n        # Pick a seed vertex having color a or b\n        candidates = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if not candidates:\n            return (s, \"noop\")\n        seed = random.choice(candidates)\n        # BFS in subgraph induced by colors {a,b}\n        comp = []\n        seen = set()\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            if s[u-1] not in (a, b):\n                continue\n            seen.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if s[v-1] in (a, b) and v not in seen:\n                    stack.append(v)\n        # Swap colors within this component\n        for u in comp:\n            s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n        return (s, f\"kempe-swap-{a}-{b}\")\n\n    # 3) Global color label swap (exploration, keeps conflicts unchanged but helps search symmetry)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        return (s, f\"label-swap-{a}-{b}\")\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback seed if invalid input\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    n = 9\n    s = s[:]\n    k = max(s) if s else 1\n\n    # Color elimination: choose least-used color and try to recolor its vertices into remaining colors\n    cnt = Counter(s)\n    tgt = min(cnt, key=cnt.get)\n    verts = [i+1 for i,c in enumerate(s) if c == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            if conf < bestconf:\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = random.choice(remaining) if remaining else s[u-1]\n        s[u-1] = bestc\n\n    # Optional single Kempe-chain swap between two non-target colors to diversify\n    if k >= 2 and len(remaining) >= 2 and random.random() < 0.8:\n        a, b = random.sample(remaining, 2)\n        # Trigger only if there is visible tension in both color classes\n        tension_a = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == a)\n        tension_b = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == b)\n        if tension_a or tension_b:\n            # Swap a<->b across entire graph (simple Kempe move variant)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n\n    # Normalize contiguity to {1..k'} to avoid label gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":[[3,1,4,1,2,4,2,3,4],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00195756}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k; solution is [c1,...,c9] with ci>=1 integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return colors\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    n = 9\n    k = max(s) if s else 1\n\n    def conflict_count_of_color(u, c, arr):\n        cnt = 0\n        for v in adj[u]:\n            if arr[v-1] == c:\n                cnt += 1\n        return cnt\n\n    move_choice = random.random()\n\n    # 1) Conflict-guided single-vertex min-conflicts recolor (with occasional k+1)\n    if move_choice < 0.5:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if any(s[u-1] == s[v-1] for v in adj[u])]\n        if conflicting_vertices and random.random() < 0.7:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            u = random.randint(1, n)\n            move_type = \"random-minconf\"\n        allow_new = (random.random() < 0.05)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            # Align with evaluator: conflicts dominate; slight bias against introducing a new color\n            if c > k:\n                cost += 0.1\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        return (s, move_type)\n\n    # 2) Kempe-chain style color-pair swap along a connected component of colors (a,b)\n    if move_choice < 0.8:\n        if k == 1:\n            return (s, \"noop\")\n        a, b = random.sample(range(1, k+1), 2)\n        # Pick a seed vertex having color a or b\n        candidates = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if not candidates:\n            return (s, \"noop\")\n        seed = random.choice(candidates)\n        # BFS in subgraph induced by colors {a,b}\n        comp = []\n        seen = set()\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            if u in seen:\n                continue\n            if s[u-1] not in (a, b):\n                continue\n            seen.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if s[v-1] in (a, b) and v not in seen:\n                    stack.append(v)\n        # Swap colors within this component\n        for u in comp:\n            s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n        return (s, f\"kempe-swap-{a}-{b}\")\n\n    # 3) Global color label swap (exploration, keeps conflicts unchanged but helps search symmetry)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        return (s, f\"label-swap-{a}-{b}\")\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    # Fallback seed if invalid input\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    n = 9\n    s = s[:]\n    k = max(s) if s else 1\n\n    # Color elimination: choose least-used color and try to recolor its vertices into remaining colors\n    cnt = Counter(s)\n    tgt = min(cnt, key=cnt.get)\n    verts = [i+1 for i,c in enumerate(s) if c == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            if conf < bestconf:\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = random.choice(remaining) if remaining else s[u-1]\n        s[u-1] = bestc\n\n    # Optional single Kempe-chain swap between two non-target colors to diversify\n    if k >= 2 and len(remaining) >= 2 and random.random() < 0.8:\n        a, b = random.sample(remaining, 2)\n        # Trigger only if there is visible tension in both color classes\n        tension_a = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == a)\n        tension_b = any(any(s[v-1] == s[u-1] for v in adj[u]) for u in range(1, n+1) if s[u-1] == b)\n        if tension_a or tension_b:\n            # Swap a<->b across entire graph (simple Kempe move variant)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n\n    # Normalize contiguity to {1..k'} to avoid label gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n    return s\n","Resultados":[[4,2,1,3,2,1,3,3,1],4.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001796938}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k: solution is [c1,...,c9] with ci in positive integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return normalize_colors(colors)\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    def conflicts_of_vertex(u, arr):\n        c = arr[u-1]\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    def conflict_count_of_color(u, c, arr):\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    # Move selection probabilities tuned to prioritize conflict \/ k reduction\n    r = random.random()\n\n    # A) Targeted k-reduction: attempt to eliminate least-used color via local recolor + small Kempe chain\n    if r < 0.35 and k >= 2:\n        cnt = Counter(s)\n        a = min(cnt, key=cnt.get)\n        remaining = [c for c in range(1, k+1) if c != a]\n        verts = [u for u in range(1, n+1) if s[u-1] == a]\n        # Greedy recolor vertices of color a\n        for u in verts:\n            bestc = None\n            bestconf = 10**9\n            for c in remaining:\n                conf = conflict_count_of_color(u, c, s)\n                if conf < bestconf:\n                    bestconf = conf\n                    bestc = c\n            if bestc is None:\n                bestc = remaining[0]\n            s[u-1] = bestc\n        # Light Kempe swap between two remaining colors to reduce conflicts\n        if len(remaining) >= 2:\n            b1, b2 = random.sample(remaining, 2)\n            # Build component in subgraph induced by {b1,b2}\n            seed_candidates = [u for u in range(1, n+1) if s[u-1] in (b1, b2)]\n            if seed_candidates:\n                seed = random.choice(seed_candidates)\n                comp = []\n                seen = set([seed])\n                stack = [seed]\n                while stack:\n                    u = stack.pop()\n                    if s[u-1] not in (b1, b2):\n                        continue\n                    comp.append(u)\n                    for v in adj[u]:\n                        if v not in seen and s[v-1] in (b1, b2):\n                            seen.add(v)\n                            stack.append(v)\n                for u in comp:\n                    s[u-1] = b1 if s[u-1] == b2 else (b2 if s[u-1] == b1 else s[u-1])\n        s = normalize_colors(s)\n        return (s, \"k-reduce-greedy-kempe\")\n\n    # B) Conflict-guided single-vertex min-conflicts recolor (allow new color with tiny prob)\n    if r < 0.8:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if conflicts_of_vertex(u, s) > 0]\n        if conflicting_vertices and random.random() < 0.8:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            # pick high-saturation vertex\n            sat = []\n            for u in range(1, n+1):\n                neigh_cols = {s[v-1] for v in adj[u]}\n                sat.append((len(neigh_cols), u))\n            u = max(sat)[1]\n            move_type = \"sat-minconf\"\n        allow_new = (random.random() < 0.03)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            if c > k:\n                cost += 0.2  # slight bias against opening a new color\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        s = normalize_colors(s)\n        return (s, move_type)\n\n    # C) Ejection chain: move a vertex to best alternative and iteratively fix one induced conflict neighbor\n    if r < 0.95:\n        u0 = random.randint(1, n)\n        cur = s[u0-1]\n        # choose best alternative color minimizing conflicts\n        cand = [(conflict_count_of_color(u0, c, s), c) for c in range(1, k+1) if c != cur]\n        if not cand:\n            return (s, \"noop\")\n        cand.sort()\n        newc = cand[0][1]\n        s[u0-1] = newc\n        # cascade: pick one neighbor that now conflicts and recolor it greedily (one step)\n        conflicted = [v for v in adj[u0] if s[v-1] == newc]\n        if conflicted:\n            v = random.choice(conflicted)\n            bestc = s[v-1]\n            bestcost = 10**9\n            for c in range(1, k+1):\n                if c == s[v-1]:\n                    continue\n                cost = conflict_count_of_color(v, c, s)\n                if cost < bestcost:\n                    bestcost = cost\n                    bestc = c\n            s[v-1] = bestc\n        s = normalize_colors(s)\n        return (s, \"ejection-1step\")\n\n    # D) Rare global label swap (symmetry handling)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        s = normalize_colors(s)\n        return (s, f\"label-swap-{a}-{b}\")\n\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    # Deterministic RNG seed derived from solution to ensure reproducibility across runs\n    seed = 1469598103934665603\n    for x in s:\n        seed ^= (x + 0x9e3779b97f4a7c15) & ((1<<64)-1)\n        seed = (seed * 1099511628211) & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Focused k-elimination kick: choose least-used color; if tie, use deterministic tie-break\n    cnt = Counter(s)\n    least_count = min(cnt.values())\n    candidates = [c for c,v in cnt.items() if v == least_count]\n    tgt = sorted(candidates)[0]\n    verts = [u for u in range(1, n+1) if s[u-1] == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n    if not remaining:\n        return s\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    # Recolor all vertices of target color to best available colors\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        # deterministic scan order with slight randomized tie-break from seeded rng\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            score = (conf, rng.random())\n            if conf < bestconf or (conf == bestconf and rng.random() < 0.5):\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = remaining[0]\n        s[u-1] = bestc\n\n    # Optional one Kempe-style swap among remaining colors to diversify (deterministic rng)\n    if len(remaining) >= 2 and rng.random() < 0.85:\n        a, b = rng.sample(remaining, 2)\n        seed_vertices = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if seed_vertices:\n            seed_u = rng.choice(seed_vertices)\n            comp = []\n            seen = set([seed_u])\n            stack = [seed_u]\n            while stack:\n                u = stack.pop()\n                if s[u-1] not in (a, b):\n                    continue\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in seen and s[v-1] in (a, b):\n                        seen.add(v)\n                        stack.append(v)\n            for u in comp:\n                s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n\n    # Normalize labels to keep contiguity\n    s = normalize_colors(s)\n    return s\n","Resultados":[[3,2,1,3,2,1,2,3,1],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.003267963}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k: solution is [c1,...,c9] with ci in positive integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return normalize_colors(colors)\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    def conflicts_of_vertex(u, arr):\n        c = arr[u-1]\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    def conflict_count_of_color(u, c, arr):\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    # Move selection probabilities tuned to prioritize conflict \/ k reduction\n    r = random.random()\n\n    # A) Targeted k-reduction: attempt to eliminate least-used color via local recolor + small Kempe chain\n    if r < 0.35 and k >= 2:\n        cnt = Counter(s)\n        a = min(cnt, key=cnt.get)\n        remaining = [c for c in range(1, k+1) if c != a]\n        verts = [u for u in range(1, n+1) if s[u-1] == a]\n        # Greedy recolor vertices of color a\n        for u in verts:\n            bestc = None\n            bestconf = 10**9\n            for c in remaining:\n                conf = conflict_count_of_color(u, c, s)\n                if conf < bestconf:\n                    bestconf = conf\n                    bestc = c\n            if bestc is None:\n                bestc = remaining[0]\n            s[u-1] = bestc\n        # Light Kempe swap between two remaining colors to reduce conflicts\n        if len(remaining) >= 2:\n            b1, b2 = random.sample(remaining, 2)\n            # Build component in subgraph induced by {b1,b2}\n            seed_candidates = [u for u in range(1, n+1) if s[u-1] in (b1, b2)]\n            if seed_candidates:\n                seed = random.choice(seed_candidates)\n                comp = []\n                seen = set([seed])\n                stack = [seed]\n                while stack:\n                    u = stack.pop()\n                    if s[u-1] not in (b1, b2):\n                        continue\n                    comp.append(u)\n                    for v in adj[u]:\n                        if v not in seen and s[v-1] in (b1, b2):\n                            seen.add(v)\n                            stack.append(v)\n                for u in comp:\n                    s[u-1] = b1 if s[u-1] == b2 else (b2 if s[u-1] == b1 else s[u-1])\n        s = normalize_colors(s)\n        return (s, \"k-reduce-greedy-kempe\")\n\n    # B) Conflict-guided single-vertex min-conflicts recolor (allow new color with tiny prob)\n    if r < 0.8:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if conflicts_of_vertex(u, s) > 0]\n        if conflicting_vertices and random.random() < 0.8:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            # pick high-saturation vertex\n            sat = []\n            for u in range(1, n+1):\n                neigh_cols = {s[v-1] for v in adj[u]}\n                sat.append((len(neigh_cols), u))\n            u = max(sat)[1]\n            move_type = \"sat-minconf\"\n        allow_new = (random.random() < 0.03)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            if c > k:\n                cost += 0.2  # slight bias against opening a new color\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        s = normalize_colors(s)\n        return (s, move_type)\n\n    # C) Ejection chain: move a vertex to best alternative and iteratively fix one induced conflict neighbor\n    if r < 0.95:\n        u0 = random.randint(1, n)\n        cur = s[u0-1]\n        # choose best alternative color minimizing conflicts\n        cand = [(conflict_count_of_color(u0, c, s), c) for c in range(1, k+1) if c != cur]\n        if not cand:\n            return (s, \"noop\")\n        cand.sort()\n        newc = cand[0][1]\n        s[u0-1] = newc\n        # cascade: pick one neighbor that now conflicts and recolor it greedily (one step)\n        conflicted = [v for v in adj[u0] if s[v-1] == newc]\n        if conflicted:\n            v = random.choice(conflicted)\n            bestc = s[v-1]\n            bestcost = 10**9\n            for c in range(1, k+1):\n                if c == s[v-1]:\n                    continue\n                cost = conflict_count_of_color(v, c, s)\n                if cost < bestcost:\n                    bestcost = cost\n                    bestc = c\n            s[v-1] = bestc\n        s = normalize_colors(s)\n        return (s, \"ejection-1step\")\n\n    # D) Rare global label swap (symmetry handling)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        s = normalize_colors(s)\n        return (s, f\"label-swap-{a}-{b}\")\n\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    # Deterministic RNG seed derived from solution to ensure reproducibility across runs\n    seed = 1469598103934665603\n    for x in s:\n        seed ^= (x + 0x9e3779b97f4a7c15) & ((1<<64)-1)\n        seed = (seed * 1099511628211) & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Focused k-elimination kick: choose least-used color; if tie, use deterministic tie-break\n    cnt = Counter(s)\n    least_count = min(cnt.values())\n    candidates = [c for c,v in cnt.items() if v == least_count]\n    tgt = sorted(candidates)[0]\n    verts = [u for u in range(1, n+1) if s[u-1] == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n    if not remaining:\n        return s\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    # Recolor all vertices of target color to best available colors\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        # deterministic scan order with slight randomized tie-break from seeded rng\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            score = (conf, rng.random())\n            if conf < bestconf or (conf == bestconf and rng.random() < 0.5):\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = remaining[0]\n        s[u-1] = bestc\n\n    # Optional one Kempe-style swap among remaining colors to diversify (deterministic rng)\n    if len(remaining) >= 2 and rng.random() < 0.85:\n        a, b = rng.sample(remaining, 2)\n        seed_vertices = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if seed_vertices:\n            seed_u = rng.choice(seed_vertices)\n            comp = []\n            seen = set([seed_u])\n            stack = [seed_u]\n            while stack:\n                u = stack.pop()\n                if s[u-1] not in (a, b):\n                    continue\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in seen and s[v-1] in (a, b):\n                        seen.add(v)\n                        stack.append(v)\n            for u in comp:\n                s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n\n    # Normalize labels to keep contiguity\n    s = normalize_colors(s)\n    return s\n","Resultados":[[3,2,1,3,2,1,2,3,1],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003312074}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLOR_LABELS_1..k: solution is [c1,...,c9] with ci in positive integers; labels must be exactly {1,...,k}.","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph encoded internally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Structural checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Type and value checks\n    s = []\n    try:\n        for x in solution:\n            if isinstance(x, bool):\n                return float(HARD_PEN)\n            xi = int(x)\n            if xi != x:\n                return float(HARD_PEN)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n    if not s:\n        return float(HARD_PEN)\n    k = max(s)\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    used = set(s)\n    for t in range(1, k+1):\n        if t not in used:\n            fitness += PEN_GAP\n            break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        degrees = [0] + [len(adj[u]) for u in range(1, n+1)]\n        used_colors = 0\n        colored = set()\n        while len(colored) < n:\n            sat = [0]*(n+1)\n            neigh_colors = [set() for _ in range(n+1)]\n            for u in range(1, n+1):\n                if colors[u-1] != 0:\n                    continue\n                for v in adj[u]:\n                    if colors[v-1] != 0:\n                        neigh_colors[u].add(colors[v-1])\n                sat[u] = len(neigh_colors[u])\n            cand = [u for u in range(1, n+1) if colors[u-1] == 0]\n            u = max(cand, key=lambda x: (sat[x], degrees[x]))\n            c = 1\n            while c in neigh_colors[u]:\n                c += 1\n            colors[u-1] = c\n            if c > used_colors:\n                used_colors = c\n            colored.add(u)\n        return normalize_colors(colors)\n\n    # Validate and coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (dsatur_seed(), \"seed-dsatur\")\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (dsatur_seed(), \"seed-dsatur\")\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return (dsatur_seed(), \"seed-dsatur\")\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    def conflicts_of_vertex(u, arr):\n        c = arr[u-1]\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    def conflict_count_of_color(u, c, arr):\n        return sum(1 for v in adj[u] if arr[v-1] == c)\n\n    # Move selection probabilities tuned to prioritize conflict \/ k reduction\n    r = random.random()\n\n    # A) Targeted k-reduction: attempt to eliminate least-used color via local recolor + small Kempe chain\n    if r < 0.35 and k >= 2:\n        cnt = Counter(s)\n        a = min(cnt, key=cnt.get)\n        remaining = [c for c in range(1, k+1) if c != a]\n        verts = [u for u in range(1, n+1) if s[u-1] == a]\n        # Greedy recolor vertices of color a\n        for u in verts:\n            bestc = None\n            bestconf = 10**9\n            for c in remaining:\n                conf = conflict_count_of_color(u, c, s)\n                if conf < bestconf:\n                    bestconf = conf\n                    bestc = c\n            if bestc is None:\n                bestc = remaining[0]\n            s[u-1] = bestc\n        # Light Kempe swap between two remaining colors to reduce conflicts\n        if len(remaining) >= 2:\n            b1, b2 = random.sample(remaining, 2)\n            # Build component in subgraph induced by {b1,b2}\n            seed_candidates = [u for u in range(1, n+1) if s[u-1] in (b1, b2)]\n            if seed_candidates:\n                seed = random.choice(seed_candidates)\n                comp = []\n                seen = set([seed])\n                stack = [seed]\n                while stack:\n                    u = stack.pop()\n                    if s[u-1] not in (b1, b2):\n                        continue\n                    comp.append(u)\n                    for v in adj[u]:\n                        if v not in seen and s[v-1] in (b1, b2):\n                            seen.add(v)\n                            stack.append(v)\n                for u in comp:\n                    s[u-1] = b1 if s[u-1] == b2 else (b2 if s[u-1] == b1 else s[u-1])\n        s = normalize_colors(s)\n        return (s, \"k-reduce-greedy-kempe\")\n\n    # B) Conflict-guided single-vertex min-conflicts recolor (allow new color with tiny prob)\n    if r < 0.8:\n        # Identify conflicting vertices\n        conflicting_vertices = [u for u in range(1, n+1) if conflicts_of_vertex(u, s) > 0]\n        if conflicting_vertices and random.random() < 0.8:\n            u = random.choice(conflicting_vertices)\n            move_type = \"conflict-minconf\"\n        else:\n            # pick high-saturation vertex\n            sat = []\n            for u in range(1, n+1):\n                neigh_cols = {s[v-1] for v in adj[u]}\n                sat.append((len(neigh_cols), u))\n            u = max(sat)[1]\n            move_type = \"sat-minconf\"\n        allow_new = (random.random() < 0.03)\n        max_color = k + (1 if allow_new else 0)\n        cur = s[u-1]\n        bestc = cur\n        best_cost = 10**9\n        for c in range(1, max_color+1):\n            if c == cur and max_color > 1:\n                continue\n            cost = conflict_count_of_color(u, c, s)\n            if c > k:\n                cost += 0.2  # slight bias against opening a new color\n            if cost < best_cost:\n                best_cost = cost\n                bestc = c\n        s[u-1] = bestc\n        s = normalize_colors(s)\n        return (s, move_type)\n\n    # C) Ejection chain: move a vertex to best alternative and iteratively fix one induced conflict neighbor\n    if r < 0.95:\n        u0 = random.randint(1, n)\n        cur = s[u0-1]\n        # choose best alternative color minimizing conflicts\n        cand = [(conflict_count_of_color(u0, c, s), c) for c in range(1, k+1) if c != cur]\n        if not cand:\n            return (s, \"noop\")\n        cand.sort()\n        newc = cand[0][1]\n        s[u0-1] = newc\n        # cascade: pick one neighbor that now conflicts and recolor it greedily (one step)\n        conflicted = [v for v in adj[u0] if s[v-1] == newc]\n        if conflicted:\n            v = random.choice(conflicted)\n            bestc = s[v-1]\n            bestcost = 10**9\n            for c in range(1, k+1):\n                if c == s[v-1]:\n                    continue\n                cost = conflict_count_of_color(v, c, s)\n                if cost < bestcost:\n                    bestcost = cost\n                    bestc = c\n            s[v-1] = bestc\n        s = normalize_colors(s)\n        return (s, \"ejection-1step\")\n\n    # D) Rare global label swap (symmetry handling)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n        s = normalize_colors(s)\n        return (s, f\"label-swap-{a}-{b}\")\n\n    return (s, \"noop\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import Counter\n\n    # Adjacency (1-indexed helper, ignore index 0)\n    adj = [\n        [],\n        [2,3,7,9],  # 1\n        [1,6,9],    # 2\n        [1,4,5,7],  # 3\n        [3,5,6],    # 4\n        [3,4,6,8],  # 5\n        [2,4,5,7,8],# 6\n        [1,3,6,9],  # 7\n        [5,6,9],    # 8\n        [1,2,7,8]   # 9\n    ]\n\n    def normalize_colors(arr):\n        used = sorted(set(arr))\n        remap = {c: i+1 for i, c in enumerate(used)}\n        return [remap[c] for c in arr]\n\n    def fallback():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return fallback()\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return fallback()\n    if any(isinstance(x, bool) or x < 1 for x in s):\n        return fallback()\n\n    s = normalize_colors(s)\n    n = 9\n    k = max(s) if s else 1\n\n    # Deterministic RNG seed derived from solution to ensure reproducibility across runs\n    seed = 1469598103934665603\n    for x in s:\n        seed ^= (x + 0x9e3779b97f4a7c15) & ((1<<64)-1)\n        seed = (seed * 1099511628211) & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Focused k-elimination kick: choose least-used color; if tie, use deterministic tie-break\n    cnt = Counter(s)\n    least_count = min(cnt.values())\n    candidates = [c for c,v in cnt.items() if v == least_count]\n    tgt = sorted(candidates)[0]\n    verts = [u for u in range(1, n+1) if s[u-1] == tgt]\n    remaining = [c for c in range(1, k+1) if c != tgt]\n    if not remaining:\n        return s\n\n    def conflicts_if(u, c):\n        return sum(1 for v in adj[u] if s[v-1] == c)\n\n    # Recolor all vertices of target color to best available colors\n    for u in verts:\n        bestc = None\n        bestconf = 10**9\n        # deterministic scan order with slight randomized tie-break from seeded rng\n        for c in remaining:\n            conf = conflicts_if(u, c)\n            score = (conf, rng.random())\n            if conf < bestconf or (conf == bestconf and rng.random() < 0.5):\n                bestconf = conf\n                bestc = c\n        if bestc is None:\n            bestc = remaining[0]\n        s[u-1] = bestc\n\n    # Optional one Kempe-style swap among remaining colors to diversify (deterministic rng)\n    if len(remaining) >= 2 and rng.random() < 0.85:\n        a, b = rng.sample(remaining, 2)\n        seed_vertices = [u for u in range(1, n+1) if s[u-1] in (a, b)]\n        if seed_vertices:\n            seed_u = rng.choice(seed_vertices)\n            comp = []\n            seen = set([seed_u])\n            stack = [seed_u]\n            while stack:\n                u = stack.pop()\n                if s[u-1] not in (a, b):\n                    continue\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in seen and s[v-1] in (a, b):\n                        seen.add(v)\n                        stack.append(v)\n            for u in comp:\n                s[u-1] = a if s[u-1] == b else (b if s[u-1] == a else s[u-1])\n\n    # Normalize labels to keep contiguity\n    s = normalize_colors(s)\n    return s\n","Resultados":[[1,3,2,1,3,2,3,1,2],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002579107}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    LARGE = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict to strictly enforce feasibility dominance\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n    v = random.randint(1, n)  # vertex to recolor\n\n    # Candidate colors: existing palette plus one new color (max+1)\n    used = sorted(set(new_sol))\n    maxc = max(used)\n    candidates = used + [maxc + 1]\n\n    # Score each candidate by local conflicts at v; tie-break by color count impact\n    best_c = None\n    best_key = None\n    for c in candidates:\n        # local conflicts\n        conflicts = 0\n        for u in adj[v]:\n            if new_sol[u-1] == c:\n                conflicts += 1\n        # projected color set size if we assign c at v\n        proj = set(new_sol)\n        old_c = new_sol[v-1]\n        if c != old_c:\n            proj.add(c)\n            # if v was the only vertex with old_c, its removal may shrink palette\n            if sum(1 for x in new_sol if x == old_c) == 1:\n                if old_c in proj:\n                    proj.remove(old_c)\n        ksize = len(proj)\n        key = (conflicts, ksize, c)  # lexicographic: prefer fewer conflicts, fewer colors, smaller label\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n\n    new_sol[v-1] = best_c\n\n    # Relabel compression to keep small labels contiguous starting from 1\n    remap = {}\n    next_label = 1\n    for c in sorted(set(new_sol)):\n        remap[c] = next_label\n        next_label += 1\n    new_sol = [remap[c] for c in new_sol]\n\n    return new_sol, \"random_recolor\", \"single_change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    s = list(solution)\n\n    # Apply a series of randomized recolors to escape local minima\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randint(1, n)\n        used = sorted(set(s))\n        maxc = max(used)\n        candidates = used + [maxc + 1]\n        # Bias toward colors not used by neighbors\n        neigh_colors = {s[u-1] for u in adj[v]}\n        safe = [c for c in candidates if c not in neigh_colors]\n        pool = safe if safe else candidates\n        c = random.choice(pool)\n        s[v-1] = c\n        # occasional palette reduction attempt\n        if random.random() < 0.5:\n            # try to remap the highest color to a lower feasible color for a random vertex with that color\n            palette = sorted(set(s))\n            if len(palette) > 1:\n                high = max(palette)\n                idxs = [i for i, col in enumerate(s, start=1) if col == high]\n                if idxs:\n                    w = random.choice(idxs)\n                    # try to assign the smallest feasible color\n                    for tgt in range(1, high):\n                        if all(s[u-1] != tgt for u in adj[w]):\n                            s[w-1] = tgt\n                            break\n        # compress labels after each step to keep numbers small and contiguous\n        remap = {}\n        next_label = 1\n        for col in sorted(set(s)):\n            remap[col] = next_label\n            next_label += 1\n        s = [remap[col] for col in s]\n\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.0009884}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    LARGE = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict to strictly enforce feasibility dominance\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n    v = random.randint(1, n)  # vertex to recolor\n\n    # Candidate colors: existing palette plus one new color (max+1)\n    used = sorted(set(new_sol))\n    maxc = max(used)\n    candidates = used + [maxc + 1]\n\n    # Score each candidate by local conflicts at v; tie-break by color count impact\n    best_c = None\n    best_key = None\n    for c in candidates:\n        # local conflicts\n        conflicts = 0\n        for u in adj[v]:\n            if new_sol[u-1] == c:\n                conflicts += 1\n        # projected color set size if we assign c at v\n        proj = set(new_sol)\n        old_c = new_sol[v-1]\n        if c != old_c:\n            proj.add(c)\n            # if v was the only vertex with old_c, its removal may shrink palette\n            if sum(1 for x in new_sol if x == old_c) == 1:\n                if old_c in proj:\n                    proj.remove(old_c)\n        ksize = len(proj)\n        key = (conflicts, ksize, c)  # lexicographic: prefer fewer conflicts, fewer colors, smaller label\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n\n    new_sol[v-1] = best_c\n\n    # Relabel compression to keep small labels contiguous starting from 1\n    remap = {}\n    next_label = 1\n    for c in sorted(set(new_sol)):\n        remap[c] = next_label\n        next_label += 1\n    new_sol = [remap[c] for c in new_sol]\n\n    return new_sol, \"random_recolor\", \"single_change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    s = list(solution)\n\n    # Apply a series of randomized recolors to escape local minima\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randint(1, n)\n        used = sorted(set(s))\n        maxc = max(used)\n        candidates = used + [maxc + 1]\n        # Bias toward colors not used by neighbors\n        neigh_colors = {s[u-1] for u in adj[v]}\n        safe = [c for c in candidates if c not in neigh_colors]\n        pool = safe if safe else candidates\n        c = random.choice(pool)\n        s[v-1] = c\n        # occasional palette reduction attempt\n        if random.random() < 0.5:\n            # try to remap the highest color to a lower feasible color for a random vertex with that color\n            palette = sorted(set(s))\n            if len(palette) > 1:\n                high = max(palette)\n                idxs = [i for i, col in enumerate(s, start=1) if col == high]\n                if idxs:\n                    w = random.choice(idxs)\n                    # try to assign the smallest feasible color\n                    for tgt in range(1, high):\n                        if all(s[u-1] != tgt for u in adj[w]):\n                            s[w-1] = tgt\n                            break\n        # compress labels after each step to keep numbers small and contiguous\n        remap = {}\n        next_label = 1\n        for col in sorted(set(s)):\n            remap[col] = next_label\n            next_label += 1\n        s = [remap[col] for col in s]\n\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000856099}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    LARGE = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty per conflict to strictly enforce feasibility dominance\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n    v = random.randint(1, n)  # vertex to recolor\n\n    # Candidate colors: existing palette plus one new color (max+1)\n    used = sorted(set(new_sol))\n    maxc = max(used)\n    candidates = used + [maxc + 1]\n\n    # Score each candidate by local conflicts at v; tie-break by color count impact\n    best_c = None\n    best_key = None\n    for c in candidates:\n        # local conflicts\n        conflicts = 0\n        for u in adj[v]:\n            if new_sol[u-1] == c:\n                conflicts += 1\n        # projected color set size if we assign c at v\n        proj = set(new_sol)\n        old_c = new_sol[v-1]\n        if c != old_c:\n            proj.add(c)\n            # if v was the only vertex with old_c, its removal may shrink palette\n            if sum(1 for x in new_sol if x == old_c) == 1:\n                if old_c in proj:\n                    proj.remove(old_c)\n        ksize = len(proj)\n        key = (conflicts, ksize, c)  # lexicographic: prefer fewer conflicts, fewer colors, smaller label\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n\n    new_sol[v-1] = best_c\n\n    # Relabel compression to keep small labels contiguous starting from 1\n    remap = {}\n    next_label = 1\n    for c in sorted(set(new_sol)):\n        remap[c] = next_label\n        next_label += 1\n    new_sol = [remap[c] for c in new_sol]\n\n    return new_sol, \"random_recolor\", \"single_change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"all colors must be positive integers\")\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    s = list(solution)\n\n    # Apply a series of randomized recolors to escape local minima\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        v = random.randint(1, n)\n        used = sorted(set(s))\n        maxc = max(used)\n        candidates = used + [maxc + 1]\n        # Bias toward colors not used by neighbors\n        neigh_colors = {s[u-1] for u in adj[v]}\n        safe = [c for c in candidates if c not in neigh_colors]\n        pool = safe if safe else candidates\n        c = random.choice(pool)\n        s[v-1] = c\n        # occasional palette reduction attempt\n        if random.random() < 0.5:\n            # try to remap the highest color to a lower feasible color for a random vertex with that color\n            palette = sorted(set(s))\n            if len(palette) > 1:\n                high = max(palette)\n                idxs = [i for i, col in enumerate(s, start=1) if col == high]\n                if idxs:\n                    w = random.choice(idxs)\n                    # try to assign the smallest feasible color\n                    for tgt in range(1, high):\n                        if all(s[u-1] != tgt for u in adj[w]):\n                            s[w-1] = tgt\n                            break\n        # compress labels after each step to keep numbers small and contiguous\n        remap = {}\n        next_label = 1\n        for col in sorted(set(s)):\n            remap[col] = next_label\n            next_label += 1\n        s = [remap[col] for col in s]\n\n    return s\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000847239}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count hard conflicts and distinct conflicting pairs for soft differentiation\n    conflicts = 0\n    conflict_pairs = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            # use an unordered pair of vertex indices to diversify penalty\n            conflict_pairs.add((min(u, v), max(u, v)))\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility + soft tie-breaker among infeasible\n    return num_groups + conflicts * 100000 + len(conflict_pairs)\n","Vecindad":"import random\n\n# Helper: build adjacency once per call scope\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain swap between colors a and b starting from vertex v\n# Returns modified solution (in-place on a copy) and a boolean indicating if swap occurred\n\ndef _kempe_swap(sol, adj, v, a, b):\n    n = len(sol)\n    target_colors = {a, b}\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in target_colors:\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in target_colors and y not in visited:\n                stack.append(y)\n    # swap a<->b on component\n    changed = False\n    for x in component:\n        if sol[x-1] == a:\n            sol[x-1] = b\n            changed = True\n        elif sol[x-1] == b:\n            sol[x-1] = a\n            changed = True\n    return sol, changed\n\n# Count conflicts for a vertex v with a color c\n\ndef _vertex_conflicts(sol, adj, v, c):\n    cnt = 0\n    for u in adj[v]:\n        if sol[u-1] == c:\n            cnt += 1\n    return cnt\n\n# Choose a color for v preferring existing palette; allow new color only if necessary\n\ndef _choose_color(sol, adj, v):\n    used = sorted(set(sol))\n    best_c = None\n    best_key = None\n    old = sol[v-1]\n    # Try existing colors first\n    for c in used:\n        conf = _vertex_conflicts(sol, adj, v, c)\n        # prefer zero-conflict, then minimal added conflicts, then smaller label\n        # also prefer not increasing palette if possible\n        inc_palette = 0  # using existing color never increases palette\n        key = (conf, inc_palette, c)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n    # If all existing colors conflict at all neighbors equals degree, consider new color\n    deg = len(adj[v])\n    if best_key is not None and best_key[0] == deg:\n        newc = max(used) + 1\n        # new color leads to zero local conflicts by definition\n        cand_key = (0, 1, newc)  # using new color increases palette\n        if cand_key < best_key:\n            best_key = cand_key\n            best_c = newc\n    return best_c\n\n# Core neighbor generator (conflict-biased selection with recolor or Kempe swap)\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    # Compute conflicted vertices\n    conflicted = set()\n    for u, v in _DEF_EDGES:\n        if solution[u-1] == solution[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(solution)\n\n    # Select a vertex: prioritize conflicted; otherwise try a vertex from the largest color class to reduce palette\n    if conflicted:\n        v = random.choice(list(conflicted))\n        move_type = 'conflict_repair'\n    else:\n        # pick a color class with maximum size\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        move_type = 'palette_reduction_attempt'\n\n    # Try direct recolor with existing colors preferred\n    chosen = _choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen == new_sol[v-1]:\n        # If recolor does not change or still conflicts, attempt a Kempe-chain swap with a random neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v]]\n        if neigh_colors:\n            target_color = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            b = target_color\n            tmp = list(new_sol)\n            tmp, _ = _kempe_swap(tmp, adj, v, a, b)\n            new_sol = tmp\n            return new_sol, 'kempe_swap', move_type\n\n    # Apply recolor\n    new_sol[v-1] = chosen\n\n    return new_sol, 'recolor', move_type\n","Perturbacion":"import random\n\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain helper (same as in NB)\n\ndef _kempe_swap(sol, adj, v, a, b):\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in (a, b):\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in (a, b) and y not in visited:\n                stack.append(y)\n    for x in component:\n        sol[x-1] = a if sol[x-1] == b else b\n    return sol\n\n# Greedy recolor for a vertex choosing smallest feasible color; if none, use a new color\n\ndef _greedy_recolor_vertex(sol, adj, v):\n    neigh = {sol[u-1] for u in adj[v]}\n    c = 1\n    while True:\n        if c not in neigh:\n            sol[v-1] = c\n            return\n        c += 1\n\n# Force-remove a rare color class and repair\n\ndef _force_remove_rarest_color(sol, adj):\n    counts = {}\n    for col in sol:\n        counts[col] = counts.get(col, 0) + 1\n    rare_color = min(counts.items(), key=lambda x: x[1])[0]\n    vertices = [i+1 for i, col in enumerate(sol) if col == rare_color]\n    # Temporarily mark with 0 then recolor greedily\n    for v in vertices:\n        sol[v-1] = 0\n    for v in vertices:\n        _greedy_recolor_vertex(sol, adj, v)\n    return sol\n\n# Public API\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    s = list(solution)\n\n    # With probability 0.5, force-remove a rare color; else perform several Kempe swaps\n    if random.random() < 0.5:\n        s = _force_remove_rarest_color(s, adj)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v]]\n            if not neigh_colors:\n                continue\n            target_color = random.choice(neigh_colors)\n            a = s[v-1]\n            b = target_color\n            s = _kempe_swap(s, adj, v, a, b)\n            # ensure list result if helper returns tuple in other context\n            if isinstance(s, tuple):\n                s = s[0]\n\n    return s\n","Resultados":"Failed to run target heuristic: can only concatenate list (not \"int\") to list.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001361853}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count hard conflicts and distinct conflicting pairs for soft differentiation\n    conflicts = 0\n    conflict_pairs = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            # use an unordered pair of vertex indices to diversify penalty\n            conflict_pairs.add((min(u, v), max(u, v)))\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility + soft tie-breaker among infeasible\n    return num_groups + conflicts * 100000 + len(conflict_pairs)\n","Vecindad":"import random\n\n# Helper: build adjacency once per call scope\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain swap between colors a and b starting from vertex v\n# Returns modified solution (in-place on a copy) and a boolean indicating if swap occurred\n\ndef _kempe_swap(sol, adj, v, a, b):\n    n = len(sol)\n    target_colors = {a, b}\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in target_colors:\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in target_colors and y not in visited:\n                stack.append(y)\n    # swap a<->b on component\n    changed = False\n    for x in component:\n        if sol[x-1] == a:\n            sol[x-1] = b\n            changed = True\n        elif sol[x-1] == b:\n            sol[x-1] = a\n            changed = True\n    return sol, changed\n\n# Count conflicts for a vertex v with a color c\n\ndef _vertex_conflicts(sol, adj, v, c):\n    cnt = 0\n    for u in adj[v]:\n        if sol[u-1] == c:\n            cnt += 1\n    return cnt\n\n# Choose a color for v preferring existing palette; allow new color only if necessary\n\ndef _choose_color(sol, adj, v):\n    used = sorted(set(sol))\n    best_c = None\n    best_key = None\n    old = sol[v-1]\n    # Try existing colors first\n    for c in used:\n        conf = _vertex_conflicts(sol, adj, v, c)\n        # prefer zero-conflict, then minimal added conflicts, then smaller label\n        # also prefer not increasing palette if possible\n        inc_palette = 0  # using existing color never increases palette\n        key = (conf, inc_palette, c)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n    # If all existing colors conflict at all neighbors equals degree, consider new color\n    deg = len(adj[v])\n    if best_key is not None and best_key[0] == deg:\n        newc = max(used) + 1\n        # new color leads to zero local conflicts by definition\n        cand_key = (0, 1, newc)  # using new color increases palette\n        if cand_key < best_key:\n            best_key = cand_key\n            best_c = newc\n    return best_c\n\n# Core neighbor generator (conflict-biased selection with recolor or Kempe swap)\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    # Compute conflicted vertices\n    conflicted = set()\n    for u, v in _DEF_EDGES:\n        if solution[u-1] == solution[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(solution)\n\n    # Select a vertex: prioritize conflicted; otherwise try a vertex from the largest color class to reduce palette\n    if conflicted:\n        v = random.choice(list(conflicted))\n        move_type = 'conflict_repair'\n    else:\n        # pick a color class with maximum size\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        move_type = 'palette_reduction_attempt'\n\n    # Try direct recolor with existing colors preferred\n    chosen = _choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen == new_sol[v-1]:\n        # If recolor does not change or still conflicts, attempt a Kempe-chain swap with a random neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v]]\n        if neigh_colors:\n            target_color = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            b = target_color\n            tmp = list(new_sol)\n            tmp, _ = _kempe_swap(tmp, adj, v, a, b)\n            new_sol = tmp\n            return new_sol, 'kempe_swap', move_type\n\n    # Apply recolor\n    new_sol[v-1] = chosen\n\n    return new_sol, 'recolor', move_type\n","Perturbacion":"import random\n\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain helper (same as in NB)\n\ndef _kempe_swap(sol, adj, v, a, b):\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in (a, b):\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in (a, b) and y not in visited:\n                stack.append(y)\n    for x in component:\n        sol[x-1] = a if sol[x-1] == b else b\n    return sol\n\n# Greedy recolor for a vertex choosing smallest feasible color; if none, use a new color\n\ndef _greedy_recolor_vertex(sol, adj, v):\n    neigh = {sol[u-1] for u in adj[v]}\n    c = 1\n    while True:\n        if c not in neigh:\n            sol[v-1] = c\n            return\n        c += 1\n\n# Force-remove a rare color class and repair\n\ndef _force_remove_rarest_color(sol, adj):\n    counts = {}\n    for col in sol:\n        counts[col] = counts.get(col, 0) + 1\n    rare_color = min(counts.items(), key=lambda x: x[1])[0]\n    vertices = [i+1 for i, col in enumerate(sol) if col == rare_color]\n    # Temporarily mark with 0 then recolor greedily\n    for v in vertices:\n        sol[v-1] = 0\n    for v in vertices:\n        _greedy_recolor_vertex(sol, adj, v)\n    return sol\n\n# Public API\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    s = list(solution)\n\n    # With probability 0.5, force-remove a rare color; else perform several Kempe swaps\n    if random.random() < 0.5:\n        s = _force_remove_rarest_color(s, adj)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v]]\n            if not neigh_colors:\n                continue\n            target_color = random.choice(neigh_colors)\n            a = s[v-1]\n            b = target_color\n            s = _kempe_swap(s, adj, v, a, b)\n            # ensure list result if helper returns tuple in other context\n            if isinstance(s, tuple):\n                s = s[0]\n\n    return s\n","Resultados":"Failed to run target heuristic: can only concatenate list (not \"int\") to list.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001189863}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count hard conflicts and distinct conflicting pairs for soft differentiation\n    conflicts = 0\n    conflict_pairs = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            # use an unordered pair of vertex indices to diversify penalty\n            conflict_pairs.add((min(u, v), max(u, v)))\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility + soft tie-breaker among infeasible\n    return num_groups + conflicts * 100000 + len(conflict_pairs)\n","Vecindad":"import random\n\n# Helper: build adjacency once per call scope\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain swap between colors a and b starting from vertex v\n# Returns modified solution (in-place on a copy) and a boolean indicating if swap occurred\n\ndef _kempe_swap(sol, adj, v, a, b):\n    n = len(sol)\n    target_colors = {a, b}\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in target_colors:\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in target_colors and y not in visited:\n                stack.append(y)\n    # swap a<->b on component\n    changed = False\n    for x in component:\n        if sol[x-1] == a:\n            sol[x-1] = b\n            changed = True\n        elif sol[x-1] == b:\n            sol[x-1] = a\n            changed = True\n    return sol, changed\n\n# Count conflicts for a vertex v with a color c\n\ndef _vertex_conflicts(sol, adj, v, c):\n    cnt = 0\n    for u in adj[v]:\n        if sol[u-1] == c:\n            cnt += 1\n    return cnt\n\n# Choose a color for v preferring existing palette; allow new color only if necessary\n\ndef _choose_color(sol, adj, v):\n    used = sorted(set(sol))\n    best_c = None\n    best_key = None\n    old = sol[v-1]\n    # Try existing colors first\n    for c in used:\n        conf = _vertex_conflicts(sol, adj, v, c)\n        # prefer zero-conflict, then minimal added conflicts, then smaller label\n        # also prefer not increasing palette if possible\n        inc_palette = 0  # using existing color never increases palette\n        key = (conf, inc_palette, c)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n    # If all existing colors conflict at all neighbors equals degree, consider new color\n    deg = len(adj[v])\n    if best_key is not None and best_key[0] == deg:\n        newc = max(used) + 1\n        # new color leads to zero local conflicts by definition\n        cand_key = (0, 1, newc)  # using new color increases palette\n        if cand_key < best_key:\n            best_key = cand_key\n            best_c = newc\n    return best_c\n\n# Core neighbor generator (conflict-biased selection with recolor or Kempe swap)\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    # Compute conflicted vertices\n    conflicted = set()\n    for u, v in _DEF_EDGES:\n        if solution[u-1] == solution[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(solution)\n\n    # Select a vertex: prioritize conflicted; otherwise try a vertex from the largest color class to reduce palette\n    if conflicted:\n        v = random.choice(list(conflicted))\n        move_type = 'conflict_repair'\n    else:\n        # pick a color class with maximum size\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        move_type = 'palette_reduction_attempt'\n\n    # Try direct recolor with existing colors preferred\n    chosen = _choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen == new_sol[v-1]:\n        # If recolor does not change or still conflicts, attempt a Kempe-chain swap with a random neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v]]\n        if neigh_colors:\n            target_color = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            b = target_color\n            tmp = list(new_sol)\n            tmp, _ = _kempe_swap(tmp, adj, v, a, b)\n            new_sol = tmp\n            return new_sol, 'kempe_swap', move_type\n\n    # Apply recolor\n    new_sol[v-1] = chosen\n\n    return new_sol, 'recolor', move_type\n","Perturbacion":"import random\n\n_DEF_EDGES = [\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9),\n]\n\ndef _adjacency_list(n=9):\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in _DEF_EDGES:\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n# Kempe chain helper (same as in NB)\n\ndef _kempe_swap(sol, adj, v, a, b):\n    stack = [v]\n    visited = set()\n    component = []\n    while stack:\n        x = stack.pop()\n        if x in visited:\n            continue\n        if sol[x-1] not in (a, b):\n            continue\n        visited.add(x)\n        component.append(x)\n        for y in adj[x]:\n            if sol[y-1] in (a, b) and y not in visited:\n                stack.append(y)\n    for x in component:\n        sol[x-1] = a if sol[x-1] == b else b\n    return sol\n\n# Greedy recolor for a vertex choosing smallest feasible color; if none, use a new color\n\ndef _greedy_recolor_vertex(sol, adj, v):\n    neigh = {sol[u-1] for u in adj[v]}\n    c = 1\n    while True:\n        if c not in neigh:\n            sol[v-1] = c\n            return\n        c += 1\n\n# Force-remove a rare color class and repair\n\ndef _force_remove_rarest_color(sol, adj):\n    counts = {}\n    for col in sol:\n        counts[col] = counts.get(col, 0) + 1\n    rare_color = min(counts.items(), key=lambda x: x[1])[0]\n    vertices = [i+1 for i, col in enumerate(sol) if col == rare_color]\n    # Temporarily mark with 0 then recolor greedily\n    for v in vertices:\n        sol[v-1] = 0\n    for v in vertices:\n        _greedy_recolor_vertex(sol, adj, v)\n    return sol\n\n# Public API\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    adj = _adjacency_list(9)\n    s = list(solution)\n\n    # With probability 0.5, force-remove a rare color; else perform several Kempe swaps\n    if random.random() < 0.5:\n        s = _force_remove_rarest_color(s, adj)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v]]\n            if not neigh_colors:\n                continue\n            target_color = random.choice(neigh_colors)\n            a = s[v-1]\n            b = target_color\n            s = _kempe_swap(s, adj, v, a, b)\n            # ensure list result if helper returns tuple in other context\n            if isinstance(s, tuple):\n                s = s[0]\n\n    return s\n","Resultados":"Failed to run target heuristic: can only concatenate list (not \"int\") to list.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001131081}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (internal to function)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct color count\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def vertex_conflicts(sol, adj, v, c):\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def choose_color(sol, adj, v):\n        used = sorted(set(sol))\n        best = (10**9, 1, None)  # (conflicts, palette_increase_flag, color)\n        current_palette = set(used)\n        for c in used:\n            conf = vertex_conflicts(sol, adj, v, c)\n            key = (conf, 0, c)\n            if key < best:\n                best = key\n        # consider new color if it strictly reduces conflicts\n        new_c = (max(used) + 1) if used else 1\n        new_key = (0, 1, new_c)\n        if new_key < best:\n            best = new_key\n        return best[2]\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n\n    cur = list(solution)\n\n    # find conflicted vertices\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(cur)\n\n    if conflicted:\n        v = random.choice(list(conflicted))\n    else:\n        # choose a vertex from the largest color class to try palette reduction\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n\n    # Try recolor first\n    chosen = choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen != new_sol[v-1]:\n        new_sol[v-1] = chosen\n    else:\n        # attempt Kempe swap with random distinct neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            new_sol = kempe_swap(new_sol, adj, v, a, b)\n\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def greedy_recolor_vertex(sol, adj, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n    s = list(solution)\n\n    # Strategy: with 50% chance, remove the rarest color class and repair; otherwise, do several Kempe swaps\n    if random.random() < 0.5:\n        # remove rarest color\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        for v in vertices:\n            greedy_recolor_vertex(s, adj, v)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, adj, v, a, b)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00151736}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (internal to function)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct color count\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def vertex_conflicts(sol, adj, v, c):\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def choose_color(sol, adj, v):\n        used = sorted(set(sol))\n        best = (10**9, 1, None)  # (conflicts, palette_increase_flag, color)\n        current_palette = set(used)\n        for c in used:\n            conf = vertex_conflicts(sol, adj, v, c)\n            key = (conf, 0, c)\n            if key < best:\n                best = key\n        # consider new color if it strictly reduces conflicts\n        new_c = (max(used) + 1) if used else 1\n        new_key = (0, 1, new_c)\n        if new_key < best:\n            best = new_key\n        return best[2]\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n\n    cur = list(solution)\n\n    # find conflicted vertices\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(cur)\n\n    if conflicted:\n        v = random.choice(list(conflicted))\n    else:\n        # choose a vertex from the largest color class to try palette reduction\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n\n    # Try recolor first\n    chosen = choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen != new_sol[v-1]:\n        new_sol[v-1] = chosen\n    else:\n        # attempt Kempe swap with random distinct neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            new_sol = kempe_swap(new_sol, adj, v, a, b)\n\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def greedy_recolor_vertex(sol, adj, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n    s = list(solution)\n\n    # Strategy: with 50% chance, remove the rarest color class and repair; otherwise, do several Kempe swaps\n    if random.random() < 0.5:\n        # remove rarest color\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        for v in vertices:\n            greedy_recolor_vertex(s, adj, v)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, adj, v, a, b)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001289907}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (internal to function)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct color count\n    num_groups = len(set(solution))\n    # Strong dominance for feasibility\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def vertex_conflicts(sol, adj, v, c):\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def choose_color(sol, adj, v):\n        used = sorted(set(sol))\n        best = (10**9, 1, None)  # (conflicts, palette_increase_flag, color)\n        current_palette = set(used)\n        for c in used:\n            conf = vertex_conflicts(sol, adj, v, c)\n            key = (conf, 0, c)\n            if key < best:\n                best = key\n        # consider new color if it strictly reduces conflicts\n        new_c = (max(used) + 1) if used else 1\n        new_key = (0, 1, new_c)\n        if new_key < best:\n            best = new_key\n        return best[2]\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n\n    cur = list(solution)\n\n    # find conflicted vertices\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    new_sol = list(cur)\n\n    if conflicted:\n        v = random.choice(list(conflicted))\n    else:\n        # choose a vertex from the largest color class to try palette reduction\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n\n    # Try recolor first\n    chosen = choose_color(new_sol, adj, v)\n    if chosen is None:\n        chosen = new_sol[v-1]\n\n    if chosen != new_sol[v-1]:\n        new_sol[v-1] = chosen\n    else:\n        # attempt Kempe swap with random distinct neighbor color\n        neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            a = new_sol[v-1]\n            new_sol = kempe_swap(new_sol, adj, v, a, b)\n\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9),\n        ]\n        adj = {i: [] for i in range(1, 10)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return edges, adj\n\n    def greedy_recolor_vertex(sol, adj, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, adj, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    edges, adj = build_adj()\n    s = list(solution)\n\n    # Strategy: with 50% chance, remove the rarest color class and repair; otherwise, do several Kempe swaps\n    if random.random() < 0.5:\n        # remove rarest color\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        for v in vertices:\n            greedy_recolor_vertex(s, adj, v)\n    else:\n        steps = random.randint(2, 5)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            if not adj[v]:\n                continue\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, adj, v, a, b)\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001252146}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data (internal)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts first\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant penalty; skip distinct color count to save time\n        return conflicts * 100000\n\n    # Feasible: minimize number of used groups\n    num_groups = len(set(solution))\n    return num_groups","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def score(sol):\n        # Fast score aligned with evaluate_solution (conflicts dominant)\n        conflicts = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return conflicts * 100000\n        return len(set(sol))\n\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def saturation(sol, v):\n        return len({sol[u-1] for u in adj[v]})\n\n    def try_recolor(sol, v):\n        current = sol[v-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_val = math.inf\n        # evaluate existing palette only (avoid increasing palette unless needed)\n        for col in used:\n            if col == current:\n                continue\n            sol[v-1] = col\n            val = score(sol)\n            if val < best_val:\n                best_val = val\n                best_c = col\n        sol[v-1] = current\n        # Consider palette increase only if no improvement found\n        if best_c == current:\n            new_c = (max(used) + 1) if used else 1\n            sol[v-1] = new_c\n            val = score(sol)\n            sol[v-1] = current\n            if val < best_val:\n                best_c = new_c\n        return best_c\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize_if_palette_reduced(old, new):\n        if len(set(new)) < len(set(old)):\n            mapping = {}\n            next_c = 1\n            out = []\n            for c in new:\n                if c not in mapping:\n                    mapping[c] = next_c\n                    next_c += 1\n                out.append(mapping[c])\n            return out\n        return new\n\n    cur = list(solution)\n\n    # Identify conflicted vertices and compute priorities\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    move_type = (\"LOCAL\", \"RECOLOR\")\n    new_sol = list(cur)\n\n    if conflicted:\n        # Select vertex by highest conflicts, then degree, then saturation\n        candidates = list(conflicted)\n        candidates.sort(key=lambda v: (\n            -vertex_conflicts(cur, v),\n            -len(adj[v]),\n            -saturation(cur, v)\n        ))\n        v = candidates[0]\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Kempe with a neighbor color that best improves score\n            neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n            if neigh_colors:\n                best = None\n                base = score(new_sol)\n                for bcol in set(neigh_colors):\n                    trial = kempe_swap(list(new_sol), v, new_sol[v-1], bcol)\n                    val = score(trial)\n                    if best is None or val < best[0]:\n                        best = (val, trial)\n                if best is not None and best[0] <= base:\n                    new_sol = best[1]\n                    move_type = (\"LOCAL\", \"KEMPE\")\n                else:\n                    # fallback random kempe\n                    bcol = random.choice(neigh_colors)\n                    new_sol = kempe_swap(new_sol, v, new_sol[v-1], bcol)\n                    move_type = (\"LOCAL\", \"KEMPE\")\n    else:\n        # Feasible state: attempt palette reduction\n        # Pick largest color class and move one vertex to best alternative color\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Try swapping colors of two vertices from different classes\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                Va = [i+1 for i, c in enumerate(new_sol) if c == a]\n                Vb = [i+1 for i, c in enumerate(new_sol) if c == b]\n                if Va and Vb:\n                    ia = random.choice(Va)\n                    ib = random.choice(Vb)\n                    trial = list(new_sol)\n                    trial[ia-1], trial[ib-1] = trial[ib-1], trial[ia-1]\n                    if score(trial) <= score(new_sol):\n                        new_sol = trial\n                        move_type = (\"LOCAL\", \"SWAP\")\n\n    new_sol = normalize_if_palette_reduced(cur, new_sol)\n    return new_sol, move_type","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_recolor_vertex(sol, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    s = list(solution)\n\n    # Strategy: remove a small color class or apply multiple Kempe swaps\n    if random.random() < 0.6:\n        # Remove rarest color class and repair greedily\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        random.shuffle(vertices)\n        for v in vertices:\n            greedy_recolor_vertex(s, v)\n    else:\n        # Perform several random Kempe swaps\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, v, a, b)\n\n    s = normalize(s)\n    return s","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002721644}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data (internal)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts first\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant penalty; skip distinct color count to save time\n        return conflicts * 100000\n\n    # Feasible: minimize number of used groups\n    num_groups = len(set(solution))\n    return num_groups","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def score(sol):\n        # Fast score aligned with evaluate_solution (conflicts dominant)\n        conflicts = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return conflicts * 100000\n        return len(set(sol))\n\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def saturation(sol, v):\n        return len({sol[u-1] for u in adj[v]})\n\n    def try_recolor(sol, v):\n        current = sol[v-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_val = math.inf\n        # evaluate existing palette only (avoid increasing palette unless needed)\n        for col in used:\n            if col == current:\n                continue\n            sol[v-1] = col\n            val = score(sol)\n            if val < best_val:\n                best_val = val\n                best_c = col\n        sol[v-1] = current\n        # Consider palette increase only if no improvement found\n        if best_c == current:\n            new_c = (max(used) + 1) if used else 1\n            sol[v-1] = new_c\n            val = score(sol)\n            sol[v-1] = current\n            if val < best_val:\n                best_c = new_c\n        return best_c\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize_if_palette_reduced(old, new):\n        if len(set(new)) < len(set(old)):\n            mapping = {}\n            next_c = 1\n            out = []\n            for c in new:\n                if c not in mapping:\n                    mapping[c] = next_c\n                    next_c += 1\n                out.append(mapping[c])\n            return out\n        return new\n\n    cur = list(solution)\n\n    # Identify conflicted vertices and compute priorities\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    move_type = (\"LOCAL\", \"RECOLOR\")\n    new_sol = list(cur)\n\n    if conflicted:\n        # Select vertex by highest conflicts, then degree, then saturation\n        candidates = list(conflicted)\n        candidates.sort(key=lambda v: (\n            -vertex_conflicts(cur, v),\n            -len(adj[v]),\n            -saturation(cur, v)\n        ))\n        v = candidates[0]\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Kempe with a neighbor color that best improves score\n            neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n            if neigh_colors:\n                best = None\n                base = score(new_sol)\n                for bcol in set(neigh_colors):\n                    trial = kempe_swap(list(new_sol), v, new_sol[v-1], bcol)\n                    val = score(trial)\n                    if best is None or val < best[0]:\n                        best = (val, trial)\n                if best is not None and best[0] <= base:\n                    new_sol = best[1]\n                    move_type = (\"LOCAL\", \"KEMPE\")\n                else:\n                    # fallback random kempe\n                    bcol = random.choice(neigh_colors)\n                    new_sol = kempe_swap(new_sol, v, new_sol[v-1], bcol)\n                    move_type = (\"LOCAL\", \"KEMPE\")\n    else:\n        # Feasible state: attempt palette reduction\n        # Pick largest color class and move one vertex to best alternative color\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Try swapping colors of two vertices from different classes\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                Va = [i+1 for i, c in enumerate(new_sol) if c == a]\n                Vb = [i+1 for i, c in enumerate(new_sol) if c == b]\n                if Va and Vb:\n                    ia = random.choice(Va)\n                    ib = random.choice(Vb)\n                    trial = list(new_sol)\n                    trial[ia-1], trial[ib-1] = trial[ib-1], trial[ia-1]\n                    if score(trial) <= score(new_sol):\n                        new_sol = trial\n                        move_type = (\"LOCAL\", \"SWAP\")\n\n    new_sol = normalize_if_palette_reduced(cur, new_sol)\n    return new_sol, move_type","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_recolor_vertex(sol, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    s = list(solution)\n\n    # Strategy: remove a small color class or apply multiple Kempe swaps\n    if random.random() < 0.6:\n        # Remove rarest color class and repair greedily\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        random.shuffle(vertices)\n        for v in vertices:\n            greedy_recolor_vertex(s, v)\n    else:\n        # Perform several random Kempe swaps\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, v, a, b)\n\n    s = normalize(s)\n    return s","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002298678}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_LABELS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data (internal)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts first\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant penalty; skip distinct color count to save time\n        return conflicts * 100000\n\n    # Feasible: minimize number of used groups\n    num_groups = len(set(solution))\n    return num_groups","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def score(sol):\n        # Fast score aligned with evaluate_solution (conflicts dominant)\n        conflicts = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        if conflicts > 0:\n            return conflicts * 100000\n        return len(set(sol))\n\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for u in adj[v] if sol[u-1] == c)\n\n    def saturation(sol, v):\n        return len({sol[u-1] for u in adj[v]})\n\n    def try_recolor(sol, v):\n        current = sol[v-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_val = math.inf\n        # evaluate existing palette only (avoid increasing palette unless needed)\n        for col in used:\n            if col == current:\n                continue\n            sol[v-1] = col\n            val = score(sol)\n            if val < best_val:\n                best_val = val\n                best_c = col\n        sol[v-1] = current\n        # Consider palette increase only if no improvement found\n        if best_c == current:\n            new_c = (max(used) + 1) if used else 1\n            sol[v-1] = new_c\n            val = score(sol)\n            sol[v-1] = current\n            if val < best_val:\n                best_c = new_c\n        return best_c\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize_if_palette_reduced(old, new):\n        if len(set(new)) < len(set(old)):\n            mapping = {}\n            next_c = 1\n            out = []\n            for c in new:\n                if c not in mapping:\n                    mapping[c] = next_c\n                    next_c += 1\n                out.append(mapping[c])\n            return out\n        return new\n\n    cur = list(solution)\n\n    # Identify conflicted vertices and compute priorities\n    conflicted = set()\n    for u, v in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    move_type = (\"LOCAL\", \"RECOLOR\")\n    new_sol = list(cur)\n\n    if conflicted:\n        # Select vertex by highest conflicts, then degree, then saturation\n        candidates = list(conflicted)\n        candidates.sort(key=lambda v: (\n            -vertex_conflicts(cur, v),\n            -len(adj[v]),\n            -saturation(cur, v)\n        ))\n        v = candidates[0]\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Kempe with a neighbor color that best improves score\n            neigh_colors = [new_sol[u-1] for u in adj[v] if new_sol[u-1] != new_sol[v-1]]\n            if neigh_colors:\n                best = None\n                base = score(new_sol)\n                for bcol in set(neigh_colors):\n                    trial = kempe_swap(list(new_sol), v, new_sol[v-1], bcol)\n                    val = score(trial)\n                    if best is None or val < best[0]:\n                        best = (val, trial)\n                if best is not None and best[0] <= base:\n                    new_sol = best[1]\n                    move_type = (\"LOCAL\", \"KEMPE\")\n                else:\n                    # fallback random kempe\n                    bcol = random.choice(neigh_colors)\n                    new_sol = kempe_swap(new_sol, v, new_sol[v-1], bcol)\n                    move_type = (\"LOCAL\", \"KEMPE\")\n    else:\n        # Feasible state: attempt palette reduction\n        # Pick largest color class and move one vertex to best alternative color\n        counts = {}\n        for col in new_sol:\n            counts[col] = counts.get(col, 0) + 1\n        largest_color = max(counts.items(), key=lambda x: x[1])[0]\n        idxs = [i+1 for i, col in enumerate(new_sol) if col == largest_color]\n        v = random.choice(idxs)\n        best_col = try_recolor(new_sol, v)\n        if best_col != new_sol[v-1]:\n            new_sol[v-1] = best_col\n            move_type = (\"LOCAL\", \"RECOLOR\")\n        else:\n            # Try swapping colors of two vertices from different classes\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                Va = [i+1 for i, c in enumerate(new_sol) if c == a]\n                Vb = [i+1 for i, c in enumerate(new_sol) if c == b]\n                if Va and Vb:\n                    ia = random.choice(Va)\n                    ib = random.choice(Vb)\n                    trial = list(new_sol)\n                    trial[ia-1], trial[ib-1] = trial[ib-1], trial[ia-1]\n                    if score(trial) <= score(new_sol):\n                        new_sol = trial\n                        move_type = (\"LOCAL\", \"SWAP\")\n\n    new_sol = normalize_if_palette_reduced(cur, new_sol)\n    return new_sol, move_type","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError('solution must be a list of length 9')\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError('all colors must be positive integers')\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_recolor_vertex(sol, v):\n        forbidden = {sol[u-1] for u in adj[v]}\n        c = 1\n        while True:\n            if c not in forbidden:\n                sol[v-1] = c\n                return\n            c += 1\n\n    def kempe_swap(sol, v, a, b):\n        if a == b:\n            return sol\n        target = {a, b}\n        stack = [v]\n        seen = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in seen:\n                continue\n            if sol[x-1] not in target:\n                continue\n            seen.add(x)\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in target:\n                    stack.append(y)\n        for x in comp:\n            sol[x-1] = a if sol[x-1] == b else b\n        return sol\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    s = list(solution)\n\n    # Strategy: remove a small color class or apply multiple Kempe swaps\n    if random.random() < 0.6:\n        # Remove rarest color class and repair greedily\n        counts = {}\n        for col in s:\n            counts[col] = counts.get(col, 0) + 1\n        rare_color = min(counts.items(), key=lambda x: x[1])[0]\n        vertices = [i+1 for i, col in enumerate(s) if col == rare_color]\n        random.shuffle(vertices)\n        for v in vertices:\n            greedy_recolor_vertex(s, v)\n    else:\n        # Perform several random Kempe swaps\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            v = random.randint(1, 9)\n            neigh_colors = [s[u-1] for u in adj[v] if s[u-1] != s[v-1]]\n            if not neigh_colors:\n                continue\n            b = random.choice(neigh_colors)\n            a = s[v-1]\n            s = kempe_swap(s, v, a, b)\n\n    s = normalize(s)\n    return s","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002259718}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K. solution := list of 9 positive integers; i-th entry is color of vertex i (1-indexed vertices). Objective: minimize max(solution) with edge constraints x_u != x_v for all given edges.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize K) + heavy penalties for conflicts; lower is better.\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _conflicted_vertices(sol: List[int]) -> List[int]:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n\ndef _adjacent_colors(sol: List[int], idx: int) -> set:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    adj = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            adj.add(sol[v-1])\n        elif v-1 == idx:\n            adj.add(sol[u-1])\n    return adj\n\n\ndef _lowest_feasible_color(sol: List[int], idx: int, allow_new: bool = True) -> int:\n    used_adj = _adjacent_colors(sol, idx)\n    c = 1\n    while True:\n        if c not in used_adj:\n            return c\n        c += 1\n        if not allow_new and c > max(sol):\n            # fallback: keep original color if no feasible within current K\n            return sol[idx]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-ish solution if invalid\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    K = max(sol) if sol else 3\n\n    move_type = None\n    nb_type = None\n\n    conflicted = _conflicted_vertices(sol)\n\n    r = random.random()\n    if conflicted and r < 0.7:\n        # Conflict-directed recolor to the lowest feasible color\n        idx = random.choice(conflicted)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=True)\n        sol[idx] = new_color\n        move_type = \"recolor_one_conflict_min\"\n        nb_type = \"feasible_bias\"\n    elif r < 0.85:\n        # Try to reduce palette by recoloring a random vertex within current K\n        idx = random.randrange(9)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=False)\n        sol[idx] = new_color\n        move_type = \"recolor_one_reduceK\"\n        nb_type = \"intensification\"\n    else:\n        # Swap colors of two random vertices to diversify\n        i, j = random.sample(range(9), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        move_type = \"swap_two\"\n        nb_type = \"diversification\"\n\n    # Optional post-step: if max color is unused, compress palette\n    present = set(sol)\n    mapping = {}\n    next_c = 1\n    for c in sorted(present):\n        mapping[c] = next_c\n        next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    return (sol, nb_type, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong shake: multi-recolor + palette compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n_steps = random.randint(3, 6)\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n\n    def adj_colors(idx: int) -> set:\n        s = set()\n        for (u, v) in E:\n            if u-1 == idx:\n                s.add(sol[v-1])\n            elif v-1 == idx:\n                s.add(sol[u-1])\n        return s\n\n    for _ in range(n_steps):\n        idx = random.randrange(9)\n        used = adj_colors(idx)\n        # allow sampling from a slightly larger palette to escape local minima\n        max_try = max(sol) + 1\n        candidates = [c for c in range(1, max_try + 1) if c not in used]\n        if not candidates:\n            # fallback random color\n            sol[idx] = random.randint(1, max_try)\n        else:\n            sol[idx] = random.choice(candidates)\n\n    # Palette compression to normalize\n    present = sorted(set(sol))\n    remap = {c: i+1 for i, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001052573}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K. solution := list of 9 positive integers; i-th entry is color of vertex i (1-indexed vertices). Objective: minimize max(solution) with edge constraints x_u != x_v for all given edges.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize K) + heavy penalties for conflicts; lower is better.\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _conflicted_vertices(sol: List[int]) -> List[int]:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n\ndef _adjacent_colors(sol: List[int], idx: int) -> set:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    adj = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            adj.add(sol[v-1])\n        elif v-1 == idx:\n            adj.add(sol[u-1])\n    return adj\n\n\ndef _lowest_feasible_color(sol: List[int], idx: int, allow_new: bool = True) -> int:\n    used_adj = _adjacent_colors(sol, idx)\n    c = 1\n    while True:\n        if c not in used_adj:\n            return c\n        c += 1\n        if not allow_new and c > max(sol):\n            # fallback: keep original color if no feasible within current K\n            return sol[idx]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-ish solution if invalid\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    K = max(sol) if sol else 3\n\n    move_type = None\n    nb_type = None\n\n    conflicted = _conflicted_vertices(sol)\n\n    r = random.random()\n    if conflicted and r < 0.7:\n        # Conflict-directed recolor to the lowest feasible color\n        idx = random.choice(conflicted)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=True)\n        sol[idx] = new_color\n        move_type = \"recolor_one_conflict_min\"\n        nb_type = \"feasible_bias\"\n    elif r < 0.85:\n        # Try to reduce palette by recoloring a random vertex within current K\n        idx = random.randrange(9)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=False)\n        sol[idx] = new_color\n        move_type = \"recolor_one_reduceK\"\n        nb_type = \"intensification\"\n    else:\n        # Swap colors of two random vertices to diversify\n        i, j = random.sample(range(9), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        move_type = \"swap_two\"\n        nb_type = \"diversification\"\n\n    # Optional post-step: if max color is unused, compress palette\n    present = set(sol)\n    mapping = {}\n    next_c = 1\n    for c in sorted(present):\n        mapping[c] = next_c\n        next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    return (sol, nb_type, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong shake: multi-recolor + palette compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n_steps = random.randint(3, 6)\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n\n    def adj_colors(idx: int) -> set:\n        s = set()\n        for (u, v) in E:\n            if u-1 == idx:\n                s.add(sol[v-1])\n            elif v-1 == idx:\n                s.add(sol[u-1])\n        return s\n\n    for _ in range(n_steps):\n        idx = random.randrange(9)\n        used = adj_colors(idx)\n        # allow sampling from a slightly larger palette to escape local minima\n        max_try = max(sol) + 1\n        candidates = [c for c in range(1, max_try + 1) if c not in used]\n        if not candidates:\n            # fallback random color\n            sol[idx] = random.randint(1, max_try)\n        else:\n            sol[idx] = random.choice(candidates)\n\n    # Palette compression to normalize\n    present = sorted(set(sol))\n    remap = {c: i+1 for i, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000892321}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K. solution := list of 9 positive integers; i-th entry is color of vertex i (1-indexed vertices). Objective: minimize max(solution) with edge constraints x_u != x_v for all given edges.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (minimize K) + heavy penalties for conflicts; lower is better.\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _conflicted_vertices(sol: List[int]) -> List[int]:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n\ndef _adjacent_colors(sol: List[int], idx: int) -> set:\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n    adj = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            adj.add(sol[v-1])\n        elif v-1 == idx:\n            adj.add(sol[u-1])\n    return adj\n\n\ndef _lowest_feasible_color(sol: List[int], idx: int, allow_new: bool = True) -> int:\n    used_adj = _adjacent_colors(sol, idx)\n    c = 1\n    while True:\n        if c not in used_adj:\n            return c\n        c += 1\n        if not allow_new and c > max(sol):\n            # fallback: keep original color if no feasible within current K\n            return sol[idx]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-ish solution if invalid\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    K = max(sol) if sol else 3\n\n    move_type = None\n    nb_type = None\n\n    conflicted = _conflicted_vertices(sol)\n\n    r = random.random()\n    if conflicted and r < 0.7:\n        # Conflict-directed recolor to the lowest feasible color\n        idx = random.choice(conflicted)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=True)\n        sol[idx] = new_color\n        move_type = \"recolor_one_conflict_min\"\n        nb_type = \"feasible_bias\"\n    elif r < 0.85:\n        # Try to reduce palette by recoloring a random vertex within current K\n        idx = random.randrange(9)\n        new_color = _lowest_feasible_color(sol, idx, allow_new=False)\n        sol[idx] = new_color\n        move_type = \"recolor_one_reduceK\"\n        nb_type = \"intensification\"\n    else:\n        # Swap colors of two random vertices to diversify\n        i, j = random.sample(range(9), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        move_type = \"swap_two\"\n        nb_type = \"diversification\"\n\n    # Optional post-step: if max color is unused, compress palette\n    present = set(sol)\n    mapping = {}\n    next_c = 1\n    for c in sorted(present):\n        mapping[c] = next_c\n        next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    return (sol, nb_type, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong shake: multi-recolor + palette compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n_steps = random.randint(3, 6)\n    E = [(1,2),(1,3),(1,7),(1,9),\n         (2,6),(2,9),\n         (3,4),(3,5),(3,7),\n         (4,5),(4,6),\n         (5,6),(5,8),\n         (6,7),(6,8),\n         (7,9),\n         (8,9)]\n\n    def adj_colors(idx: int) -> set:\n        s = set()\n        for (u, v) in E:\n            if u-1 == idx:\n                s.add(sol[v-1])\n            elif v-1 == idx:\n                s.add(sol[u-1])\n        return s\n\n    for _ in range(n_steps):\n        idx = random.randrange(9)\n        used = adj_colors(idx)\n        # allow sampling from a slightly larger palette to escape local minima\n        max_try = max(sol) + 1\n        candidates = [c for c in range(1, max_try + 1) if c not in used]\n        if not candidates:\n            # fallback random color\n            sol[idx] = random.randint(1, max_try)\n        else:\n            sol[idx] = random.choice(candidates)\n\n    # Palette compression to normalize\n    present = sorted(set(sol))\n    remap = {c: i+1 for i, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000882481}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic-like scalarization: prioritize feasibility, then K, then usage of highest color\n    # Lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Count how many vertices use the highest color (helps compression\/tie-breaks)\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        # Heavy but smooth penalty on conflicts; K and highest count still influence\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    # Feasible: primary K, then minimize count of highest color as tie-breaker\n    return 1_000 * K + count_highest\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list once per call\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate\/input-fix\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def conflicts_of(idx, col):\n        cnt = 0\n        for j in adj[idx]:\n            if sol[j] == col:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def dsat_degree(idx):\n        # Distinct neighbor colors count\n        return len({sol[j] for j in adj[idx]})\n\n    def lowest_feasible_color(idx, allow_new=True):\n        used = {sol[j] for j in adj[idx]}\n        K = max(sol) if sol else 1\n        c = 1\n        best = None\n        limit = K if not allow_new else K + 1\n        while c <= limit:\n            if c not in used:\n                best = c\n                break\n            c += 1\n        if best is None:\n            # fallback keep or random within [1..limit]\n            best = sol[idx] if not allow_new else random.randint(1, limit)\n        return best\n\n    def kempe_chain_interchange(a_idx):\n        # Pick a second color b != color(a_idx), BFS swap within {a,b}\n        a = sol[a_idx]\n        colors = sorted(set(sol))\n        if len(colors) == 1:\n            return False\n        b = random.choice([c for c in colors if c != a])\n        # BFS over vertices reachable via edges that alternate in colors a\/b\n        visited = [False]*n\n        queue = [a_idx]\n        visited[a_idx] = True\n        component = []\n        while queue:\n            u = queue.pop()\n            component.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    queue.append(v)\n        # Swap colors a<->b on component\n        for u in component:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Move selection policy\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.5:\n        # Conflict-directed best-response on most saturated conflicted vertex\n        idx = max(bad, key=lambda i: (dsat_degree(i), len(adj[i])))\n        K = max(sol)\n        best_col = sol[idx]\n        best_score = (conflicts_of(idx, sol[idx]), sol[idx])\n        # Try colors within current palette first, then possibly K+1\n        candidates = list(range(1, K+1)) + [K+1]\n        rand_bias = random.random()\n        if rand_bias < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_of(idx, c), c)\n            if sc < best_score:\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[idx] = best_col\n        nb_type = \"feasible_bias\"; mv = \"best_response_recolor\"\n    elif r < 0.8:\n        # Kempe-chain interchange starting from a high-degree or conflicted vertex\n        if bad:\n            start = max(bad, key=lambda i: len(adj[i]))\n        else:\n            start = max(range(n), key=lambda i: len(adj[i]))\n        kempe_chain_interchange(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette reduction attempt\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            # single vertex recolor with palette-reduction constraint\n            idx = random.randrange(n)\n            sol[idx] = lowest_feasible_color(idx, allow_new=False)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Adaptive-strength perturbation combining conflict-biased recolors and Kempe kicks\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS within {a,b}\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Determine strength based on conflicts\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    if base_conf == 0:\n        steps = max(2, K - 1)  # gentle shake when feasible\n    else:\n        steps = min(6, 3 + base_conf)  # stronger when infeasible\n\n    # Apply mixed perturbations\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # conflict-biased recolor\n            # pick vertex with highest local conflicts, tie by degree\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            # Kempe kick from random vertex\n            kempe_kick(random.randrange(n))\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001805501}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic-like scalarization: prioritize feasibility, then K, then usage of highest color\n    # Lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Count how many vertices use the highest color (helps compression\/tie-breaks)\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        # Heavy but smooth penalty on conflicts; K and highest count still influence\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    # Feasible: primary K, then minimize count of highest color as tie-breaker\n    return 1_000 * K + count_highest\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list once per call\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate\/input-fix\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def conflicts_of(idx, col):\n        cnt = 0\n        for j in adj[idx]:\n            if sol[j] == col:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def dsat_degree(idx):\n        # Distinct neighbor colors count\n        return len({sol[j] for j in adj[idx]})\n\n    def lowest_feasible_color(idx, allow_new=True):\n        used = {sol[j] for j in adj[idx]}\n        K = max(sol) if sol else 1\n        c = 1\n        best = None\n        limit = K if not allow_new else K + 1\n        while c <= limit:\n            if c not in used:\n                best = c\n                break\n            c += 1\n        if best is None:\n            # fallback keep or random within [1..limit]\n            best = sol[idx] if not allow_new else random.randint(1, limit)\n        return best\n\n    def kempe_chain_interchange(a_idx):\n        # Pick a second color b != color(a_idx), BFS swap within {a,b}\n        a = sol[a_idx]\n        colors = sorted(set(sol))\n        if len(colors) == 1:\n            return False\n        b = random.choice([c for c in colors if c != a])\n        # BFS over vertices reachable via edges that alternate in colors a\/b\n        visited = [False]*n\n        queue = [a_idx]\n        visited[a_idx] = True\n        component = []\n        while queue:\n            u = queue.pop()\n            component.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    queue.append(v)\n        # Swap colors a<->b on component\n        for u in component:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Move selection policy\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.5:\n        # Conflict-directed best-response on most saturated conflicted vertex\n        idx = max(bad, key=lambda i: (dsat_degree(i), len(adj[i])))\n        K = max(sol)\n        best_col = sol[idx]\n        best_score = (conflicts_of(idx, sol[idx]), sol[idx])\n        # Try colors within current palette first, then possibly K+1\n        candidates = list(range(1, K+1)) + [K+1]\n        rand_bias = random.random()\n        if rand_bias < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_of(idx, c), c)\n            if sc < best_score:\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[idx] = best_col\n        nb_type = \"feasible_bias\"; mv = \"best_response_recolor\"\n    elif r < 0.8:\n        # Kempe-chain interchange starting from a high-degree or conflicted vertex\n        if bad:\n            start = max(bad, key=lambda i: len(adj[i]))\n        else:\n            start = max(range(n), key=lambda i: len(adj[i]))\n        kempe_chain_interchange(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette reduction attempt\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            # single vertex recolor with palette-reduction constraint\n            idx = random.randrange(n)\n            sol[idx] = lowest_feasible_color(idx, allow_new=False)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Adaptive-strength perturbation combining conflict-biased recolors and Kempe kicks\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS within {a,b}\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Determine strength based on conflicts\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    if base_conf == 0:\n        steps = max(2, K - 1)  # gentle shake when feasible\n    else:\n        steps = min(6, 3 + base_conf)  # stronger when infeasible\n\n    # Apply mixed perturbations\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # conflict-biased recolor\n            # pick vertex with highest local conflicts, tie by degree\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            # Kempe kick from random vertex\n            kempe_kick(random.randrange(n))\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001568799}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic-like scalarization: prioritize feasibility, then K, then usage of highest color\n    # Lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Count how many vertices use the highest color (helps compression\/tie-breaks)\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        # Heavy but smooth penalty on conflicts; K and highest count still influence\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    # Feasible: primary K, then minimize count of highest color as tie-breaker\n    return 1_000 * K + count_highest\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency list once per call\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate\/input-fix\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def conflicts_of(idx, col):\n        cnt = 0\n        for j in adj[idx]:\n            if sol[j] == col:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def dsat_degree(idx):\n        # Distinct neighbor colors count\n        return len({sol[j] for j in adj[idx]})\n\n    def lowest_feasible_color(idx, allow_new=True):\n        used = {sol[j] for j in adj[idx]}\n        K = max(sol) if sol else 1\n        c = 1\n        best = None\n        limit = K if not allow_new else K + 1\n        while c <= limit:\n            if c not in used:\n                best = c\n                break\n            c += 1\n        if best is None:\n            # fallback keep or random within [1..limit]\n            best = sol[idx] if not allow_new else random.randint(1, limit)\n        return best\n\n    def kempe_chain_interchange(a_idx):\n        # Pick a second color b != color(a_idx), BFS swap within {a,b}\n        a = sol[a_idx]\n        colors = sorted(set(sol))\n        if len(colors) == 1:\n            return False\n        b = random.choice([c for c in colors if c != a])\n        # BFS over vertices reachable via edges that alternate in colors a\/b\n        visited = [False]*n\n        queue = [a_idx]\n        visited[a_idx] = True\n        component = []\n        while queue:\n            u = queue.pop()\n            component.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    queue.append(v)\n        # Swap colors a<->b on component\n        for u in component:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Move selection policy\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.5:\n        # Conflict-directed best-response on most saturated conflicted vertex\n        idx = max(bad, key=lambda i: (dsat_degree(i), len(adj[i])))\n        K = max(sol)\n        best_col = sol[idx]\n        best_score = (conflicts_of(idx, sol[idx]), sol[idx])\n        # Try colors within current palette first, then possibly K+1\n        candidates = list(range(1, K+1)) + [K+1]\n        rand_bias = random.random()\n        if rand_bias < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_of(idx, c), c)\n            if sc < best_score:\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[idx] = best_col\n        nb_type = \"feasible_bias\"; mv = \"best_response_recolor\"\n    elif r < 0.8:\n        # Kempe-chain interchange starting from a high-degree or conflicted vertex\n        if bad:\n            start = max(bad, key=lambda i: len(adj[i]))\n        else:\n            start = max(range(n), key=lambda i: len(adj[i]))\n        kempe_chain_interchange(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette reduction attempt\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            # single vertex recolor with palette-reduction constraint\n            idx = random.randrange(n)\n            sol[idx] = lowest_feasible_color(idx, allow_new=False)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Adaptive-strength perturbation combining conflict-biased recolors and Kempe kicks\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n        for i in range(n):\n            if not isinstance(sol[i], int) or sol[i] < 1:\n                sol[i] = 1\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS within {a,b}\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Determine strength based on conflicts\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    if base_conf == 0:\n        steps = max(2, K - 1)  # gentle shake when feasible\n    else:\n        steps = min(6, 3 + base_conf)  # stronger when infeasible\n\n    # Apply mixed perturbations\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # conflict-biased recolor\n            # pick vertex with highest local conflicts, tie by degree\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            # Kempe kick from random vertex\n            kempe_kick(random.randrange(n))\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c:i+1 for i,c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001449807}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate and evaluate coloring: lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, nb_type, movement)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Ensure valid base\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflicts_vertex(i, col=None):\n        c = sol[i] if col is None else col\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def kempe_chain(start):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start]\n        visited[start] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.6:\n        # DSATUR-like repair on most saturated conflicted vertex\n        i = max(bad, key=lambda t: (dsat(t), len(adj[t])))\n        K = max(sol)\n        best_col = sol[i]\n        best_score = (conflicts_vertex(i), sol[i])\n        # Prefer within current palette, allow K+1 only if strictly reduces conflicts\n        candidates = list(range(1, K+1)) + [K+1]\n        if random.random() < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_vertex(i, c), c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[i] = best_col\n        nb_type = \"intensification\"; mv = \"best_response_recolor\"\n    elif r < 0.85:\n        # Kempe-chain diversification\n        start = max(range(n), key=lambda i: (len(adj[i]), dsat(i)))\n        kempe_chain(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette-reducing recolor\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a: sol[i] = b\n                elif sol[i] == b: sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            i = random.randrange(n)\n            used = {sol[j] for j in adj[i]}\n            palette = [c for c in range(1, max(sol)+1) if c not in used]\n            if palette:\n                sol[i] = random.choice(palette)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Adaptive multi-step perturbation; returns a valid solution list\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.55:\n            # conflict-biased recolor of a vertex with highest local conflicts\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            kempe_kick(random.randrange(n))\n\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001666029}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate and evaluate coloring: lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, nb_type, movement)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Ensure valid base\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflicts_vertex(i, col=None):\n        c = sol[i] if col is None else col\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def kempe_chain(start):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start]\n        visited[start] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.6:\n        # DSATUR-like repair on most saturated conflicted vertex\n        i = max(bad, key=lambda t: (dsat(t), len(adj[t])))\n        K = max(sol)\n        best_col = sol[i]\n        best_score = (conflicts_vertex(i), sol[i])\n        # Prefer within current palette, allow K+1 only if strictly reduces conflicts\n        candidates = list(range(1, K+1)) + [K+1]\n        if random.random() < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_vertex(i, c), c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[i] = best_col\n        nb_type = \"intensification\"; mv = \"best_response_recolor\"\n    elif r < 0.85:\n        # Kempe-chain diversification\n        start = max(range(n), key=lambda i: (len(adj[i]), dsat(i)))\n        kempe_chain(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette-reducing recolor\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a: sol[i] = b\n                elif sol[i] == b: sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            i = random.randrange(n)\n            used = {sol[j] for j in adj[i]}\n            palette = [c for c in range(1, max(sol)+1) if c not in used]\n            if palette:\n                sol[i] = random.choice(palette)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Adaptive multi-step perturbation; returns a valid solution list\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.55:\n            # conflict-biased recolor of a vertex with highest local conflicts\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            kempe_kick(random.randrange(n))\n\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001508797}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate and evaluate coloring: lower is better.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, nb_type, movement)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Ensure valid base\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflicts_vertex(i, col=None):\n        c = sol[i] if col is None else col\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def conflicted_vertices():\n        bad = set()\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def kempe_chain(start):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start]\n        visited[start] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad = conflicted_vertices()\n    r = random.random()\n    if bad and r < 0.6:\n        # DSATUR-like repair on most saturated conflicted vertex\n        i = max(bad, key=lambda t: (dsat(t), len(adj[t])))\n        K = max(sol)\n        best_col = sol[i]\n        best_score = (conflicts_vertex(i), sol[i])\n        # Prefer within current palette, allow K+1 only if strictly reduces conflicts\n        candidates = list(range(1, K+1)) + [K+1]\n        if random.random() < 0.3:\n            random.shuffle(candidates)\n        for c in candidates:\n            sc = (conflicts_vertex(i, c), c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_col = c\n                if sc[0] == 0:\n                    break\n        sol[i] = best_col\n        nb_type = \"intensification\"; mv = \"best_response_recolor\"\n    elif r < 0.85:\n        # Kempe-chain diversification\n        start = max(range(n), key=lambda i: (len(adj[i]), dsat(i)))\n        kempe_chain(start)\n        nb_type = \"diversification\"; mv = \"kempe_chain\"\n    else:\n        # Color-class swap or palette-reducing recolor\n        colors = sorted(set(sol))\n        if len(colors) >= 2 and random.random() < 0.5:\n            a, b = random.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a: sol[i] = b\n                elif sol[i] == b: sol[i] = a\n            nb_type = \"diversification\"; mv = \"color_class_swap\"\n        else:\n            i = random.randrange(n)\n            used = {sol[j] for j in adj[i]}\n            palette = [c for c in range(1, max(sol)+1) if c not in used]\n            if palette:\n                sol[i] = random.choice(palette)\n            nb_type = \"intensification\"; mv = \"recolor_reduceK\"\n\n    # Canonical palette compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, nb_type, mv)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Adaptive multi-step perturbation; returns a valid solution list\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.55:\n            # conflict-biased recolor of a vertex with highest local conflicts\n            scores = []\n            for i in range(n):\n                lc = sum(1 for j in adj[i] if sol[j] == sol[i])\n                scores.append((lc, len(adj[i]), i))\n            i = max(range(n), key=lambda t: scores[t])\n            used = {sol[j] for j in adj[i]}\n            palette = list(range(1, max(sol)+2))\n            candidates = [c for c in palette if c not in used]\n            if candidates:\n                sol[i] = random.choice(candidates)\n            else:\n                sol[i] = random.randint(1, max(sol)+1)\n        else:\n            kempe_kick(random.randrange(n))\n\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001396736}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Heavy penalty for conflicts, then K, then tie-breaker on count using K.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, meta) where meta={'nb_type':..., 'movement':...}\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflict_edges(s):\n        return [(u-1, v-1) for (u,v) in E if s[u-1] == s[v-1]]\n\n    def vertex_conflicts(i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def try_recolor(i, allow_expand=False):\n        K = max(sol)\n        used = {sol[j] for j in adj[i]}\n        palette = list(range(1, K+1))\n        best_c = sol[i]\n        best_score = (vertex_conflicts(i), sol[i])\n        if allow_expand:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == sol[i]:\n                continue\n            conf = sum(1 for j in adj[i] if sol[j] == c)\n            sc = (conf, c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                # avoid expansion unless strictly better\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_c = c\n                if sc[0] == 0 and c <= K:\n                    break\n        sol[i] = best_c\n\n    def kempe_chain(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad_edges = conflict_edges(sol)\n    meta = {\"nb_type\":\"diversification\", \"movement\":\"noop\"}\n\n    if bad_edges:\n        # Repair: choose vertex with highest conflicts (tie: higher degree, higher dsat)\n        counts = [vertex_conflicts(i) for i in range(n)]\n        i = max(range(n), key=lambda t: (counts[t], len(adj[t]), dsat(t)))\n        before = counts[i]\n        try_recolor(i, allow_expand=False)\n        after = vertex_conflicts(i)\n        meta = {\"nb_type\":\"intensification\", \"movement\":\"best_response_recolor\"}\n        if after > before:\n            # rollback via Kempe if made worse\n            kempe_chain(i)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain_rollback\"}\n    else:\n        r = random.random()\n        if r < 0.5:\n            # Kempe chain on high-degree node\n            start = max(range(n), key=lambda i: len(adj[i]))\n            kempe_chain(start)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain\"}\n        elif r < 0.8:\n            # Attempt to reduce K by recoloring a vertex of max color\n            K = max(sol)\n            max_vertices = [i for i,c in enumerate(sol) if c == K]\n            if max_vertices:\n                i = random.choice(max_vertices)\n                try_recolor(i, allow_expand=False)\n                meta = {\"nb_type\":\"intensification\", \"movement\":\"palette_reduce_recolor\"}\n        else:\n            # Color class swap\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(n):\n                    if sol[i] == a:\n                        sol[i] = b\n                    elif sol[i] == b:\n                        sol[i] = a\n                meta = {\"nb_type\":\"diversification\", \"movement\":\"color_class_swap\"}\n\n    # Canonical compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, meta)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step perturbation; returns a valid list of 9 ints >=1\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.6:\n            # recolor vertex with highest local conflicts\n            lc = []\n            for i in range(n):\n                vconf = sum(1 for j in adj[i] if sol[j] == sol[i])\n                lc.append((vconf, len(adj[i]), i))\n            idx = max(range(n), key=lambda t: lc[t])\n            Kc = max(sol)\n            used = {sol[j] for j in adj[idx]}\n            cand = [c for c in range(1, Kc+1) if c not in used]\n            if not cand:\n                cand = [c for c in range(1, Kc+2) if c not in used]\n            sol[idx] = random.choice(cand)\n        else:\n            kempe_kick(random.randrange(n))\n\n    # Compress palette\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":[[1,3,2,1,3,2,3,1,2],3003,[1,2,3,1,2,3,2,1,3],3003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002438918}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Heavy penalty for conflicts, then K, then tie-breaker on count using K.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, meta) where meta={'nb_type':..., 'movement':...}\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflict_edges(s):\n        return [(u-1, v-1) for (u,v) in E if s[u-1] == s[v-1]]\n\n    def vertex_conflicts(i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def try_recolor(i, allow_expand=False):\n        K = max(sol)\n        used = {sol[j] for j in adj[i]}\n        palette = list(range(1, K+1))\n        best_c = sol[i]\n        best_score = (vertex_conflicts(i), sol[i])\n        if allow_expand:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == sol[i]:\n                continue\n            conf = sum(1 for j in adj[i] if sol[j] == c)\n            sc = (conf, c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                # avoid expansion unless strictly better\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_c = c\n                if sc[0] == 0 and c <= K:\n                    break\n        sol[i] = best_c\n\n    def kempe_chain(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad_edges = conflict_edges(sol)\n    meta = {\"nb_type\":\"diversification\", \"movement\":\"noop\"}\n\n    if bad_edges:\n        # Repair: choose vertex with highest conflicts (tie: higher degree, higher dsat)\n        counts = [vertex_conflicts(i) for i in range(n)]\n        i = max(range(n), key=lambda t: (counts[t], len(adj[t]), dsat(t)))\n        before = counts[i]\n        try_recolor(i, allow_expand=False)\n        after = vertex_conflicts(i)\n        meta = {\"nb_type\":\"intensification\", \"movement\":\"best_response_recolor\"}\n        if after > before:\n            # rollback via Kempe if made worse\n            kempe_chain(i)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain_rollback\"}\n    else:\n        r = random.random()\n        if r < 0.5:\n            # Kempe chain on high-degree node\n            start = max(range(n), key=lambda i: len(adj[i]))\n            kempe_chain(start)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain\"}\n        elif r < 0.8:\n            # Attempt to reduce K by recoloring a vertex of max color\n            K = max(sol)\n            max_vertices = [i for i,c in enumerate(sol) if c == K]\n            if max_vertices:\n                i = random.choice(max_vertices)\n                try_recolor(i, allow_expand=False)\n                meta = {\"nb_type\":\"intensification\", \"movement\":\"palette_reduce_recolor\"}\n        else:\n            # Color class swap\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(n):\n                    if sol[i] == a:\n                        sol[i] = b\n                    elif sol[i] == b:\n                        sol[i] = a\n                meta = {\"nb_type\":\"diversification\", \"movement\":\"color_class_swap\"}\n\n    # Canonical compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, meta)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step perturbation; returns a valid list of 9 ints >=1\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.6:\n            # recolor vertex with highest local conflicts\n            lc = []\n            for i in range(n):\n                vconf = sum(1 for j in adj[i] if sol[j] == sol[i])\n                lc.append((vconf, len(adj[i]), i))\n            idx = max(range(n), key=lambda t: lc[t])\n            Kc = max(sol)\n            used = {sol[j] for j in adj[idx]}\n            cand = [c for c in range(1, Kc+1) if c not in used]\n            if not cand:\n                cand = [c for c in range(1, Kc+2) if c not in used]\n            sol[idx] = random.choice(cand)\n        else:\n            kempe_kick(random.randrange(n))\n\n    # Compress palette\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3003,[1,2,3,1,2,3,2,1,3],3003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002355787}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Heavy penalty for conflicts, then K, then tie-breaker on count using K.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    count_highest = sum(1 for c in solution if c == K)\n    if conflicts > 0:\n        return 1_000_000 * conflicts + 1_000 * K + count_highest\n    return 1_000 * K + count_highest\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, meta) where meta={'nb_type':..., 'movement':...}\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def conflict_edges(s):\n        return [(u-1, v-1) for (u,v) in E if s[u-1] == s[v-1]]\n\n    def vertex_conflicts(i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def dsat(i):\n        return len({sol[j] for j in adj[i]})\n\n    def try_recolor(i, allow_expand=False):\n        K = max(sol)\n        used = {sol[j] for j in adj[i]}\n        palette = list(range(1, K+1))\n        best_c = sol[i]\n        best_score = (vertex_conflicts(i), sol[i])\n        if allow_expand:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == sol[i]:\n                continue\n            conf = sum(1 for j in adj[i] if sol[j] == c)\n            sc = (conf, c)\n            if sc[0] < best_score[0] or (sc[0] == best_score[0] and sc[1] < best_score[1]):\n                # avoid expansion unless strictly better\n                if c == K+1 and sc[0] >= best_score[0]:\n                    continue\n                best_score = sc\n                best_c = c\n                if sc[0] == 0 and c <= K:\n                    break\n        sol[i] = best_c\n\n    def kempe_chain(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return False\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return False\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    bad_edges = conflict_edges(sol)\n    meta = {\"nb_type\":\"diversification\", \"movement\":\"noop\"}\n\n    if bad_edges:\n        # Repair: choose vertex with highest conflicts (tie: higher degree, higher dsat)\n        counts = [vertex_conflicts(i) for i in range(n)]\n        i = max(range(n), key=lambda t: (counts[t], len(adj[t]), dsat(t)))\n        before = counts[i]\n        try_recolor(i, allow_expand=False)\n        after = vertex_conflicts(i)\n        meta = {\"nb_type\":\"intensification\", \"movement\":\"best_response_recolor\"}\n        if after > before:\n            # rollback via Kempe if made worse\n            kempe_chain(i)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain_rollback\"}\n    else:\n        r = random.random()\n        if r < 0.5:\n            # Kempe chain on high-degree node\n            start = max(range(n), key=lambda i: len(adj[i]))\n            kempe_chain(start)\n            meta = {\"nb_type\":\"diversification\", \"movement\":\"kempe_chain\"}\n        elif r < 0.8:\n            # Attempt to reduce K by recoloring a vertex of max color\n            K = max(sol)\n            max_vertices = [i for i,c in enumerate(sol) if c == K]\n            if max_vertices:\n                i = random.choice(max_vertices)\n                try_recolor(i, allow_expand=False)\n                meta = {\"nb_type\":\"intensification\", \"movement\":\"palette_reduce_recolor\"}\n        else:\n            # Color class swap\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(n):\n                    if sol[i] == a:\n                        sol[i] = b\n                    elif sol[i] == b:\n                        sol[i] = a\n                meta = {\"nb_type\":\"diversification\", \"movement\":\"color_class_swap\"}\n\n    # Canonical compression\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return (sol, meta)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step perturbation; returns a valid list of 9 ints >=1\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in solution]\n\n    def count_conflicts(s):\n        c = 0\n        for (u,v) in E:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n\n    def kempe_kick(start_idx):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return\n        a = sol[start_idx]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        stack = [start_idx]\n        visited[start_idx] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    base_conf = count_conflicts(sol)\n    K = max(sol) if sol else 1\n    steps = max(2, K - 1) if base_conf == 0 else min(6, 3 + base_conf)\n\n    for _ in range(steps):\n        if random.random() < 0.6:\n            # recolor vertex with highest local conflicts\n            lc = []\n            for i in range(n):\n                vconf = sum(1 for j in adj[i] if sol[j] == sol[i])\n                lc.append((vconf, len(adj[i]), i))\n            idx = max(range(n), key=lambda t: lc[t])\n            Kc = max(sol)\n            used = {sol[j] for j in adj[idx]}\n            cand = [c for c in range(1, Kc+1) if c not in used]\n            if not cand:\n                cand = [c for c in range(1, Kc+2) if c not in used]\n            sol[idx] = random.choice(cand)\n        else:\n            kempe_kick(random.randrange(n))\n\n    # Compress palette\n    present = sorted(set(sol))\n    remap = {c: idx+1 for idx, c in enumerate(present)}\n    sol = [remap[c] for c in sol]\n\n    return sol\n","Resultados":[[2,3,1,2,3,1,3,2,1],3003,[1,2,3,1,2,3,2,1,3],3003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002326406}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1: solution[i-1] gives color of vertex i; objective k=max(solution); proper iff for all edges (u,v) colors differ.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\nrandom.seed()\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a descriptor tuple (NB_Type, Movement_Type).\n    Side-effect free; computes an internal neighbour but does not return it to comply with required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    \"\"\"\n    # Internal safe construction (not returned): recolor one vertex to another existing color or a new color\n    try:\n        n = 9\n        if not isinstance(solution, list) or len(solution) != n:\n            return (\"ListRecolor\",\"Recolor-One\")\n        if not all(isinstance(x, int) and x >= 1 for x in solution):\n            return (\"ListRecolor\",\"Recolor-One\")\n        max_c = max(solution) if solution else 1\n        idx = random.randrange(n)\n        current_color = solution[idx]\n        # Candidate colors: keep diversity; allow up to max_c+1\n        candidates = list(range(1, max_c + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        _new_color = random.choice(candidates) if candidates else current_color\n        _ = solution[:]\n        _[idx] = _new_color\n    finally:\n        return (\"ListRecolor\",\"Recolor-One\")\n","Perturbacion":"import random\nfrom typing import List\n\nrandom.seed()\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color max+1.\n    Returns a new solution list of length 9 with colors >=1.\n    \"\"\"\n    # Embedded problem data for feasibility-aware tweaks (no external refs)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # If invalid, initialize a random feasible-ish starting point (greedy coloring)\n        colors = [0]*n\n        max_color = 0\n        for v in range(1, n+1):\n            used = set()\n            for (u,w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            if c > max_color:\n                max_color = c\n        solution = colors\n    new_sol = solution[:]\n    max_c = max(new_sol)\n    # Number of vertices to perturb: 2..4\n    p = random.randint(2, 4)\n    idxs = random.sample(range(n), p)\n    for idx in idxs:\n        current = new_sol[idx]\n        # Occasionally allow introducing a new color to escape local minima\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = list(range(1, upper + 1))\n        if current in candidates:\n            candidates.remove(current)\n        if not candidates:\n            continue\n        new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000757049}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1: solution[i-1] gives color of vertex i; objective k=max(solution); proper iff for all edges (u,v) colors differ.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\nrandom.seed()\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a descriptor tuple (NB_Type, Movement_Type).\n    Side-effect free; computes an internal neighbour but does not return it to comply with required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    \"\"\"\n    # Internal safe construction (not returned): recolor one vertex to another existing color or a new color\n    try:\n        n = 9\n        if not isinstance(solution, list) or len(solution) != n:\n            return (\"ListRecolor\",\"Recolor-One\")\n        if not all(isinstance(x, int) and x >= 1 for x in solution):\n            return (\"ListRecolor\",\"Recolor-One\")\n        max_c = max(solution) if solution else 1\n        idx = random.randrange(n)\n        current_color = solution[idx]\n        # Candidate colors: keep diversity; allow up to max_c+1\n        candidates = list(range(1, max_c + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        _new_color = random.choice(candidates) if candidates else current_color\n        _ = solution[:]\n        _[idx] = _new_color\n    finally:\n        return (\"ListRecolor\",\"Recolor-One\")\n","Perturbacion":"import random\nfrom typing import List\n\nrandom.seed()\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color max+1.\n    Returns a new solution list of length 9 with colors >=1.\n    \"\"\"\n    # Embedded problem data for feasibility-aware tweaks (no external refs)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # If invalid, initialize a random feasible-ish starting point (greedy coloring)\n        colors = [0]*n\n        max_color = 0\n        for v in range(1, n+1):\n            used = set()\n            for (u,w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            if c > max_color:\n                max_color = c\n        solution = colors\n    new_sol = solution[:]\n    max_c = max(new_sol)\n    # Number of vertices to perturb: 2..4\n    p = random.randint(2, 4)\n    idxs = random.sample(range(n), p)\n    for idx in idxs:\n        current = new_sol[idx]\n        # Occasionally allow introducing a new color to escape local minima\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = list(range(1, upper + 1))\n        if current in candidates:\n            candidates.remove(current)\n        if not candidates:\n            continue\n        new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000671207}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1: solution[i-1] gives color of vertex i; objective k=max(solution); proper iff for all edges (u,v) colors differ.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Constraint check\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\nrandom.seed()\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a descriptor tuple (NB_Type, Movement_Type).\n    Side-effect free; computes an internal neighbour but does not return it to comply with required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    \"\"\"\n    # Internal safe construction (not returned): recolor one vertex to another existing color or a new color\n    try:\n        n = 9\n        if not isinstance(solution, list) or len(solution) != n:\n            return (\"ListRecolor\",\"Recolor-One\")\n        if not all(isinstance(x, int) and x >= 1 for x in solution):\n            return (\"ListRecolor\",\"Recolor-One\")\n        max_c = max(solution) if solution else 1\n        idx = random.randrange(n)\n        current_color = solution[idx]\n        # Candidate colors: keep diversity; allow up to max_c+1\n        candidates = list(range(1, max_c + 2))\n        if current_color in candidates:\n            candidates.remove(current_color)\n        _new_color = random.choice(candidates) if candidates else current_color\n        _ = solution[:]\n        _[idx] = _new_color\n    finally:\n        return (\"ListRecolor\",\"Recolor-One\")\n","Perturbacion":"import random\nfrom typing import List\n\nrandom.seed()\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color max+1.\n    Returns a new solution list of length 9 with colors >=1.\n    \"\"\"\n    # Embedded problem data for feasibility-aware tweaks (no external refs)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # If invalid, initialize a random feasible-ish starting point (greedy coloring)\n        colors = [0]*n\n        max_color = 0\n        for v in range(1, n+1):\n            used = set()\n            for (u,w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            if c > max_color:\n                max_color = c\n        solution = colors\n    new_sol = solution[:]\n    max_c = max(new_sol)\n    # Number of vertices to perturb: 2..4\n    p = random.randint(2, 4)\n    idxs = random.sample(range(n), p)\n    for idx in idxs:\n        current = new_sol[idx]\n        # Occasionally allow introducing a new color to escape local minima\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = list(range(1, upper + 1))\n        if current in candidates:\n            candidates.remove(current)\n        if not candidates:\n            continue\n        new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000728528}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    return (\"ListRecolor\", \"Recolor-One\")\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    def greedy_build():\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n    max_c = max(new_sol)\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for idx in idxs:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != current]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000773399}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    return (\"ListRecolor\", \"Recolor-One\")\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    def greedy_build():\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n    max_c = max(new_sol)\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for idx in idxs:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != current]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000652717}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type: 'ListRecolor'\n    Movement_Type: 'Recolor-One'\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    return (\"ListRecolor\", \"Recolor-One\")\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    def greedy_build():\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n    max_c = max(new_sol)\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for idx in idxs:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != current]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000641297}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1; solution[i-1] is the color (party) assigned to vertex i (1..9). Objective is k = max(solution).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 1e9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00092658}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1; solution[i-1] is the color (party) assigned to vertex i (1..9). Objective is k = max(solution).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 1e9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000805669}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1; solution[i-1] is the color (party) assigned to vertex i (1..9). Objective is k = max(solution).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 1e9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n    return new_sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000786009}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    _ = solution  # unused; descriptor-only by spec\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    def relabel_compact(col):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 10**9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n\n    return relabel_compact(new_sol)\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000938311}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    _ = solution  # unused; descriptor-only by spec\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    def relabel_compact(col):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 10**9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n\n    return relabel_compact(new_sol)\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000837969}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_START_1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns fitness value (lower is better): k + alpha*conflicts\n    - solution: list of 9 positive ints; solution[i-1] is color of vertex i (1-indexed)\n    - Graph edges embedded internally.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    alpha = 10\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**6\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6\n    # Compute conflicts and k\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    return k + alpha * conflicts\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Descriptor-only neighbour generator per required signature.\n    NB_Type in {ListRecolor, KempeChain, ColorSwap}\n    Movement_Type in {Recolor-One, Swap-ColorPair, Swap-Chain}\n    Side-effect free; does not modify 'solution'.\n    \"\"\"\n    _ = solution  # unused; descriptor-only by spec\n    nb_types = [\n        (\"ListRecolor\", \"Recolor-One\"),\n        (\"KempeChain\", \"Swap-Chain\"),\n        (\"ColorSwap\", \"Swap-ColorPair\"),\n    ]\n    return random.choice(nb_types)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: recolor a random subset of vertices; may introduce a new color.\n    If input is invalid, builds a greedy feasible solution first.\n    Returns a new list of length 9.\n    \"\"\"\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def greedy_build():\n        # Simple greedy by vertex index\n        colors = [0]*n\n        for v in range(1, n+1):\n            used = set()\n            for (u, w) in E:\n                if u == v and colors[w-1] > 0:\n                    used.add(colors[w-1])\n                elif w == v and colors[u-1] > 0:\n                    used.add(colors[u-1])\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n        return colors\n\n    def conflict_vertices(col):\n        cnt = [0]*n\n        for (u, v) in E:\n            if col[u-1] == col[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n        return cnt\n\n    def relabel_compact(col):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    base = solution[:] if valid else greedy_build()\n    new_sol = base[:]\n\n    # Focus on conflicting or high-degree vertices\n    conf_cnt = conflict_vertices(new_sol)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (-conf_cnt[i], random.random()))\n\n    max_c = max(new_sol)\n\n    # number of vertices to perturb (2..4)\n    t = random.randint(2, 4)\n    chosen = vertices[:t]\n\n    for idx in chosen:\n        current = new_sol[idx]\n        allow_new = random.random() < 0.35\n        upper = max_c + (1 if allow_new else 0)\n        # Prefer colors that reduce local conflicts\n        best_colors = []\n        best_score = 10**9\n        for c in range(1, upper+1):\n            if c == current:\n                continue\n            local_conf = 0\n            for (u, v) in E:\n                if u-1 == idx:\n                    if c == new_sol[v-1]:\n                        local_conf += 1\n                elif v-1 == idx:\n                    if c == new_sol[u-1]:\n                        local_conf += 1\n            if local_conf < best_score:\n                best_score = local_conf\n                best_colors = [c]\n            elif local_conf == best_score:\n                best_colors.append(c)\n        if best_colors:\n            new_c = random.choice(best_colors)\n            if new_c > max_c:\n                max_c = new_c\n            new_sol[idx] = new_c\n\n    return relabel_compact(new_sol)\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000770168}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Robust evaluation: lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element\/domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len({x for x in solution if isinstance(x, int) and x >= 1})\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (neighbor_solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n\n    sol = list(solution)\n\n    idx = random.randrange(n)\n    current_color = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1:\n            if x > max_color:\n                max_color = x\n    # Allow exploring one new color occasionally\n    allow_new_color = random.random() < 0.3\n    color_choices = list(range(1, max_color + (1 if allow_new_color else 0) + 1))\n    # Ensure a different color is selected if possible\n    if len(color_choices) > 1 and current_color in color_choices:\n        color_choices.remove(current_color)\n    new_color = random.choice(color_choices) if color_choices else current_color\n    sol[idx] = int(new_color) if isinstance(new_color, int) else current_color\n\n    return (sol, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger kick: recolor a random subset of vertices and optionally introduce a new color\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    sol = list(solution)\n\n    # Determine current max color\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1 and x > max_color:\n            max_color = x\n\n    # Number of vertices to perturb\n    m = max(1, int(0.3 * n))\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:m]\n\n    # With small prob, allow a new color to escape local minima\n    allow_new = random.random() < 0.5\n    palette_max = max_color + (1 if allow_new else 0)\n    palette = list(range(1, palette_max + 1))\n\n    for idx in indices:\n        curr = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n        choices = [c for c in palette if c != curr] or [curr]\n        sol[idx] = random.choice(choices)\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000824599}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Robust evaluation: lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element\/domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len({x for x in solution if isinstance(x, int) and x >= 1})\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (neighbor_solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n\n    sol = list(solution)\n\n    idx = random.randrange(n)\n    current_color = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1:\n            if x > max_color:\n                max_color = x\n    # Allow exploring one new color occasionally\n    allow_new_color = random.random() < 0.3\n    color_choices = list(range(1, max_color + (1 if allow_new_color else 0) + 1))\n    # Ensure a different color is selected if possible\n    if len(color_choices) > 1 and current_color in color_choices:\n        color_choices.remove(current_color)\n    new_color = random.choice(color_choices) if color_choices else current_color\n    sol[idx] = int(new_color) if isinstance(new_color, int) else current_color\n\n    return (sol, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger kick: recolor a random subset of vertices and optionally introduce a new color\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    sol = list(solution)\n\n    # Determine current max color\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1 and x > max_color:\n            max_color = x\n\n    # Number of vertices to perturb\n    m = max(1, int(0.3 * n))\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:m]\n\n    # With small prob, allow a new color to escape local minima\n    allow_new = random.random() < 0.5\n    palette_max = max_color + (1 if allow_new else 0)\n    palette = list(range(1, palette_max + 1))\n\n    for idx in indices:\n        curr = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n        choices = [c for c in palette if c != curr] or [curr]\n        sol[idx] = random.choice(choices)\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.000697448}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Robust evaluation: lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element\/domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len({x for x in solution if isinstance(x, int) and x >= 1})\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns: (neighbor_solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n\n    sol = list(solution)\n\n    idx = random.randrange(n)\n    current_color = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1:\n            if x > max_color:\n                max_color = x\n    # Allow exploring one new color occasionally\n    allow_new_color = random.random() < 0.3\n    color_choices = list(range(1, max_color + (1 if allow_new_color else 0) + 1))\n    # Ensure a different color is selected if possible\n    if len(color_choices) > 1 and current_color in color_choices:\n        color_choices.remove(current_color)\n    new_color = random.choice(color_choices) if color_choices else current_color\n    sol[idx] = int(new_color) if isinstance(new_color, int) else current_color\n\n    return (sol, \"NB_RandomRecolor\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger kick: recolor a random subset of vertices and optionally introduce a new color\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    sol = list(solution)\n\n    # Determine current max color\n    max_color = 1\n    for x in sol:\n        if isinstance(x, int) and x >= 1 and x > max_color:\n            max_color = x\n\n    # Number of vertices to perturb\n    m = max(1, int(0.3 * n))\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:m]\n\n    # With small prob, allow a new color to escape local minima\n    allow_new = random.random() < 0.5\n    palette_max = max_color + (1 if allow_new else 0)\n    palette = list(range(1, palette_max + 1))\n\n    for idx in indices:\n        curr = sol[idx] if isinstance(sol[idx], int) and sol[idx] >= 1 else 1\n        choices = [c for c in palette if c != curr] or [curr]\n        sol[idx] = random.choice(choices)\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000688717}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with guarded color introduction\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate input and repair non-positive\/non-int entries to 1\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    if len(solution) != n:\n        # Return unchanged if structurally invalid; upstream should handle\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute current conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Candidate vertex: pick conflicted vertex if any, else random\n    conflicted_vertices = [i for i in range(n) if conflicts[i] > 0]\n    if conflicted_vertices:\n        v = random.choice(conflicted_vertices)\n    else:\n        v = random.randrange(n)\n\n    # Current palette and max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    # Evaluate conflicts if v were assigned color c\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Generate candidate colors\n    palette = list(range(1, max_color + 1))\n\n    # Guard: do not introduce new color if there are no violations\n    allow_new_color = (total_viol > 0)\n\n    best_color = current_color\n    best_conf = conflicts_if_color(v, current_color)\n\n    # Try existing colors first\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n            if best_conf == 0:\n                break\n\n    # If still conflicted and allowed, consider introducing one new color\n    if best_conf > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    return (sol, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    if len(solution) != n:\n        return list(solution)\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine current max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if max_color < 2:\n        # Nothing meaningful to swap; recolor a random vertex to color 1\n        idx = random.randrange(n)\n        sol[idx] = 1\n        return sol\n\n    # Repeat a few Kempe-chain swaps\n    repeats = 2\n\n    for _ in range(repeats):\n        # Pick two distinct colors present (or allow a new color with small prob)\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if len(colors_present) == 0:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            # optionally introduce a new color if only one present\n            c2 = c1 + 1\n        else:\n            c2 = random.choice(c2_choices)\n\n        # Pick a random start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get the Kempe chain component in subgraph induced by {c1, c2}\n        comp = []\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        valid_colors = {c1, c2}\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in valid_colors:\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in valid_colors:\n                    seen[nb] = True\n                    dq.append(nb)\n\n        # Swap colors c1 <-> c2 within the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001346245}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with guarded color introduction\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate input and repair non-positive\/non-int entries to 1\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    if len(solution) != n:\n        # Return unchanged if structurally invalid; upstream should handle\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute current conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Candidate vertex: pick conflicted vertex if any, else random\n    conflicted_vertices = [i for i in range(n) if conflicts[i] > 0]\n    if conflicted_vertices:\n        v = random.choice(conflicted_vertices)\n    else:\n        v = random.randrange(n)\n\n    # Current palette and max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    # Evaluate conflicts if v were assigned color c\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Generate candidate colors\n    palette = list(range(1, max_color + 1))\n\n    # Guard: do not introduce new color if there are no violations\n    allow_new_color = (total_viol > 0)\n\n    best_color = current_color\n    best_conf = conflicts_if_color(v, current_color)\n\n    # Try existing colors first\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n            if best_conf == 0:\n                break\n\n    # If still conflicted and allowed, consider introducing one new color\n    if best_conf > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    return (sol, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    if len(solution) != n:\n        return list(solution)\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine current max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if max_color < 2:\n        # Nothing meaningful to swap; recolor a random vertex to color 1\n        idx = random.randrange(n)\n        sol[idx] = 1\n        return sol\n\n    # Repeat a few Kempe-chain swaps\n    repeats = 2\n\n    for _ in range(repeats):\n        # Pick two distinct colors present (or allow a new color with small prob)\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if len(colors_present) == 0:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            # optionally introduce a new color if only one present\n            c2 = c1 + 1\n        else:\n            c2 = random.choice(c2_choices)\n\n        # Pick a random start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get the Kempe chain component in subgraph induced by {c1, c2}\n        comp = []\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        valid_colors = {c1, c2}\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in valid_colors:\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in valid_colors:\n                    seen[nb] = True\n                    dq.append(nb)\n\n        # Swap colors c1 <-> c2 within the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001194333}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with guarded color introduction\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate input and repair non-positive\/non-int entries to 1\n    if not isinstance(solution, (list, tuple)):\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n    if len(solution) != n:\n        # Return unchanged if structurally invalid; upstream should handle\n        return (solution, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute current conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Candidate vertex: pick conflicted vertex if any, else random\n    conflicted_vertices = [i for i in range(n) if conflicts[i] > 0]\n    if conflicted_vertices:\n        v = random.choice(conflicted_vertices)\n    else:\n        v = random.randrange(n)\n\n    # Current palette and max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    # Evaluate conflicts if v were assigned color c\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Generate candidate colors\n    palette = list(range(1, max_color + 1))\n\n    # Guard: do not introduce new color if there are no violations\n    allow_new_color = (total_viol > 0)\n\n    best_color = current_color\n    best_conf = conflicts_if_color(v, current_color)\n\n    # Try existing colors first\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n            if best_conf == 0:\n                break\n\n    # If still conflicted and allowed, consider introducing one new color\n    if best_conf > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        if c_conf < best_conf:\n            best_conf = c_conf\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    return (sol, \"NB_ConflictDirected\", \"Move_SingleVertexRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    if len(solution) != n:\n        return list(solution)\n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine current max color\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if max_color < 2:\n        # Nothing meaningful to swap; recolor a random vertex to color 1\n        idx = random.randrange(n)\n        sol[idx] = 1\n        return sol\n\n    # Repeat a few Kempe-chain swaps\n    repeats = 2\n\n    for _ in range(repeats):\n        # Pick two distinct colors present (or allow a new color with small prob)\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if len(colors_present) == 0:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            # optionally introduce a new color if only one present\n            c2 = c1 + 1\n        else:\n            c2 = random.choice(c2_choices)\n\n        # Pick a random start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get the Kempe chain component in subgraph induced by {c1, c2}\n        comp = []\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        valid_colors = {c1, c2}\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in valid_colors:\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in valid_colors:\n                    seen[nb] = True\n                    dq.append(nb)\n\n        # Swap colors c1 <-> c2 within the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001150602}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with tie-breaking and guarded color introduction\n# Returns only the neighbor solution to satisfy common drivers expecting 1-value return\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        return list(solution) if isinstance(solution, list) else [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Choose vertex: prioritize by max conflicts then by degree\n    if any(c > 0 for c in conflicts):\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        # break ties by degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in cand)\n        cand = [i for i in cand if deg[i] == best_deg]\n        v = random.choice(cand)\n    else:\n        v = random.randrange(n)\n\n    # Palette info\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Existing palette first\n    palette = list(range(1, max_color + 1))\n    allow_new_color = (total_viol > 0)\n\n    # Evaluate color moves with slight bias against introducing new colors\n    best_color = current_color\n    best_tuple = (conflicts_if_color(v, current_color), 0, current_color)  # (conflicts, new_color_penalty, color_id)\n\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 0, c)\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n            if c_conf == 0:\n                break\n\n    # Consider one new color only if still conflicted\n    if best_tuple[0] > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 1, c)  # penalize new color\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    # Optional color compaction to avoid label drift\n    # Remap colors to 1..k_used in order of appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        sol[i] = seen[c]\n\n    return sol\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine colors present\n    colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n    if len(colors_present) < 2:\n        # random recolor a couple of vertices\n        for _ in range(2):\n            idx = random.randrange(n)\n            sol[idx] = 1\n        return sol\n\n    repeats = 2  # small controlled perturbation\n    for _ in range(repeats):\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if not colors_present:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            break\n        c2 = random.choice(c2_choices)\n\n        # pick a start vertex with color in {c1,c2}\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get Kempe chain component induced by {c1,c2}\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        # swap colors on the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    # Compact colors after perturbation\n    seen_map = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen_map:\n            seen_map[c] = nxt\n            nxt += 1\n        sol[i] = seen_map[c]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001457766}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with tie-breaking and guarded color introduction\n# Returns only the neighbor solution to satisfy common drivers expecting 1-value return\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        return list(solution) if isinstance(solution, list) else [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Choose vertex: prioritize by max conflicts then by degree\n    if any(c > 0 for c in conflicts):\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        # break ties by degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in cand)\n        cand = [i for i in cand if deg[i] == best_deg]\n        v = random.choice(cand)\n    else:\n        v = random.randrange(n)\n\n    # Palette info\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Existing palette first\n    palette = list(range(1, max_color + 1))\n    allow_new_color = (total_viol > 0)\n\n    # Evaluate color moves with slight bias against introducing new colors\n    best_color = current_color\n    best_tuple = (conflicts_if_color(v, current_color), 0, current_color)  # (conflicts, new_color_penalty, color_id)\n\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 0, c)\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n            if c_conf == 0:\n                break\n\n    # Consider one new color only if still conflicted\n    if best_tuple[0] > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 1, c)  # penalize new color\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    # Optional color compaction to avoid label drift\n    # Remap colors to 1..k_used in order of appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        sol[i] = seen[c]\n\n    return sol\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine colors present\n    colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n    if len(colors_present) < 2:\n        # random recolor a couple of vertices\n        for _ in range(2):\n            idx = random.randrange(n)\n            sol[idx] = 1\n        return sol\n\n    repeats = 2  # small controlled perturbation\n    for _ in range(repeats):\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if not colors_present:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            break\n        c2 = random.choice(c2_choices)\n\n        # pick a start vertex with color in {c1,c2}\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get Kempe chain component induced by {c1,c2}\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        # swap colors on the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    # Compact colors after perturbation\n    seen_map = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen_map:\n            seen_map[c] = nxt\n            nxt += 1\n        sol[i] = seen_map[c]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001294224}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better (lexicographic: structure\/domain >> violations >> colors used)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Fitness: strict lexicographic scaling\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"import random\n\n# Conflict-directed least-conflicts neighbor with tie-breaking and guarded color introduction\n# Returns only the neighbor solution to satisfy common drivers expecting 1-value return\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        return list(solution) if isinstance(solution, list) else [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Choose vertex: prioritize by max conflicts then by degree\n    if any(c > 0 for c in conflicts):\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        # break ties by degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in cand)\n        cand = [i for i in cand if deg[i] == best_deg]\n        v = random.choice(cand)\n    else:\n        v = random.randrange(n)\n\n    # Palette info\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    current_color = sol[v]\n\n    def conflicts_if_color(vtx, color):\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Existing palette first\n    palette = list(range(1, max_color + 1))\n    allow_new_color = (total_viol > 0)\n\n    # Evaluate color moves with slight bias against introducing new colors\n    best_color = current_color\n    best_tuple = (conflicts_if_color(v, current_color), 0, current_color)  # (conflicts, new_color_penalty, color_id)\n\n    for c in palette:\n        if c == current_color:\n            continue\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 0, c)\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n            if c_conf == 0:\n                break\n\n    # Consider one new color only if still conflicted\n    if best_tuple[0] > 0 and allow_new_color:\n        c = max_color + 1\n        c_conf = conflicts_if_color(v, c)\n        cand_tuple = (c_conf, 1, c)  # penalize new color\n        if cand_tuple < best_tuple:\n            best_tuple = cand_tuple\n            best_color = c\n\n    # Apply move\n    sol[v] = best_color\n\n    # Optional color compaction to avoid label drift\n    # Remap colors to 1..k_used in order of appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        sol[i] = seen[c]\n\n    return sol\n","Perturbacion":"import random\nfrom collections import deque\n\n# Kempe-chain based perturbation to escape local minima\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return [1]*n\n    if len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Determine colors present\n    colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n    if len(colors_present) < 2:\n        # random recolor a couple of vertices\n        for _ in range(2):\n            idx = random.randrange(n)\n            sol[idx] = 1\n        return sol\n\n    repeats = 2  # small controlled perturbation\n    for _ in range(repeats):\n        colors_present = sorted({c for c in sol if isinstance(c, int) and c >= 1})\n        if not colors_present:\n            break\n        c1 = random.choice(colors_present)\n        c2_choices = [c for c in colors_present if c != c1]\n        if not c2_choices:\n            break\n        c2 = random.choice(c2_choices)\n\n        # pick a start vertex with color in {c1,c2}\n        candidates = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n\n        # BFS to get Kempe chain component induced by {c1,c2}\n        seen = [False]*n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        # swap colors on the component\n        for u in comp:\n            sol[u] = c1 if sol[u] == c2 else (c2 if sol[u] == c1 else sol[u])\n\n    # Compact colors after perturbation\n    seen_map = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in seen_map:\n            seen_map[c] = nxt\n            nxt += 1\n        sol[i] = seen_map[c]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001208013}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos_neg = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**4  # keep lexicographic dominance while preventing dwarfing other terms\n\n    # Fitness: strict lexicographic scaling (lower is better)\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos_neg * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"from typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic conflict-directed neighbor with optional guarded color introduction and color-reduction when feasible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce to internal list\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency and degrees\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    degree = [len(adj[i]) for i in range(n)]\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Helper: conflicts if vertex vtx takes color c\n    def conflicts_if_color(vtx: int, color: int) -> int:\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Current palette\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if total_viol > 0:\n        # Select a most-conflicted vertex; tie-break by higher degree then smallest index for determinism\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n\n        current_color = sol[v]\n        best_color = current_color\n        best_tuple = (conflicts_if_color(v, current_color), 1, current_color)  # (conflicts, new_color_penalty, color_id)\n\n        # Try existing colors first\n        for c in range(1, max_color + 1):\n            if c == current_color:\n                continue\n            c_conf = conflicts_if_color(v, c)\n            cand_tuple = (c_conf, 0, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c\n                if c_conf == 0:\n                    break  # optimal for this vertex\n\n        # Guarded new color if still conflicted under all existing colors\n        if best_tuple[0] > 0:\n            c_new = max_color + 1\n            # This will always be 0 conflicts by construction\n            cand_tuple = (0, 1, c_new)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c_new\n\n        sol[v] = best_color\n        return sol\n\n    # If no conflicts: attempt deterministic color reduction\n    # Try to recolor vertices that use the maximum color down to a lower feasible color\n    max_color = 1\n    for c in sol:\n        if c > max_color:\n            max_color = c\n    if max_color > 1:\n        max_color_vertices = [i for i, c in enumerate(sol) if c == max_color]\n        for v in sorted(max_color_vertices):\n            for c in range(1, max_color):\n                if conflicts_if_color(v, c) == 0:\n                    sol[v] = c\n                    return sol\n    # Fallback: try any vertex with any lower feasible color\n    for v in range(n):\n        c0 = sol[v]\n        for c in range(1, c0):\n            if conflicts_if_color(v, c) == 0:\n                sol[v] = c\n                return sol\n    # If no move possible, return the solution unchanged (still a valid neighbor contract)\n    return sol\n","Perturbacion":"from collections import deque\n\n\ndef perturb_solution(solution):\n    # Deterministic Kempe-chain perturbation to escape local minima while preserving constraints when possible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    def kempe_chain(start: int, c1: int, c2: int):\n        seen = [False] * n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        for u in comp:\n            if sol[u] == c1:\n                sol[u] = c2\n            elif sol[u] == c2:\n                sol[u] = c1\n\n    if total_viol > 0:\n        # Pick most conflicted vertex, tiebreak by degree then index\n        degree = [len(adj[i]) for i in range(n)]\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n        c1 = sol[v]\n        # Choose c2 as the smallest color among neighbors conflicting with v; if none, pick smallest neighbor color\n        nb_colors = sorted(set(sol[nb] for nb in adj[v]))\n        if nb_colors:\n            c2 = nb_colors[0] if nb_colors[0] != c1 else (nb_colors[1] if len(nb_colors) > 1 else nb_colors[0])\n        else:\n            c2 = c1 + 1\n        if c2 == c1:\n            c2 = c1 + 1\n        kempe_chain(v, c1, c2)\n        return sol\n\n    # Feasible: perform a Kempe swap between max color and lowest color to encourage palette compression\n    max_color = max(sol) if sol else 1\n    if max_color > 1:\n        # pick first vertex with max_color\n        start_candidates = [i for i, c in enumerate(sol) if c == max_color]\n        if start_candidates:\n            start = min(start_candidates)\n            c1 = max_color\n            c2 = 1 if 1 != c1 else 2\n            kempe_chain(start, c1, c2)\n            return sol\n\n    # Fallback: simple recolor of first vertex to color 1 if safe\n    for i in range(n):\n        ok = True\n        for nb in adj[i]:\n            if sol[nb] == 1:\n                ok = False\n                break\n        if ok:\n            sol[i] = 1\n            break\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001606737}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos_neg = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**4  # keep lexicographic dominance while preventing dwarfing other terms\n\n    # Fitness: strict lexicographic scaling (lower is better)\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos_neg * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"from typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic conflict-directed neighbor with optional guarded color introduction and color-reduction when feasible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce to internal list\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency and degrees\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    degree = [len(adj[i]) for i in range(n)]\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Helper: conflicts if vertex vtx takes color c\n    def conflicts_if_color(vtx: int, color: int) -> int:\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Current palette\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if total_viol > 0:\n        # Select a most-conflicted vertex; tie-break by higher degree then smallest index for determinism\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n\n        current_color = sol[v]\n        best_color = current_color\n        best_tuple = (conflicts_if_color(v, current_color), 1, current_color)  # (conflicts, new_color_penalty, color_id)\n\n        # Try existing colors first\n        for c in range(1, max_color + 1):\n            if c == current_color:\n                continue\n            c_conf = conflicts_if_color(v, c)\n            cand_tuple = (c_conf, 0, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c\n                if c_conf == 0:\n                    break  # optimal for this vertex\n\n        # Guarded new color if still conflicted under all existing colors\n        if best_tuple[0] > 0:\n            c_new = max_color + 1\n            # This will always be 0 conflicts by construction\n            cand_tuple = (0, 1, c_new)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c_new\n\n        sol[v] = best_color\n        return sol\n\n    # If no conflicts: attempt deterministic color reduction\n    # Try to recolor vertices that use the maximum color down to a lower feasible color\n    max_color = 1\n    for c in sol:\n        if c > max_color:\n            max_color = c\n    if max_color > 1:\n        max_color_vertices = [i for i, c in enumerate(sol) if c == max_color]\n        for v in sorted(max_color_vertices):\n            for c in range(1, max_color):\n                if conflicts_if_color(v, c) == 0:\n                    sol[v] = c\n                    return sol\n    # Fallback: try any vertex with any lower feasible color\n    for v in range(n):\n        c0 = sol[v]\n        for c in range(1, c0):\n            if conflicts_if_color(v, c) == 0:\n                sol[v] = c\n                return sol\n    # If no move possible, return the solution unchanged (still a valid neighbor contract)\n    return sol\n","Perturbacion":"from collections import deque\n\n\ndef perturb_solution(solution):\n    # Deterministic Kempe-chain perturbation to escape local minima while preserving constraints when possible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    def kempe_chain(start: int, c1: int, c2: int):\n        seen = [False] * n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        for u in comp:\n            if sol[u] == c1:\n                sol[u] = c2\n            elif sol[u] == c2:\n                sol[u] = c1\n\n    if total_viol > 0:\n        # Pick most conflicted vertex, tiebreak by degree then index\n        degree = [len(adj[i]) for i in range(n)]\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n        c1 = sol[v]\n        # Choose c2 as the smallest color among neighbors conflicting with v; if none, pick smallest neighbor color\n        nb_colors = sorted(set(sol[nb] for nb in adj[v]))\n        if nb_colors:\n            c2 = nb_colors[0] if nb_colors[0] != c1 else (nb_colors[1] if len(nb_colors) > 1 else nb_colors[0])\n        else:\n            c2 = c1 + 1\n        if c2 == c1:\n            c2 = c1 + 1\n        kempe_chain(v, c1, c2)\n        return sol\n\n    # Feasible: perform a Kempe swap between max color and lowest color to encourage palette compression\n    max_color = max(sol) if sol else 1\n    if max_color > 1:\n        # pick first vertex with max_color\n        start_candidates = [i for i, c in enumerate(sol) if c == max_color]\n        if start_candidates:\n            start = min(start_candidates)\n            c1 = max_color\n            c2 = 1 if 1 != c1 else 2\n            kempe_chain(start, c1, c2)\n            return sol\n\n    # Fallback: simple recolor of first vertex to color 1 if safe\n    for i in range(n):\n        ok = True\n        for nb in adj[i]:\n            if sol[nb] == 1:\n                ok = False\n                break\n        if ok:\n            sol[i] = 1\n            break\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001397315}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"COLOR_LIST_LEN9_POSINT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n) * 10**10\n\n    # Domain checks\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos_neg = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors) if colors else 0\n    if k_used == 0:\n        k_used = 10**4  # keep lexicographic dominance while preventing dwarfing other terms\n\n    # Fitness: strict lexicographic scaling (lower is better)\n    fitness = 0\n    fitness += non_int * 10**11\n    fitness += non_pos_neg * 10**9\n    fitness += violations * 10**6\n    fitness += k_used\n\n    return int(fitness)\n","Vecindad":"from typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic conflict-directed neighbor with optional guarded color introduction and color-reduction when feasible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce to internal list\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency and degrees\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    degree = [len(adj[i]) for i in range(n)]\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    # Helper: conflicts if vertex vtx takes color c\n    def conflicts_if_color(vtx: int, color: int) -> int:\n        cnt = 0\n        for nb in adj[vtx]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Current palette\n    max_color = 1\n    for c in sol:\n        if isinstance(c, int) and c >= 1 and c > max_color:\n            max_color = c\n\n    if total_viol > 0:\n        # Select a most-conflicted vertex; tie-break by higher degree then smallest index for determinism\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n\n        current_color = sol[v]\n        best_color = current_color\n        best_tuple = (conflicts_if_color(v, current_color), 1, current_color)  # (conflicts, new_color_penalty, color_id)\n\n        # Try existing colors first\n        for c in range(1, max_color + 1):\n            if c == current_color:\n                continue\n            c_conf = conflicts_if_color(v, c)\n            cand_tuple = (c_conf, 0, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c\n                if c_conf == 0:\n                    break  # optimal for this vertex\n\n        # Guarded new color if still conflicted under all existing colors\n        if best_tuple[0] > 0:\n            c_new = max_color + 1\n            # This will always be 0 conflicts by construction\n            cand_tuple = (0, 1, c_new)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_color = c_new\n\n        sol[v] = best_color\n        return sol\n\n    # If no conflicts: attempt deterministic color reduction\n    # Try to recolor vertices that use the maximum color down to a lower feasible color\n    max_color = 1\n    for c in sol:\n        if c > max_color:\n            max_color = c\n    if max_color > 1:\n        max_color_vertices = [i for i, c in enumerate(sol) if c == max_color]\n        for v in sorted(max_color_vertices):\n            for c in range(1, max_color):\n                if conflicts_if_color(v, c) == 0:\n                    sol[v] = c\n                    return sol\n    # Fallback: try any vertex with any lower feasible color\n    for v in range(n):\n        c0 = sol[v]\n        for c in range(1, c0):\n            if conflicts_if_color(v, c) == 0:\n                sol[v] = c\n                return sol\n    # If no move possible, return the solution unchanged (still a valid neighbor contract)\n    return sol\n","Perturbacion":"from collections import deque\n\n\ndef perturb_solution(solution):\n    # Deterministic Kempe-chain perturbation to escape local minima while preserving constraints when possible\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validate and coerce\n    if not isinstance(solution, (list, tuple)):\n        sol = [1] * n\n    elif len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflicts per vertex and total violations\n    conflicts = [0] * n\n    total_viol = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts[u] += 1\n            conflicts[v] += 1\n            total_viol += 1\n\n    def kempe_chain(start: int, c1: int, c2: int):\n        seen = [False] * n\n        dq = deque([start])\n        seen[start] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if sol[u] not in (c1, c2):\n                continue\n            comp.append(u)\n            for nb in adj[u]:\n                if not seen[nb] and sol[nb] in (c1, c2):\n                    seen[nb] = True\n                    dq.append(nb)\n        for u in comp:\n            if sol[u] == c1:\n                sol[u] = c2\n            elif sol[u] == c2:\n                sol[u] = c1\n\n    if total_viol > 0:\n        # Pick most conflicted vertex, tiebreak by degree then index\n        degree = [len(adj[i]) for i in range(n)]\n        max_conf = max(conflicts)\n        cand = [i for i, c in enumerate(conflicts) if c == max_conf]\n        best_deg = max(degree[i] for i in cand)\n        cand = [i for i in cand if degree[i] == best_deg]\n        v = min(cand)\n        c1 = sol[v]\n        # Choose c2 as the smallest color among neighbors conflicting with v; if none, pick smallest neighbor color\n        nb_colors = sorted(set(sol[nb] for nb in adj[v]))\n        if nb_colors:\n            c2 = nb_colors[0] if nb_colors[0] != c1 else (nb_colors[1] if len(nb_colors) > 1 else nb_colors[0])\n        else:\n            c2 = c1 + 1\n        if c2 == c1:\n            c2 = c1 + 1\n        kempe_chain(v, c1, c2)\n        return sol\n\n    # Feasible: perform a Kempe swap between max color and lowest color to encourage palette compression\n    max_color = max(sol) if sol else 1\n    if max_color > 1:\n        # pick first vertex with max_color\n        start_candidates = [i for i, c in enumerate(sol) if c == max_color]\n        if start_candidates:\n            start = min(start_candidates)\n            c1 = max_color\n            c2 = 1 if 1 != c1 else 2\n            kempe_chain(start, c1, c2)\n            return sol\n\n    # Fallback: simple recolor of first vertex to color 1 if safe\n    for i in range(n):\n        ok = True\n        for nb in adj[i]:\n            if sol[nb] == 1:\n                ok = False\n                break\n        if ok:\n            sol[i] = 1\n            break\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001298415}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9. Nine integers c1,...,c9 in [1..k], comma-separated with no brackets or spaces required. Example: 1,2,3,4,1,2,3,4,1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    import math\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    lb_violation = 0.0 if (k_hat >= omega) else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) == 0:\n        # fallback to a trivial feasible-length vector\n        colors = [1]*9\n    n = 9\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def to_str(cols):\n        return ','.join(str(x) for x in cols)\n    cols = colors[:]\n    # Ensure length n\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move types\n    nb_type = \"RECOLOR\"\n    mv_type = \"LOCAL\"\n    # If conflicts exist: pick one endpoint and recolor to smallest feasible\n    if conflicts:\n        (u,v) = random.choice(conflicts)\n        pick = u if random.random() < 0.5 else v\n        used = set(cols[w-1] for w in adj[pick])\n        k_hat = max(cols) if cols else 1\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (to_str(cols), nb_type, mv_type)\n    # Otherwise perform a diversification recolor\/swap\n    k_hat = max(cols) if cols else 1\n    mode = random.random()\n    if mode < 0.6:\n        # recolor a random node to the smallest available color (possibly reducing k)\n        u = random.randint(1, n)\n        used = set(cols[w-1] for w in adj[u])\n        for c in range(1, k_hat):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        # try same k\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[u-1] = k_hat\n        return (to_str(cols), nb_type, mv_type)\n    else:\n        # color swap between two colors to escape plateaus\n        nb_type = \"SWAP\"\n        mv_type = \"LOCAL\"\n        if k_hat >= 2:\n            c1, c2 = random.sample(range(1, k_hat+1), 2)\n            for i in range(n):\n                if cols[i] == c1:\n                    cols[i] = c2\n                elif cols[i] == c2:\n                    cols[i] = c1\n        return (to_str(cols), nb_type, mv_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        cols = [1]*9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    k_hat = max(cols) if cols else 1\n    # Apply t random recolors to diversify\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow expanding palette slightly to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return ','.join(str(x) for x in cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002089752}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9. Nine integers c1,...,c9 in [1..k], comma-separated with no brackets or spaces required. Example: 1,2,3,4,1,2,3,4,1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    import math\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    lb_violation = 0.0 if (k_hat >= omega) else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) == 0:\n        # fallback to a trivial feasible-length vector\n        colors = [1]*9\n    n = 9\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def to_str(cols):\n        return ','.join(str(x) for x in cols)\n    cols = colors[:]\n    # Ensure length n\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move types\n    nb_type = \"RECOLOR\"\n    mv_type = \"LOCAL\"\n    # If conflicts exist: pick one endpoint and recolor to smallest feasible\n    if conflicts:\n        (u,v) = random.choice(conflicts)\n        pick = u if random.random() < 0.5 else v\n        used = set(cols[w-1] for w in adj[pick])\n        k_hat = max(cols) if cols else 1\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (to_str(cols), nb_type, mv_type)\n    # Otherwise perform a diversification recolor\/swap\n    k_hat = max(cols) if cols else 1\n    mode = random.random()\n    if mode < 0.6:\n        # recolor a random node to the smallest available color (possibly reducing k)\n        u = random.randint(1, n)\n        used = set(cols[w-1] for w in adj[u])\n        for c in range(1, k_hat):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        # try same k\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[u-1] = k_hat\n        return (to_str(cols), nb_type, mv_type)\n    else:\n        # color swap between two colors to escape plateaus\n        nb_type = \"SWAP\"\n        mv_type = \"LOCAL\"\n        if k_hat >= 2:\n            c1, c2 = random.sample(range(1, k_hat+1), 2)\n            for i in range(n):\n                if cols[i] == c1:\n                    cols[i] = c2\n                elif cols[i] == c2:\n                    cols[i] = c1\n        return (to_str(cols), nb_type, mv_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        cols = [1]*9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    k_hat = max(cols) if cols else 1\n    # Apply t random recolors to diversify\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow expanding palette slightly to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return ','.join(str(x) for x in cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.00182888}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9. Nine integers c1,...,c9 in [1..k], comma-separated with no brackets or spaces required. Example: 1,2,3,4,1,2,3,4,1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    import math\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    lb_violation = 0.0 if (k_hat >= omega) else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) == 0:\n        # fallback to a trivial feasible-length vector\n        colors = [1]*9\n    n = 9\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def to_str(cols):\n        return ','.join(str(x) for x in cols)\n    cols = colors[:]\n    # Ensure length n\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move types\n    nb_type = \"RECOLOR\"\n    mv_type = \"LOCAL\"\n    # If conflicts exist: pick one endpoint and recolor to smallest feasible\n    if conflicts:\n        (u,v) = random.choice(conflicts)\n        pick = u if random.random() < 0.5 else v\n        used = set(cols[w-1] for w in adj[pick])\n        k_hat = max(cols) if cols else 1\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (to_str(cols), nb_type, mv_type)\n    # Otherwise perform a diversification recolor\/swap\n    k_hat = max(cols) if cols else 1\n    mode = random.random()\n    if mode < 0.6:\n        # recolor a random node to the smallest available color (possibly reducing k)\n        u = random.randint(1, n)\n        used = set(cols[w-1] for w in adj[u])\n        for c in range(1, k_hat):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        # try same k\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[u-1] = c\n                return (to_str(cols), nb_type, mv_type)\n        cols[u-1] = k_hat\n        return (to_str(cols), nb_type, mv_type)\n    else:\n        # color swap between two colors to escape plateaus\n        nb_type = \"SWAP\"\n        mv_type = \"LOCAL\"\n        if k_hat >= 2:\n            c1, c2 = random.sample(range(1, k_hat+1), 2)\n            for i in range(n):\n                if cols[i] == c1:\n                    cols[i] = c2\n                elif cols[i] == c2:\n                    cols[i] = c1\n        return (to_str(cols), nb_type, mv_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    import random\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        cols = [1]*9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    if len(cols) != n:\n        if len(cols) < n:\n            cols += [max(cols) if cols else 1]*(n-len(cols))\n        else:\n            cols = cols[:n]\n    k_hat = max(cols) if cols else 1\n    # Apply t random recolors to diversify\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow expanding palette slightly to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return ','.join(str(x) for x in cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00179693}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Scaled objective: prioritize feasibility, then minimize k\n    alpha = 100.0\n    return violations * alpha + float(k_hat)","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    # Identify conflicts and degrees for weighted selection\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move: recolor a chosen vertex to the smallest available color; if none, open new color\n    mv_type = \"LOCAL\"\n    k_hat = max(cols) if cols else 1\n    if conflicts:\n        # Weighted by degree sum to focus hard vertices\n        u,v = random.choice(conflicts)\n        pick = u if (len(adj[u]) >= len(adj[v])) else v\n        used = set(cols[w-1] for w in adj[pick])\n        # try colors up to k_hat first (greedy reduce)\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (cols, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (cols, mv_type)\n    # No conflicts: attempt potential k reduction or diversification via limited swap\n    u = random.randint(1, n)\n    used = set(cols[w-1] for w in adj[u])\n    # try to recolor u with a smaller color if possible\n    for c in range(1, k_hat):\n        if c not in used:\n            cols[u-1] = c\n            return (cols, mv_type)\n    # small color swap between two colors on a random vertex neighborhood (Kempe-like lite)\n    if k_hat >= 2:\n        c1 = cols[u-1]\n        cand = [c for c in range(1, k_hat+1) if c != c1]\n        c2 = random.choice(cand)\n        # swap c1<->c2 only on neighbors of u to limit disruption\n        affected = [i for i in range(1, n+1) if i==u or i in adj[u]]\n        for i in affected:\n            if cols[i-1] == c1:\n                cols[i-1] = c2\n            elif cols[i-1] == c2:\n                cols[i-1] = c1\n    return (cols, mv_type)","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    import random\n    # Parse\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k_hat = max(cols) if cols else 1\n    # intensity t = 3 fixed\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow palette expansion by 1 to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return cols","Resultados":[[2,5,1,4,3,4,2,1,1],5.0,[5,3,1,3,2,4,2,1,1],5.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001795699}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Scaled objective: prioritize feasibility, then minimize k\n    alpha = 100.0\n    return violations * alpha + float(k_hat)","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    # Identify conflicts and degrees for weighted selection\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move: recolor a chosen vertex to the smallest available color; if none, open new color\n    mv_type = \"LOCAL\"\n    k_hat = max(cols) if cols else 1\n    if conflicts:\n        # Weighted by degree sum to focus hard vertices\n        u,v = random.choice(conflicts)\n        pick = u if (len(adj[u]) >= len(adj[v])) else v\n        used = set(cols[w-1] for w in adj[pick])\n        # try colors up to k_hat first (greedy reduce)\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (cols, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (cols, mv_type)\n    # No conflicts: attempt potential k reduction or diversification via limited swap\n    u = random.randint(1, n)\n    used = set(cols[w-1] for w in adj[u])\n    # try to recolor u with a smaller color if possible\n    for c in range(1, k_hat):\n        if c not in used:\n            cols[u-1] = c\n            return (cols, mv_type)\n    # small color swap between two colors on a random vertex neighborhood (Kempe-like lite)\n    if k_hat >= 2:\n        c1 = cols[u-1]\n        cand = [c for c in range(1, k_hat+1) if c != c1]\n        c2 = random.choice(cand)\n        # swap c1<->c2 only on neighbors of u to limit disruption\n        affected = [i for i in range(1, n+1) if i==u or i in adj[u]]\n        for i in affected:\n            if cols[i-1] == c1:\n                cols[i-1] = c2\n            elif cols[i-1] == c2:\n                cols[i-1] = c1\n    return (cols, mv_type)","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    import random\n    # Parse\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k_hat = max(cols) if cols else 1\n    # intensity t = 3 fixed\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow palette expansion by 1 to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return cols","Resultados":[[1,1,1,4,2,4,2,3,3],4.0,[1,1,1,2,4,2,3,4,3],4.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001626158}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Scaled objective: prioritize feasibility, then minimize k\n    alpha = 100.0\n    return violations * alpha + float(k_hat)","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    # Identify conflicts and degrees for weighted selection\n    conflicts = []\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts.append((u,v))\n    # Move: recolor a chosen vertex to the smallest available color; if none, open new color\n    mv_type = \"LOCAL\"\n    k_hat = max(cols) if cols else 1\n    if conflicts:\n        # Weighted by degree sum to focus hard vertices\n        u,v = random.choice(conflicts)\n        pick = u if (len(adj[u]) >= len(adj[v])) else v\n        used = set(cols[w-1] for w in adj[pick])\n        # try colors up to k_hat first (greedy reduce)\n        for c in range(1, k_hat+1):\n            if c not in used:\n                cols[pick-1] = c\n                return (cols, mv_type)\n        cols[pick-1] = k_hat + 1\n        return (cols, mv_type)\n    # No conflicts: attempt potential k reduction or diversification via limited swap\n    u = random.randint(1, n)\n    used = set(cols[w-1] for w in adj[u])\n    # try to recolor u with a smaller color if possible\n    for c in range(1, k_hat):\n        if c not in used:\n            cols[u-1] = c\n            return (cols, mv_type)\n    # small color swap between two colors on a random vertex neighborhood (Kempe-like lite)\n    if k_hat >= 2:\n        c1 = cols[u-1]\n        cand = [c for c in range(1, k_hat+1) if c != c1]\n        c2 = random.choice(cand)\n        # swap c1<->c2 only on neighbors of u to limit disruption\n        affected = [i for i in range(1, n+1) if i==u or i in adj[u]]\n        for i in affected:\n            if cols[i-1] == c1:\n                cols[i-1] = c2\n            elif cols[i-1] == c2:\n                cols[i-1] = c1\n    return (cols, mv_type)","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    import random\n    # Parse\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k_hat = max(cols) if cols else 1\n    # intensity t = 3 fixed\n    t = 3\n    for _ in range(t):\n        u = random.randint(1, n)\n        used = set(cols[v-1] for v in adj[u])\n        # allow palette expansion by 1 to escape traps\n        options = list(range(1, k_hat+2))\n        random.shuffle(options)\n        for c in options:\n            if c not in used:\n                cols[u-1] = c\n                break\n        k_hat = max(k_hat, cols[u-1])\n    return cols","Resultados":[[3,2,1,2,4,5,3,1,1],5.0,[4,4,1,2,3,2,3,1,1],4.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001594907}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10000000.0\n    if len(cols) != n:\n        return 9000000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8000000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    alpha = 100.0\n    return violations * alpha + float(k_hat)\n\n# Optional: Simulated Annealing controller as requested (not invoked here)\n# cost is minimized; on equal cost, accept.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if cf <= 0.0 or cf >= 1.0:\n        cf = 0.95\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 500:\n        nb, mv_type = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            # deterministic tie-break using sigmoid on delta and T with hashing\n            h = hash(tuple([x for x in (nb if isinstance(nb, list) else [])] + [int(T*1e6)]))\n            r = ((h & 0xffffffff) \/ 0xffffffff)\n            if r < prob:\n                curr, curr_score = nb, nb_score\n        if curr_score < best_score:\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random, collections\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n    def saturation(v, c):\n        return len({c[u-1] for u in adj[v]})\n    def smallest_feasible_color(v, c, kmax):\n        used = {c[u-1] for u in adj[v]}\n        for col in range(1, kmax+1):\n            if col not in used:\n                return col\n        return None\n    def kempe_component(nodes_color, c1, c2, start):\n        # BFS component in subgraph induced by colors {c1,c2}\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n    def try_kempe_swap(c, v, target_color):\n        old = c[v-1]\n        if old == target_color:\n            return c\n        comp = kempe_component(c, old, target_color, v)\n        newc = c[:]\n        for u in comp:\n            if newc[u-1] == old:\n                newc[u-1] = target_color\n            elif newc[u-1] == target_color:\n                newc[u-1] = old\n        return newc\n\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n    mv_type = \"LOCAL\"\n\n    if total_conf > 0:\n        # choose vertex with max (conflicts, saturation, degree)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda v:(-vc[v], -saturation(v, cols), -len(adj[v])))\n        v = candidates[0]\n        # try recolor with smallest feasible in current palette\n        cfeas = smallest_feasible_color(v, cols, k_hat)\n        if cfeas is not None and cfeas != cols[v-1]:\n            cols[v-1] = cfeas\n            return (cols, mv_type)\n        # attempt Kempe with each color in 1..k_hat\n        for c2 in range(1, k_hat+1):\n            if c2 == cols[v-1]:\n                continue\n            cand = try_kempe_swap(cols, v, c2)\n            if eval_conflicts(cand) <= total_conf:\n                return (cand, mv_type)\n        # as last resort, open new color\n        cols[v-1] = k_hat + 1\n        return (cols, mv_type)\n\n    # No conflicts: attempt color class elimination (reduce k)\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        success = True\n        newc = cols[:]\n        for v in class_h:\n            placed = False\n            for c2 in range(1, h):\n                used = {newc[u-1] for u in adj[v]}\n                if c2 not in used:\n                    newc[v-1] = c2\n                    placed = True\n                    break\n            if not placed:\n                # try Kempe to free a color\n                freed = False\n                for c2 in range(1, h):\n                    cand = try_kempe_swap(newc, v, c2)\n                    used = {cand[u-1] for u in adj[v]}\n                    if c2 not in used:\n                        newc = cand\n                        newc[v-1] = c2\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # normalize colors > h removed; remap h down if present\n            cols = newc\n            mv_type = \"K_REDUCE\"\n            return (cols, mv_type)\n    # Otherwise, small diversification: swap a Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        for w in comp:\n            cols[w-1] = c2 if cols[w-1] == c1 else c1\n    return (cols, mv_type)\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic, side-effect-free perturbation via local PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # simple xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    k_hat = max(cols) if cols else 1\n    # Apply 3 deterministic Kempe swaps anchored at pseudo-random vertices\n    steps = 3\n    newc = cols[:]\n    for _ in range(steps):\n        u = rnd_int(1, n)\n        c1 = newc[u-1]\n        if k_hat == 1:\n            # open a new color deterministically if stuck\n            newc[u-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, k_hat-1) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, u)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n    return newc\n","Resultados":[[1,2,1,2,1,1,1,1,1],1002.0,[1,2,1,2,1,1,1,1,1],1002.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002996928}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10000000.0\n    if len(cols) != n:\n        return 9000000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8000000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    alpha = 100.0\n    return violations * alpha + float(k_hat)\n\n# Optional: Simulated Annealing controller as requested (not invoked here)\n# cost is minimized; on equal cost, accept.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if cf <= 0.0 or cf >= 1.0:\n        cf = 0.95\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 500:\n        nb, mv_type = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            # deterministic tie-break using sigmoid on delta and T with hashing\n            h = hash(tuple([x for x in (nb if isinstance(nb, list) else [])] + [int(T*1e6)]))\n            r = ((h & 0xffffffff) \/ 0xffffffff)\n            if r < prob:\n                curr, curr_score = nb, nb_score\n        if curr_score < best_score:\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random, collections\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n    def saturation(v, c):\n        return len({c[u-1] for u in adj[v]})\n    def smallest_feasible_color(v, c, kmax):\n        used = {c[u-1] for u in adj[v]}\n        for col in range(1, kmax+1):\n            if col not in used:\n                return col\n        return None\n    def kempe_component(nodes_color, c1, c2, start):\n        # BFS component in subgraph induced by colors {c1,c2}\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n    def try_kempe_swap(c, v, target_color):\n        old = c[v-1]\n        if old == target_color:\n            return c\n        comp = kempe_component(c, old, target_color, v)\n        newc = c[:]\n        for u in comp:\n            if newc[u-1] == old:\n                newc[u-1] = target_color\n            elif newc[u-1] == target_color:\n                newc[u-1] = old\n        return newc\n\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n    mv_type = \"LOCAL\"\n\n    if total_conf > 0:\n        # choose vertex with max (conflicts, saturation, degree)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda v:(-vc[v], -saturation(v, cols), -len(adj[v])))\n        v = candidates[0]\n        # try recolor with smallest feasible in current palette\n        cfeas = smallest_feasible_color(v, cols, k_hat)\n        if cfeas is not None and cfeas != cols[v-1]:\n            cols[v-1] = cfeas\n            return (cols, mv_type)\n        # attempt Kempe with each color in 1..k_hat\n        for c2 in range(1, k_hat+1):\n            if c2 == cols[v-1]:\n                continue\n            cand = try_kempe_swap(cols, v, c2)\n            if eval_conflicts(cand) <= total_conf:\n                return (cand, mv_type)\n        # as last resort, open new color\n        cols[v-1] = k_hat + 1\n        return (cols, mv_type)\n\n    # No conflicts: attempt color class elimination (reduce k)\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        success = True\n        newc = cols[:]\n        for v in class_h:\n            placed = False\n            for c2 in range(1, h):\n                used = {newc[u-1] for u in adj[v]}\n                if c2 not in used:\n                    newc[v-1] = c2\n                    placed = True\n                    break\n            if not placed:\n                # try Kempe to free a color\n                freed = False\n                for c2 in range(1, h):\n                    cand = try_kempe_swap(newc, v, c2)\n                    used = {cand[u-1] for u in adj[v]}\n                    if c2 not in used:\n                        newc = cand\n                        newc[v-1] = c2\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # normalize colors > h removed; remap h down if present\n            cols = newc\n            mv_type = \"K_REDUCE\"\n            return (cols, mv_type)\n    # Otherwise, small diversification: swap a Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        for w in comp:\n            cols[w-1] = c2 if cols[w-1] == c1 else c1\n    return (cols, mv_type)\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic, side-effect-free perturbation via local PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # simple xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    k_hat = max(cols) if cols else 1\n    # Apply 3 deterministic Kempe swaps anchored at pseudo-random vertices\n    steps = 3\n    newc = cols[:]\n    for _ in range(steps):\n        u = rnd_int(1, n)\n        c1 = newc[u-1]\n        if k_hat == 1:\n            # open a new color deterministically if stuck\n            newc[u-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, k_hat-1) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, u)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n    return newc\n","Resultados":[[1,2,1,2,1,1,1,1,1],1002.0,[1,2,1,2,1,1,1,1,1],1002.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.002574772}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10000000.0\n    if len(cols) != n:\n        return 9000000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8000000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    alpha = 100.0\n    return violations * alpha + float(k_hat)\n\n# Optional: Simulated Annealing controller as requested (not invoked here)\n# cost is minimized; on equal cost, accept.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if cf <= 0.0 or cf >= 1.0:\n        cf = 0.95\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 500:\n        nb, mv_type = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            # deterministic tie-break using sigmoid on delta and T with hashing\n            h = hash(tuple([x for x in (nb if isinstance(nb, list) else [])] + [int(T*1e6)]))\n            r = ((h & 0xffffffff) \/ 0xffffffff)\n            if r < prob:\n                curr, curr_score = nb, nb_score\n        if curr_score < best_score:\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random, collections\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n    def saturation(v, c):\n        return len({c[u-1] for u in adj[v]})\n    def smallest_feasible_color(v, c, kmax):\n        used = {c[u-1] for u in adj[v]}\n        for col in range(1, kmax+1):\n            if col not in used:\n                return col\n        return None\n    def kempe_component(nodes_color, c1, c2, start):\n        # BFS component in subgraph induced by colors {c1,c2}\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n    def try_kempe_swap(c, v, target_color):\n        old = c[v-1]\n        if old == target_color:\n            return c\n        comp = kempe_component(c, old, target_color, v)\n        newc = c[:]\n        for u in comp:\n            if newc[u-1] == old:\n                newc[u-1] = target_color\n            elif newc[u-1] == target_color:\n                newc[u-1] = old\n        return newc\n\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n    mv_type = \"LOCAL\"\n\n    if total_conf > 0:\n        # choose vertex with max (conflicts, saturation, degree)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda v:(-vc[v], -saturation(v, cols), -len(adj[v])))\n        v = candidates[0]\n        # try recolor with smallest feasible in current palette\n        cfeas = smallest_feasible_color(v, cols, k_hat)\n        if cfeas is not None and cfeas != cols[v-1]:\n            cols[v-1] = cfeas\n            return (cols, mv_type)\n        # attempt Kempe with each color in 1..k_hat\n        for c2 in range(1, k_hat+1):\n            if c2 == cols[v-1]:\n                continue\n            cand = try_kempe_swap(cols, v, c2)\n            if eval_conflicts(cand) <= total_conf:\n                return (cand, mv_type)\n        # as last resort, open new color\n        cols[v-1] = k_hat + 1\n        return (cols, mv_type)\n\n    # No conflicts: attempt color class elimination (reduce k)\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        success = True\n        newc = cols[:]\n        for v in class_h:\n            placed = False\n            for c2 in range(1, h):\n                used = {newc[u-1] for u in adj[v]}\n                if c2 not in used:\n                    newc[v-1] = c2\n                    placed = True\n                    break\n            if not placed:\n                # try Kempe to free a color\n                freed = False\n                for c2 in range(1, h):\n                    cand = try_kempe_swap(newc, v, c2)\n                    used = {cand[u-1] for u in adj[v]}\n                    if c2 not in used:\n                        newc = cand\n                        newc[v-1] = c2\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # normalize colors > h removed; remap h down if present\n            cols = newc\n            mv_type = \"K_REDUCE\"\n            return (cols, mv_type)\n    # Otherwise, small diversification: swap a Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        for w in comp:\n            cols[w-1] = c2 if cols[w-1] == c1 else c1\n    return (cols, mv_type)\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic, side-effect-free perturbation via local PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    # simple xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    k_hat = max(cols) if cols else 1\n    # Apply 3 deterministic Kempe swaps anchored at pseudo-random vertices\n    steps = 3\n    newc = cols[:]\n    for _ in range(steps):\n        u = rnd_int(1, n)\n        c1 = newc[u-1]\n        if k_hat == 1:\n            # open a new color deterministically if stuck\n            newc[u-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, k_hat-1) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, u)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n    return newc\n","Resultados":[[1,2,1,2,1,1,1,1,1],1002.0,[1,2,1,2,1,1,1,1,1],1002.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00246484}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000_000.0\n    if len(cols) != n:\n        return 9_000_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Lexicographic feasibility-first scoring\n    return violations * 1_000_000.0 + float(k_hat)\n\n# Simulated Annealing controller as requested; cost minimized.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math, random\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if not (0.0 < cf < 1.0):\n        cf = 0.95\n    # Estimate initial T if temp not informative\n    if T <= 0:\n        deltas = []\n        probe = curr\n        probe_score = curr_score\n        for _ in range(25):\n            nb, _ = generate_neighbour(probe)\n            nb_score = evaluate_solution(nb)\n            d = nb_score - probe_score\n            if d > 0:\n                deltas.append(d)\n            probe, probe_score = nb, nb_score\n        if deltas:\n            deltas.sort()\n            T = deltas[int(0.75*(len(deltas)-1))]\n        else:\n            T = 1.0\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 2000:\n        nb, _ = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            if random.random() < prob:\n                curr, curr_score = nb, nb_score\n        if (curr_score < best_score) or (curr_score == best_score and float(max(curr if isinstance(curr, list) else [] or [0])) < float(max(best if isinstance(best, list) else [] or [0]))):\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import math, random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n\n    def min_conflicts_color(v, c, kmax):\n        # choose color in [1..kmax+1] minimizing conflicts for v\n        bestc = c[v-1]\n        bestval = math.inf\n        for col in range(1, kmax+2):\n            val = 0\n            for u in adj[v]:\n                if c[u-1] == col:\n                    val += 1\n            if val < bestval:\n                bestval = val\n                bestc = col\n        return bestc, bestval\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    cols = normalize_palette(cols)\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n\n    # If conflicts exist: perform repair using min-conflicts recolor on a worst vertex\n    if total_conf > 0:\n        candidates = list(range(1, n+1))\n        # rank by conflicts then degree\n        candidates.sort(key=lambda v: (-vc[v], -len(adj[v])))\n        v = candidates[0]\n        newc = cols[:]\n        color_choice, _ = min_conflicts_color(v, newc, k_hat)\n        newc[v-1] = color_choice\n        newc = normalize_palette(newc)\n        mv_type = \"REPAIR_MIN_CONFLICTS\"\n        return (newc, mv_type)\n\n    # No conflicts: attempt k-reduction by re-inserting highest color class\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        order = sorted(class_h, key=lambda v: -len(adj[v]))\n        newc = cols[:]\n        success = True\n        for v in order:\n            # Temporarily remove color h from v\n            newc[v-1] = 0\n            feasible = False\n            for c2 in range(1, h):\n                conflict = any(newc[u-1] == c2 for u in adj[v])\n                if not conflict:\n                    newc[v-1] = c2\n                    feasible = True\n                    break\n            if not feasible:\n                # Try a guided Kempe swap to free a color for v\n                freed = False\n                # choose target color minimizing neighbor usage\n                usage = [(c2, sum(1 for u in adj[v] if newc[u-1]==c2)) for c2 in range(1,h)]\n                usage.sort(key=lambda t: t[1])\n                for c2,_ in usage:\n                    comp = kempe_component(newc, c2, h, v)\n                    trial = newc[:]\n                    for w in comp:\n                        trial[w-1] = h if trial[w-1]==c2 else c2\n                    if not any(trial[u-1] == c2 for u in adj[v]):\n                        trial[v-1] = c2\n                        newc = trial\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # Remove any remaining h and normalize\n            newc = [x for x in newc]\n            newc = normalize_palette(newc)\n            mv_type = \"K_REDUCE\"\n            return (newc, mv_type)\n\n    # Diversification: swap along a random Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        newc = cols[:]\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        newc = normalize_palette(newc)\n        return (newc, \"DIVERSIFY_KEMPE\")\n\n    # Fallback no-op neighbor (should be rare)\n    return (cols[:], \"NO_OP\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    import math\n    # Deterministic, side-effect-free perturbation via xorshift PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    # xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    newc = cols[:]\n    newc = normalize_palette(newc)\n    k_hat = max(newc) if newc else 1\n\n    # Select top-B conflicting vertices (ties broken deterministically)\n    B = 4\n    # build conflict counts\n    vc = [0]*(n+1)\n    for (u,v) in edges:\n        if newc[u-1] == newc[v-1]:\n            vc[u] += 1; vc[v] += 1\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: (-vc[v], -len(adj[v]), v))\n    targets = order[:B]\n\n    # For each target, perform a deterministic Kempe swap with a pseudo-random partner color\n    for v in targets:\n        c1 = newc[v-1]\n        if k_hat == 1:\n            newc[v-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, max(1, k_hat-1)) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, v)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n\n    # Additionally, recolor one random vertex among targets to a new or existing color to shake palette\n    if targets:\n        v = targets[rnd_int(0, len(targets)-1)]\n        # choose color index possibly k_hat+1\n        choose = rnd_int(1, k_hat+1)\n        newc[v-1] = choose\n\n    newc = normalize_palette(newc)\n    # Ensure domain is valid\n    for i in range(n):\n        if newc[i] < 1:\n            newc[i] = 1\n    _ = eval_conflicts(newc)  # computed to keep symmetry with other components; not used\n    return newc\n","Resultados":[[1,1,2,3,2,3,4,2,4],4.0,[1,1,1,2,3,2,4,3,4],4.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.003223919}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000_000.0\n    if len(cols) != n:\n        return 9_000_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Lexicographic feasibility-first scoring\n    return violations * 1_000_000.0 + float(k_hat)\n\n# Simulated Annealing controller as requested; cost minimized.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math, random\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if not (0.0 < cf < 1.0):\n        cf = 0.95\n    # Estimate initial T if temp not informative\n    if T <= 0:\n        deltas = []\n        probe = curr\n        probe_score = curr_score\n        for _ in range(25):\n            nb, _ = generate_neighbour(probe)\n            nb_score = evaluate_solution(nb)\n            d = nb_score - probe_score\n            if d > 0:\n                deltas.append(d)\n            probe, probe_score = nb, nb_score\n        if deltas:\n            deltas.sort()\n            T = deltas[int(0.75*(len(deltas)-1))]\n        else:\n            T = 1.0\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 2000:\n        nb, _ = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            if random.random() < prob:\n                curr, curr_score = nb, nb_score\n        if (curr_score < best_score) or (curr_score == best_score and float(max(curr if isinstance(curr, list) else [] or [0])) < float(max(best if isinstance(best, list) else [] or [0]))):\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import math, random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n\n    def min_conflicts_color(v, c, kmax):\n        # choose color in [1..kmax+1] minimizing conflicts for v\n        bestc = c[v-1]\n        bestval = math.inf\n        for col in range(1, kmax+2):\n            val = 0\n            for u in adj[v]:\n                if c[u-1] == col:\n                    val += 1\n            if val < bestval:\n                bestval = val\n                bestc = col\n        return bestc, bestval\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    cols = normalize_palette(cols)\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n\n    # If conflicts exist: perform repair using min-conflicts recolor on a worst vertex\n    if total_conf > 0:\n        candidates = list(range(1, n+1))\n        # rank by conflicts then degree\n        candidates.sort(key=lambda v: (-vc[v], -len(adj[v])))\n        v = candidates[0]\n        newc = cols[:]\n        color_choice, _ = min_conflicts_color(v, newc, k_hat)\n        newc[v-1] = color_choice\n        newc = normalize_palette(newc)\n        mv_type = \"REPAIR_MIN_CONFLICTS\"\n        return (newc, mv_type)\n\n    # No conflicts: attempt k-reduction by re-inserting highest color class\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        order = sorted(class_h, key=lambda v: -len(adj[v]))\n        newc = cols[:]\n        success = True\n        for v in order:\n            # Temporarily remove color h from v\n            newc[v-1] = 0\n            feasible = False\n            for c2 in range(1, h):\n                conflict = any(newc[u-1] == c2 for u in adj[v])\n                if not conflict:\n                    newc[v-1] = c2\n                    feasible = True\n                    break\n            if not feasible:\n                # Try a guided Kempe swap to free a color for v\n                freed = False\n                # choose target color minimizing neighbor usage\n                usage = [(c2, sum(1 for u in adj[v] if newc[u-1]==c2)) for c2 in range(1,h)]\n                usage.sort(key=lambda t: t[1])\n                for c2,_ in usage:\n                    comp = kempe_component(newc, c2, h, v)\n                    trial = newc[:]\n                    for w in comp:\n                        trial[w-1] = h if trial[w-1]==c2 else c2\n                    if not any(trial[u-1] == c2 for u in adj[v]):\n                        trial[v-1] = c2\n                        newc = trial\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # Remove any remaining h and normalize\n            newc = [x for x in newc]\n            newc = normalize_palette(newc)\n            mv_type = \"K_REDUCE\"\n            return (newc, mv_type)\n\n    # Diversification: swap along a random Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        newc = cols[:]\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        newc = normalize_palette(newc)\n        return (newc, \"DIVERSIFY_KEMPE\")\n\n    # Fallback no-op neighbor (should be rare)\n    return (cols[:], \"NO_OP\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    import math\n    # Deterministic, side-effect-free perturbation via xorshift PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    # xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    newc = cols[:]\n    newc = normalize_palette(newc)\n    k_hat = max(newc) if newc else 1\n\n    # Select top-B conflicting vertices (ties broken deterministically)\n    B = 4\n    # build conflict counts\n    vc = [0]*(n+1)\n    for (u,v) in edges:\n        if newc[u-1] == newc[v-1]:\n            vc[u] += 1; vc[v] += 1\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: (-vc[v], -len(adj[v]), v))\n    targets = order[:B]\n\n    # For each target, perform a deterministic Kempe swap with a pseudo-random partner color\n    for v in targets:\n        c1 = newc[v-1]\n        if k_hat == 1:\n            newc[v-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, max(1, k_hat-1)) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, v)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n\n    # Additionally, recolor one random vertex among targets to a new or existing color to shake palette\n    if targets:\n        v = targets[rnd_int(0, len(targets)-1)]\n        # choose color index possibly k_hat+1\n        choose = rnd_int(1, k_hat+1)\n        newc[v-1] = choose\n\n    newc = normalize_palette(newc)\n    # Ensure domain is valid\n    for i in range(n):\n        if newc[i] < 1:\n            newc[i] = 1\n    _ = eval_conflicts(newc)  # computed to keep symmetry with other components; not used\n    return newc\n","Resultados":[[1,1,2,3,4,3,4,2,2],4.0,[1,1,2,3,4,3,4,2,2],4.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.002846163}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEP_INT_LIST_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    import math\n    # Parse input\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list):\n        return 10_000_000_000.0\n    if len(cols) != n:\n        return 9_000_000_000.0 + abs(len(cols)-n)\n    for x in cols:\n        if not isinstance(x, int) or x < 1:\n            return 8_000_000_000.0\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    violations = 0\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            violations += 1\n    k_hat = max(cols) if cols else 0\n    # Lexicographic feasibility-first scoring\n    return violations * 1_000_000.0 + float(k_hat)\n\n# Simulated Annealing controller as requested; cost minimized.\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    import math, random\n    curr = currentSolution\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best, best_score = curr, curr_score\n    T = float(temp)\n    minT = float(minTemp)\n    cf = float(cooling_factor)\n    if not (0.0 < cf < 1.0):\n        cf = 0.95\n    # Estimate initial T if temp not informative\n    if T <= 0:\n        deltas = []\n        probe = curr\n        probe_score = curr_score\n        for _ in range(25):\n            nb, _ = generate_neighbour(probe)\n            nb_score = evaluate_solution(nb)\n            d = nb_score - probe_score\n            if d > 0:\n                deltas.append(d)\n            probe, probe_score = nb, nb_score\n        if deltas:\n            deltas.sort()\n            T = deltas[int(0.75*(len(deltas)-1))]\n        else:\n            T = 1.0\n    iters_without_improv = 0\n    while T > minT and iters_without_improv < 2000:\n        nb, _ = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if delta <= 0:\n            curr, curr_score = nb, nb_score\n        else:\n            prob = math.exp(-delta \/ T)\n            if random.random() < prob:\n                curr, curr_score = nb, nb_score\n        if (curr_score < best_score) or (curr_score == best_score and float(max(curr if isinstance(curr, list) else [] or [0])) < float(max(best if isinstance(best, list) else [] or [0]))):\n            best, best_score = curr, curr_score\n            iters_without_improv = 0\n        else:\n            iters_without_improv += 1\n        T *= cf\n    return curr, curr_score, best, best_score\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import math, random\n    # Parse and normalize\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertex_conflict_counts(c):\n        vc = [0]*(n+1)\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                vc[u] += 1; vc[v] += 1\n        return vc\n\n    def min_conflicts_color(v, c, kmax):\n        # choose color in [1..kmax+1] minimizing conflicts for v\n        bestc = c[v-1]\n        bestval = math.inf\n        for col in range(1, kmax+2):\n            val = 0\n            for u in adj[v]:\n                if c[u-1] == col:\n                    val += 1\n            if val < bestval:\n                bestval = val\n                bestc = col\n        return bestc, bestval\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    cols = normalize_palette(cols)\n    k_hat = max(cols) if cols else 1\n    vc = vertex_conflict_counts(cols)\n    total_conf = sum(vc)\/\/2\n\n    # If conflicts exist: perform repair using min-conflicts recolor on a worst vertex\n    if total_conf > 0:\n        candidates = list(range(1, n+1))\n        # rank by conflicts then degree\n        candidates.sort(key=lambda v: (-vc[v], -len(adj[v])))\n        v = candidates[0]\n        newc = cols[:]\n        color_choice, _ = min_conflicts_color(v, newc, k_hat)\n        newc[v-1] = color_choice\n        newc = normalize_palette(newc)\n        mv_type = \"REPAIR_MIN_CONFLICTS\"\n        return (newc, mv_type)\n\n    # No conflicts: attempt k-reduction by re-inserting highest color class\n    h = k_hat\n    class_h = [v for v in range(1, n+1) if cols[v-1] == h]\n    if class_h:\n        order = sorted(class_h, key=lambda v: -len(adj[v]))\n        newc = cols[:]\n        success = True\n        for v in order:\n            # Temporarily remove color h from v\n            newc[v-1] = 0\n            feasible = False\n            for c2 in range(1, h):\n                conflict = any(newc[u-1] == c2 for u in adj[v])\n                if not conflict:\n                    newc[v-1] = c2\n                    feasible = True\n                    break\n            if not feasible:\n                # Try a guided Kempe swap to free a color for v\n                freed = False\n                # choose target color minimizing neighbor usage\n                usage = [(c2, sum(1 for u in adj[v] if newc[u-1]==c2)) for c2 in range(1,h)]\n                usage.sort(key=lambda t: t[1])\n                for c2,_ in usage:\n                    comp = kempe_component(newc, c2, h, v)\n                    trial = newc[:]\n                    for w in comp:\n                        trial[w-1] = h if trial[w-1]==c2 else c2\n                    if not any(trial[u-1] == c2 for u in adj[v]):\n                        trial[v-1] = c2\n                        newc = trial\n                        freed = True\n                        break\n                if not freed:\n                    success = False\n                    break\n        if success:\n            # Remove any remaining h and normalize\n            newc = [x for x in newc]\n            newc = normalize_palette(newc)\n            mv_type = \"K_REDUCE\"\n            return (newc, mv_type)\n\n    # Diversification: swap along a random Kempe component between two random colors\n    u = random.randint(1, n)\n    c1 = cols[u-1]\n    palette = list(range(1, k_hat+1))\n    if len(palette) >= 2:\n        c2 = random.choice([c for c in palette if c != c1])\n        comp = kempe_component(cols, c1, c2, u)\n        newc = cols[:]\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        newc = normalize_palette(newc)\n        return (newc, \"DIVERSIFY_KEMPE\")\n\n    # Fallback no-op neighbor (should be rare)\n    return (cols[:], \"NO_OP\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    import math\n    # Deterministic, side-effect-free perturbation via xorshift PRNG seeded from solution\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n            return out\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    cols = parse(solution)\n    n = 9\n    if not isinstance(cols, list) or len(cols) != n:\n        cols = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_palette(c):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in c:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n\n    def eval_conflicts(c):\n        cnt = 0\n        for (u,v) in edges:\n            if c[u-1] == c[v-1]:\n                cnt += 1\n        return cnt\n\n    # xorshift32 PRNG\n    def rng(seed):\n        x = seed & 0xffffffff\n        while True:\n            x ^= (x << 13) & 0xffffffff\n            x ^= (x >> 17) & 0xffffffff\n            x ^= (x << 5) & 0xffffffff\n            yield x & 0xffffffff\n\n    seed = 2166136261\n    for v in cols:\n        seed ^= (v + 0x9e3779b9) & 0xffffffff\n        seed &= 0xffffffff\n    R = rng(seed)\n    def rnd_int(a,b):\n        r = next(R)\n        return a + (r % (b - a + 1))\n\n    def kempe_component(nodes_color, c1, c2, start):\n        comp = set()\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v in comp:\n                continue\n            if nodes_color[v-1] not in (c1, c2):\n                continue\n            comp.add(v)\n            for u in adj[v]:\n                if nodes_color[u-1] in (c1, c2) and u not in comp:\n                    stack.append(u)\n        return comp\n\n    newc = cols[:]\n    newc = normalize_palette(newc)\n    k_hat = max(newc) if newc else 1\n\n    # Select top-B conflicting vertices (ties broken deterministically)\n    B = 4\n    # build conflict counts\n    vc = [0]*(n+1)\n    for (u,v) in edges:\n        if newc[u-1] == newc[v-1]:\n            vc[u] += 1; vc[v] += 1\n    order = list(range(1, n+1))\n    order.sort(key=lambda v: (-vc[v], -len(adj[v]), v))\n    targets = order[:B]\n\n    # For each target, perform a deterministic Kempe swap with a pseudo-random partner color\n    for v in targets:\n        c1 = newc[v-1]\n        if k_hat == 1:\n            newc[v-1] = 2\n            k_hat = 2\n            continue\n        c2 = ((c1 + rnd_int(1, max(1, k_hat-1)) - 1) % k_hat) + 1\n        if c2 == c1:\n            c2 = (c1 % k_hat) + 1\n        comp = kempe_component(newc, c1, c2, v)\n        for w in comp:\n            newc[w-1] = c2 if newc[w-1] == c1 else c1\n        k_hat = max(k_hat, max(newc))\n\n    # Additionally, recolor one random vertex among targets to a new or existing color to shake palette\n    if targets:\n        v = targets[rnd_int(0, len(targets)-1)]\n        # choose color index possibly k_hat+1\n        choose = rnd_int(1, k_hat+1)\n        newc[v-1] = choose\n\n    newc = normalize_palette(newc)\n    # Ensure domain is valid\n    for i in range(n):\n        if newc[i] < 1:\n            newc[i] = 1\n    _ = eval_conflicts(newc)  # computed to keep symmetry with other components; not used\n    return newc\n","Resultados":[[1,1,2,3,2,3,4,2,4],4.0,[1,1,2,3,2,3,4,2,4],4.0],"Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002697361}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; length=9; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices have different labels.","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: lower is better. Feasible => max color; infeasible penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: \"Recolor\"\n    # Strategy: single-vertex greedy recolor to smallest feasible color; if none, introduce a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        # Start from trivial solution if input is invalid\n        curr = [1]*n\n    else:\n        curr = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(curr) != n:\n            curr = (curr + [1]*n)[:n]\n        for i in range(n):\n            if curr[i] < 1:\n                curr[i] = 1\n\n    # adjacency list 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = curr[:]\n    idx = random.randrange(n)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    max_c = max(new_sol) if new_sol else 1\n\n    # Try smallest feasible color\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max_c + 1\n    new_sol[idx] = chosen\n\n    return (new_sol, \"Local\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex random recolor and occasional color compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [1]*n\n    else:\n        sol = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i in range(n):\n            if sol[i] < 1:\n                sol[i] = 1\n\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Apply k random vertex recolors\n    k = random.randint(2, 4)\n    vertices = random.sample(range(n), k)\n    for i in vertices:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing a new color\n        random.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction: remap to consecutive colors starting at 1\n    unique = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(unique)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001052236}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; length=9; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices have different labels.","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: lower is better. Feasible => max color; infeasible penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: \"Recolor\"\n    # Strategy: single-vertex greedy recolor to smallest feasible color; if none, introduce a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        # Start from trivial solution if input is invalid\n        curr = [1]*n\n    else:\n        curr = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(curr) != n:\n            curr = (curr + [1]*n)[:n]\n        for i in range(n):\n            if curr[i] < 1:\n                curr[i] = 1\n\n    # adjacency list 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = curr[:]\n    idx = random.randrange(n)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    max_c = max(new_sol) if new_sol else 1\n\n    # Try smallest feasible color\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max_c + 1\n    new_sol[idx] = chosen\n\n    return (new_sol, \"Local\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex random recolor and occasional color compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [1]*n\n    else:\n        sol = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i in range(n):\n            if sol[i] < 1:\n                sol[i] = 1\n\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Apply k random vertex recolors\n    k = random.randint(2, 4)\n    vertices = random.sample(range(n), k)\n    for i in vertices:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing a new color\n        random.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction: remap to consecutive colors starting at 1\n    unique = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(unique)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.000845982}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; length=9; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices have different labels.","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: lower is better. Feasible => max color; infeasible penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: \"Recolor\"\n    # Strategy: single-vertex greedy recolor to smallest feasible color; if none, introduce a new color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        # Start from trivial solution if input is invalid\n        curr = [1]*n\n    else:\n        curr = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(curr) != n:\n            curr = (curr + [1]*n)[:n]\n        for i in range(n):\n            if curr[i] < 1:\n                curr[i] = 1\n\n    # adjacency list 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = curr[:]\n    idx = random.randrange(n)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    max_c = max(new_sol) if new_sol else 1\n\n    # Try smallest feasible color\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max_c + 1\n    new_sol[idx] = chosen\n\n    return (new_sol, \"Local\", \"Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex random recolor and occasional color compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [1]*n\n    else:\n        sol = list(int(x) if not isinstance(x, bool) else 1 for x in solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i in range(n):\n            if sol[i] < 1:\n                sol[i] = 1\n\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Apply k random vertex recolors\n    k = random.randint(2, 4)\n    vertices = random.sample(range(n), k)\n    for i in vertices:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing a new color\n        random.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction: remap to consecutive colors starting at 1\n    unique = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(unique)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.000829892}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom collections.abc import Iterable\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven single-move neighborhood with recolor, Kempe-chain swap, or color-intro as fallback.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic to construct a valid seed\n        colors = [0]*n\n        used_colors = 0\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        # degrees for tie-breaking\n        deg = [len(adj[i]) for i in range(n)]\n        while uncol:\n            # pick vertex with max saturation, then max degree\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            used_colors = max(used_colors, c)\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize\/validate input or seed via DSATUR\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            curr = []\n            for v in lst:\n                try:\n                    c = int(v)\n                except Exception:\n                    c = 1\n                if c < 1:\n                    c = 1\n                curr.append(c)\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Compute conflicts and select target vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    if conflicting_vertices:\n        # pick vertex with highest conflicts; tie-break by higher color then random\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n    else:\n        # no conflicts: try to reduce highest color class\n        hc = max_c\n        candidates = [i for i in range(n) if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n\n    # Attempt 1: greedy recolor to smallest feasible color (prefer <= current color)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    movement = \"Recolor\"\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            if c <= new_sol[idx]:\n                chosen = c\n                break\n    if chosen is None:\n        for c in range(1, max_c + 1):\n            if c not in neighbor_colors:\n                chosen = c\n                break\n    if chosen is not None and chosen != new_sol[idx]:\n        new_sol[idx] = chosen\n        return (new_sol, \"Local\", movement)\n\n    # Attempt 2: Kempe-chain swap between current color a and some b < a\n    a = new_sol[idx]\n    def kempe_component(start, color_a, color_b):\n        stack = [start]\n        comp = set([start])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (color_a, color_b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    for b in range(1, max_c + 1):\n        if b == a:\n            continue\n        comp = kempe_component(idx, a, b)\n        # swap colors on component\n        trial = new_sol[:]\n        for u in comp:\n            trial[u] = b if trial[u] == a else a\n        # check feasibility improvement for idx (now has color b)\n        ok = True\n        cb = trial[idx]\n        for j in adj[idx]:\n            if trial[j] == cb:\n                ok = False\n                break\n        if ok:\n            new_sol = trial\n            return (new_sol, \"Local\", \"KempeSwap\")\n\n    # Attempt 3: introduce new color only if strictly necessary\n    movement = \"IntroduceColor\"\n    new_sol[idx] = max_c + 1\n    return (new_sol, \"Local\", movement)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Randomized multi-vertex recolor focusing on high-color\/high-degree vertices, with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or seed fallback\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input or len(list(solution)) != n:\n        sol = dsatur_seed()\n    else:\n        sol = []\n        for v in list(solution):\n            try:\n                c = int(v)\n            except Exception:\n                c = 1\n            if c < 1:\n                c = 1\n            sol.append(c)\n\n    rng = random.Random()\n    pert = sol[:]\n\n    # Ranking by color (desc) then degree (desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n    rng.shuffle(targets)\n\n    max_c = max(pert)\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing new color\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001748084}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom collections.abc import Iterable\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven single-move neighborhood with recolor, Kempe-chain swap, or color-intro as fallback.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic to construct a valid seed\n        colors = [0]*n\n        used_colors = 0\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        # degrees for tie-breaking\n        deg = [len(adj[i]) for i in range(n)]\n        while uncol:\n            # pick vertex with max saturation, then max degree\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            used_colors = max(used_colors, c)\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize\/validate input or seed via DSATUR\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            curr = []\n            for v in lst:\n                try:\n                    c = int(v)\n                except Exception:\n                    c = 1\n                if c < 1:\n                    c = 1\n                curr.append(c)\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Compute conflicts and select target vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    if conflicting_vertices:\n        # pick vertex with highest conflicts; tie-break by higher color then random\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n    else:\n        # no conflicts: try to reduce highest color class\n        hc = max_c\n        candidates = [i for i in range(n) if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n\n    # Attempt 1: greedy recolor to smallest feasible color (prefer <= current color)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    movement = \"Recolor\"\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            if c <= new_sol[idx]:\n                chosen = c\n                break\n    if chosen is None:\n        for c in range(1, max_c + 1):\n            if c not in neighbor_colors:\n                chosen = c\n                break\n    if chosen is not None and chosen != new_sol[idx]:\n        new_sol[idx] = chosen\n        return (new_sol, \"Local\", movement)\n\n    # Attempt 2: Kempe-chain swap between current color a and some b < a\n    a = new_sol[idx]\n    def kempe_component(start, color_a, color_b):\n        stack = [start]\n        comp = set([start])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (color_a, color_b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    for b in range(1, max_c + 1):\n        if b == a:\n            continue\n        comp = kempe_component(idx, a, b)\n        # swap colors on component\n        trial = new_sol[:]\n        for u in comp:\n            trial[u] = b if trial[u] == a else a\n        # check feasibility improvement for idx (now has color b)\n        ok = True\n        cb = trial[idx]\n        for j in adj[idx]:\n            if trial[j] == cb:\n                ok = False\n                break\n        if ok:\n            new_sol = trial\n            return (new_sol, \"Local\", \"KempeSwap\")\n\n    # Attempt 3: introduce new color only if strictly necessary\n    movement = \"IntroduceColor\"\n    new_sol[idx] = max_c + 1\n    return (new_sol, \"Local\", movement)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Randomized multi-vertex recolor focusing on high-color\/high-degree vertices, with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or seed fallback\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input or len(list(solution)) != n:\n        sol = dsatur_seed()\n    else:\n        sol = []\n        for v in list(solution):\n            try:\n                c = int(v)\n            except Exception:\n                c = 1\n            if c < 1:\n                c = 1\n            sol.append(c)\n\n    rng = random.Random()\n    pert = sol[:]\n\n    # Ranking by color (desc) then degree (desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n    rng.shuffle(targets)\n\n    max_c = max(pert)\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing new color\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001584522}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom collections.abc import Iterable\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            invalid_values += 1\n            c = 0\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven single-move neighborhood with recolor, Kempe-chain swap, or color-intro as fallback.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic to construct a valid seed\n        colors = [0]*n\n        used_colors = 0\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        # degrees for tie-breaking\n        deg = [len(adj[i]) for i in range(n)]\n        while uncol:\n            # pick vertex with max saturation, then max degree\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            used_colors = max(used_colors, c)\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize\/validate input or seed via DSATUR\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            curr = []\n            for v in lst:\n                try:\n                    c = int(v)\n                except Exception:\n                    c = 1\n                if c < 1:\n                    c = 1\n                curr.append(c)\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Compute conflicts and select target vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    if conflicting_vertices:\n        # pick vertex with highest conflicts; tie-break by higher color then random\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n    else:\n        # no conflicts: try to reduce highest color class\n        hc = max_c\n        candidates = [i for i in range(n) if new_sol[i] == hc]\n        idx = rng.choice(candidates)\n\n    # Attempt 1: greedy recolor to smallest feasible color (prefer <= current color)\n    neighbor_colors = {new_sol[j] for j in adj[idx]}\n    movement = \"Recolor\"\n    chosen = None\n    for c in range(1, max_c + 1):\n        if c not in neighbor_colors:\n            if c <= new_sol[idx]:\n                chosen = c\n                break\n    if chosen is None:\n        for c in range(1, max_c + 1):\n            if c not in neighbor_colors:\n                chosen = c\n                break\n    if chosen is not None and chosen != new_sol[idx]:\n        new_sol[idx] = chosen\n        return (new_sol, \"Local\", movement)\n\n    # Attempt 2: Kempe-chain swap between current color a and some b < a\n    a = new_sol[idx]\n    def kempe_component(start, color_a, color_b):\n        stack = [start]\n        comp = set([start])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (color_a, color_b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    for b in range(1, max_c + 1):\n        if b == a:\n            continue\n        comp = kempe_component(idx, a, b)\n        # swap colors on component\n        trial = new_sol[:]\n        for u in comp:\n            trial[u] = b if trial[u] == a else a\n        # check feasibility improvement for idx (now has color b)\n        ok = True\n        cb = trial[idx]\n        for j in adj[idx]:\n            if trial[j] == cb:\n                ok = False\n                break\n        if ok:\n            new_sol = trial\n            return (new_sol, \"Local\", \"KempeSwap\")\n\n    # Attempt 3: introduce new color only if strictly necessary\n    movement = \"IntroduceColor\"\n    new_sol[idx] = max_c + 1\n    return (new_sol, \"Local\", movement)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Randomized multi-vertex recolor focusing on high-color\/high-degree vertices, with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Validate or seed fallback\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input or len(list(solution)) != n:\n        sol = dsatur_seed()\n    else:\n        sol = []\n        for v in list(solution):\n            try:\n                c = int(v)\n            except Exception:\n                c = 1\n            if c < 1:\n                c = 1\n            sol.append(c)\n\n    rng = random.Random()\n    pert = sol[:]\n\n    # Ranking by color (desc) then degree (desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n    rng.shuffle(targets)\n\n    max_c = max(pert)\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow introducing new color\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Iterable() takes no arguments","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00144864}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # strong feasibility-first pressure\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven recolor\/Kempe; in feasible state attempt K-reduction; no new color if conflict-free.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic for initial feasible seed\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            ok = True\n            for v in lst:\n                if not isinstance(v, int) or v < 1:\n                    ok = False\n                    break\n            curr = lst if ok else dsatur_seed()\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    def greedy_recolor(i: int, prefer_leq_current: bool = True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        order = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors\n        freq = {c: 0 for c in order}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        order.sort(key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            order = [c for c in order if c <= new_sol[i]] + [c for c in order if c > new_sol[i]]\n        for c in order:\n            if c not in neighbor_colors:\n                return c\n        return None\n\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; break ties by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        # tie-break on degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        # Attempt 1: greedy recolor within existing palette\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            return (new_sol, \"Local\", \"Recolor\")\n\n        # Attempt 2: Kempe swap to resolve conflict\n        a = new_sol[idx]\n        for b in range(1, max_c + 1):\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            # check if idx conflict resolved\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # Attempt 3: introduce new color as last resort under conflicts\n        new_sol[idx] = max_c + 1\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by moving a vertex from max color to a lower feasible color\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                # If no vertex remains with old max color, K reduces implicitly\n                return (new_sol, \"Local\", \"Recolor\")\n        # Try Kempe to reduce max color count\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                # ensure idx color becomes b and remains feasible\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = trial\n                    return (new_sol, \"Local\", \"KempeSwap\")\n        # No beneficial move; keep solution\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            sol = dsatur_seed()\n        else:\n            sol = lst\n\n    rng = random.Random()\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Phase 1: target top span vertices by (color desc, degree desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: apply a few random Kempe swaps to diversify\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in set(pert) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.0022136}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # strong feasibility-first pressure\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven recolor\/Kempe; in feasible state attempt K-reduction; no new color if conflict-free.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic for initial feasible seed\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            ok = True\n            for v in lst:\n                if not isinstance(v, int) or v < 1:\n                    ok = False\n                    break\n            curr = lst if ok else dsatur_seed()\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    def greedy_recolor(i: int, prefer_leq_current: bool = True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        order = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors\n        freq = {c: 0 for c in order}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        order.sort(key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            order = [c for c in order if c <= new_sol[i]] + [c for c in order if c > new_sol[i]]\n        for c in order:\n            if c not in neighbor_colors:\n                return c\n        return None\n\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; break ties by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        # tie-break on degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        # Attempt 1: greedy recolor within existing palette\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            return (new_sol, \"Local\", \"Recolor\")\n\n        # Attempt 2: Kempe swap to resolve conflict\n        a = new_sol[idx]\n        for b in range(1, max_c + 1):\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            # check if idx conflict resolved\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # Attempt 3: introduce new color as last resort under conflicts\n        new_sol[idx] = max_c + 1\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by moving a vertex from max color to a lower feasible color\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                # If no vertex remains with old max color, K reduces implicitly\n                return (new_sol, \"Local\", \"Recolor\")\n        # Try Kempe to reduce max color count\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                # ensure idx color becomes b and remains feasible\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = trial\n                    return (new_sol, \"Local\", \"KempeSwap\")\n        # No beneficial move; keep solution\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            sol = dsatur_seed()\n        else:\n            sol = lst\n\n    rng = random.Random()\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Phase 1: target top span vertices by (color desc, degree desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: apply a few random Kempe swaps to diversify\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in set(pert) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.001781184}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # strong feasibility-first pressure\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Conflict-driven recolor\/Kempe; in feasible state attempt K-reduction; no new color if conflict-free.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        # DSATUR heuristic for initial feasible seed\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        curr = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n:\n            curr = dsatur_seed()\n        else:\n            ok = True\n            for v in lst:\n                if not isinstance(v, int) or v < 1:\n                    ok = False\n                    break\n            curr = lst if ok else dsatur_seed()\n\n    new_sol = curr[:]\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random()\n\n    def greedy_recolor(i: int, prefer_leq_current: bool = True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        order = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors\n        freq = {c: 0 for c in order}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        order.sort(key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            order = [c for c in order if c <= new_sol[i]] + [c for c in order if c > new_sol[i]]\n        for c in order:\n            if c not in neighbor_colors:\n                return c\n        return None\n\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; break ties by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        # tie-break on degree\n        deg = [len(adj[i]) for i in range(n)]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        # Attempt 1: greedy recolor within existing palette\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            return (new_sol, \"Local\", \"Recolor\")\n\n        # Attempt 2: Kempe swap to resolve conflict\n        a = new_sol[idx]\n        for b in range(1, max_c + 1):\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            # check if idx conflict resolved\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # Attempt 3: introduce new color as last resort under conflicts\n        new_sol[idx] = max_c + 1\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by moving a vertex from max color to a lower feasible color\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                # If no vertex remains with old max color, K reduces implicitly\n                return (new_sol, \"Local\", \"Recolor\")\n        # Try Kempe to reduce max color count\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                # ensure idx color becomes b and remains feasible\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = trial\n                    return (new_sol, \"Local\", \"KempeSwap\")\n        # No beneficial move; keep solution\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_seed() -> List[int]:\n        colors = [0]*n\n        sat_deg = [0]*n\n        deg = [len(adj[i]) for i in range(n)]\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            sol = dsatur_seed()\n        else:\n            sol = lst\n\n    rng = random.Random()\n    pert = sol[:]\n    max_c = max(pert)\n\n    # Phase 1: target top span vertices by (color desc, degree desc)\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: apply a few random Kempe swaps to diversify\n    def kempe_component(start: int, a: int, b: int):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in set(pert) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002214499}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 200_000\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency and degrees (constants for this graph)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        new_sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            new_sol = dsatur_seed()\n        else:\n            new_sol = lst[:]\n\n    # Palette compaction to remove gaps\n    uniq = sorted(set(new_sol))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    new_sol = [remap[c] for c in new_sol]\n\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random(1337)\n\n    def color_conflicts_if(i, color):\n        cnt = 0\n        for j in adj[i]:\n            if new_sol[j] == color:\n                cnt += 1\n        return cnt\n\n    def greedy_recolor(i, prefer_leq_current=True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        palette = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors, then by 2-hop avoidance\n        freq = {c: 0 for c in palette}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        ordered = sorted(palette, key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            ordered = [c for c in ordered if c <= new_sol[i]] + [c for c in ordered if c > new_sol[i]]\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in ordered:\n            if c in neighbor_colors:\n                continue\n            # score by resulting immediate conflicts on neighbors and color value\n            res_conf = 0\n            for j in adj[i]:\n                if new_sol[j] == c:\n                    res_conf += 1\n            score = (res_conf, c)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; tie-break by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            # compact palette\n            uniq = sorted(set(new_sol))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            new_sol = [remap[c] for c in new_sol]\n            return (new_sol, \"Local\", \"Recolor\")\n\n        a = new_sol[idx]\n        # try several b colors\n        order_b = list(range(1, max_c + 1))\n        rng.shuffle(order_b)\n        for b in order_b:\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # introduce new color as last resort\n        new_sol[idx] = max_c + 1\n        uniq = sorted(set(new_sol))\n        remap = {c:i+1 for i,c in enumerate(uniq)}\n        new_sol = [remap[c] for c in new_sol]\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by eliminating max color class\n        max_c = max(new_sol)\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        # try sequential recolor of entire max class\n        order = sorted(max_class, key=lambda i: (-deg[i]))\n        trial = new_sol[:]\n        success = True\n        for idx in order:\n            neighbor_colors = {trial[j] for j in adj[idx]}\n            palette = list(range(1, max_c))  # force move to lower color if possible\n            # order by minimal conflicts\n            palette.sort(key=lambda c: (sum(1 for j in adj[idx] if trial[j] == c), c))\n            placed = False\n            for c in palette:\n                if c not in neighbor_colors:\n                    trial[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            uniq = sorted(set(trial))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            trial = [remap[c] for c in trial]\n            return (trial, \"Local\", \"ClassElimination\")\n\n        # fallback: single-vertex recolor from max class\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"Recolor\")\n\n        # Kempe attempts targeting max color\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    uniq = sorted(set(trial))\n                    remap = {c:i+1 for i,c in enumerate(uniq)}\n                    trial = [remap[c] for c in trial]\n                    return (trial, \"Local\", \"KempeSwap\")\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        pert = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            pert = dsatur_seed()\n        else:\n            pert = lst[:]\n\n    rng = random.Random(20240517)\n    max_c = max(pert)\n\n    # Phase 1: bias to perturb top-span vertices by (color desc, degree desc)\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: a couple of random Kempe swaps\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in sorted(set(pert)) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002557223}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 200_000\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency and degrees (constants for this graph)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        new_sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            new_sol = dsatur_seed()\n        else:\n            new_sol = lst[:]\n\n    # Palette compaction to remove gaps\n    uniq = sorted(set(new_sol))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    new_sol = [remap[c] for c in new_sol]\n\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random(1337)\n\n    def color_conflicts_if(i, color):\n        cnt = 0\n        for j in adj[i]:\n            if new_sol[j] == color:\n                cnt += 1\n        return cnt\n\n    def greedy_recolor(i, prefer_leq_current=True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        palette = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors, then by 2-hop avoidance\n        freq = {c: 0 for c in palette}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        ordered = sorted(palette, key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            ordered = [c for c in ordered if c <= new_sol[i]] + [c for c in ordered if c > new_sol[i]]\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in ordered:\n            if c in neighbor_colors:\n                continue\n            # score by resulting immediate conflicts on neighbors and color value\n            res_conf = 0\n            for j in adj[i]:\n                if new_sol[j] == c:\n                    res_conf += 1\n            score = (res_conf, c)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; tie-break by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            # compact palette\n            uniq = sorted(set(new_sol))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            new_sol = [remap[c] for c in new_sol]\n            return (new_sol, \"Local\", \"Recolor\")\n\n        a = new_sol[idx]\n        # try several b colors\n        order_b = list(range(1, max_c + 1))\n        rng.shuffle(order_b)\n        for b in order_b:\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # introduce new color as last resort\n        new_sol[idx] = max_c + 1\n        uniq = sorted(set(new_sol))\n        remap = {c:i+1 for i,c in enumerate(uniq)}\n        new_sol = [remap[c] for c in new_sol]\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by eliminating max color class\n        max_c = max(new_sol)\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        # try sequential recolor of entire max class\n        order = sorted(max_class, key=lambda i: (-deg[i]))\n        trial = new_sol[:]\n        success = True\n        for idx in order:\n            neighbor_colors = {trial[j] for j in adj[idx]}\n            palette = list(range(1, max_c))  # force move to lower color if possible\n            # order by minimal conflicts\n            palette.sort(key=lambda c: (sum(1 for j in adj[idx] if trial[j] == c), c))\n            placed = False\n            for c in palette:\n                if c not in neighbor_colors:\n                    trial[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            uniq = sorted(set(trial))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            trial = [remap[c] for c in trial]\n            return (trial, \"Local\", \"ClassElimination\")\n\n        # fallback: single-vertex recolor from max class\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"Recolor\")\n\n        # Kempe attempts targeting max color\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    uniq = sorted(set(trial))\n                    remap = {c:i+1 for i,c in enumerate(uniq)}\n                    trial = [remap[c] for c in trial]\n                    return (trial, \"Local\", \"KempeSwap\")\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        pert = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            pert = dsatur_seed()\n        else:\n            pert = lst[:]\n\n    rng = random.Random(20240517)\n    max_c = max(pert)\n\n    # Phase 1: bias to perturb top-span vertices by (color desc, degree desc)\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: a couple of random Kempe swaps\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in sorted(set(pert)) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.002717985}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS; position i (1-based vertex i) stores positive integer color label; objective=minimize max(label); feasibility: adjacent vertices must have different labels.","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> float:\n    # Lower is better. Feasible => max color; infeasible heavily penalized strictly.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 200_000\n    PENALTY_VALUE = 100\n\n    # Type\/shape validation\n    if solution is None or not hasattr(solution, \"__iter__\") or isinstance(solution, (str, bytes)):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    # Strict int and positivity check\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n    return max_color\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build 0-based adjacency and degrees (constants for this graph)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Normalize input or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        new_sol = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            new_sol = dsatur_seed()\n        else:\n            new_sol = lst[:]\n\n    # Palette compaction to remove gaps\n    uniq = sorted(set(new_sol))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    new_sol = [remap[c] for c in new_sol]\n\n    max_c = max(new_sol) if new_sol else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for i in range(n):\n        ci = new_sol[i]\n        for j in adj[i]:\n            if new_sol[j] == ci:\n                conflicts[i] += 1\n    conflicting_vertices = [i for i in range(n) if conflicts[i] > 0]\n\n    rng = random.Random(1337)\n\n    def color_conflicts_if(i, color):\n        cnt = 0\n        for j in adj[i]:\n            if new_sol[j] == color:\n                cnt += 1\n        return cnt\n\n    def greedy_recolor(i, prefer_leq_current=True):\n        neighbor_colors = {new_sol[j] for j in adj[i]}\n        palette = list(range(1, max_c + 1))\n        # prioritize colors that appear least among neighbors, then by 2-hop avoidance\n        freq = {c: 0 for c in palette}\n        for j in adj[i]:\n            c = new_sol[j]\n            if c in freq:\n                freq[c] += 1\n        ordered = sorted(palette, key=lambda c: (freq.get(c, 0), c))\n        if prefer_leq_current:\n            ordered = [c for c in ordered if c <= new_sol[i]] + [c for c in ordered if c > new_sol[i]]\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in ordered:\n            if c in neighbor_colors:\n                continue\n            # score by resulting immediate conflicts on neighbors and color value\n            res_conf = 0\n            for j in adj[i]:\n                if new_sol[j] == c:\n                    res_conf += 1\n            score = (res_conf, c)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and new_sol[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    if conflicting_vertices:\n        # choose vertex with highest conflicts; tie-break by color then degree\n        m = max(conflicts[i] for i in conflicting_vertices)\n        candidates = [i for i in conflicting_vertices if conflicts[i] == m]\n        hc = max(new_sol[i] for i in candidates)\n        candidates = [i for i in candidates if new_sol[i] == hc]\n        best_deg = max(deg[i] for i in candidates)\n        candidates = [i for i in candidates if deg[i] == best_deg]\n        idx = rng.choice(candidates)\n\n        chosen = greedy_recolor(idx, prefer_leq_current=False)\n        if chosen is not None and chosen != new_sol[idx]:\n            new_sol[idx] = chosen\n            # compact palette\n            uniq = sorted(set(new_sol))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            new_sol = [remap[c] for c in new_sol]\n            return (new_sol, \"Local\", \"Recolor\")\n\n        a = new_sol[idx]\n        # try several b colors\n        order_b = list(range(1, max_c + 1))\n        rng.shuffle(order_b)\n        for b in order_b:\n            if b == a:\n                continue\n            comp = kempe_component(idx, a, b)\n            trial = new_sol[:]\n            for u in comp:\n                trial[u] = b if trial[u] == a else a\n            ok = True\n            cb = trial[idx]\n            for j in adj[idx]:\n                if trial[j] == cb:\n                    ok = False\n                    break\n            if ok:\n                new_sol = trial\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"KempeSwap\")\n\n        # introduce new color as last resort\n        new_sol[idx] = max_c + 1\n        uniq = sorted(set(new_sol))\n        remap = {c:i+1 for i,c in enumerate(uniq)}\n        new_sol = [remap[c] for c in new_sol]\n        return (new_sol, \"Local\", \"IntroduceColor\")\n    else:\n        # Feasible: attempt to reduce K by eliminating max color class\n        max_c = max(new_sol)\n        max_class = [i for i in range(n) if new_sol[i] == max_c]\n        # try sequential recolor of entire max class\n        order = sorted(max_class, key=lambda i: (-deg[i]))\n        trial = new_sol[:]\n        success = True\n        for idx in order:\n            neighbor_colors = {trial[j] for j in adj[idx]}\n            palette = list(range(1, max_c))  # force move to lower color if possible\n            # order by minimal conflicts\n            palette.sort(key=lambda c: (sum(1 for j in adj[idx] if trial[j] == c), c))\n            placed = False\n            for c in palette:\n                if c not in neighbor_colors:\n                    trial[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            uniq = sorted(set(trial))\n            remap = {c:i+1 for i,c in enumerate(uniq)}\n            trial = [remap[c] for c in trial]\n            return (trial, \"Local\", \"ClassElimination\")\n\n        # fallback: single-vertex recolor from max class\n        rng.shuffle(max_class)\n        for idx in max_class:\n            chosen = greedy_recolor(idx, prefer_leq_current=True)\n            if chosen is not None and chosen < max_c:\n                new_sol[idx] = chosen\n                uniq = sorted(set(new_sol))\n                remap = {c:i+1 for i,c in enumerate(uniq)}\n                new_sol = [remap[c] for c in new_sol]\n                return (new_sol, \"Local\", \"Recolor\")\n\n        # Kempe attempts targeting max color\n        for idx in max_class:\n            a = new_sol[idx]\n            for b in range(1, max_c):\n                comp = kempe_component(idx, a, b)\n                trial = new_sol[:]\n                for u in comp:\n                    trial[u] = b if trial[u] == a else a\n                if trial[idx] != b:\n                    continue\n                ok = True\n                for j in adj[idx]:\n                    if trial[j] == trial[idx]:\n                        ok = False\n                        break\n                if ok:\n                    uniq = sorted(set(trial))\n                    remap = {c:i+1 for i,c in enumerate(uniq)}\n                    trial = [remap[c] for c in trial]\n                    return (trial, \"Local\", \"KempeSwap\")\n        return (new_sol, \"Local\", \"NoOp\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex randomized recolor + Kempe perturbations with compaction.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency 0-based\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    deg = [len(adj[i]) for i in range(n)]\n\n    def dsatur_seed():\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncol = set(range(n))\n        while uncol:\n            best = max(uncol, key=lambda i: (sat_deg[i], deg[i]))\n            forbid = {colors[j] for j in adj[best] if colors[j] != 0}\n            c = 1\n            while c in forbid:\n                c += 1\n            colors[best] = c\n            uncol.remove(best)\n            for j in adj[best]:\n                if colors[j] == 0:\n                    sat_deg[j] = len({colors[k] for k in adj[j] if colors[k] != 0})\n        return colors\n\n    # Validate or seed\n    valid_input = (\n        solution is not None and hasattr(solution, \"__iter__\") and not isinstance(solution, (str, bytes))\n    )\n    if not valid_input:\n        pert = dsatur_seed()\n    else:\n        lst = list(solution)\n        if len(lst) != n or any((not isinstance(v, int) or v < 1) for v in lst):\n            pert = dsatur_seed()\n        else:\n            pert = lst[:]\n\n    rng = random.Random(20240517)\n    max_c = max(pert)\n\n    # Phase 1: bias to perturb top-span vertices by (color desc, degree desc)\n    order = sorted(range(n), key=lambda i: (pert[i], deg[i]), reverse=True)\n    span = max(3, n \/\/ 3)\n    targets = order[:span]\n\n    for i in targets:\n        neighbor_colors = {pert[j] for j in adj[i]}\n        palette = list(range(1, max_c + 2))  # allow new color temporarily\n        rng.shuffle(palette)\n        for c in palette:\n            if c not in neighbor_colors:\n                pert[i] = c\n                break\n\n    # Phase 2: a couple of random Kempe swaps\n    def kempe_component(start, a, b):\n        stack = [start]\n        comp = {start}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in comp and pert[v] in (a, b):\n                    comp.add(v)\n                    stack.append(v)\n        return comp\n\n    kempe_trials = 2\n    for _ in range(kempe_trials):\n        i = rng.randrange(n)\n        a = pert[i]\n        b_choices = [c for c in sorted(set(pert)) if c != a]\n        if not b_choices:\n            continue\n        b = rng.choice(b_choices)\n        comp = kempe_component(i, a, b)\n        for u in comp:\n            pert[u] = b if pert[u] == a else a\n\n    # Phase 3: color compaction to consecutive labels starting at 1\n    uniq = sorted(set(pert))\n    remap = {c:i+1 for i,c in enumerate(uniq)}\n    pert = [remap[c] for c in pert]\n\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002435602}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_LABELS_IN_{1..k}. ORDER=[c(1),c(2),...,c(9)].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible solutions: number of colors used (labels must be exactly {1..k} to avoid small penalty).\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor by recoloring one vertex to a different color (prefer non-conflicting colors).\n    # Returns (new_solution, movement_type_str)\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # adjacency list (1-based keys)\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    i = random.randrange(n)  # 0-based index of vertex to recolor\n    current_color = new_sol[i]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = list(range(1, max_color + 2))  # allow introducing at most one new color\n    # Remove current color to enforce a change\n    candidate_colors = [c for c in candidate_colors if c != current_color]\n    # Filter colors that do not conflict with neighbors\n    def conflicts_with(i0, color_val):\n        vi = i0 + 1  # 1-based\n        for nb in adj[vi]:\n            if new_sol[nb-1] == color_val:\n                return True\n        return False\n    non_conflicting = [c for c in candidate_colors if not conflicts_with(i, c)]\n    if non_conflicting:\n        new_color = random.choice(non_conflicting)\n    else:\n        new_color = random.choice(candidate_colors)\n    new_sol[i] = new_color\n    return (new_sol, \"Recolor-One-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset of vertices with heuristic bias to reduce conflicts.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        current_color = new_sol[i]\n        candidate_colors = list(range(1, max_color + 2))\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        # Prefer colors least used among neighbors\n        nb_colors = [new_sol[j-1] for j in adj[i+1]]\n        color_penalty = {c: nb_colors.count(c) for c in candidate_colors}\n        # Sort by increasing neighbor frequency, tie-break random\n        random.shuffle(candidate_colors)\n        candidate_colors.sort(key=lambda c: color_penalty[c])\n        # Choose best available; if none reduce conflicts, pick first\n        new_sol[i] = candidate_colors[0]\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.000941512}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_LABELS_IN_{1..k}. ORDER=[c(1),c(2),...,c(9)].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible solutions: number of colors used (labels must be exactly {1..k} to avoid small penalty).\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor by recoloring one vertex to a different color (prefer non-conflicting colors).\n    # Returns (new_solution, movement_type_str)\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # adjacency list (1-based keys)\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    i = random.randrange(n)  # 0-based index of vertex to recolor\n    current_color = new_sol[i]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = list(range(1, max_color + 2))  # allow introducing at most one new color\n    # Remove current color to enforce a change\n    candidate_colors = [c for c in candidate_colors if c != current_color]\n    # Filter colors that do not conflict with neighbors\n    def conflicts_with(i0, color_val):\n        vi = i0 + 1  # 1-based\n        for nb in adj[vi]:\n            if new_sol[nb-1] == color_val:\n                return True\n        return False\n    non_conflicting = [c for c in candidate_colors if not conflicts_with(i, c)]\n    if non_conflicting:\n        new_color = random.choice(non_conflicting)\n    else:\n        new_color = random.choice(candidate_colors)\n    new_sol[i] = new_color\n    return (new_sol, \"Recolor-One-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset of vertices with heuristic bias to reduce conflicts.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        current_color = new_sol[i]\n        candidate_colors = list(range(1, max_color + 2))\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        # Prefer colors least used among neighbors\n        nb_colors = [new_sol[j-1] for j in adj[i+1]]\n        color_penalty = {c: nb_colors.count(c) for c in candidate_colors}\n        # Sort by increasing neighbor frequency, tie-break random\n        random.shuffle(candidate_colors)\n        candidate_colors.sort(key=lambda c: color_penalty[c])\n        # Choose best available; if none reduce conflicts, pick first\n        new_sol[i] = candidate_colors[0]\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.00080001}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_LABELS_IN_{1..k}. ORDER=[c(1),c(2),...,c(9)].","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible solutions: number of colors used (labels must be exactly {1..k} to avoid small penalty).\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor by recoloring one vertex to a different color (prefer non-conflicting colors).\n    # Returns (new_solution, movement_type_str)\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # adjacency list (1-based keys)\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    i = random.randrange(n)  # 0-based index of vertex to recolor\n    current_color = new_sol[i]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = list(range(1, max_color + 2))  # allow introducing at most one new color\n    # Remove current color to enforce a change\n    candidate_colors = [c for c in candidate_colors if c != current_color]\n    # Filter colors that do not conflict with neighbors\n    def conflicts_with(i0, color_val):\n        vi = i0 + 1  # 1-based\n        for nb in adj[vi]:\n            if new_sol[nb-1] == color_val:\n                return True\n        return False\n    non_conflicting = [c for c in candidate_colors if not conflicts_with(i, c)]\n    if non_conflicting:\n        new_color = random.choice(non_conflicting)\n    else:\n        new_color = random.choice(candidate_colors)\n    new_sol[i] = new_color\n    return (new_sol, \"Recolor-One-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset of vertices with heuristic bias to reduce conflicts.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Number of vertices to perturb: between 2 and 5\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        current_color = new_sol[i]\n        candidate_colors = list(range(1, max_color + 2))\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        # Prefer colors least used among neighbors\n        nb_colors = [new_sol[j-1] for j in adj[i+1]]\n        color_penalty = {c: nb_colors.count(c) for c in candidate_colors}\n        # Sort by increasing neighbor frequency, tie-break random\n        random.shuffle(candidate_colors)\n        candidate_colors.sort(key=lambda c: color_penalty[c])\n        # Choose best available; if none reduce conflicts, pick first\n        new_sol[i] = candidate_colors[0]\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00077686}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Identify conflicting vertices and saturation degrees\n    conflicts_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u-1)\n            conflicts_vertices.add(v-1)\n    # Vertex selection bias: conflicting vertices first; else highest saturation degree\n    candidates = list(conflicts_vertices)\n    if not candidates:\n        sat_deg = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat_deg.append((len(nb_colors), v-1))\n        max_sat = max(sat_deg)[0]\n        candidates = [idx for deg, idx in sat_deg if deg == max_sat]\n    i = random.choice(candidates)\n    vi = i + 1\n    current_color = new_sol[i]\n    palette = sorted(set(new_sol))\n    # Helper: find allowed colors (no neighbor conflict)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # Move types: try in order for quality; fallback to random recolor\n    # 1) Recolor to an existing allowed color (avoid introducing new colors)\n    if allowed:\n        new_sol[i] = random.choice(allowed)\n        return (canonicalize(new_sol), \"Recolor-Allowed\")\n    # 2) Kempe chain interchange between current_color and a neighbor color\n    if adj[vi]:\n        target_color = random.choice(list(nb_cols)) if nb_cols else current_color\n        if target_color != current_color:\n            cA, cB = current_color, target_color\n            # BFS over vertices colored cA or cB starting at vi\n            visited = set()\n            q = deque([vi])\n            visited.add(vi)\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            # Swap colors on the Kempe chain\n            for x in visited:\n                if new_sol[x-1] == cA:\n                    new_sol[x-1] = cB\n                elif new_sol[x-1] == cB:\n                    new_sol[x-1] = cA\n            return (canonicalize(new_sol), \"Kempe-Chain-Swap\")\n    # 3) Global color class swap between two colors\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for t in range(n):\n            if new_sol[t] == a:\n                new_sol[t] = b\n            elif new_sol[t] == b:\n                new_sol[t] = a\n        return (canonicalize(new_sol), \"ColorClass-Swap\")\n    # 4) Two-vertex coordinated recolor: recolor i and one neighbor\n    if adj[vi]:\n        j = random.choice(adj[vi]) - 1\n        # Try move j to a different non-conflicting color\n        nb_cols_j = set(new_sol[x-1] for x in adj[j+1])\n        allowed_j = [c for c in palette if c != new_sol[j] and c not in nb_cols_j]\n        if allowed_j:\n            new_sol[j] = random.choice(allowed_j)\n            # After freeing neighbor color, try recoloring i again\n            nb_cols = set(new_sol[x-1] for x in adj[vi])\n            allowed2 = [c for c in palette if c != current_color and c not in nb_cols]\n            if allowed2:\n                new_sol[i] = random.choice(allowed2)\n            return (canonicalize(new_sol), \"TwoVertex-Coordinated\")\n    # 5) Fallback: recolor i to a random color from palette or at most introduce one new color\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    new_sol[i] = random.choice(candidate_colors)\n    return (canonicalize(new_sol), \"Recolor-Random\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n    # 1) Apply a few random Kempe-chain flips between random color pairs\n    flips = random.randint(1, 3)\n    for _ in range(flips):\n        if k < 2:\n            break\n        a, b = random.sample(used_colors, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n        used_colors = sorted(set(new_sol))\n        k = len(used_colors)\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        random.shuffle(candidate)\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    target_colors = [c for c in palette if counts[c] == min(counts.values())]\n    if target_colors:\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        # if all reassigned, color disappears implicitly on canonicalization\n    return canonicalize(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.001939414}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Identify conflicting vertices and saturation degrees\n    conflicts_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u-1)\n            conflicts_vertices.add(v-1)\n    # Vertex selection bias: conflicting vertices first; else highest saturation degree\n    candidates = list(conflicts_vertices)\n    if not candidates:\n        sat_deg = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat_deg.append((len(nb_colors), v-1))\n        max_sat = max(sat_deg)[0]\n        candidates = [idx for deg, idx in sat_deg if deg == max_sat]\n    i = random.choice(candidates)\n    vi = i + 1\n    current_color = new_sol[i]\n    palette = sorted(set(new_sol))\n    # Helper: find allowed colors (no neighbor conflict)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # Move types: try in order for quality; fallback to random recolor\n    # 1) Recolor to an existing allowed color (avoid introducing new colors)\n    if allowed:\n        new_sol[i] = random.choice(allowed)\n        return (canonicalize(new_sol), \"Recolor-Allowed\")\n    # 2) Kempe chain interchange between current_color and a neighbor color\n    if adj[vi]:\n        target_color = random.choice(list(nb_cols)) if nb_cols else current_color\n        if target_color != current_color:\n            cA, cB = current_color, target_color\n            # BFS over vertices colored cA or cB starting at vi\n            visited = set()\n            q = deque([vi])\n            visited.add(vi)\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            # Swap colors on the Kempe chain\n            for x in visited:\n                if new_sol[x-1] == cA:\n                    new_sol[x-1] = cB\n                elif new_sol[x-1] == cB:\n                    new_sol[x-1] = cA\n            return (canonicalize(new_sol), \"Kempe-Chain-Swap\")\n    # 3) Global color class swap between two colors\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for t in range(n):\n            if new_sol[t] == a:\n                new_sol[t] = b\n            elif new_sol[t] == b:\n                new_sol[t] = a\n        return (canonicalize(new_sol), \"ColorClass-Swap\")\n    # 4) Two-vertex coordinated recolor: recolor i and one neighbor\n    if adj[vi]:\n        j = random.choice(adj[vi]) - 1\n        # Try move j to a different non-conflicting color\n        nb_cols_j = set(new_sol[x-1] for x in adj[j+1])\n        allowed_j = [c for c in palette if c != new_sol[j] and c not in nb_cols_j]\n        if allowed_j:\n            new_sol[j] = random.choice(allowed_j)\n            # After freeing neighbor color, try recoloring i again\n            nb_cols = set(new_sol[x-1] for x in adj[vi])\n            allowed2 = [c for c in palette if c != current_color and c not in nb_cols]\n            if allowed2:\n                new_sol[i] = random.choice(allowed2)\n            return (canonicalize(new_sol), \"TwoVertex-Coordinated\")\n    # 5) Fallback: recolor i to a random color from palette or at most introduce one new color\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    new_sol[i] = random.choice(candidate_colors)\n    return (canonicalize(new_sol), \"Recolor-Random\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n    # 1) Apply a few random Kempe-chain flips between random color pairs\n    flips = random.randint(1, 3)\n    for _ in range(flips):\n        if k < 2:\n            break\n        a, b = random.sample(used_colors, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n        used_colors = sorted(set(new_sol))\n        k = len(used_colors)\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        random.shuffle(candidate)\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    target_colors = [c for c in palette if counts[c] == min(counts.values())]\n    if target_colors:\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        # if all reassigned, color disappears implicitly on canonicalization\n    return canonicalize(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.00157933}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    max_color = max(used_colors) if used_colors else 1\n    # Identify conflicting vertices and saturation degrees\n    conflicts_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u-1)\n            conflicts_vertices.add(v-1)\n    # Vertex selection bias: conflicting vertices first; else highest saturation degree\n    candidates = list(conflicts_vertices)\n    if not candidates:\n        sat_deg = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat_deg.append((len(nb_colors), v-1))\n        max_sat = max(sat_deg)[0]\n        candidates = [idx for deg, idx in sat_deg if deg == max_sat]\n    i = random.choice(candidates)\n    vi = i + 1\n    current_color = new_sol[i]\n    palette = sorted(set(new_sol))\n    # Helper: find allowed colors (no neighbor conflict)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # Move types: try in order for quality; fallback to random recolor\n    # 1) Recolor to an existing allowed color (avoid introducing new colors)\n    if allowed:\n        new_sol[i] = random.choice(allowed)\n        return (canonicalize(new_sol), \"Recolor-Allowed\")\n    # 2) Kempe chain interchange between current_color and a neighbor color\n    if adj[vi]:\n        target_color = random.choice(list(nb_cols)) if nb_cols else current_color\n        if target_color != current_color:\n            cA, cB = current_color, target_color\n            # BFS over vertices colored cA or cB starting at vi\n            visited = set()\n            q = deque([vi])\n            visited.add(vi)\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            # Swap colors on the Kempe chain\n            for x in visited:\n                if new_sol[x-1] == cA:\n                    new_sol[x-1] = cB\n                elif new_sol[x-1] == cB:\n                    new_sol[x-1] = cA\n            return (canonicalize(new_sol), \"Kempe-Chain-Swap\")\n    # 3) Global color class swap between two colors\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for t in range(n):\n            if new_sol[t] == a:\n                new_sol[t] = b\n            elif new_sol[t] == b:\n                new_sol[t] = a\n        return (canonicalize(new_sol), \"ColorClass-Swap\")\n    # 4) Two-vertex coordinated recolor: recolor i and one neighbor\n    if adj[vi]:\n        j = random.choice(adj[vi]) - 1\n        # Try move j to a different non-conflicting color\n        nb_cols_j = set(new_sol[x-1] for x in adj[j+1])\n        allowed_j = [c for c in palette if c != new_sol[j] and c not in nb_cols_j]\n        if allowed_j:\n            new_sol[j] = random.choice(allowed_j)\n            # After freeing neighbor color, try recoloring i again\n            nb_cols = set(new_sol[x-1] for x in adj[vi])\n            allowed2 = [c for c in palette if c != current_color and c not in nb_cols]\n            if allowed2:\n                new_sol[i] = random.choice(allowed2)\n            return (canonicalize(new_sol), \"TwoVertex-Coordinated\")\n    # 5) Fallback: recolor i to a random color from palette or at most introduce one new color\n    candidate_colors = list(range(1, max_color + 2))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    new_sol[i] = random.choice(candidate_colors)\n    return (canonicalize(new_sol), \"Recolor-Random\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n    # 1) Apply a few random Kempe-chain flips between random color pairs\n    flips = random.randint(1, 3)\n    for _ in range(flips):\n        if k < 2:\n            break\n        a, b = random.sample(used_colors, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n        used_colors = sorted(set(new_sol))\n        k = len(used_colors)\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = random.randint(2, 5)\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        random.shuffle(candidate)\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    target_colors = [c for c in palette if counts[c] == min(counts.values())]\n    if target_colors:\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        # if all reassigned, color disappears implicitly on canonicalization\n    return canonicalize(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.001517228}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using DSATUR order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Order vertices by descending degree (tie-break by index for determinism)\n        vertices.sort(key=lambda i: (-deg[i+1], i))\n        for i in vertices:\n            vi = i + 1\n            nb_cols = set(base[j-1] for j in adj[vi])\n            allowed = [c for c in palette if c != target and c not in nb_cols]\n            # First-improvement: choose the smallest feasible color to be deterministic\n            if allowed:\n                base[i] = min(allowed)\n            else:\n                return None  # fail\n        return canonicalize(base)\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, first attempt a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a vertex deterministically\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u,v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))  # deterministic\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # deterministic scan: prefer smallest color\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            # keep feasible; prefer not increasing palette (guaranteed since c in palette)\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of two vertices if it improves or preserves feasibility\n    # Scan neighbors first for locality\n    candidates = list(set([v-1 for v in adj[vi]] + list(range(n))))\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a conflicting neighbor color (or any neighbor color if feasible)\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set(nb_cols_list))\n    if target_candidates:\n        # deterministic choice: smallest neighbor color different from current\n        target_candidates = [c for c in sorted(target_candidates) if c != current_color]\n        if target_candidates:\n            cA, cB = current_color, target_candidates[0]\n            visited = set([vi])\n            q = deque([vi])\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            trial = new_sol[:]\n            for x in visited:\n                if trial[x-1] == cA:\n                    trial[x-1] = cB\n                elif trial[x-1] == cB:\n                    trial[x-1] = cA\n            if current_conf > 0:\n                if conflicts_of(trial) < current_conf:\n                    return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n            else:\n                if is_feasible(trial):\n                    return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # Global color-class swap between two colors (feasibility preserved)\n    if len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if current_conf > 0:\n            if conflicts_of(trial) <= current_conf:\n                return (canonicalize(trial), \"ColorClass-Swap-NonWorse\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"ColorClass-Swap-Feasible\")\n\n    # Fallback: recolor i to another color, possibly introducing one new color but never exceeding n\n    max_color = max(palette) if palette else 1\n    candidate_colors = list(range(1, min(n, max_color + 1) + 1))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if candidate_colors:\n        trial = new_sol[:]\n        trial[i] = min(candidate_colors)\n        return (canonicalize(trial), \"Recolor-Fallback\")\n\n    return (canonicalize(new_sol), \"NoOp-Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    flips = 2 if k >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(2, k))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        min_count = min(counts.values())\n        target_colors = [c for c in palette if counts[c] == min_count]\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n    return canonicalize(new_sol)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.00000516}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using DSATUR order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Order vertices by descending degree (tie-break by index for determinism)\n        vertices.sort(key=lambda i: (-deg[i+1], i))\n        for i in vertices:\n            vi = i + 1\n            nb_cols = set(base[j-1] for j in adj[vi])\n            allowed = [c for c in palette if c != target and c not in nb_cols]\n            # First-improvement: choose the smallest feasible color to be deterministic\n            if allowed:\n                base[i] = min(allowed)\n            else:\n                return None  # fail\n        return canonicalize(base)\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, first attempt a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a vertex deterministically\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u,v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))  # deterministic\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # deterministic scan: prefer smallest color\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            # keep feasible; prefer not increasing palette (guaranteed since c in palette)\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of two vertices if it improves or preserves feasibility\n    # Scan neighbors first for locality\n    candidates = list(set([v-1 for v in adj[vi]] + list(range(n))))\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a conflicting neighbor color (or any neighbor color if feasible)\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set(nb_cols_list))\n    if target_candidates:\n        # deterministic choice: smallest neighbor color different from current\n        target_candidates = [c for c in sorted(target_candidates) if c != current_color]\n        if target_candidates:\n            cA, cB = current_color, target_candidates[0]\n            visited = set([vi])\n            q = deque([vi])\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            trial = new_sol[:]\n            for x in visited:\n                if trial[x-1] == cA:\n                    trial[x-1] = cB\n                elif trial[x-1] == cB:\n                    trial[x-1] = cA\n            if current_conf > 0:\n                if conflicts_of(trial) < current_conf:\n                    return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n            else:\n                if is_feasible(trial):\n                    return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # Global color-class swap between two colors (feasibility preserved)\n    if len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if current_conf > 0:\n            if conflicts_of(trial) <= current_conf:\n                return (canonicalize(trial), \"ColorClass-Swap-NonWorse\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"ColorClass-Swap-Feasible\")\n\n    # Fallback: recolor i to another color, possibly introducing one new color but never exceeding n\n    max_color = max(palette) if palette else 1\n    candidate_colors = list(range(1, min(n, max_color + 1) + 1))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if candidate_colors:\n        trial = new_sol[:]\n        trial[i] = min(candidate_colors)\n        return (canonicalize(trial), \"Recolor-Fallback\")\n\n    return (canonicalize(new_sol), \"NoOp-Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    flips = 2 if k >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(2, k))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        min_count = min(counts.values())\n        target_colors = [c for c in palette if counts[c] == min_count]\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n    return canonicalize(new_sol)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.00000142}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_POSITIVE_LEN_9_VERTEX_COLORS_ORDERED_AS_[c1,c2,c3,c4,c5,c6,c7,c8,c9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Feasible: number of colors used (k). Non-canonical color labels incur SMALL penalty.\n    # Infeasible: MED + number of edge conflicts. Invalid type\/shape\/domain: BIG.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    SMALL = 10\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n        if c > n:  # guard against runaway palette\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    fitness = k_used\n    # Normalization penalty if labels are not exactly {1..k}\n    if distinct != list(range(1, k_used + 1)):\n        fitness += SMALL\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_list, movement_type_str)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using DSATUR order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Order vertices by descending degree (tie-break by index for determinism)\n        vertices.sort(key=lambda i: (-deg[i+1], i))\n        for i in vertices:\n            vi = i + 1\n            nb_cols = set(base[j-1] for j in adj[vi])\n            allowed = [c for c in palette if c != target and c not in nb_cols]\n            # First-improvement: choose the smallest feasible color to be deterministic\n            if allowed:\n                base[i] = min(allowed)\n            else:\n                return None  # fail\n        return canonicalize(base)\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, first attempt a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a vertex deterministically\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u,v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))  # deterministic\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    # deterministic scan: prefer smallest color\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            # keep feasible; prefer not increasing palette (guaranteed since c in palette)\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of two vertices if it improves or preserves feasibility\n    # Scan neighbors first for locality\n    candidates = list(set([v-1 for v in adj[vi]] + list(range(n))))\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a conflicting neighbor color (or any neighbor color if feasible)\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set(nb_cols_list))\n    if target_candidates:\n        # deterministic choice: smallest neighbor color different from current\n        target_candidates = [c for c in sorted(target_candidates) if c != current_color]\n        if target_candidates:\n            cA, cB = current_color, target_candidates[0]\n            visited = set([vi])\n            q = deque([vi])\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if y not in visited and new_sol[y-1] in (cA, cB):\n                        visited.add(y)\n                        q.append(y)\n            trial = new_sol[:]\n            for x in visited:\n                if trial[x-1] == cA:\n                    trial[x-1] = cB\n                elif trial[x-1] == cB:\n                    trial[x-1] = cA\n            if current_conf > 0:\n                if conflicts_of(trial) < current_conf:\n                    return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n            else:\n                if is_feasible(trial):\n                    return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # Global color-class swap between two colors (feasibility preserved)\n    if len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if current_conf > 0:\n            if conflicts_of(trial) <= current_conf:\n                return (canonicalize(trial), \"ColorClass-Swap-NonWorse\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"ColorClass-Swap-Feasible\")\n\n    # Fallback: recolor i to another color, possibly introducing one new color but never exceeding n\n    max_color = max(palette) if palette else 1\n    candidate_colors = list(range(1, min(n, max_color + 1) + 1))\n    if current_color in candidate_colors:\n        candidate_colors.remove(current_color)\n    if candidate_colors:\n        trial = new_sol[:]\n        trial[i] = min(candidate_colors)\n        return (canonicalize(trial), \"Recolor-Fallback\")\n\n    return (canonicalize(new_sol), \"NoOp-Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k constant.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    used_colors = sorted(set(new_sol))\n    k = len(used_colors)\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    flips = 2 if k >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        # pick a random start vertex from color a or b\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS over a\/b component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        # swap a<->b on this component\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(2, k))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        # prefer colors least frequent among neighbors\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Optional attempt to reduce palette by eliminating a sparsely used color\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        min_count = min(counts.values())\n        target_colors = [c for c in palette if counts[c] == min_count]\n        tc = random.choice(target_colors)\n        # try to recolor vertices of tc greedily to existing colors\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n    return canonicalize(new_sol)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.00000092}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci is the color of vertex i. Colors are labels in {1,2,...}. Objective minimizes distinct colors used, subject to proper-coloring (adjacent vertices have different colors).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Infeasible: MED + number of edge conflicts. Feasible: number of colors used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    k_used = len(set(solution))\n    return int(k_used)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor generator for graph coloring (self-contained, no globals)\n    # Returns (new_solution_list, movement_type_str)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency and degree\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using degree order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Two ordering attempts to improve success chance\n        orderings = []\n        orderings.append(sorted(vertices, key=lambda i: (-deg[i+1], i)))\n        orderings.append(sorted(vertices, key=lambda i: (deg[i+1], i)))\n        for order in orderings:\n            trial = base[:]\n            ok = True\n            for i in order:\n                vi = i + 1\n                nb_cols = set(trial[j-1] for j in adj[vi])\n                allowed = [c for c in palette if c != target and c not in nb_cols]\n                if allowed:\n                    trial[i] = min(allowed)\n                else:\n                    ok = False\n                    break\n            if ok and is_feasible(trial):\n                return canonicalize(trial)\n        return None\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, prioritize a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a pivot vertex\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color (keeps or improves feasibility)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of i with a conflicting neighbor or a few sampled vertices\n    candidates = []\n    # prioritize conflict-adjacent vertices\n    for jv in adj[vi]:\n        j = jv - 1\n        if new_sol[j] == current_color:\n            continue\n        candidates.append(j)\n    # add a small deterministic sample of other vertices to diversify\n    extra = [x for x in range(n) if x != i and x not in candidates]\n    extra = extra[:3]\n    candidates.extend(extra)\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a neighbor color chosen by conflict impact\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set([c for c in nb_cols_list if c != current_color]))\n    if target_candidates:\n        # choose color that appears most among conflicting edges (heuristic)\n        target_candidates.sort(key=lambda col: -nb_cols_list.count(col))\n        cA, cB = current_color, target_candidates[0]\n        visited = set([vi])\n        q = deque([vi])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (cA, cB):\n                    visited.add(y)\n                    q.append(y)\n        trial = new_sol[:]\n        for x in visited:\n            if trial[x-1] == cA:\n                trial[x-1] = cB\n            elif trial[x-1] == cB:\n                trial[x-1] = cA\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # If infeasible, allow introducing at most one new color if it strictly reduces conflicts\n    if current_conf > 0:\n        max_color = max(palette) if palette else 1\n        candidate_colors = list(range(1, max_color + 2))  # allow one new color\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        best_trial = None\n        best_conf = current_conf\n        for c in candidate_colors:\n            trial = new_sol[:]\n            trial[i] = c\n            conf = conflicts_of(trial)\n            if conf < best_conf:\n                best_conf = conf\n                best_trial = trial\n        if best_trial is not None:\n            return (canonicalize(best_trial), \"Recolor-AddColor-ImproveConflicts\")\n\n    # Last resort: neutral class swap if feasible (keep objective neutral)\n    if current_conf == 0 and len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if is_feasible(trial):\n            return (canonicalize(trial), \"ColorClass-Swap-Feasible-Neutral\")\n\n    # No change possible\n    return (canonicalize(new_sol), \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k small.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    palette = sorted(set(new_sol))\n    flips = 2 if len(palette) >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(3, len(set(new_sol))))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Attempt to merge a sparsely used color and locally repair by greedy recolor\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        tc = min(palette, key=lambda c: counts[c])\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        new_sol = canonicalize(new_sol)\n\n    # 4) If still highly conflicting, allow introducing one new color on worst-conflict vertex\n    conf = conflicts_of(new_sol)\n    if conf > 0:\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], len(adj[x+1]), -x))\n        max_color = max(new_sol) if new_sol else 1\n        new_sol[i] = max_color + 1\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"SA","Tiempo":0.002450529}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci is the color of vertex i. Colors are labels in {1,2,...}. Objective minimizes distinct colors used, subject to proper-coloring (adjacent vertices have different colors).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Infeasible: MED + number of edge conflicts. Feasible: number of colors used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    k_used = len(set(solution))\n    return int(k_used)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor generator for graph coloring (self-contained, no globals)\n    # Returns (new_solution_list, movement_type_str)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency and degree\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using degree order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Two ordering attempts to improve success chance\n        orderings = []\n        orderings.append(sorted(vertices, key=lambda i: (-deg[i+1], i)))\n        orderings.append(sorted(vertices, key=lambda i: (deg[i+1], i)))\n        for order in orderings:\n            trial = base[:]\n            ok = True\n            for i in order:\n                vi = i + 1\n                nb_cols = set(trial[j-1] for j in adj[vi])\n                allowed = [c for c in palette if c != target and c not in nb_cols]\n                if allowed:\n                    trial[i] = min(allowed)\n                else:\n                    ok = False\n                    break\n            if ok and is_feasible(trial):\n                return canonicalize(trial)\n        return None\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, prioritize a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a pivot vertex\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color (keeps or improves feasibility)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of i with a conflicting neighbor or a few sampled vertices\n    candidates = []\n    # prioritize conflict-adjacent vertices\n    for jv in adj[vi]:\n        j = jv - 1\n        if new_sol[j] == current_color:\n            continue\n        candidates.append(j)\n    # add a small deterministic sample of other vertices to diversify\n    extra = [x for x in range(n) if x != i and x not in candidates]\n    extra = extra[:3]\n    candidates.extend(extra)\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a neighbor color chosen by conflict impact\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set([c for c in nb_cols_list if c != current_color]))\n    if target_candidates:\n        # choose color that appears most among conflicting edges (heuristic)\n        target_candidates.sort(key=lambda col: -nb_cols_list.count(col))\n        cA, cB = current_color, target_candidates[0]\n        visited = set([vi])\n        q = deque([vi])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (cA, cB):\n                    visited.add(y)\n                    q.append(y)\n        trial = new_sol[:]\n        for x in visited:\n            if trial[x-1] == cA:\n                trial[x-1] = cB\n            elif trial[x-1] == cB:\n                trial[x-1] = cA\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # If infeasible, allow introducing at most one new color if it strictly reduces conflicts\n    if current_conf > 0:\n        max_color = max(palette) if palette else 1\n        candidate_colors = list(range(1, max_color + 2))  # allow one new color\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        best_trial = None\n        best_conf = current_conf\n        for c in candidate_colors:\n            trial = new_sol[:]\n            trial[i] = c\n            conf = conflicts_of(trial)\n            if conf < best_conf:\n                best_conf = conf\n                best_trial = trial\n        if best_trial is not None:\n            return (canonicalize(best_trial), \"Recolor-AddColor-ImproveConflicts\")\n\n    # Last resort: neutral class swap if feasible (keep objective neutral)\n    if current_conf == 0 and len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if is_feasible(trial):\n            return (canonicalize(trial), \"ColorClass-Swap-Feasible-Neutral\")\n\n    # No change possible\n    return (canonicalize(new_sol), \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k small.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    palette = sorted(set(new_sol))\n    flips = 2 if len(palette) >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(3, len(set(new_sol))))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Attempt to merge a sparsely used color and locally repair by greedy recolor\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        tc = min(palette, key=lambda c: counts[c])\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        new_sol = canonicalize(new_sol)\n\n    # 4) If still highly conflicting, allow introducing one new color on worst-conflict vertex\n    conf = conflicts_of(new_sol)\n    if conf > 0:\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], len(adj[x+1]), -x))\n        max_color = max(new_sol) if new_sol else 1\n        new_sol[i] = max_color + 1\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"ILS","Tiempo":0.002375158}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci is the color of vertex i. Colors are labels in {1,2,...}. Objective minimizes distinct colors used, subject to proper-coloring (adjacent vertices have different colors).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better.\n    # Infeasible: MED + number of edge conflicts. Feasible: number of colors used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    BIG = 10**9\n    MED = 10**5\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used\n    k_used = len(set(solution))\n    return int(k_used)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor generator for graph coloring (self-contained, no globals)\n    # Returns (new_solution_list, movement_type_str)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return (solution[:], \"NoOp-InvalidInput\")\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Build adjacency and degree\n    adj = {i: [] for i in range(1, n+1)}\n    deg = {i: 0 for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def is_feasible(sol):\n        return conflicts_of(sol) == 0\n\n    def try_color_drop(sol):\n        # Attempt to remove the highest color class greedily using degree order\n        base = sol[:]\n        palette = sorted(set(base))\n        if len(palette) <= 1:\n            return None\n        target = max(palette)\n        vertices = [i for i, c in enumerate(base) if c == target]\n        if not vertices:\n            return None\n        # Two ordering attempts to improve success chance\n        orderings = []\n        orderings.append(sorted(vertices, key=lambda i: (-deg[i+1], i)))\n        orderings.append(sorted(vertices, key=lambda i: (deg[i+1], i)))\n        for order in orderings:\n            trial = base[:]\n            ok = True\n            for i in order:\n                vi = i + 1\n                nb_cols = set(trial[j-1] for j in adj[vi])\n                allowed = [c for c in palette if c != target and c not in nb_cols]\n                if allowed:\n                    trial[i] = min(allowed)\n                else:\n                    ok = False\n                    break\n            if ok and is_feasible(trial):\n                return canonicalize(trial)\n        return None\n\n    new_sol = solution[:]\n    current_conf = conflicts_of(new_sol)\n    palette = sorted(set(new_sol))\n\n    # If feasible, prioritize a ColorDrop move\n    if current_conf == 0:\n        dropped = try_color_drop(new_sol)\n        if dropped is not None:\n            return (dropped, \"ColorDrop\")\n\n    # Select a pivot vertex\n    if current_conf > 0:\n        # pick vertex with max incident conflicts; tie-break by degree then index\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], deg[x+1], -x))\n    else:\n        # feasible: pick vertex with max saturation degree; tie-break by degree then index\n        sat = []\n        for v in range(1, n+1):\n            nb_colors = set(new_sol[u-1] for u in adj[v])\n            sat.append((len(nb_colors), deg[v], -v))\n        i = max(range(n), key=lambda x: sat[x])\n\n    vi = i + 1\n    current_color = new_sol[i]\n\n    # Try first-improvement recolor to existing allowed color (keeps or improves feasibility)\n    nb_cols = set(new_sol[j-1] for j in adj[vi])\n    allowed = [c for c in palette if c != current_color and c not in nb_cols]\n    for c in sorted(allowed):\n        trial = new_sol[:]\n        trial[i] = c\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Recolor-Allowed-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Recolor-Allowed-Feasible\")\n\n    # Pair-exchange: swap colors of i with a conflicting neighbor or a few sampled vertices\n    candidates = []\n    # prioritize conflict-adjacent vertices\n    for jv in adj[vi]:\n        j = jv - 1\n        if new_sol[j] == current_color:\n            continue\n        candidates.append(j)\n    # add a small deterministic sample of other vertices to diversify\n    extra = [x for x in range(n) if x != i and x not in candidates]\n    extra = extra[:3]\n    candidates.extend(extra)\n    for j in candidates:\n        if j == i:\n            continue\n        if new_sol[j] == current_color:\n            continue\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"PairExchange-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"PairExchange-Feasible\")\n\n    # Kempe chain swap between current_color and a neighbor color chosen by conflict impact\n    nb_cols_list = [new_sol[j-1] for j in adj[vi]]\n    target_candidates = list(set([c for c in nb_cols_list if c != current_color]))\n    if target_candidates:\n        # choose color that appears most among conflicting edges (heuristic)\n        target_candidates.sort(key=lambda col: -nb_cols_list.count(col))\n        cA, cB = current_color, target_candidates[0]\n        visited = set([vi])\n        q = deque([vi])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (cA, cB):\n                    visited.add(y)\n                    q.append(y)\n        trial = new_sol[:]\n        for x in visited:\n            if trial[x-1] == cA:\n                trial[x-1] = cB\n            elif trial[x-1] == cB:\n                trial[x-1] = cA\n        if current_conf > 0:\n            if conflicts_of(trial) < current_conf:\n                return (canonicalize(trial), \"Kempe-Chain-ImproveConflicts\")\n        else:\n            if is_feasible(trial):\n                return (canonicalize(trial), \"Kempe-Chain-Feasible\")\n\n    # If infeasible, allow introducing at most one new color if it strictly reduces conflicts\n    if current_conf > 0:\n        max_color = max(palette) if palette else 1\n        candidate_colors = list(range(1, max_color + 2))  # allow one new color\n        if current_color in candidate_colors:\n            candidate_colors.remove(current_color)\n        best_trial = None\n        best_conf = current_conf\n        for c in candidate_colors:\n            trial = new_sol[:]\n            trial[i] = c\n            conf = conflicts_of(trial)\n            if conf < best_conf:\n                best_conf = conf\n                best_trial = trial\n        if best_trial is not None:\n            return (canonicalize(best_trial), \"Recolor-AddColor-ImproveConflicts\")\n\n    # Last resort: neutral class swap if feasible (keep objective neutral)\n    if current_conf == 0 and len(palette) >= 2:\n        a, b = palette[0], palette[-1]\n        trial = [b if c == a else (a if c == b else c) for c in new_sol]\n        if is_feasible(trial):\n            return (canonicalize(trial), \"ColorClass-Swap-Feasible-Neutral\")\n\n    # No change possible\n    return (canonicalize(new_sol), \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation to escape local minima while trying to keep k small.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c < 1) for c in solution):\n        return solution[:]\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # 1) Apply a few Kempe-chain flips between random color pairs\n    palette = sorted(set(new_sol))\n    flips = 2 if len(palette) >= 2 else 0\n    for _ in range(flips):\n        palette = sorted(set(new_sol))\n        if len(palette) < 2:\n            break\n        a, b = random.sample(palette, 2)\n        cand = [i+1 for i, c in enumerate(new_sol) if c in (a, b)]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        visited = set([start])\n        q = deque([start])\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if y not in visited and new_sol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        for x in visited:\n            if new_sol[x-1] == a:\n                new_sol[x-1] = b\n            elif new_sol[x-1] == b:\n                new_sol[x-1] = a\n        new_sol = canonicalize(new_sol)\n\n    # 2) Randomly recolor a subset of vertices with bias against neighbor colors\n    m = min(5, max(3, len(set(new_sol))))\n    idxs = random.sample(range(n), m)\n    palette = sorted(set(new_sol))\n    for i in idxs:\n        vi = i + 1\n        nb_cols = [new_sol[j-1] for j in adj[vi]]\n        candidate = list(palette)\n        if new_sol[i] in candidate:\n            candidate.remove(new_sol[i])\n        if not candidate:\n            continue\n        candidate.sort(key=lambda c: nb_cols.count(c))\n        new_sol[i] = candidate[0]\n\n    # 3) Attempt to merge a sparsely used color and locally repair by greedy recolor\n    palette = sorted(set(new_sol))\n    counts = {c: new_sol.count(c) for c in palette}\n    if palette:\n        tc = min(palette, key=lambda c: counts[c])\n        for i, c in enumerate(list(new_sol)):\n            if c != tc:\n                continue\n            vi = i + 1\n            nb_cols = set(new_sol[j-1] for j in adj[vi])\n            allowed = [col for col in palette if col != tc and col not in nb_cols]\n            if allowed:\n                new_sol[i] = random.choice(allowed)\n        new_sol = canonicalize(new_sol)\n\n    # 4) If still highly conflicting, allow introducing one new color on worst-conflict vertex\n    conf = conflicts_of(new_sol)\n    if conf > 0:\n        conflict_count = [0]*n\n        for (u, v) in edges:\n            if new_sol[u-1] == new_sol[v-1]:\n                conflict_count[u-1] += 1\n                conflict_count[v-1] += 1\n        i = max(range(n), key=lambda x: (conflict_count[x], len(adj[x+1]), -x))\n        max_color = max(new_sol) if new_sol else 1\n        new_sol[i] = max_color + 1\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[1,1,3,4,3,4,2,3,2],"Valor Optimo":4,"Metaheuristica":"TS","Tiempo":0.002440439}
