{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST: a list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-indexed vertices 1..9). Objective is to minimize max(ci).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    CONFLICT_PEN = 1000\n    INVALID_PEN = 1000\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY\n    if len(solution) != 9:\n        return PENALTY\n\n    invalids = 0\n    all_ints = True\n    for x in solution:\n        if not isinstance(x, int):\n            all_ints = False\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    if not all_ints:\n        return PENALTY\n\n    # Objective part\n    obj = max(solution) if len(solution) == 9 else PENALTY\n\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    conflicts = 0\n    if invalids == 0:\n        for u, v in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = obj + conflicts * CONFLICT_PEN + invalids * INVALID_PEN\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by recoloring a single random vertex\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: initialize a random valid solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Determine current color bound\n    current_max = max(sol) if len(sol) == 9 and all(isinstance(x, int) for x in sol) else 3\n\n    # Choose a vertex to modify\n    idx = random.randrange(9)\n\n    # Candidate color set: existing colors and with small probability a new color (current_max+1)\n    colors = list(range(1, current_max + 1))\n    if random.random() < 0.15:\n        colors.append(current_max + 1)\n\n    # Ensure a different color is chosen if possible\n    current_color = sol[idx]\n    if len(colors) > 1 and current_color in colors:\n        colors = [c for c in colors if c != current_color]\n\n    sol[idx] = random.choice(colors)\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset (~30-50%) of vertices\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n = 9\n    k = random.randint(max(1, n \/\/ 3), max(1, n \/\/ 2))\n    idxs = random.sample(range(n), k)\n\n    current_max = max(sol)\n    for i in idxs:\n        # Allow recolor from existing palette with small chance to introduce a new color\n        palette = list(range(1, current_max + 1))\n        if random.random() < 0.2:\n            palette.append(current_max + 1)\n        # Avoid keeping the same color if alternatives exist\n        old = sol[i]\n        if len(palette) > 1 and old in palette:\n            palette = [c for c in palette if c != old]\n        sol[i] = random.choice(palette)\n        current_max = max(current_max, sol[i])\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000505347}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST: a list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-indexed vertices 1..9). Objective is to minimize max(ci).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    CONFLICT_PEN = 1000\n    INVALID_PEN = 1000\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY\n    if len(solution) != 9:\n        return PENALTY\n\n    invalids = 0\n    all_ints = True\n    for x in solution:\n        if not isinstance(x, int):\n            all_ints = False\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    if not all_ints:\n        return PENALTY\n\n    # Objective part\n    obj = max(solution) if len(solution) == 9 else PENALTY\n\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    conflicts = 0\n    if invalids == 0:\n        for u, v in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = obj + conflicts * CONFLICT_PEN + invalids * INVALID_PEN\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by recoloring a single random vertex\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: initialize a random valid solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Determine current color bound\n    current_max = max(sol) if len(sol) == 9 and all(isinstance(x, int) for x in sol) else 3\n\n    # Choose a vertex to modify\n    idx = random.randrange(9)\n\n    # Candidate color set: existing colors and with small probability a new color (current_max+1)\n    colors = list(range(1, current_max + 1))\n    if random.random() < 0.15:\n        colors.append(current_max + 1)\n\n    # Ensure a different color is chosen if possible\n    current_color = sol[idx]\n    if len(colors) > 1 and current_color in colors:\n        colors = [c for c in colors if c != current_color]\n\n    sol[idx] = random.choice(colors)\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset (~30-50%) of vertices\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n = 9\n    k = random.randint(max(1, n \/\/ 3), max(1, n \/\/ 2))\n    idxs = random.sample(range(n), k)\n\n    current_max = max(sol)\n    for i in idxs:\n        # Allow recolor from existing palette with small chance to introduce a new color\n        palette = list(range(1, current_max + 1))\n        if random.random() < 0.2:\n            palette.append(current_max + 1)\n        # Avoid keeping the same color if alternatives exist\n        old = sol[i]\n        if len(palette) > 1 and old in palette:\n            palette = [c for c in palette if c != old]\n        sol[i] = random.choice(palette)\n        current_max = max(current_max, sol[i])\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000552098}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST: a list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-indexed vertices 1..9). Objective is to minimize max(ci).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    CONFLICT_PEN = 1000\n    INVALID_PEN = 1000\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY\n    if len(solution) != 9:\n        return PENALTY\n\n    invalids = 0\n    all_ints = True\n    for x in solution:\n        if not isinstance(x, int):\n            all_ints = False\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    if not all_ints:\n        return PENALTY\n\n    # Objective part\n    obj = max(solution) if len(solution) == 9 else PENALTY\n\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    conflicts = 0\n    if invalids == 0:\n        for u, v in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = obj + conflicts * CONFLICT_PEN + invalids * INVALID_PEN\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by recoloring a single random vertex\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: initialize a random valid solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Determine current color bound\n    current_max = max(sol) if len(sol) == 9 and all(isinstance(x, int) for x in sol) else 3\n\n    # Choose a vertex to modify\n    idx = random.randrange(9)\n\n    # Candidate color set: existing colors and with small probability a new color (current_max+1)\n    colors = list(range(1, current_max + 1))\n    if random.random() < 0.15:\n        colors.append(current_max + 1)\n\n    # Ensure a different color is chosen if possible\n    current_color = sol[idx]\n    if len(colors) > 1 and current_color in colors:\n        colors = [c for c in colors if c != current_color]\n\n    sol[idx] = random.choice(colors)\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor a random subset (~30-50%) of vertices\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    n = 9\n    k = random.randint(max(1, n \/\/ 3), max(1, n \/\/ 2))\n    idxs = random.sample(range(n), k)\n\n    current_max = max(sol)\n    for i in idxs:\n        # Allow recolor from existing palette with small chance to introduce a new color\n        palette = list(range(1, current_max + 1))\n        if random.random() < 0.2:\n            palette.append(current_max + 1)\n        # Avoid keeping the same color if alternatives exist\n        old = sol[i]\n        if len(palette) > 1 and old in palette:\n            palette = [c for c in palette if c != old]\n        sol[i] = random.choice(palette)\n        current_max = max(current_max, sol[i])\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000517537}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize conflicts first, then max color\n    # fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    # Valid solution is a list of 9 integers >= 1\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 50_000_000\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    max_color = max(solution) if invalids == 0 else 9\n\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    return fitness\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-vertex recolor guided by conflict minimization; no new colors introduced\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)  # Enforce cap at 3 once reachable\n    palette = list(range(1, cap_max + 1))\n\n    # Identify conflicting vertices and their conflict counts\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    if conflicted_vertices:\n        # Choose a vertex with maximum conflicts (break ties randomly)\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        # No conflicts: choose a random vertex; prefer reducing max color if possible\n        idx = random.randrange(n)\n\n    old_color = sol[idx]\n\n    # Evaluate all candidate colors to minimize resulting conflicts on idx\n    best_color = old_color\n    best_conf = 10**9\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        # Tie-break: prefer smaller color to help reduce max color usage\n        key = (cnt, c)\n        if cnt < best_conf or (cnt == best_conf and c < best_color):\n            best_conf = cnt\n            best_color = c\n\n    sol[idx] = best_color\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation (1-2 swaps) to escape local minima while preserving color count\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)\n    r = random.randint(1, 2)\n\n    def kempe_swap(start):\n        a = sol[start]\n        # Choose b different from a within current palette\n        b_choices = [c for c in range(1, cap_max + 1) if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        comp = []\n        dq = deque([start])\n        visited[start] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on the component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00075259}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize conflicts first, then max color\n    # fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    # Valid solution is a list of 9 integers >= 1\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 50_000_000\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    max_color = max(solution) if invalids == 0 else 9\n\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    return fitness\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-vertex recolor guided by conflict minimization; no new colors introduced\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)  # Enforce cap at 3 once reachable\n    palette = list(range(1, cap_max + 1))\n\n    # Identify conflicting vertices and their conflict counts\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    if conflicted_vertices:\n        # Choose a vertex with maximum conflicts (break ties randomly)\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        # No conflicts: choose a random vertex; prefer reducing max color if possible\n        idx = random.randrange(n)\n\n    old_color = sol[idx]\n\n    # Evaluate all candidate colors to minimize resulting conflicts on idx\n    best_color = old_color\n    best_conf = 10**9\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        # Tie-break: prefer smaller color to help reduce max color usage\n        key = (cnt, c)\n        if cnt < best_conf or (cnt == best_conf and c < best_color):\n            best_conf = cnt\n            best_color = c\n\n    sol[idx] = best_color\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation (1-2 swaps) to escape local minima while preserving color count\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)\n    r = random.randint(1, 2)\n\n    def kempe_swap(start):\n        a = sol[start]\n        # Choose b different from a within current palette\n        b_choices = [c for c in range(1, cap_max + 1) if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        comp = []\n        dq = deque([start])\n        visited[start] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on the component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000867441}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize conflicts first, then max color\n    # fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    # Valid solution is a list of 9 integers >= 1\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 50_000_000\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    max_color = max(solution) if invalids == 0 else 9\n\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n\n    fitness = conflicts * 1_000_000 + max_color + invalids * 1_000_000\n    return fitness\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-vertex recolor guided by conflict minimization; no new colors introduced\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)  # Enforce cap at 3 once reachable\n    palette = list(range(1, cap_max + 1))\n\n    # Identify conflicting vertices and their conflict counts\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    if conflicted_vertices:\n        # Choose a vertex with maximum conflicts (break ties randomly)\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        # No conflicts: choose a random vertex; prefer reducing max color if possible\n        idx = random.randrange(n)\n\n    old_color = sol[idx]\n\n    # Evaluate all candidate colors to minimize resulting conflicts on idx\n    best_color = old_color\n    best_conf = 10**9\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        # Tie-break: prefer smaller color to help reduce max color usage\n        key = (cnt, c)\n        if cnt < best_conf or (cnt == best_conf and c < best_color):\n            best_conf = cnt\n            best_color = c\n\n    sol[idx] = best_color\n\n    return sol, \"SingleVertexRecolor\", \"RandomChoice\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation (1-2 swaps) to escape local minima while preserving color count\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    current_max = max(sol)\n    cap_max = min(current_max, 3)\n    r = random.randint(1, 2)\n\n    def kempe_swap(start):\n        a = sol[start]\n        # Choose b different from a within current palette\n        b_choices = [c for c in range(1, cap_max + 1) if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        comp = []\n        dq = deque([start])\n        visited[start] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on the component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000906393}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    # Conflicts and auxiliary metrics\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n    max_color = max(solution) if len(solution) == n and all(isinstance(x, int) for x in solution) else n\n    sum_colors = sum(solution) if invalids == 0 else n * n\n\n    # Lexicographic objective: invalids >> conflicts >> max_color >> sum_colors\n    fitness = invalids * (10**12) + conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, Dict, Any\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Identify conflicts per vertex\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    # Choose target vertex: most conflicted if any, else random\n    if conflicted_vertices:\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        idx = random.randrange(n)\n\n    current_max = max(sol)\n    # Soft palette: allow temporary +1 color up to 4 to escape local minima\n    palette = list(range(1, min(current_max + 1, 4) + (1 if current_max < 4 else 0)))\n    # Ensure palette non-empty and includes existing colors\n    if not palette:\n        palette = [1, 2, 3]\n\n    old_color = sol[idx]\n\n    # Score candidate colors by local conflicts, then color value\n    best_color = old_color\n    best_key = (10**9, old_color)\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        key = (cnt, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n\n    sol[idx] = best_color\n\n    move_meta = {\"move\": \"SingleVertexRecolor\", \"vertex\": idx + 1, \"from\": old_color, \"to\": best_color}\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = list({x for x in sol})\n        if len(palette) <= 1:\n            return\n        # choose a different color b\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on this component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Apply 1-2 Kempe swaps to escape local minima while preserving color count\n    r = random.randint(1, 2)\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00073591}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    # Conflicts and auxiliary metrics\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n    max_color = max(solution) if len(solution) == n and all(isinstance(x, int) for x in solution) else n\n    sum_colors = sum(solution) if invalids == 0 else n * n\n\n    # Lexicographic objective: invalids >> conflicts >> max_color >> sum_colors\n    fitness = invalids * (10**12) + conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, Dict, Any\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Identify conflicts per vertex\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    # Choose target vertex: most conflicted if any, else random\n    if conflicted_vertices:\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        idx = random.randrange(n)\n\n    current_max = max(sol)\n    # Soft palette: allow temporary +1 color up to 4 to escape local minima\n    palette = list(range(1, min(current_max + 1, 4) + (1 if current_max < 4 else 0)))\n    # Ensure palette non-empty and includes existing colors\n    if not palette:\n        palette = [1, 2, 3]\n\n    old_color = sol[idx]\n\n    # Score candidate colors by local conflicts, then color value\n    best_color = old_color\n    best_key = (10**9, old_color)\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        key = (cnt, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n\n    sol[idx] = best_color\n\n    move_meta = {\"move\": \"SingleVertexRecolor\", \"vertex\": idx + 1, \"from\": old_color, \"to\": best_color}\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = list({x for x in sol})\n        if len(palette) <= 1:\n            return\n        # choose a different color b\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on this component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Apply 1-2 Kempe swaps to escape local minima while preserving color count\n    r = random.randint(1, 2)\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000978643}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n\n    # Conflicts and auxiliary metrics\n    conflicts = 0\n    if invalids == 0:\n        for (u, v) in edges:\n            if solution[u-1] == solution[v-1]:\n                conflicts += 1\n    max_color = max(solution) if len(solution) == n and all(isinstance(x, int) for x in solution) else n\n    sum_colors = sum(solution) if invalids == 0 else n * n\n\n    # Lexicographic objective: invalids >> conflicts >> max_color >> sum_colors\n    fitness = invalids * (10**12) + conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, Dict, Any\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Identify conflicts per vertex\n    conflict_counts = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n\n    # Choose target vertex: most conflicted if any, else random\n    if conflicted_vertices:\n        max_conf = max(conflict_counts[i] for i in conflicted_vertices)\n        candidates = [i for i in conflicted_vertices if conflict_counts[i] == max_conf]\n        idx = random.choice(candidates)\n    else:\n        idx = random.randrange(n)\n\n    current_max = max(sol)\n    # Soft palette: allow temporary +1 color up to 4 to escape local minima\n    palette = list(range(1, min(current_max + 1, 4) + (1 if current_max < 4 else 0)))\n    # Ensure palette non-empty and includes existing colors\n    if not palette:\n        palette = [1, 2, 3]\n\n    old_color = sol[idx]\n\n    # Score candidate colors by local conflicts, then color value\n    best_color = old_color\n    best_key = (10**9, old_color)\n    for c in palette:\n        if c == old_color and len(palette) > 1:\n            continue\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        key = (cnt, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n\n    sol[idx] = best_color\n\n    move_meta = {\"move\": \"SingleVertexRecolor\", \"vertex\": idx + 1, \"from\": old_color, \"to\": best_color}\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Initialize\/repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = list({x for x in sol})\n        if len(palette) <= 1:\n            return\n        # choose a different color b\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = [False] * n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        # Swap colors a <-> b on this component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Apply 1-2 Kempe swaps to escape local minima while preserving color count\n    r = random.randint(1, 2)\n    for _ in range(r):\n        start = random.randrange(n)\n        kempe_swap(start)\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000895682}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return invalids * (10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    max_color = max(solution) if solution else n\n    sum_colors = sum(solution)\n\n    # Lexicographic scalarization: invalids >> conflicts >> max_color >> sum_colors\n    fitness = conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Repair\/initialize input solution\n    def greedy_seed():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for u in order:\n            used = {colors[v] for v in adj[u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: compute conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    # Normalize palette bounds\n    base_max = max(3, current_max)\n    palette = list(range(1, base_max + 1))\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u):\n        # Try assign the smallest feasible color that reduces max color\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, current_max):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        # BFS on subgraph induced by colors {a,b}\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    move_meta = {\"NB_Type\": \"\", \"Movement_Type\": \"\"}\n\n    # Phase A: if conflicts>0, reduce conflicts preferentially\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # Choose most conflicted, tie-break by higher degree then lowest index\n        if conflicted_vertices:\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        # Allow temporary +1 color only when conflicts>0 and current_max < 4\n        local_palette = list(palette)\n        if current_max < 4:\n            local_palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in local_palette:\n            if c == old and len(local_palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        move_meta[\"NB_Type\"] = \"LocalSearch\"\n        move_meta[\"Movement_Type\"] = \"SingleVertexRecolor\"\n        return sol, move_meta\n\n    # Phase B: conflict-free -> attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    # Try greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u)\n        if new_c is not None:\n            old = sol[u]\n            sol[u] = new_c\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"LowerColorGreedy\"\n            return sol, move_meta\n\n    # If no direct lowering feasible, try a Kempe swap with a lower color\n    if top_vertices:\n        u = random.choice(top_vertices)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            kempe_swap(u, a, b)\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"KempeSwap\"\n            return sol, move_meta\n\n    # Fallback: mild diversification via recolor of random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    move_meta[\"NB_Type\"] = \"Diversification\"\n    move_meta[\"Movement_Type\"] = \"RandomBestLocal\"\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Simple greedy seed if invalid\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        sol = [0]*n\n        for u in order:\n            used = {sol[v] for v in adj[u] if sol[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u] = c\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            # Prefer colors not used by neighbors\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Measure conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(2, min(6, conflicts))\n\n    # Apply 1-2 Kempe swaps + a short random walk recolor\n    for _ in range(1 + (1 if random.random() < 0.5 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001325057}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return invalids * (10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    max_color = max(solution) if solution else n\n    sum_colors = sum(solution)\n\n    # Lexicographic scalarization: invalids >> conflicts >> max_color >> sum_colors\n    fitness = conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Repair\/initialize input solution\n    def greedy_seed():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for u in order:\n            used = {colors[v] for v in adj[u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: compute conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    # Normalize palette bounds\n    base_max = max(3, current_max)\n    palette = list(range(1, base_max + 1))\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u):\n        # Try assign the smallest feasible color that reduces max color\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, current_max):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        # BFS on subgraph induced by colors {a,b}\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    move_meta = {\"NB_Type\": \"\", \"Movement_Type\": \"\"}\n\n    # Phase A: if conflicts>0, reduce conflicts preferentially\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # Choose most conflicted, tie-break by higher degree then lowest index\n        if conflicted_vertices:\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        # Allow temporary +1 color only when conflicts>0 and current_max < 4\n        local_palette = list(palette)\n        if current_max < 4:\n            local_palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in local_palette:\n            if c == old and len(local_palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        move_meta[\"NB_Type\"] = \"LocalSearch\"\n        move_meta[\"Movement_Type\"] = \"SingleVertexRecolor\"\n        return sol, move_meta\n\n    # Phase B: conflict-free -> attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    # Try greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u)\n        if new_c is not None:\n            old = sol[u]\n            sol[u] = new_c\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"LowerColorGreedy\"\n            return sol, move_meta\n\n    # If no direct lowering feasible, try a Kempe swap with a lower color\n    if top_vertices:\n        u = random.choice(top_vertices)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            kempe_swap(u, a, b)\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"KempeSwap\"\n            return sol, move_meta\n\n    # Fallback: mild diversification via recolor of random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    move_meta[\"NB_Type\"] = \"Diversification\"\n    move_meta[\"Movement_Type\"] = \"RandomBestLocal\"\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Simple greedy seed if invalid\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        sol = [0]*n\n        for u in order:\n            used = {sol[v] for v in adj[u] if sol[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u] = c\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            # Prefer colors not used by neighbors\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Measure conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(2, min(6, conflicts))\n\n    # Apply 1-2 Kempe swaps + a short random walk recolor\n    for _ in range(1 + (1 if random.random() < 0.5 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00149969}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return invalids * (10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    max_color = max(solution) if solution else n\n    sum_colors = sum(solution)\n\n    # Lexicographic scalarization: invalids >> conflicts >> max_color >> sum_colors\n    fitness = conflicts * (10**6) + max_color * 1000 + sum_colors\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Repair\/initialize input solution\n    def greedy_seed():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for u in order:\n            used = {colors[v] for v in adj[u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: compute conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    # Normalize palette bounds\n    base_max = max(3, current_max)\n    palette = list(range(1, base_max + 1))\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u):\n        # Try assign the smallest feasible color that reduces max color\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, current_max):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        # BFS on subgraph induced by colors {a,b}\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    move_meta = {\"NB_Type\": \"\", \"Movement_Type\": \"\"}\n\n    # Phase A: if conflicts>0, reduce conflicts preferentially\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # Choose most conflicted, tie-break by higher degree then lowest index\n        if conflicted_vertices:\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        # Allow temporary +1 color only when conflicts>0 and current_max < 4\n        local_palette = list(palette)\n        if current_max < 4:\n            local_palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in local_palette:\n            if c == old and len(local_palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        move_meta[\"NB_Type\"] = \"LocalSearch\"\n        move_meta[\"Movement_Type\"] = \"SingleVertexRecolor\"\n        return sol, move_meta\n\n    # Phase B: conflict-free -> attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    # Try greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u)\n        if new_c is not None:\n            old = sol[u]\n            sol[u] = new_c\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"LowerColorGreedy\"\n            return sol, move_meta\n\n    # If no direct lowering feasible, try a Kempe swap with a lower color\n    if top_vertices:\n        u = random.choice(top_vertices)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            kempe_swap(u, a, b)\n            move_meta[\"NB_Type\"] = \"ColorReduction\"\n            move_meta[\"Movement_Type\"] = \"KempeSwap\"\n            return sol, move_meta\n\n    # Fallback: mild diversification via recolor of random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    move_meta[\"NB_Type\"] = \"Diversification\"\n    move_meta[\"Movement_Type\"] = \"RandomBestLocal\"\n    return sol, move_meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair input\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Simple greedy seed if invalid\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        sol = [0]*n\n        for u in order:\n            used = {sol[v] for v in adj[u] if sol[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u] = c\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            # Prefer colors not used by neighbors\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Measure conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(2, min(6, conflicts))\n\n    # Apply 1-2 Kempe swaps + a short random walk recolor\n    for _ in range(1 + (1 if random.random() < 0.5 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00146708}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**18\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return 10**18 + invalids\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # If solution empty (should not), guard\n    if not solution:\n        return 10**18\n\n    max_color = max(solution)\n    sum_colors = sum(solution)\n\n    # Strong lexicographic scalarization: conflicts >> max_color >> sum_colors\n    # weights ensure no trade-offs\n    fitness = conflicts * (10**12) + max_color * (10**6) + sum_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Greedy seed (DSATUR-like simplified) if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # Select vertex with max saturation (distinct neighbor colors), tie by degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u, top_color):\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, top_color):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, prioritize reducing them\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        if conflicted_vertices:\n            # choose most conflicted, tie by higher degree then lower index\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 1))\n        # Allow temporary +1 expansion to escape deadlocks when necessary\n        if all(local_conflicts_if(u, c) >= conflict_counts[u] for c in palette):\n            palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old and len(palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        return sol, \"LocalSearch\", \"SingleVertexRecolor\"\n\n    # Conflict-free: attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u, top_color)\n        if new_c is not None:\n            sol[u] = new_c\n            return sol, \"ColorReduction\", \"LowerColorGreedy\"\n\n    # Kempe swap with a lower color targeting reduction\n    if top_vertices:\n        # pick vertex with highest adjacency to lower colors\n        def score(u):\n            return -sum(1 for v in adj[u] if sol[v] < sol[u])\n        u = min(top_vertices, key=score)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            before_max = max(sol)\n            kempe_swap(u, a, b)\n            after_max = max(sol)\n            move = \"KempeSwapReduce\" if after_max < before_max else \"KempeSwapNeutral\"\n            return sol, \"ColorReduction\", move\n\n    # Diversification: recolor random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    palette = list(range(1, max(1, current_max) + 1))\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"Diversification\", \"RandomBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair\/seed if invalid\n    def greedy_seed():\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    for _ in range(1 + (1 if random.random() < 0.6 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001360558}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**18\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return 10**18 + invalids\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # If solution empty (should not), guard\n    if not solution:\n        return 10**18\n\n    max_color = max(solution)\n    sum_colors = sum(solution)\n\n    # Strong lexicographic scalarization: conflicts >> max_color >> sum_colors\n    # weights ensure no trade-offs\n    fitness = conflicts * (10**12) + max_color * (10**6) + sum_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Greedy seed (DSATUR-like simplified) if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # Select vertex with max saturation (distinct neighbor colors), tie by degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u, top_color):\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, top_color):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, prioritize reducing them\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        if conflicted_vertices:\n            # choose most conflicted, tie by higher degree then lower index\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 1))\n        # Allow temporary +1 expansion to escape deadlocks when necessary\n        if all(local_conflicts_if(u, c) >= conflict_counts[u] for c in palette):\n            palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old and len(palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        return sol, \"LocalSearch\", \"SingleVertexRecolor\"\n\n    # Conflict-free: attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u, top_color)\n        if new_c is not None:\n            sol[u] = new_c\n            return sol, \"ColorReduction\", \"LowerColorGreedy\"\n\n    # Kempe swap with a lower color targeting reduction\n    if top_vertices:\n        # pick vertex with highest adjacency to lower colors\n        def score(u):\n            return -sum(1 for v in adj[u] if sol[v] < sol[u])\n        u = min(top_vertices, key=score)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            before_max = max(sol)\n            kempe_swap(u, a, b)\n            after_max = max(sol)\n            move = \"KempeSwapReduce\" if after_max < before_max else \"KempeSwapNeutral\"\n            return sol, \"ColorReduction\", move\n\n    # Diversification: recolor random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    palette = list(range(1, max(1, current_max) + 1))\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"Diversification\", \"RandomBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair\/seed if invalid\n    def greedy_seed():\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    for _ in range(1 + (1 if random.random() < 0.6 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001900405}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**18\n    invalids = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalids += 1\n    if invalids > 0:\n        return 10**18 + invalids\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # If solution empty (should not), guard\n    if not solution:\n        return 10**18\n\n    max_color = max(solution)\n    sum_colors = sum(solution)\n\n    # Strong lexicographic scalarization: conflicts >> max_color >> sum_colors\n    # weights ensure no trade-offs\n    fitness = conflicts * (10**12) + max_color * (10**6) + sum_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Greedy seed (DSATUR-like simplified) if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # Select vertex with max saturation (distinct neighbor colors), tie by degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Helper: conflicts per vertex\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    def try_lower_color_for(u, top_color):\n        used = {sol[v] for v in adj[u]}\n        for c in range(1, top_color):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_swap(start, a, b):\n        visited = [False]*n\n        dq = deque([start])\n        visited[start] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, prioritize reducing them\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        if conflicted_vertices:\n            # choose most conflicted, tie by higher degree then lower index\n            maxc = max(conflict_counts[i] for i in conflicted_vertices)\n            cand = [i for i in conflicted_vertices if conflict_counts[i] == maxc]\n        else:\n            cand = list(range(n))\n        cand.sort(key=lambda i: (-len(adj[i]), i))\n        u = cand[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 1))\n        # Allow temporary +1 expansion to escape deadlocks when necessary\n        if all(local_conflicts_if(u, c) >= conflict_counts[u] for c in palette):\n            palette.append(current_max + 1)\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old and len(palette) > 1:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        sol[u] = best_color\n        return sol, \"LocalSearch\", \"SingleVertexRecolor\"\n\n    # Conflict-free: attempt to reduce max color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Greedy lowering\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        new_c = try_lower_color_for(u, top_color)\n        if new_c is not None:\n            sol[u] = new_c\n            return sol, \"ColorReduction\", \"LowerColorGreedy\"\n\n    # Kempe swap with a lower color targeting reduction\n    if top_vertices:\n        # pick vertex with highest adjacency to lower colors\n        def score(u):\n            return -sum(1 for v in adj[u] if sol[v] < sol[u])\n        u = min(top_vertices, key=score)\n        a = sol[u]\n        lower_choices = [c for c in range(1, a)]\n        if lower_choices:\n            b = random.choice(lower_choices)\n            before_max = max(sol)\n            kempe_swap(u, a, b)\n            after_max = max(sol)\n            move = \"KempeSwapReduce\" if after_max < before_max else \"KempeSwapNeutral\"\n            return sol, \"ColorReduction\", move\n\n    # Diversification: recolor random vertex to best local color\n    u = random.randrange(n)\n    old = sol[u]\n    palette = list(range(1, max(1, current_max) + 1))\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in palette:\n        if c == old and len(palette) > 1:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"Diversification\", \"RandomBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Repair\/seed if invalid\n    def greedy_seed():\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Adaptive strength\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    for _ in range(1 + (1 if random.random() < 0.6 else 0)):\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001950706}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Large integer penalty; lesser is better\n        return int(10**9 + conflicts)\n\n    # Feasible: objective is to minimize max color (k)\n    return int(max(solution))\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # DSATUR-like greedy seeding if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Helper: count conflicts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # If conflicts exist, try to recolor a conflicted vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # pick the most conflicted, tie-break by higher degree then lower index\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 0)) or [1]\n        if not palette:\n            palette = [1]\n        # Ensure at least one candidate; try existing palette only to avoid color inflation\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in range(1, current_max + 0):\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        # If no better color in current palette, allow same color (no-op) to keep signature\n        sol[u] = best_color\n        move = \"SingleVertexRecolor\"\n        return sol, move\n\n    # Conflict-free: attempt to reduce maximum color by lowering vertices of top color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Try to lower each top-color vertex using best-fit (min conflicts)\n    improved = False\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # Choose the candidate minimizing future conflicts around neighbors (tie by smaller color)\n        best_c = None\n        best_c_key = (10**9, 10**9)\n        for c in candidate_colors:\n            loc = local_conflicts_if(u, c)\n            key = (loc, c)\n            if key < best_c_key:\n                best_c_key = key\n                best_c = c\n        if best_c is not None:\n            sol[u] = best_c\n            improved = True\n            move = \"LowerColorGreedyBestFit\"\n            break\n\n    if improved:\n        return sol, move\n\n    # As a diversification step, recolor a random vertex within current palette to its best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in range(1, current_max + 1):\n        if c == old:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"DiversificationBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Simple repair\/seed if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Kempe chain swap focused on a random vertex\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Short random recolor walk constrained to current palette\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Determine conflict level to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.6:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001092225}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Large integer penalty; lesser is better\n        return int(10**9 + conflicts)\n\n    # Feasible: objective is to minimize max color (k)\n    return int(max(solution))\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # DSATUR-like greedy seeding if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Helper: count conflicts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # If conflicts exist, try to recolor a conflicted vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # pick the most conflicted, tie-break by higher degree then lower index\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 0)) or [1]\n        if not palette:\n            palette = [1]\n        # Ensure at least one candidate; try existing palette only to avoid color inflation\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in range(1, current_max + 0):\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        # If no better color in current palette, allow same color (no-op) to keep signature\n        sol[u] = best_color\n        move = \"SingleVertexRecolor\"\n        return sol, move\n\n    # Conflict-free: attempt to reduce maximum color by lowering vertices of top color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Try to lower each top-color vertex using best-fit (min conflicts)\n    improved = False\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # Choose the candidate minimizing future conflicts around neighbors (tie by smaller color)\n        best_c = None\n        best_c_key = (10**9, 10**9)\n        for c in candidate_colors:\n            loc = local_conflicts_if(u, c)\n            key = (loc, c)\n            if key < best_c_key:\n                best_c_key = key\n                best_c = c\n        if best_c is not None:\n            sol[u] = best_c\n            improved = True\n            move = \"LowerColorGreedyBestFit\"\n            break\n\n    if improved:\n        return sol, move\n\n    # As a diversification step, recolor a random vertex within current palette to its best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in range(1, current_max + 1):\n        if c == old:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"DiversificationBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Simple repair\/seed if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Kempe chain swap focused on a random vertex\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Short random recolor walk constrained to current palette\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Determine conflict level to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.6:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001434709}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(10**12)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Large integer penalty; lesser is better\n        return int(10**9 + conflicts)\n\n    # Feasible: objective is to minimize max color (k)\n    return int(max(solution))\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # DSATUR-like greedy seeding if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Helper: count conflicts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # If conflicts exist, try to recolor a conflicted vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        # pick the most conflicted, tie-break by higher degree then lower index\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = list(range(1, max(1, current_max) + 0)) or [1]\n        if not palette:\n            palette = [1]\n        # Ensure at least one candidate; try existing palette only to avoid color inflation\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in range(1, current_max + 0):\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        # If no better color in current palette, allow same color (no-op) to keep signature\n        sol[u] = best_color\n        move = \"SingleVertexRecolor\"\n        return sol, move\n\n    # Conflict-free: attempt to reduce maximum color by lowering vertices of top color\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n\n    # Try to lower each top-color vertex using best-fit (min conflicts)\n    improved = False\n    for u in sorted(top_vertices, key=lambda i: (len(adj[i]), i)):\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # Choose the candidate minimizing future conflicts around neighbors (tie by smaller color)\n        best_c = None\n        best_c_key = (10**9, 10**9)\n        for c in candidate_colors:\n            loc = local_conflicts_if(u, c)\n            key = (loc, c)\n            if key < best_c_key:\n                best_c_key = key\n                best_c = c\n        if best_c is not None:\n            sol[u] = best_c\n            improved = True\n            move = \"LowerColorGreedyBestFit\"\n            break\n\n    if improved:\n        return sol, move\n\n    # As a diversification step, recolor a random vertex within current palette to its best local color\n    u = random.randrange(n)\n    old = sol[u]\n    best_color = old\n    best_key = (10**9, current_max, old)\n    for c in range(1, current_max + 1):\n        if c == old:\n            continue\n        loc = local_conflicts_if(u, c)\n        new_max = max(current_max, c)\n        key = (loc, new_max, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n    sol[u] = best_color\n    return sol, \"DiversificationBestLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Simple repair\/seed if invalid\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Kempe chain swap focused on a random vertex\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Short random recolor walk constrained to current palette\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            if free:\n                sol[u] = random.choice(free)\n            else:\n                sol[u] = random.choice(choices)\n\n    # Determine conflict level to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.6:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001364028}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ list of 9 positive integers; color labels compacted to 1..k","Evaluacion":"import math\nfrom typing import List, Dict\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return int(10**12)\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping: Dict[int,int] = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts and stats\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    k = max(compact)\n    max_color_count = sum(1 for x in compact if x == k)\n    sum_colors = sum(compact)\n\n    # Penalty with gradient among infeasible moves; lesser is better\n    # Primary: conflicts; Secondary: k; Tertiary: number of vertices at max color; Quaternary: sum of colors\n    M = 10**6\n    if conflicts > 0:\n        return int(M*conflicts + 1000*k + 10*max_color_count + sum_colors)\n\n    # Feasible\n    return int(1000*k + 10*max_color_count + sum_colors)","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u: int, color: int) -> int:\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Kempe chain interchange between two colors a and b starting from u\n    def kempe_chain_interchange(u: int, a: int, b: int):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, repair by recolor or Kempe move\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        # Try recolor within palette to minimize local conflicts\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return compact_colors(sol), \"ConflictRecolor\"\n        # Try Kempe chain with a random other color to break ties\n        if len(palette) >= 2:\n            other = random.choice([c for c in palette if c != old])\n            kempe_chain_interchange(u, old, other)\n            return compact_colors(sol), \"ConflictKempe\"\n        return compact_colors(sol), \"ConflictNoOp\"\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # choose smallest color to bias compaction\n        c = min(candidate_colors)\n        sol[u] = c\n        return compact_colors(sol), \"ReduceK_LowerTopVertex\"\n\n    # If k-reduction failed, diversify via color-class swap of two colors\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return compact_colors(sol), \"Diversify_SwapClasses\"\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return compact_colors(sol), \"Diversify_RandomRecolor\"","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Seed if invalid\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Kempe chain swap focused on random vertices\n    def kempe_swap(start_idx: int):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk constrained to current palette\n    def random_walk_recolors(L: int):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Determine conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001307937}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ list of 9 positive integers; color labels compacted to 1..k","Evaluacion":"import math\nfrom typing import List, Dict\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return int(10**12)\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping: Dict[int,int] = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts and stats\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    k = max(compact)\n    max_color_count = sum(1 for x in compact if x == k)\n    sum_colors = sum(compact)\n\n    # Penalty with gradient among infeasible moves; lesser is better\n    # Primary: conflicts; Secondary: k; Tertiary: number of vertices at max color; Quaternary: sum of colors\n    M = 10**6\n    if conflicts > 0:\n        return int(M*conflicts + 1000*k + 10*max_color_count + sum_colors)\n\n    # Feasible\n    return int(1000*k + 10*max_color_count + sum_colors)","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u: int, color: int) -> int:\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Kempe chain interchange between two colors a and b starting from u\n    def kempe_chain_interchange(u: int, a: int, b: int):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, repair by recolor or Kempe move\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        # Try recolor within palette to minimize local conflicts\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return compact_colors(sol), \"ConflictRecolor\"\n        # Try Kempe chain with a random other color to break ties\n        if len(palette) >= 2:\n            other = random.choice([c for c in palette if c != old])\n            kempe_chain_interchange(u, old, other)\n            return compact_colors(sol), \"ConflictKempe\"\n        return compact_colors(sol), \"ConflictNoOp\"\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # choose smallest color to bias compaction\n        c = min(candidate_colors)\n        sol[u] = c\n        return compact_colors(sol), \"ReduceK_LowerTopVertex\"\n\n    # If k-reduction failed, diversify via color-class swap of two colors\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return compact_colors(sol), \"Diversify_SwapClasses\"\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return compact_colors(sol), \"Diversify_RandomRecolor\"","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Seed if invalid\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Kempe chain swap focused on random vertices\n    def kempe_swap(start_idx: int):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk constrained to current palette\n    def random_walk_recolors(L: int):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Determine conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001682123}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ list of 9 positive integers; color labels compacted to 1..k","Evaluacion":"import math\nfrom typing import List, Dict\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return int(10**12)\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return int(10**12)\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping: Dict[int,int] = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts and stats\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    k = max(compact)\n    max_color_count = sum(1 for x in compact if x == k)\n    sum_colors = sum(compact)\n\n    # Penalty with gradient among infeasible moves; lesser is better\n    # Primary: conflicts; Secondary: k; Tertiary: number of vertices at max color; Quaternary: sum of colors\n    M = 10**6\n    if conflicts > 0:\n        return int(M*conflicts + 1000*k + 10*max_color_count + sum_colors)\n\n    # Feasible\n    return int(1000*k + 10*max_color_count + sum_colors)","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u: int, color: int) -> int:\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Kempe chain interchange between two colors a and b starting from u\n    def kempe_chain_interchange(u: int, a: int, b: int):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    # If conflicts exist, repair by recolor or Kempe move\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-conflict_counts[i], -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        # Try recolor within palette to minimize local conflicts\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = max(current_max, c)\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return compact_colors(sol), \"ConflictRecolor\"\n        # Try Kempe chain with a random other color to break ties\n        if len(palette) >= 2:\n            other = random.choice([c for c in palette if c != old])\n            kempe_chain_interchange(u, old, other)\n            return compact_colors(sol), \"ConflictKempe\"\n        return compact_colors(sol), \"ConflictNoOp\"\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        # choose smallest color to bias compaction\n        c = min(candidate_colors)\n        sol[u] = c\n        return compact_colors(sol), \"ReduceK_LowerTopVertex\"\n\n    # If k-reduction failed, diversify via color-class swap of two colors\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return compact_colors(sol), \"Diversify_SwapClasses\"\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return compact_colors(sol), \"Diversify_RandomRecolor\"","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Seed if invalid\n    def greedy_seed() -> List[int]:\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Kempe chain swap focused on random vertices\n    def kempe_swap(start_idx: int):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk constrained to current palette\n    def random_walk_recolors(L: int):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Determine conflicts to scale perturbation\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    # Apply a couple of Kempe swaps and a short recolor walk\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002018676}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # k and label-invariant tie-breakers based on class sizes\n    k = max(compact)\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    # ignore index 0\n    class_sizes = class_sizes[1:]\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq) with dynamic safe weights\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n           # max_class <= n\n    max_quat = n*n        # sum of squares <= n^2 when one class has all\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR-like: pick vertex with most distinct neighbor colors, then degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Fine-grained move: single-vertex recolor prioritized on conflicts\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (compact_colors(sol), \"ConflictRecolor\")\n        # If no improvement with palette recolor, try a small Kempe chain with one random other color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            return (compact_colors(sol), \"ConflictKempe\")\n        return (compact_colors(sol), \"ConflictNoOp\")\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (compact_colors(sol), \"ReduceK_LowerTopVertex\")\n\n    # Diversify: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (compact_colors(sol), \"Diversify_SwapClasses\")\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (compact_colors(sol), \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001283117}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # k and label-invariant tie-breakers based on class sizes\n    k = max(compact)\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    # ignore index 0\n    class_sizes = class_sizes[1:]\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq) with dynamic safe weights\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n           # max_class <= n\n    max_quat = n*n        # sum of squares <= n^2 when one class has all\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR-like: pick vertex with most distinct neighbor colors, then degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Fine-grained move: single-vertex recolor prioritized on conflicts\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (compact_colors(sol), \"ConflictRecolor\")\n        # If no improvement with palette recolor, try a small Kempe chain with one random other color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            return (compact_colors(sol), \"ConflictKempe\")\n        return (compact_colors(sol), \"ConflictNoOp\")\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (compact_colors(sol), \"ReduceK_LowerTopVertex\")\n\n    # Diversify: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (compact_colors(sol), \"Diversify_SwapClasses\")\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (compact_colors(sol), \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001928396}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # k and label-invariant tie-breakers based on class sizes\n    k = max(compact)\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    # ignore index 0\n    class_sizes = class_sizes[1:]\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq) with dynamic safe weights\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n           # max_class <= n\n    max_quat = n*n        # sum of squares <= n^2 when one class has all\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR-like: pick vertex with most distinct neighbor colors, then degree\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = compact_colors(list(solution))\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # Fine-grained move: single-vertex recolor prioritized on conflicts\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (compact_colors(sol), \"ConflictRecolor\")\n        # If no improvement with palette recolor, try a small Kempe chain with one random other color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            return (compact_colors(sol), \"ConflictKempe\")\n        return (compact_colors(sol), \"ConflictNoOp\")\n\n    # Conflict-free: try to reduce k by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (compact_colors(sol), \"ReduceK_LowerTopVertex\")\n\n    # Diversify: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (compact_colors(sol), \"Diversify_SwapClasses\")\n\n    # Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (compact_colors(sol), \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = compact_colors(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return compact_colors(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001639802}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]  \/\/ list of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure fast\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations (label-invariant evaluation)\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # Number of colors\n    k = max(compact) if compact else 0\n\n    # Tie-breakers\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    class_sizes = class_sizes[1:] if k > 0 else []\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq)\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n\n    max_quat = n*n\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # 1) If conflicts exist: prioritize resolving a high-conflict vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n\n        # Try recoloring within existing palette minimizing local conflicts and k\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (sol, \"ConflictRecolor\")\n\n        # If no gain, attempt a Kempe chain swap on a random alternate color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                sol[x] = b if sol[x] == old else (old if sol[x] == b else sol[x])\n            return (sol, \"ConflictKempe\")\n\n        return (sol, \"ConflictNoOp\")\n\n    # 2) If conflict-free: attempt to reduce number of colors by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (sol, \"ReduceK_LowerTopVertex\")\n\n    # 3) Diversification: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"Diversify_SwapClasses\")\n\n    # 4) Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00000523}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]  \/\/ list of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure fast\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations (label-invariant evaluation)\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # Number of colors\n    k = max(compact) if compact else 0\n\n    # Tie-breakers\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    class_sizes = class_sizes[1:] if k > 0 else []\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq)\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n\n    max_quat = n*n\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # 1) If conflicts exist: prioritize resolving a high-conflict vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n\n        # Try recoloring within existing palette minimizing local conflicts and k\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (sol, \"ConflictRecolor\")\n\n        # If no gain, attempt a Kempe chain swap on a random alternate color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                sol[x] = b if sol[x] == old else (old if sol[x] == b else sol[x])\n            return (sol, \"ConflictKempe\")\n\n        return (sol, \"ConflictNoOp\")\n\n    # 2) If conflict-free: attempt to reduce number of colors by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (sol, \"ReduceK_LowerTopVertex\")\n\n    # 3) Diversification: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"Diversify_SwapClasses\")\n\n    # 4) Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00000145}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9]  \/\/ list of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate structure fast\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations (label-invariant evaluation)\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    # Number of colors\n    k = max(compact) if compact else 0\n\n    # Tie-breakers\n    class_sizes = [0]*(k+1)\n    for c in compact:\n        class_sizes[c] += 1\n    class_sizes = class_sizes[1:] if k > 0 else []\n    max_class = max(class_sizes) if class_sizes else 0\n    sum_sq = sum(s*s for s in class_sizes)\n\n    # Lexicographic weighting (conflicts, k, max_class, sum_sq)\n    m = len(edges)\n    max_conflicts = m\n    max_k = n\n    max_ter = n\n    max_quat = n*n\n\n    w4 = 1\n    w3 = max_quat + 1\n    w2 = max_ter * w3 + 1\n    w1 = max_k * w2 + 1\n\n    score = conflicts * w1 + k * w2 + max_class * w3 + sum_sq * w4\n    return int(score)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    # Validate\/repair input solution\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n        move = \"SeedGreedy\"\n    else:\n        sol = list(solution)\n        move = \"None\"\n\n    # Conflict counts\n    conflict_counts = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n    total_conflicts = sum(1 for (u, v) in edges if sol[u-1] == sol[v-1])\n    current_max = max(sol) if sol else 1\n\n    def local_conflicts_if(u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n\n    # 1) If conflicts exist: prioritize resolving a high-conflict vertex\n    if total_conflicts > 0:\n        conflicted_vertices = [i for i, c in enumerate(conflict_counts) if c > 0]\n        conflicted_vertices.sort(key=lambda i: (-(conflict_counts[i]), -len(adj[i]), i))\n        u = conflicted_vertices[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n\n        # Try recoloring within existing palette minimizing local conflicts and k\n        best_color = old\n        best_key = (10**9, current_max, old)\n        for c in palette:\n            if c == old:\n                continue\n            loc = local_conflicts_if(u, c)\n            new_max = current_max if c <= current_max else c\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            return (sol, \"ConflictRecolor\")\n\n        # If no gain, attempt a Kempe chain swap on a random alternate color\n        if len(palette) >= 2:\n            other_choices = [c for c in palette if c != old]\n            b = random.choice(other_choices)\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                sol[x] = b if sol[x] == old else (old if sol[x] == b else sol[x])\n            return (sol, \"ConflictKempe\")\n\n        return (sol, \"ConflictNoOp\")\n\n    # 2) If conflict-free: attempt to reduce number of colors by lowering top color vertices\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidate_colors = [c for c in range(1, top_color) if c not in used]\n        if not candidate_colors:\n            continue\n        c = min(candidate_colors)\n        sol[u] = c\n        return (sol, \"ReduceK_LowerTopVertex\")\n\n    # 3) Diversification: swap two color classes\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"Diversify_SwapClasses\")\n\n    # 4) Fallback random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, n)\n            for u in uncolored:\n                neigh_colors = {colors[v] for v in adj[u] if colors[v] != 0}\n                key = (len(neigh_colors), degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = {colors[v] for v in adj[best_u] if colors[v] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = greedy_seed()\n    else:\n        sol = list(solution)\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n\n    # Kempe chain swap around random seeds\n    def kempe_swap(start_idx):\n        a = sol[start_idx]\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        visited = [False]*n\n        dq = deque([start_idx])\n        visited[start_idx] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and (sol[v] == a or sol[v] == b):\n                    visited[v] = True\n                    dq.append(v)\n        for u in comp:\n            sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    # Random recolor walk of length depending on conflicts\n    def random_walk_recolors(L):\n        palette = sorted(set(sol))\n        for _ in range(L):\n            u = random.randrange(n)\n            used = {sol[v] for v in adj[u]}\n            choices = [c for c in palette if c != sol[u]]\n            if not choices:\n                continue\n            free = [c for c in choices if c not in used]\n            sol[u] = random.choice(free if free else choices)\n\n    # Scale perturbation by conflicts\n    L = 2 if conflicts == 0 else max(3, min(7, conflicts))\n\n    kempe_swap(random.randrange(n))\n    if random.random() < 0.7:\n        kempe_swap(random.randrange(n))\n    random_walk_recolors(L)\n\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00000113}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ space-separated string of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data (0-indexed usage)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Fast validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 10**12\n\n    # Number of colors\n    k = max(compact) if compact else 0\n    return int(k)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    # DSATUR greedy initializer\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            # choose vertex with max saturation, then degree, then index\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    # Validate or seed\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n        return (sol, \"Seed_DSatur\")\n    sol = list(solution)\n\n    # Helper: count conflicts per vertex and total\n    conflict_counts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n            total_conflicts += 1\n\n    current_max = max(sol) if sol else 1\n\n    # If conflicts exist: try targeted recolor (allow new color if strictly reduces local conflicts)\n    if total_conflicts > 0:\n        # pick vertex with highest conflicts, break ties by degree then index\n        cand = [i for i, c in enumerate(conflict_counts) if c > 0]\n        cand.sort(key=lambda i: (conflict_counts[i], len(adj[i]), -i), reverse=True)\n        u = cand[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, 10**9, old)\n        # Try existing colors and one new color as escape\n        trial_colors = list(range(1, current_max+1)) + [current_max+1]\n        for c in trial_colors:\n            if c == old:\n                continue\n            loc = 0\n            for v in adj[u]:\n                if sol[v] == c:\n                    loc += 1\n            # prefer fewer local conflicts; then prefer not to increase max color\n            new_max = current_max if c <= current_max else current_max + 1\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            # compact if we introduced a new color that immediately became empty\/unused or emptied old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_TargetRecolor\")\n        # fallback: Kempe swap between old and best alternative conflicting color\n        alt_colors = [c for c in palette if c != old]\n        if alt_colors:\n            b = max(alt_colors, key=lambda c: sum(1 for v in adj[u] if sol[v] == c))\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_KempeSwap\")\n        return (sol, \"Conflict_NoOp\")\n\n    # Conflict-free: attempt to reduce k\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidates = [c for c in range(1, top_color) if c not in used]\n        if candidates:\n            sol[u] = min(candidates)\n            # If top color becomes empty, compact\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_RemoveTopColor\")\n            return (sol, \"ReduceK_LowerTopVertex\")\n\n    # Try Kempe chain with a lower color to free top_color vertices\n    if top_vertices:\n        u = random.choice(top_vertices)\n        lower = [c for c in range(1, top_color)]\n        if lower:\n            b = random.choice(lower)\n            a = top_color\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == a or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == a:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = a\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_KempeEliminateTop\")\n            return (sol, \"ReduceK_KempePair\")\n\n    # Diversification: swap two color classes to change landscape\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        sol = compact_colors(sol)\n        return (sol, \"Diversify_SwapClasses\")\n\n    # Fallback: random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    sol = compact_colors(sol)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n    else:\n        sol = list(solution)\n\n    current_max = max(sol) if sol else 1\n\n    # Perturbation plan:\n    # 1) Perform 1-2 Kempe swaps on random color pairs favoring top color involvement.\n    # 2) Random recolor walk of L steps within palette, preferring conflict-free choices when possible.\n\n    def kempe_swap_from(u, a, b):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        # Prefer involving top color if present\n        top = current_max\n        cand_vertices = [i for i, c in enumerate(sol) if c == top] or [random.randrange(n)]\n        u = random.choice(cand_vertices)\n        a = sol[u]\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        kempe_swap_from(u, a, b)\n        if random.random() < 0.7 and len(palette) >= 2:\n            u2 = random.randrange(n)\n            a2 = sol[u2]\n            b2_choices = [c for c in palette if c != a2]\n            if b2_choices:\n                b2 = random.choice(b2_choices)\n                kempe_swap_from(u2, a2, b2)\n\n    # Random recolor walk\n    L = max(3, min(8, len(edges)\/\/2))\n    palette = sorted(set(sol))\n    for _ in range(L):\n        u = random.randrange(n)\n        used = {sol[v] for v in adj[u]}\n        choices = [c for c in palette if c != sol[u]]\n        if not choices:\n            continue\n        free = [c for c in choices if c not in used]\n        sol[u] = random.choice(free if free else choices)\n\n    sol = compact_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001366148}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ space-separated string of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data (0-indexed usage)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Fast validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 10**12\n\n    # Number of colors\n    k = max(compact) if compact else 0\n    return int(k)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    # DSATUR greedy initializer\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            # choose vertex with max saturation, then degree, then index\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    # Validate or seed\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n        return (sol, \"Seed_DSatur\")\n    sol = list(solution)\n\n    # Helper: count conflicts per vertex and total\n    conflict_counts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n            total_conflicts += 1\n\n    current_max = max(sol) if sol else 1\n\n    # If conflicts exist: try targeted recolor (allow new color if strictly reduces local conflicts)\n    if total_conflicts > 0:\n        # pick vertex with highest conflicts, break ties by degree then index\n        cand = [i for i, c in enumerate(conflict_counts) if c > 0]\n        cand.sort(key=lambda i: (conflict_counts[i], len(adj[i]), -i), reverse=True)\n        u = cand[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, 10**9, old)\n        # Try existing colors and one new color as escape\n        trial_colors = list(range(1, current_max+1)) + [current_max+1]\n        for c in trial_colors:\n            if c == old:\n                continue\n            loc = 0\n            for v in adj[u]:\n                if sol[v] == c:\n                    loc += 1\n            # prefer fewer local conflicts; then prefer not to increase max color\n            new_max = current_max if c <= current_max else current_max + 1\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            # compact if we introduced a new color that immediately became empty\/unused or emptied old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_TargetRecolor\")\n        # fallback: Kempe swap between old and best alternative conflicting color\n        alt_colors = [c for c in palette if c != old]\n        if alt_colors:\n            b = max(alt_colors, key=lambda c: sum(1 for v in adj[u] if sol[v] == c))\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_KempeSwap\")\n        return (sol, \"Conflict_NoOp\")\n\n    # Conflict-free: attempt to reduce k\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidates = [c for c in range(1, top_color) if c not in used]\n        if candidates:\n            sol[u] = min(candidates)\n            # If top color becomes empty, compact\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_RemoveTopColor\")\n            return (sol, \"ReduceK_LowerTopVertex\")\n\n    # Try Kempe chain with a lower color to free top_color vertices\n    if top_vertices:\n        u = random.choice(top_vertices)\n        lower = [c for c in range(1, top_color)]\n        if lower:\n            b = random.choice(lower)\n            a = top_color\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == a or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == a:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = a\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_KempeEliminateTop\")\n            return (sol, \"ReduceK_KempePair\")\n\n    # Diversification: swap two color classes to change landscape\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        sol = compact_colors(sol)\n        return (sol, \"Diversify_SwapClasses\")\n\n    # Fallback: random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    sol = compact_colors(sol)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n    else:\n        sol = list(solution)\n\n    current_max = max(sol) if sol else 1\n\n    # Perturbation plan:\n    # 1) Perform 1-2 Kempe swaps on random color pairs favoring top color involvement.\n    # 2) Random recolor walk of L steps within palette, preferring conflict-free choices when possible.\n\n    def kempe_swap_from(u, a, b):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        # Prefer involving top color if present\n        top = current_max\n        cand_vertices = [i for i, c in enumerate(sol) if c == top] or [random.randrange(n)]\n        u = random.choice(cand_vertices)\n        a = sol[u]\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        kempe_swap_from(u, a, b)\n        if random.random() < 0.7 and len(palette) >= 2:\n            u2 = random.randrange(n)\n            a2 = sol[u2]\n            b2_choices = [c for c in palette if c != a2]\n            if b2_choices:\n                b2 = random.choice(b2_choices)\n                kempe_swap_from(u2, a2, b2)\n\n    # Random recolor walk\n    L = max(3, min(8, len(edges)\/\/2))\n    palette = sorted(set(sol))\n    for _ in range(L):\n        u = random.randrange(n)\n        used = {sol[v] for v in adj[u]}\n        choices = [c for c in palette if c != sol[u]]\n        if not choices:\n            continue\n        free = [c for c in choices if c not in used]\n        sol[u] = random.choice(free if free else choices)\n\n    sol = compact_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001772434}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"COLOR_LIST[9] \/\/ space-separated string of 9 positive integers; color labels are 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data (0-indexed usage)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Fast validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    if not all(isinstance(x, int) and x >= 1 for x in solution):\n        return 10**12\n\n    # Relabel colors to be compact 1..k while preserving equality relations\n    mapping = {}\n    next_c = 1\n    compact = [0]*n\n    for i, c in enumerate(solution):\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        compact[i] = mapping[c]\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if compact[u-1] == compact[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 10**12\n\n    # Number of colors\n    k = max(compact) if compact else 0\n    return int(k)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    # DSATUR greedy initializer\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            # choose vertex with max saturation, then degree, then index\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    # Validate or seed\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n        return (sol, \"Seed_DSatur\")\n    sol = list(solution)\n\n    # Helper: count conflicts per vertex and total\n    conflict_counts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if sol[ui] == sol[vi]:\n            conflict_counts[ui] += 1\n            conflict_counts[vi] += 1\n            total_conflicts += 1\n\n    current_max = max(sol) if sol else 1\n\n    # If conflicts exist: try targeted recolor (allow new color if strictly reduces local conflicts)\n    if total_conflicts > 0:\n        # pick vertex with highest conflicts, break ties by degree then index\n        cand = [i for i, c in enumerate(conflict_counts) if c > 0]\n        cand.sort(key=lambda i: (conflict_counts[i], len(adj[i]), -i), reverse=True)\n        u = cand[0]\n        old = sol[u]\n        palette = sorted(set(sol))\n        best_color = old\n        best_key = (10**9, 10**9, old)\n        # Try existing colors and one new color as escape\n        trial_colors = list(range(1, current_max+1)) + [current_max+1]\n        for c in trial_colors:\n            if c == old:\n                continue\n            loc = 0\n            for v in adj[u]:\n                if sol[v] == c:\n                    loc += 1\n            # prefer fewer local conflicts; then prefer not to increase max color\n            new_max = current_max if c <= current_max else current_max + 1\n            key = (loc, new_max, c)\n            if key < best_key:\n                best_key = key\n                best_color = c\n        if best_color != old:\n            sol[u] = best_color\n            # compact if we introduced a new color that immediately became empty\/unused or emptied old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_TargetRecolor\")\n        # fallback: Kempe swap between old and best alternative conflicting color\n        alt_colors = [c for c in palette if c != old]\n        if alt_colors:\n            b = max(alt_colors, key=lambda c: sum(1 for v in adj[u] if sol[v] == c))\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == old or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == old:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = old\n            sol = compact_colors(sol)\n            return (sol, \"Conflict_KempeSwap\")\n        return (sol, \"Conflict_NoOp\")\n\n    # Conflict-free: attempt to reduce k\n    top_color = current_max\n    top_vertices = [i for i, c in enumerate(sol) if c == top_color]\n    random.shuffle(top_vertices)\n    for u in top_vertices:\n        used = {sol[v] for v in adj[u]}\n        candidates = [c for c in range(1, top_color) if c not in used]\n        if candidates:\n            sol[u] = min(candidates)\n            # If top color becomes empty, compact\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_RemoveTopColor\")\n            return (sol, \"ReduceK_LowerTopVertex\")\n\n    # Try Kempe chain with a lower color to free top_color vertices\n    if top_vertices:\n        u = random.choice(top_vertices)\n        lower = [c for c in range(1, top_color)]\n        if lower:\n            b = random.choice(lower)\n            a = top_color\n            visited = [False]*n\n            dq = deque([u])\n            visited[u] = True\n            comp = []\n            while dq:\n                x = dq.popleft()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (sol[y] == a or sol[y] == b):\n                        visited[y] = True\n                        dq.append(y)\n            for x in comp:\n                if sol[x] == a:\n                    sol[x] = b\n                elif sol[x] == b:\n                    sol[x] = a\n            if all(x != top_color for x in sol):\n                sol = compact_colors(sol)\n                return (sol, \"ReduceK_KempeEliminateTop\")\n            return (sol, \"ReduceK_KempePair\")\n\n    # Diversification: swap two color classes to change landscape\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        sol = compact_colors(sol)\n        return (sol, \"Diversify_SwapClasses\")\n\n    # Fallback: random recolor within palette\n    u = random.randrange(n)\n    choices = [c for c in palette if c != sol[u]] or [sol[u]]\n    sol[u] = random.choice(choices)\n    sol = compact_colors(sol)\n    return (sol, \"Diversify_RandomRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def compact_colors(colors):\n        mapping = {}\n        next_c = 1\n        out = [0]*n\n        for i, c in enumerate(colors):\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out[i] = mapping[c]\n        return out\n\n    def dsatur_seed():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        sat = [0]*n\n        uncolored = set(range(n))\n        neigh_colors = [set() for _ in range(n)]\n        while uncolored:\n            best_u = None\n            best_key = (-1, -1, -1)\n            for u in uncolored:\n                key = (sat[u], degrees[u], -u)\n                if key > best_key:\n                    best_key = key\n                    best_u = u\n            used = neigh_colors[best_u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_u] = c\n            uncolored.remove(best_u)\n            for v in adj[best_u]:\n                if colors[v] == 0:\n                    if c not in neigh_colors[v]:\n                        neigh_colors[v].add(c)\n                        sat[v] = len(neigh_colors[v])\n        return compact_colors(colors)\n\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = dsatur_seed()\n    else:\n        sol = list(solution)\n\n    current_max = max(sol) if sol else 1\n\n    # Perturbation plan:\n    # 1) Perform 1-2 Kempe swaps on random color pairs favoring top color involvement.\n    # 2) Random recolor walk of L steps within palette, preferring conflict-free choices when possible.\n\n    def kempe_swap_from(u, a, b):\n        visited = [False]*n\n        dq = deque([u])\n        visited[u] = True\n        comp = []\n        while dq:\n            x = dq.popleft()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (sol[y] == a or sol[y] == b):\n                    visited[y] = True\n                    dq.append(y)\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        # Prefer involving top color if present\n        top = current_max\n        cand_vertices = [i for i, c in enumerate(sol) if c == top] or [random.randrange(n)]\n        u = random.choice(cand_vertices)\n        a = sol[u]\n        b_choices = [c for c in palette if c != a]\n        b = random.choice(b_choices)\n        kempe_swap_from(u, a, b)\n        if random.random() < 0.7 and len(palette) >= 2:\n            u2 = random.randrange(n)\n            a2 = sol[u2]\n            b2_choices = [c for c in palette if c != a2]\n            if b2_choices:\n                b2 = random.choice(b2_choices)\n                kempe_swap_from(u2, a2, b2)\n\n    # Random recolor walk\n    L = max(3, min(8, len(edges)\/\/2))\n    palette = sorted(set(sol))\n    for _ in range(L):\n        u = random.randrange(n)\n        used = {sol[v] for v in adj[u]}\n        choices = [c for c in palette if c != sol[u]]\n        if not choices:\n            continue\n        free = [c for c in choices if c not in used]\n        sol[u] = random.choice(free if free else choices)\n\n    sol = compact_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00225896}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONSECUTIVE_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Objective: minimize number of colors while satisfying constraints.\n    # Embedded problem data (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Entry checks\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n\n    cols = solution\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Consecutive color indexing check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if k > 0:\n        if unique_colors != list(range(1, k+1)):\n            # Penalize non-consecutive usage; approximate via missing indices in expected 1..k\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            # If the minimum color is not 1, add a violation\n            if unique_colors[0] != 1:\n                range_violations += 1\n\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    # Relabel colors to 1..k preserving order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor; sometimes try color reduction or swap\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple default feasible-shaped neighbor\n        base = [1]*9\n        return (_normalize_consecutive_colors(base), \"Random-Recolor\", \"Single-Vertex\")\n\n    cols = list(solution)\n    n = len(cols)\n    # Choose move type\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor to existing or new color (allow exploration)\n        i = random.randrange(n)\n        current_max = max(cols) if cols else 1\n        # Bias towards existing colors\n        if random.random() < 0.85:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Random-Recolor\", \"Single-Vertex\")\n    elif r < 0.85:\n        # Swap colors of two vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        cols[i], cols[j] = cols[j], cols[i]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Swap-Vertices\", \"Swap-Two\")\n    else:\n        # Relabel two colors (color permutation on palette) to encourage consolidation\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cols = [ (b if c==a else a if c==b else c) for c in cols ]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Relabel-Colors\", \"Palette-Permutation\")\n","Perturbacion":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    mapping = {}\n    nxt = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple randomized recolors plus optional palette squeeze\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    cols = list(solution)\n    n = len(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new color\n        if random.random() < 0.9 and current_max > 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max if current_max > 1 else 1\n    # Palette squeeze: try to map highest color to a lower one probabilistically\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.7:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [ (target if c==highest else c) for c in cols ]\n    cols = _normalize_consecutive_colors(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000581238}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONSECUTIVE_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Objective: minimize number of colors while satisfying constraints.\n    # Embedded problem data (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Entry checks\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n\n    cols = solution\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Consecutive color indexing check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if k > 0:\n        if unique_colors != list(range(1, k+1)):\n            # Penalize non-consecutive usage; approximate via missing indices in expected 1..k\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            # If the minimum color is not 1, add a violation\n            if unique_colors[0] != 1:\n                range_violations += 1\n\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    # Relabel colors to 1..k preserving order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor; sometimes try color reduction or swap\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple default feasible-shaped neighbor\n        base = [1]*9\n        return (_normalize_consecutive_colors(base), \"Random-Recolor\", \"Single-Vertex\")\n\n    cols = list(solution)\n    n = len(cols)\n    # Choose move type\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor to existing or new color (allow exploration)\n        i = random.randrange(n)\n        current_max = max(cols) if cols else 1\n        # Bias towards existing colors\n        if random.random() < 0.85:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Random-Recolor\", \"Single-Vertex\")\n    elif r < 0.85:\n        # Swap colors of two vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        cols[i], cols[j] = cols[j], cols[i]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Swap-Vertices\", \"Swap-Two\")\n    else:\n        # Relabel two colors (color permutation on palette) to encourage consolidation\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cols = [ (b if c==a else a if c==b else c) for c in cols ]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Relabel-Colors\", \"Palette-Permutation\")\n","Perturbacion":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    mapping = {}\n    nxt = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple randomized recolors plus optional palette squeeze\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    cols = list(solution)\n    n = len(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new color\n        if random.random() < 0.9 and current_max > 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max if current_max > 1 else 1\n    # Palette squeeze: try to map highest color to a lower one probabilistically\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.7:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [ (target if c==highest else c) for c in cols ]\n    cols = _normalize_consecutive_colors(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000652668}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONSECUTIVE_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Objective: minimize number of colors while satisfying constraints.\n    # Embedded problem data (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Entry checks\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n\n    cols = solution\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Consecutive color indexing check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if k > 0:\n        if unique_colors != list(range(1, k+1)):\n            # Penalize non-consecutive usage; approximate via missing indices in expected 1..k\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            # If the minimum color is not 1, add a violation\n            if unique_colors[0] != 1:\n                range_violations += 1\n\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    # Relabel colors to 1..k preserving order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Random single-vertex recolor; sometimes try color reduction or swap\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a simple default feasible-shaped neighbor\n        base = [1]*9\n        return (_normalize_consecutive_colors(base), \"Random-Recolor\", \"Single-Vertex\")\n\n    cols = list(solution)\n    n = len(cols)\n    # Choose move type\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor to existing or new color (allow exploration)\n        i = random.randrange(n)\n        current_max = max(cols) if cols else 1\n        # Bias towards existing colors\n        if random.random() < 0.85:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Random-Recolor\", \"Single-Vertex\")\n    elif r < 0.85:\n        # Swap colors of two vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        cols[i], cols[j] = cols[j], cols[i]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Swap-Vertices\", \"Swap-Two\")\n    else:\n        # Relabel two colors (color permutation on palette) to encourage consolidation\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cols = [ (b if c==a else a if c==b else c) for c in cols ]\n        cols = _normalize_consecutive_colors(cols)\n        return (cols, \"Relabel-Colors\", \"Palette-Permutation\")\n","Perturbacion":"import random\nimport math\n\ndef _normalize_consecutive_colors(cols):\n    mapping = {}\n    nxt = 1\n    out = []\n    for c in cols:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple randomized recolors plus optional palette squeeze\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    cols = list(solution)\n    n = len(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new color\n        if random.random() < 0.9 and current_max > 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max if current_max > 1 else 1\n    # Palette squeeze: try to map highest color to a lower one probabilistically\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.7:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [ (target if c==highest else c) for c in cols ]\n    cols = _normalize_consecutive_colors(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000625219}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_PALETTE_1..k; indices 1..9 map to nodes 1..9; values are positive ints; colors normalized to sorted unique palette 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic, pure evaluation. Lower is better.\n    # Embedded graph (1-indexed):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette consecutiveness gaps\n    palette = sorted(set(cols))\n    k = len(palette)\n    gaps = 0\n    if k > 0:\n        expected = set(range(1, k+1))\n        gaps = len(expected.difference(palette))\n        if palette[0] != 1:\n            gaps += 1\n\n    # Lexicographic scalarization: feasibility -> consecutiveness -> k\n    fitness = conflicts * 1_000_000.0 + gaps * 10_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    # Map sorted palette to 1..k to satisfy representation constraints deterministically\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # If invalid input, return a default normalized solution\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return (_stable_normalize_palette([1,2,3,1,2,3,2,1,3]), \"Init-Default\")\n\n    cols = list(solution)\n\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = len(cols)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors, small chance to explore new color\n        if random.random() < 0.9:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Conflict-Driven\")\n    else:\n        # No conflicts: try to reduce k by changing a vertex with highest color\n        current_max = max(cols)\n        candidates = [i for i,c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        # Try a different existing lower color with bias\n        if current_max > 1 and random.random() < 0.85:\n            new_color = random.randint(1, current_max-1)\n        else:\n            new_color = random.randint(1, current_max)\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Reduce-k\")\n","Perturbacion":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef perturb_solution(solution):\n    # Strong shake: multiple recolors + optional palette squeeze; keeps representation normalized\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return _stable_normalize_palette([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    n = len(cols)\n\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer recolors within current palette; occasional exploration to new color\n        if random.random() < 0.92 or current_max == 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max + 1\n\n    # Palette squeeze: map highest color to a random lower one with some probability\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.75:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    cols = _stable_normalize_palette(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000826461}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_PALETTE_1..k; indices 1..9 map to nodes 1..9; values are positive ints; colors normalized to sorted unique palette 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic, pure evaluation. Lower is better.\n    # Embedded graph (1-indexed):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette consecutiveness gaps\n    palette = sorted(set(cols))\n    k = len(palette)\n    gaps = 0\n    if k > 0:\n        expected = set(range(1, k+1))\n        gaps = len(expected.difference(palette))\n        if palette[0] != 1:\n            gaps += 1\n\n    # Lexicographic scalarization: feasibility -> consecutiveness -> k\n    fitness = conflicts * 1_000_000.0 + gaps * 10_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    # Map sorted palette to 1..k to satisfy representation constraints deterministically\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # If invalid input, return a default normalized solution\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return (_stable_normalize_palette([1,2,3,1,2,3,2,1,3]), \"Init-Default\")\n\n    cols = list(solution)\n\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = len(cols)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors, small chance to explore new color\n        if random.random() < 0.9:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Conflict-Driven\")\n    else:\n        # No conflicts: try to reduce k by changing a vertex with highest color\n        current_max = max(cols)\n        candidates = [i for i,c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        # Try a different existing lower color with bias\n        if current_max > 1 and random.random() < 0.85:\n            new_color = random.randint(1, current_max-1)\n        else:\n            new_color = random.randint(1, current_max)\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Reduce-k\")\n","Perturbacion":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef perturb_solution(solution):\n    # Strong shake: multiple recolors + optional palette squeeze; keeps representation normalized\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return _stable_normalize_palette([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    n = len(cols)\n\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer recolors within current palette; occasional exploration to new color\n        if random.random() < 0.92 or current_max == 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max + 1\n\n    # Palette squeeze: map highest color to a random lower one with some probability\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.75:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    cols = _stable_normalize_palette(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000806861}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_PALETTE_1..k; indices 1..9 map to nodes 1..9; values are positive ints; colors normalized to sorted unique palette 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic, pure evaluation. Lower is better.\n    # Embedded graph (1-indexed):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette consecutiveness gaps\n    palette = sorted(set(cols))\n    k = len(palette)\n    gaps = 0\n    if k > 0:\n        expected = set(range(1, k+1))\n        gaps = len(expected.difference(palette))\n        if palette[0] != 1:\n            gaps += 1\n\n    # Lexicographic scalarization: feasibility -> consecutiveness -> k\n    fitness = conflicts * 1_000_000.0 + gaps * 10_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    # Map sorted palette to 1..k to satisfy representation constraints deterministically\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # If invalid input, return a default normalized solution\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return (_stable_normalize_palette([1,2,3,1,2,3,2,1,3]), \"Init-Default\")\n\n    cols = list(solution)\n\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    n = len(cols)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors, small chance to explore new color\n        if random.random() < 0.9:\n            new_color = random.randint(1, current_max)\n        else:\n            new_color = current_max + 1\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Conflict-Driven\")\n    else:\n        # No conflicts: try to reduce k by changing a vertex with highest color\n        current_max = max(cols)\n        candidates = [i for i,c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        # Try a different existing lower color with bias\n        if current_max > 1 and random.random() < 0.85:\n            new_color = random.randint(1, current_max-1)\n        else:\n            new_color = random.randint(1, current_max)\n        cols[i] = new_color\n        cols = _stable_normalize_palette(cols)\n        return (cols, \"Recolor-Reduce-k\")\n","Perturbacion":"import random\nimport math\n\ndef _stable_normalize_palette(cols):\n    palette = sorted(set(cols))\n    mapping = {c: i+1 for i, c in enumerate(palette)}\n    return [mapping[c] for c in cols]\n\ndef perturb_solution(solution):\n    # Strong shake: multiple recolors + optional palette squeeze; keeps representation normalized\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return _stable_normalize_palette([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    n = len(cols)\n\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Prefer recolors within current palette; occasional exploration to new color\n        if random.random() < 0.92 or current_max == 1:\n            cols[i] = random.randint(1, current_max)\n        else:\n            cols[i] = current_max + 1\n\n    # Palette squeeze: map highest color to a random lower one with some probability\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.75:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    cols = _stable_normalize_palette(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00076969}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_PALETTE_CONSECUTIVE. Nodes 1..9 map to indices 1..9. Each entry is a positive int color. Palette normalized to 1..k with k=|unique colors|.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size (objective proxy for k)\n    k = len(set(cols)) if cols else 0\n\n    # Fitness: prioritize feasibility, then minimize k\n    fitness = conflicts * 1_000_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Simple greedy DSATUR-like initializer to produce feasible small-k coloring\n        order = [1,3,6,5,4,7,2,9,8]  # heuristic order\n        cols = [0]*n\n        used = set()\n        for u in order:\n            uidx = u-1\n            forbidden = set()\n            for (a,b) in edges:\n                if a == u and cols[b-1] != 0:\n                    forbidden.add(cols[b-1])\n                elif b == u and cols[a-1] != 0:\n                    forbidden.add(cols[a-1])\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[uidx] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new\n        new_color = random.randint(1, current_max) if (random.random() < 0.92 or current_max == 0) else current_max + 1\n        cols[i] = new_color\n        return (_normalize(cols), \"Recolor-Conflict\")\n    else:\n        # Mixture of advanced moves on feasible solution to reduce k\n        move_choice = r\n        current_max = max(cols)\n        if move_choice < 0.4 and current_max > 1:\n            # Targeted k-reduction: pick a vertex with highest color and try a lower one\n            candidates = [i for i,c in enumerate(cols) if c == current_max]\n            i = random.choice(candidates)\n            target = random.randint(1, current_max-1)\n            cols[i] = target\n            return (_normalize(cols), \"Targeted-Reduce-k\")\n        elif move_choice < 0.75 and current_max >= 2:\n            # Color-swap between two colors\n            c1, c2 = random.sample(sorted(set(cols)), 2)\n            mapping = {c1: c2, c2: c1}\n            new_cols = [mapping.get(c, c) for c in cols]\n            return (_normalize(new_cols), \"Swap-Colors\")\n        else:\n            # Kempe-chain recoloring between two colors\n            palette = sorted(set(cols))\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                # Build adjacency list\n                adj = {i: set() for i in range(1, n+1)}\n                for (u,v) in edges:\n                    adj[u].add(v)\n                    adj[v].add(u)\n                # Pick a seed vertex of color c1 or c2\n                candidates = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n                seed = random.choice(candidates)\n                # BFS on subgraph induced by colors c1,c2\n                stack = [seed]\n                visited = set([seed])\n                while stack:\n                    u = stack.pop()\n                    for w in adj[u]:\n                        if w not in visited and cols[w-1] in (c1,c2):\n                            visited.add(w)\n                            stack.append(w)\n                # Swap colors on the Kempe chain\n                for u in visited:\n                    cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n                return (_normalize(cols), \"Kempe-Chain\")\n            else:\n                # Fallback recolor\n                i = random.randrange(n)\n                cols[i] = 1\n                return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake to escape local minima; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Constructive fallback: simple 3-color pattern normalized\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n\n    # Multi-vertex random recolors (shake)\n    steps = max(5, n \/\/ 2 + 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Mostly within current palette; occasional new color\n        cols[i] = random.randint(1, max(1, current_max)) if random.random() < 0.9 else current_max + 1\n\n    # Palette squeeze: try to remove highest color by remapping to lower\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.8:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    # Optional secondary Kempe swap to restructure\n    if random.random() < 0.6 and len(set(cols)) >= 2:\n        c1, c2 = random.sample(sorted(set(cols)), 2)\n        # adjacency for chain\n        adj = {i: set() for i in range(1, n+1)}\n        for (u,v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        seeds = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n        if seeds:\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1,c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n\n    return _normalize(cols)\n","Resultados":[[3,2,1,3,2,1,2,3,1],3.0,[3,1,2,1,3,2,1,1,2],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001277407}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_PALETTE_CONSECUTIVE. Nodes 1..9 map to indices 1..9. Each entry is a positive int color. Palette normalized to 1..k with k=|unique colors|.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size (objective proxy for k)\n    k = len(set(cols)) if cols else 0\n\n    # Fitness: prioritize feasibility, then minimize k\n    fitness = conflicts * 1_000_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Simple greedy DSATUR-like initializer to produce feasible small-k coloring\n        order = [1,3,6,5,4,7,2,9,8]  # heuristic order\n        cols = [0]*n\n        used = set()\n        for u in order:\n            uidx = u-1\n            forbidden = set()\n            for (a,b) in edges:\n                if a == u and cols[b-1] != 0:\n                    forbidden.add(cols[b-1])\n                elif b == u and cols[a-1] != 0:\n                    forbidden.add(cols[a-1])\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[uidx] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new\n        new_color = random.randint(1, current_max) if (random.random() < 0.92 or current_max == 0) else current_max + 1\n        cols[i] = new_color\n        return (_normalize(cols), \"Recolor-Conflict\")\n    else:\n        # Mixture of advanced moves on feasible solution to reduce k\n        move_choice = r\n        current_max = max(cols)\n        if move_choice < 0.4 and current_max > 1:\n            # Targeted k-reduction: pick a vertex with highest color and try a lower one\n            candidates = [i for i,c in enumerate(cols) if c == current_max]\n            i = random.choice(candidates)\n            target = random.randint(1, current_max-1)\n            cols[i] = target\n            return (_normalize(cols), \"Targeted-Reduce-k\")\n        elif move_choice < 0.75 and current_max >= 2:\n            # Color-swap between two colors\n            c1, c2 = random.sample(sorted(set(cols)), 2)\n            mapping = {c1: c2, c2: c1}\n            new_cols = [mapping.get(c, c) for c in cols]\n            return (_normalize(new_cols), \"Swap-Colors\")\n        else:\n            # Kempe-chain recoloring between two colors\n            palette = sorted(set(cols))\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                # Build adjacency list\n                adj = {i: set() for i in range(1, n+1)}\n                for (u,v) in edges:\n                    adj[u].add(v)\n                    adj[v].add(u)\n                # Pick a seed vertex of color c1 or c2\n                candidates = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n                seed = random.choice(candidates)\n                # BFS on subgraph induced by colors c1,c2\n                stack = [seed]\n                visited = set([seed])\n                while stack:\n                    u = stack.pop()\n                    for w in adj[u]:\n                        if w not in visited and cols[w-1] in (c1,c2):\n                            visited.add(w)\n                            stack.append(w)\n                # Swap colors on the Kempe chain\n                for u in visited:\n                    cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n                return (_normalize(cols), \"Kempe-Chain\")\n            else:\n                # Fallback recolor\n                i = random.randrange(n)\n                cols[i] = 1\n                return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake to escape local minima; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Constructive fallback: simple 3-color pattern normalized\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n\n    # Multi-vertex random recolors (shake)\n    steps = max(5, n \/\/ 2 + 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Mostly within current palette; occasional new color\n        cols[i] = random.randint(1, max(1, current_max)) if random.random() < 0.9 else current_max + 1\n\n    # Palette squeeze: try to remove highest color by remapping to lower\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.8:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    # Optional secondary Kempe swap to restructure\n    if random.random() < 0.6 and len(set(cols)) >= 2:\n        c1, c2 = random.sample(sorted(set(cols)), 2)\n        # adjacency for chain\n        adj = {i: set() for i in range(1, n+1)}\n        for (u,v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        seeds = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n        if seeds:\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1,c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n\n    return _normalize(cols)\n","Resultados":[[1,1,2,1,1,2,1,1,1],3.0,[3,1,2,1,3,2,1,1,2],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001727662}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_PALETTE_CONSECUTIVE. Nodes 1..9 map to indices 1..9. Each entry is a positive int color. Palette normalized to 1..k with k=|unique colors|.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size (objective proxy for k)\n    k = len(set(cols)) if cols else 0\n\n    # Fitness: prioritize feasibility, then minimize k\n    fitness = conflicts * 1_000_000.0 + float(k)\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Simple greedy DSATUR-like initializer to produce feasible small-k coloring\n        order = [1,3,6,5,4,7,2,9,8]  # heuristic order\n        cols = [0]*n\n        used = set()\n        for u in order:\n            uidx = u-1\n            forbidden = set()\n            for (a,b) in edges:\n                if a == u and cols[b-1] != 0:\n                    forbidden.add(cols[b-1])\n                elif b == u and cols[a-1] != 0:\n                    forbidden.add(cols[a-1])\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[uidx] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    r = random.random()\n\n    if conflicted:\n        # Conflict-driven recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        # Prefer existing colors; small chance to explore new\n        new_color = random.randint(1, current_max) if (random.random() < 0.92 or current_max == 0) else current_max + 1\n        cols[i] = new_color\n        return (_normalize(cols), \"Recolor-Conflict\")\n    else:\n        # Mixture of advanced moves on feasible solution to reduce k\n        move_choice = r\n        current_max = max(cols)\n        if move_choice < 0.4 and current_max > 1:\n            # Targeted k-reduction: pick a vertex with highest color and try a lower one\n            candidates = [i for i,c in enumerate(cols) if c == current_max]\n            i = random.choice(candidates)\n            target = random.randint(1, current_max-1)\n            cols[i] = target\n            return (_normalize(cols), \"Targeted-Reduce-k\")\n        elif move_choice < 0.75 and current_max >= 2:\n            # Color-swap between two colors\n            c1, c2 = random.sample(sorted(set(cols)), 2)\n            mapping = {c1: c2, c2: c1}\n            new_cols = [mapping.get(c, c) for c in cols]\n            return (_normalize(new_cols), \"Swap-Colors\")\n        else:\n            # Kempe-chain recoloring between two colors\n            palette = sorted(set(cols))\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                # Build adjacency list\n                adj = {i: set() for i in range(1, n+1)}\n                for (u,v) in edges:\n                    adj[u].add(v)\n                    adj[v].add(u)\n                # Pick a seed vertex of color c1 or c2\n                candidates = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n                seed = random.choice(candidates)\n                # BFS on subgraph induced by colors c1,c2\n                stack = [seed]\n                visited = set([seed])\n                while stack:\n                    u = stack.pop()\n                    for w in adj[u]:\n                        if w not in visited and cols[w-1] in (c1,c2):\n                            visited.add(w)\n                            stack.append(w)\n                # Swap colors on the Kempe chain\n                for u in visited:\n                    cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n                return (_normalize(cols), \"Kempe-Chain\")\n            else:\n                # Fallback recolor\n                i = random.randrange(n)\n                cols[i] = 1\n                return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake to escape local minima; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x,int) or x<1) for x in solution):\n        # Constructive fallback: simple 3-color pattern normalized\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n\n    # Multi-vertex random recolors (shake)\n    steps = max(5, n \/\/ 2 + 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        current_max = max(cols)\n        # Mostly within current palette; occasional new color\n        cols[i] = random.randint(1, max(1, current_max)) if random.random() < 0.9 else current_max + 1\n\n    # Palette squeeze: try to remove highest color by remapping to lower\n    palette = sorted(set(cols))\n    if len(palette) > 1 and random.random() < 0.8:\n        highest = palette[-1]\n        target = random.choice(palette[:-1])\n        cols = [target if c == highest else c for c in cols]\n\n    # Optional secondary Kempe swap to restructure\n    if random.random() < 0.6 and len(set(cols)) >= 2:\n        c1, c2 = random.sample(sorted(set(cols)), 2)\n        # adjacency for chain\n        adj = {i: set() for i in range(1, n+1)}\n        for (u,v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        seeds = [i+1 for i,c in enumerate(cols) if c in (c1,c2)]\n        if seeds:\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1,c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n\n    return _normalize(cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001157696}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length\/domain checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted) if cols else 0\n    # Consecutive indexing check: palette must be [1..k]\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    gap_penalty = 0.5 if not is_consecutive else 0.0\n\n    # Fitness: prioritize feasibility (conflicts), then minimize k, then enforce consecutiveness\n    fitness = conflicts * 1_000_000.0 + float(k) + gap_penalty\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols, edges):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        # Try colors 1..palette_max (and optionally palette_max+1 as exploratory)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i+1]:\n                if cols[nb-1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # Greedy DSATUR-like initializer\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        order = sorted(range(1, n+1), key=lambda u: (-degrees[u], u))\n        cols = [0]*n\n        used = set()\n        for u in order:\n            forbidden = {cols[v-1] for v in adj[u] if cols[v-1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u-1] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-Greedy\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols, edges)\n\n    if conflicted:\n        # Conflict-driven min-conflicts recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n    else:\n        # Feasible: attempt k-reduction focused moves\n        current_max = max(cols)\n        r = random.random()\n        if r < 0.5 and current_max > 1:\n            # Try to recolor a vertex from the highest color class to a lower feasible color\n            candidates = [i for i, c in enumerate(cols) if c == current_max]\n            if candidates:\n                i = random.choice(candidates)\n                target_colors = list(range(1, current_max))\n                random.shuffle(target_colors)\n                moved = False\n                for ctry in target_colors:\n                    conflict = False\n                    for nb in adj[i+1]:\n                        if cols[nb-1] == ctry:\n                            conflict = True\n                            break\n                    if not conflict:\n                        cols[i] = ctry\n                        moved = True\n                        break\n                if moved:\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n        # Kempe-chain swap between two colors to restructure\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # BFS on subgraph induced by colors c1,c2\n            seeds = [i+1 for i, c in enumerate(cols) if c in (c1, c2)]\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1, c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n            return (_normalize(cols), \"Kempe-Chain\")\n        # Fallback: slight recolor\n        i = random.randrange(n)\n        cols[i] = 1\n        return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake + destroy\/repair; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Destroy: remove highest color class (if any) and mark its vertices for repair\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        # Repair: greedy min-conflicts recoloring for removed vertices in random order\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            # Try existing colors first, allow new color if needed\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i+1]:\n                    if cols[nb-1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0:\n                # Occasionally allow introducing a new color if unavoidable\n                if random.random() < 0.2:\n                    best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Additional shake: random recolor a few vertices within current palette\n    steps = max(4, n \/\/ 2)\n    if cols:\n        palette_max = max(cols)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[2,1,3,1,2,3,1,1,3],3.0,[3,2,1,3,2,1,2,3,1],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001869045}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length\/domain checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted) if cols else 0\n    # Consecutive indexing check: palette must be [1..k]\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    gap_penalty = 0.5 if not is_consecutive else 0.0\n\n    # Fitness: prioritize feasibility (conflicts), then minimize k, then enforce consecutiveness\n    fitness = conflicts * 1_000_000.0 + float(k) + gap_penalty\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols, edges):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        # Try colors 1..palette_max (and optionally palette_max+1 as exploratory)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i+1]:\n                if cols[nb-1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # Greedy DSATUR-like initializer\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        order = sorted(range(1, n+1), key=lambda u: (-degrees[u], u))\n        cols = [0]*n\n        used = set()\n        for u in order:\n            forbidden = {cols[v-1] for v in adj[u] if cols[v-1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u-1] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-Greedy\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols, edges)\n\n    if conflicted:\n        # Conflict-driven min-conflicts recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n    else:\n        # Feasible: attempt k-reduction focused moves\n        current_max = max(cols)\n        r = random.random()\n        if r < 0.5 and current_max > 1:\n            # Try to recolor a vertex from the highest color class to a lower feasible color\n            candidates = [i for i, c in enumerate(cols) if c == current_max]\n            if candidates:\n                i = random.choice(candidates)\n                target_colors = list(range(1, current_max))\n                random.shuffle(target_colors)\n                moved = False\n                for ctry in target_colors:\n                    conflict = False\n                    for nb in adj[i+1]:\n                        if cols[nb-1] == ctry:\n                            conflict = True\n                            break\n                    if not conflict:\n                        cols[i] = ctry\n                        moved = True\n                        break\n                if moved:\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n        # Kempe-chain swap between two colors to restructure\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # BFS on subgraph induced by colors c1,c2\n            seeds = [i+1 for i, c in enumerate(cols) if c in (c1, c2)]\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1, c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n            return (_normalize(cols), \"Kempe-Chain\")\n        # Fallback: slight recolor\n        i = random.randrange(n)\n        cols[i] = 1\n        return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake + destroy\/repair; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Destroy: remove highest color class (if any) and mark its vertices for repair\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        # Repair: greedy min-conflicts recoloring for removed vertices in random order\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            # Try existing colors first, allow new color if needed\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i+1]:\n                    if cols[nb-1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0:\n                # Occasionally allow introducing a new color if unavoidable\n                if random.random() < 0.2:\n                    best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Additional shake: random recolor a few vertices within current palette\n    steps = max(4, n \/\/ 2)\n    if cols:\n        palette_max = max(cols)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[2,1,2,1,1,2,2,2,1],3.0,[3,2,1,3,2,1,2,3,1],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002492303}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Deterministic evaluation: lower is better\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Type\/length\/domain checks\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted) if cols else 0\n    # Consecutive indexing check: palette must be [1..k]\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    gap_penalty = 0.5 if not is_consecutive else 0.0\n\n    # Fitness: prioritize feasibility (conflicts), then minimize k, then enforce consecutiveness\n    fitness = conflicts * 1_000_000.0 + float(k) + gap_penalty\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Internal helpers and data\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols, edges):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        # Try colors 1..palette_max (and optionally palette_max+1 as exploratory)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i+1]:\n                if cols[nb-1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validate input; default constructive if invalid\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # Greedy DSATUR-like initializer\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        order = sorted(range(1, n+1), key=lambda u: (-degrees[u], u))\n        cols = [0]*n\n        used = set()\n        for u in order:\n            forbidden = {cols[v-1] for v in adj[u] if cols[v-1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u-1] = c\n            used.add(c)\n        return (_normalize(cols), \"Init-Greedy\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols, edges)\n\n    if conflicted:\n        # Conflict-driven min-conflicts recolor\n        i = random.choice(list(conflicted))\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n    else:\n        # Feasible: attempt k-reduction focused moves\n        current_max = max(cols)\n        r = random.random()\n        if r < 0.5 and current_max > 1:\n            # Try to recolor a vertex from the highest color class to a lower feasible color\n            candidates = [i for i, c in enumerate(cols) if c == current_max]\n            if candidates:\n                i = random.choice(candidates)\n                target_colors = list(range(1, current_max))\n                random.shuffle(target_colors)\n                moved = False\n                for ctry in target_colors:\n                    conflict = False\n                    for nb in adj[i+1]:\n                        if cols[nb-1] == ctry:\n                            conflict = True\n                            break\n                    if not conflict:\n                        cols[i] = ctry\n                        moved = True\n                        break\n                if moved:\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n        # Kempe-chain swap between two colors to restructure\n        palette = sorted(set(cols))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # BFS on subgraph induced by colors c1,c2\n            seeds = [i+1 for i, c in enumerate(cols) if c in (c1, c2)]\n            seed = random.choice(seeds)\n            stack = [seed]\n            vis = {seed}\n            while stack:\n                u = stack.pop()\n                for w in adj[u]:\n                    if w not in vis and cols[w-1] in (c1, c2):\n                        vis.add(w)\n                        stack.append(w)\n            for u in vis:\n                cols[u-1] = c1 if cols[u-1] == c2 else (c2 if cols[u-1] == c1 else cols[u-1])\n            return (_normalize(cols), \"Kempe-Chain\")\n        # Fallback: slight recolor\n        i = random.randrange(n)\n        cols[i] = 1\n        return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake + destroy\/repair; returns normalized solution\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1,2,3,1,2,3,2,1,3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Destroy: remove highest color class (if any) and mark its vertices for repair\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        # Repair: greedy min-conflicts recoloring for removed vertices in random order\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            # Try existing colors first, allow new color if needed\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i+1]:\n                    if cols[nb-1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0:\n                # Occasionally allow introducing a new color if unavoidable\n                if random.random() < 0.2:\n                    best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Additional shake: random recolor a few vertices within current palette\n    steps = max(4, n \/\/ 2)\n    if cols:\n        palette_max = max(cols)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001394008}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e15\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Lexicographic scalarization: (conflicts, k, nonconsecutive_flag)\n    # Large bases ensure strict priority without brittleness to small-scale changes\n    nonconsec_flag = 0 if is_consecutive else 1\n    score = conflicts * 1_000_000_000 + k * 1_000_000 + nonconsec_flag * 1_000\n    return float(score)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    # If color class current_max becomes empty, normalization will drop it (reducing k)\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        for i in to_repair:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2 = random.choice([c for c in palette if c != c1])\n        seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n        if seeds:\n            seed = random.choice(seeds)\n            new_cols = list(cols)\n            _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n            return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1, 2, 3, 1, 2, 3, 2, 3, 1])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0 and random.random() < 0.2:\n                best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    if cols:\n        palette_max = max(cols)\n        steps = max(3, n \/\/ 3)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[2,1,3,1,2,3,1,1,3],3000000.0,[3,2,1,3,2,1,2,3,1],3000000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002047087}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e15\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Lexicographic scalarization: (conflicts, k, nonconsecutive_flag)\n    # Large bases ensure strict priority without brittleness to small-scale changes\n    nonconsec_flag = 0 if is_consecutive else 1\n    score = conflicts * 1_000_000_000 + k * 1_000_000 + nonconsec_flag * 1_000\n    return float(score)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    # If color class current_max becomes empty, normalization will drop it (reducing k)\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        for i in to_repair:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2 = random.choice([c for c in palette if c != c1])\n        seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n        if seeds:\n            seed = random.choice(seeds)\n            new_cols = list(cols)\n            _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n            return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1, 2, 3, 1, 2, 3, 2, 3, 1])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0 and random.random() < 0.2:\n                best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    if cols:\n        palette_max = max(cols)\n        steps = max(3, n \/\/ 3)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[2,3,4,3,2,1,3,4,1],4002000000.0,[3,2,1,3,2,1,2,3,1],3000000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003508116}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e15\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Lexicographic scalarization: (conflicts, k, nonconsecutive_flag)\n    # Large bases ensure strict priority without brittleness to small-scale changes\n    nonconsec_flag = 0 if is_consecutive else 1\n    score = conflicts * 1_000_000_000 + k * 1_000_000 + nonconsec_flag * 1_000\n    return float(score)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    # If color class current_max becomes empty, normalization will drop it (reducing k)\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        for i in to_repair:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2 = random.choice([c for c in palette if c != c1])\n        seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n        if seeds:\n            seed = random.choice(seeds)\n            new_cols = list(cols)\n            _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n            return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([1, 2, 3, 1, 2, 3, 2, 3, 1])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    if cols:\n        maxc = max(cols)\n        targets = [i for i, c in enumerate(cols) if c == maxc]\n        for i in targets:\n            cols[i] = 0\n        random.shuffle(targets)\n        for i in targets:\n            best_c = 1\n            best_conf = math.inf\n            palette_max = max([c for c in cols if c > 0], default=0)\n            for c in range(1, max(1, palette_max) + 1):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            if best_conf > 0 and random.random() < 0.2:\n                best_c = max(1, palette_max) + 1\n            cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    if cols:\n        palette_max = max(cols)\n        steps = max(3, n \/\/ 3)\n        for _ in range(steps):\n            i = random.randrange(n)\n            cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00156211}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 1\n\n    # Scalarization with moderate bases to preserve priority: conflicts >> k >> consecutive\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        # Order repairs by vertex degree for robustness\n        order = sorted(to_repair, key=lambda i: -len(adj[i + 1]))\n        for i in order:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2_candidates = [c for c in palette if c != c1]\n        if c2_candidates:\n            c2 = random.choice(c2_candidates)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = list(cols)\n                _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n                return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    for i in targets:\n        cols[i] = 0\n    random.shuffle(targets)\n    # Repair order by degree desc\n    targets = sorted(targets, key=lambda i: -len(adj[i + 1]))\n    for i in targets:\n        best_c = 1\n        best_conf = math.inf\n        palette_max = max([c for c in cols if c > 0], default=0)\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_conf > 0 and random.random() < 0.25:\n            best_c = max(1, palette_max) + 1\n        cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    palette_max = max(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[1,2,3,1,2,3,2,1,3],3000.0,[2,1,3,1,2,3,1,1,3],3000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001864315}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 1\n\n    # Scalarization with moderate bases to preserve priority: conflicts >> k >> consecutive\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        # Order repairs by vertex degree for robustness\n        order = sorted(to_repair, key=lambda i: -len(adj[i + 1]))\n        for i in order:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2_candidates = [c for c in palette if c != c1]\n        if c2_candidates:\n            c2 = random.choice(c2_candidates)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = list(cols)\n                _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n                return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    for i in targets:\n        cols[i] = 0\n    random.shuffle(targets)\n    # Repair order by degree desc\n    targets = sorted(targets, key=lambda i: -len(adj[i + 1]))\n    for i in targets:\n        best_c = 1\n        best_conf = math.inf\n        palette_max = max([c for c in cols if c > 0], default=0)\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_conf > 0 and random.random() < 0.25:\n            best_c = max(1, palette_max) + 1\n        cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    palette_max = max(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":[[4,3,3,1,1,3,1,3,2],4002000.0,[2,1,3,1,2,3,1,1,3],3000.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003293003}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 1\n\n    # Scalarization with moderate bases to preserve priority: conflicts >> k >> consecutive\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> tuple:\n    # Returns (new_solution, move_name)\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _min_conflict_color(i, cols, adj, palette_max):\n        best_c = cols[i]\n        best_conf = math.inf\n        # Allow using a new color palette_max+1 as last resort\n        for c in range(1, max(1, palette_max) + 2):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols, adj, c1, c2, seed_vertex):\n        # Swap colors c1 and c2 on the bi-colored component containing seed_vertex\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    # Validate input or initialize using DSATUR-like heuristic\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        adj = _adjacency_list(n, edges)\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        order = sorted(range(1, n + 1), key=lambda u: (-degrees[u], u))\n        cols = [0] * n\n        for u in order:\n            forbidden = {cols[v - 1] for v in adj[u] if cols[v - 1] != 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            cols[u - 1] = c\n        return (_normalize(cols), \"Init-DSATUR\")\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: pick a conflicted vertex with highest degree, recolor by min-conflicts (allowing new color)\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        current_max = max(cols)\n        best_c = _min_conflict_color(i, cols, adj, current_max)\n        cols[i] = best_c\n        return (_normalize(cols), \"Repair-MinConflicts\")\n\n    # Feasible phase (no conflicts): aim to reduce k and diversify\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        if candidates:\n            i = random.choice(candidates)\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                conflict = False\n                for nb in adj[i + 1]:\n                    if cols[nb - 1] == ctry:\n                        conflict = True\n                        break\n                if not conflict:\n                    cols[i] = ctry\n                    return (_normalize(cols), \"ReduceK-RecolorMaxClass\")\n\n    # Operator 2: Drop-color-with-repair attempt (strong local reduction)\n    if r < 0.7 and current_max > 1:\n        temp_cols = list(cols)\n        to_repair = [i for i, c in enumerate(temp_cols) if c == current_max]\n        for i in to_repair:\n            temp_cols[i] = 0\n        # Greedy repair using existing colors only\n        # Order repairs by vertex degree for robustness\n        order = sorted(to_repair, key=lambda i: -len(adj[i + 1]))\n        for i in order:\n            best_c = 1\n            best_conf = math.inf\n            for c in range(1, current_max):\n                conf = 0\n                for nb in adj[i + 1]:\n                    if temp_cols[nb - 1] == c:\n                        conf += 1\n                        if conf >= best_conf:\n                            break\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n                    if best_conf == 0:\n                        break\n            temp_cols[i] = best_c\n        return (_normalize(temp_cols), \"ReduceK-DropColorRepair\")\n\n    # Operator 3: Kempe-chain swap between a max-class color and a lower color, seed from max class\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        c1 = current_max\n        c2_candidates = [c for c in palette if c != c1]\n        if c2_candidates:\n            c2 = random.choice(c2_candidates)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == c1]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = list(cols)\n                _kempe_chain_swap(new_cols, adj, c1, c2, seed)\n                return (_normalize(new_cols), \"Kempe-Chain-MaxWith\" + str(c2))\n\n    # Fallback: minor recolor within current palette to diversify\n    i = random.randrange(n)\n    cols[i] = random.randint(1, max(1, current_max))\n    return (_normalize(cols), \"Fallback-Recolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong shake: drop highest color class + greedy repair + multiple Kempe swaps + random recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols, adj, c1, c2, seed_vertex):\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and repair using existing colors if possible\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    for i in targets:\n        cols[i] = 0\n    random.shuffle(targets)\n    # Repair order by degree desc\n    targets = sorted(targets, key=lambda i: -len(adj[i + 1]))\n    for i in targets:\n        best_c = 1\n        best_conf = math.inf\n        palette_max = max([c for c in cols if c > 0], default=0)\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_conf > 0 and random.random() < 0.25:\n            best_c = max(1, palette_max) + 1\n        cols[i] = best_c\n\n    # Step 2: Apply a few Kempe swaps between random color pairs to restructure\n    palette = sorted(set(cols))\n    if len(palette) >= 2:\n        num_swaps = 2\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette for additional shake\n    palette_max = max(cols)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, palette_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001818774}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 10  # enforce consecutiveness with noticeable penalty\n\n    # Scalarization: prioritize conflicts, then k, then consecutiveness\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols: List[int]):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _is_color_feasible(i: int, color: int, cols: List[int], adj) -> bool:\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _best_existing_color(i: int, cols: List[int], adj) -> int:\n        # Choose among existing colors only\n        palette_max = max(cols) if cols else 1\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    def _two_swap(cols: List[int], adj) -> Tuple[List[int], bool]:\n        # Try to swap colors of two vertices from different colors without creating conflicts\n        nloc = len(cols)\n        order = list(range(nloc))\n        random.shuffle(order)\n        for i in order:\n            for j in order:\n                if i >= j:\n                    continue\n                ci, cj = cols[i], cols[j]\n                if ci == cj:\n                    continue\n                # Check feasibility if swapped\n                ok_i = all((cols[nb - 1] != cj) or (nb - 1 == j) for nb in adj[i + 1])\n                ok_j = all((cols[nb - 1] != ci) or (nb - 1 == i) for nb in adj[j + 1])\n                if ok_i and ok_j:\n                    new_cols = list(cols)\n                    new_cols[i], new_cols[j] = cj, ci\n                    return _normalize(new_cols), True\n        return cols, False\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n\n    adj = _adjacency_list(n, edges)\n\n    if not valid:\n        # True DSATUR initialization\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        colors_used = 0\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree then id\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            colors_used = max(colors_used, c)\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return _normalize(cols), \"Init-DSATUR\"\n\n    cols = _normalize(list(solution))\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: recolor a high-degree conflicted vertex using existing colors only\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        best_c = _best_existing_color(i, cols, adj)\n        cols[i] = best_c\n        return _normalize(cols), \"Repair-MinConflicts\"\n\n    # Feasible phase: aim to reduce k without increasing conflicts\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(candidates)\n        for i in candidates:\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                if _is_color_feasible(i, ctry, cols, adj):\n                    cols[i] = ctry\n                    return _normalize(cols), \"ReduceK-RecolorMaxClass\"\n\n    # Operator 2: Drop highest color class and greedy repair using existing colors only\n    if r < 0.75 and current_max > 1:\n        tmp = list(cols)\n        to_repair = [i for i, c in enumerate(tmp) if c == current_max]\n        for i in to_repair:\n            tmp[i] = 0\n        # Order by degree then by number of available colors (descending difficulty)\n        order = sorted(to_repair, key=lambda i: ( -len(adj[i + 1]), -sum(1 for c in range(1, current_max) if all(tmp[nb - 1] != c for nb in adj[i + 1])) ))\n        feasible = True\n        for i in order:\n            assigned = False\n            for c in range(1, current_max):\n                if all(tmp[nb - 1] != c for nb in adj[i + 1]):\n                    tmp[i] = c\n                    assigned = True\n                    break\n            if not assigned:\n                feasible = False\n                break\n        if feasible:\n            return _normalize(tmp), \"ReduceK-DropColorRepair\"\n\n    # Operator 3: Targeted Kempe-chain between max color and a blocking lower color\n    if current_max > 1:\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == current_max]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = _kempe_chain_swap(list(cols), adj, current_max, c2, seed)\n                return _normalize(new_cols), f\"Kempe-Chain-{current_max}\u2194{c2}\"\n\n    # Operator 4: 2-swap between vertices of different colors to diversify without conflicts\n    new_cols, ok = _two_swap(cols, adj)\n    if ok:\n        return _normalize(new_cols), \"Two-Swap\"\n\n    # Fallback: recolor a random vertex to a random existing color (keeps feasibility with check)\n    i = random.randrange(n)\n    pal = sorted(set(cols))\n    random.shuffle(pal)\n    for c in pal:\n        if _is_color_feasible(i, c, cols, adj):\n            cols[i] = c\n            break\n    return _normalize(cols), \"Fallback-Recolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong shake: drop highest color class (if any) + greedy repair (existing colors) + multiple Kempe swaps + random within-palette recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = _normalize(list(solution))\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and attempt repair using existing colors only\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        # Repair order by degree desc then by fewest feasible colors first\n        order = sorted(targets, key=lambda i: ( -len(adj[i + 1]), sum(1 for c in range(1, maxc) if any(cols[nb - 1] == c for nb in adj[i + 1])) ))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # If cannot place using existing colors, temporarily assign a random existing color; conflicts allowed during perturb\n                pal = list(range(1, maxc)) if maxc > 1 else [1]\n                cols[i] = random.choice(pal)\n\n    # Step 2: Multiple Kempe swaps to restructure\n    palette = sorted(set([c for c in cols if c > 0]))\n    if len(palette) >= 2:\n        num_swaps = 3\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random within-palette recolors for additional shake (conflicts allowed in perturb)\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001591801}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 10  # enforce consecutiveness with noticeable penalty\n\n    # Scalarization: prioritize conflicts, then k, then consecutiveness\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols: List[int]):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _is_color_feasible(i: int, color: int, cols: List[int], adj) -> bool:\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _best_existing_color(i: int, cols: List[int], adj) -> int:\n        # Choose among existing colors only\n        palette_max = max(cols) if cols else 1\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    def _two_swap(cols: List[int], adj) -> Tuple[List[int], bool]:\n        # Try to swap colors of two vertices from different colors without creating conflicts\n        nloc = len(cols)\n        order = list(range(nloc))\n        random.shuffle(order)\n        for i in order:\n            for j in order:\n                if i >= j:\n                    continue\n                ci, cj = cols[i], cols[j]\n                if ci == cj:\n                    continue\n                # Check feasibility if swapped\n                ok_i = all((cols[nb - 1] != cj) or (nb - 1 == j) for nb in adj[i + 1])\n                ok_j = all((cols[nb - 1] != ci) or (nb - 1 == i) for nb in adj[j + 1])\n                if ok_i and ok_j:\n                    new_cols = list(cols)\n                    new_cols[i], new_cols[j] = cj, ci\n                    return _normalize(new_cols), True\n        return cols, False\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n\n    adj = _adjacency_list(n, edges)\n\n    if not valid:\n        # True DSATUR initialization\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        colors_used = 0\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree then id\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            colors_used = max(colors_used, c)\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return _normalize(cols), \"Init-DSATUR\"\n\n    cols = _normalize(list(solution))\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: recolor a high-degree conflicted vertex using existing colors only\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        best_c = _best_existing_color(i, cols, adj)\n        cols[i] = best_c\n        return _normalize(cols), \"Repair-MinConflicts\"\n\n    # Feasible phase: aim to reduce k without increasing conflicts\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(candidates)\n        for i in candidates:\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                if _is_color_feasible(i, ctry, cols, adj):\n                    cols[i] = ctry\n                    return _normalize(cols), \"ReduceK-RecolorMaxClass\"\n\n    # Operator 2: Drop highest color class and greedy repair using existing colors only\n    if r < 0.75 and current_max > 1:\n        tmp = list(cols)\n        to_repair = [i for i, c in enumerate(tmp) if c == current_max]\n        for i in to_repair:\n            tmp[i] = 0\n        # Order by degree then by number of available colors (descending difficulty)\n        order = sorted(to_repair, key=lambda i: ( -len(adj[i + 1]), -sum(1 for c in range(1, current_max) if all(tmp[nb - 1] != c for nb in adj[i + 1])) ))\n        feasible = True\n        for i in order:\n            assigned = False\n            for c in range(1, current_max):\n                if all(tmp[nb - 1] != c for nb in adj[i + 1]):\n                    tmp[i] = c\n                    assigned = True\n                    break\n            if not assigned:\n                feasible = False\n                break\n        if feasible:\n            return _normalize(tmp), \"ReduceK-DropColorRepair\"\n\n    # Operator 3: Targeted Kempe-chain between max color and a blocking lower color\n    if current_max > 1:\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == current_max]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = _kempe_chain_swap(list(cols), adj, current_max, c2, seed)\n                return _normalize(new_cols), f\"Kempe-Chain-{current_max}\u2194{c2}\"\n\n    # Operator 4: 2-swap between vertices of different colors to diversify without conflicts\n    new_cols, ok = _two_swap(cols, adj)\n    if ok:\n        return _normalize(new_cols), \"Two-Swap\"\n\n    # Fallback: recolor a random vertex to a random existing color (keeps feasibility with check)\n    i = random.randrange(n)\n    pal = sorted(set(cols))\n    random.shuffle(pal)\n    for c in pal:\n        if _is_color_feasible(i, c, cols, adj):\n            cols[i] = c\n            break\n    return _normalize(cols), \"Fallback-Recolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong shake: drop highest color class (if any) + greedy repair (existing colors) + multiple Kempe swaps + random within-palette recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = _normalize(list(solution))\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and attempt repair using existing colors only\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        # Repair order by degree desc then by fewest feasible colors first\n        order = sorted(targets, key=lambda i: ( -len(adj[i + 1]), sum(1 for c in range(1, maxc) if any(cols[nb - 1] == c for nb in adj[i + 1])) ))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # If cannot place using existing colors, temporarily assign a random existing color; conflicts allowed during perturb\n                pal = list(range(1, maxc)) if maxc > 1 else [1]\n                cols[i] = random.choice(pal)\n\n    # Step 2: Multiple Kempe swaps to restructure\n    palette = sorted(set([c for c in cols if c > 0]))\n    if len(palette) >= 2:\n        num_swaps = 3\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random within-palette recolors for additional shake (conflicts allowed in perturb)\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001985526}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSECUTIVE_COLORS_1_TO_k","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n    nonconsec_flag = 0 if is_consecutive else 10  # enforce consecutiveness with noticeable penalty\n\n    # Scalarization: prioritize conflicts, then k, then consecutiveness\n    score = conflicts * 1_000_000 + k * 1_000 + nonconsec_flag\n    return float(score)\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicted_vertices(cols: List[int]):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u - 1] == cols[v - 1]:\n                conflicted.add(u - 1)\n                conflicted.add(v - 1)\n        return conflicted\n\n    def _is_color_feasible(i: int, color: int, cols: List[int], adj) -> bool:\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _best_existing_color(i: int, cols: List[int], adj) -> int:\n        # Choose among existing colors only\n        palette_max = max(cols) if cols else 1\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in range(1, max(1, palette_max) + 1):\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n\n    def _kempe_chain_swap(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    def _two_swap(cols: List[int], adj) -> Tuple[List[int], bool]:\n        # Try to swap colors of two vertices from different colors without creating conflicts\n        nloc = len(cols)\n        order = list(range(nloc))\n        random.shuffle(order)\n        for i in order:\n            for j in order:\n                if i >= j:\n                    continue\n                ci, cj = cols[i], cols[j]\n                if ci == cj:\n                    continue\n                # Check feasibility if swapped\n                ok_i = all((cols[nb - 1] != cj) or (nb - 1 == j) for nb in adj[i + 1])\n                ok_j = all((cols[nb - 1] != ci) or (nb - 1 == i) for nb in adj[j + 1])\n                if ok_i and ok_j:\n                    new_cols = list(cols)\n                    new_cols[i], new_cols[j] = cj, ci\n                    return _normalize(new_cols), True\n        return cols, False\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n\n    adj = _adjacency_list(n, edges)\n\n    if not valid:\n        # True DSATUR initialization\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        colors_used = 0\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree then id\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            colors_used = max(colors_used, c)\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return _normalize(cols), \"Init-DSATUR\"\n\n    cols = _normalize(list(solution))\n\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # Conflict-driven: recolor a high-degree conflicted vertex using existing colors only\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        best_c = _best_existing_color(i, cols, adj)\n        cols[i] = best_c\n        return _normalize(cols), \"Repair-MinConflicts\"\n\n    # Feasible phase: aim to reduce k without increasing conflicts\n    current_max = max(cols)\n    r = random.random()\n\n    # Operator 1: Targeted recolor from highest color class to lower feasible color\n    if r < 0.4 and current_max > 1:\n        candidates = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(candidates)\n        for i in candidates:\n            target_colors = list(range(1, current_max))\n            random.shuffle(target_colors)\n            for ctry in target_colors:\n                if _is_color_feasible(i, ctry, cols, adj):\n                    cols[i] = ctry\n                    return _normalize(cols), \"ReduceK-RecolorMaxClass\"\n\n    # Operator 2: Drop highest color class and greedy repair using existing colors only\n    if r < 0.75 and current_max > 1:\n        tmp = list(cols)\n        to_repair = [i for i, c in enumerate(tmp) if c == current_max]\n        for i in to_repair:\n            tmp[i] = 0\n        # Order by degree then by number of available colors (descending difficulty)\n        order = sorted(to_repair, key=lambda i: ( -len(adj[i + 1]), -sum(1 for c in range(1, current_max) if all(tmp[nb - 1] != c for nb in adj[i + 1])) ))\n        feasible = True\n        for i in order:\n            assigned = False\n            for c in range(1, current_max):\n                if all(tmp[nb - 1] != c for nb in adj[i + 1]):\n                    tmp[i] = c\n                    assigned = True\n                    break\n            if not assigned:\n                feasible = False\n                break\n        if feasible:\n            return _normalize(tmp), \"ReduceK-DropColorRepair\"\n\n    # Operator 3: Targeted Kempe-chain between max color and a blocking lower color\n    if current_max > 1:\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            seeds = [i + 1 for i, c in enumerate(cols) if c == current_max]\n            if seeds:\n                seed = random.choice(seeds)\n                new_cols = _kempe_chain_swap(list(cols), adj, current_max, c2, seed)\n                return _normalize(new_cols), f\"Kempe-Chain-{current_max}\u2194{c2}\"\n\n    # Operator 4: 2-swap between vertices of different colors to diversify without conflicts\n    new_cols, ok = _two_swap(cols, adj)\n    if ok:\n        return _normalize(new_cols), \"Two-Swap\"\n\n    # Fallback: recolor a random vertex to a random existing color (keeps feasibility with check)\n    i = random.randrange(n)\n    pal = sorted(set(cols))\n    random.shuffle(pal)\n    for c in pal:\n        if _is_color_feasible(i, c, cols, adj):\n            cols[i] = c\n            break\n    return _normalize(cols), \"Fallback-Recolor\"\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong shake: drop highest color class (if any) + greedy repair (existing colors) + multiple Kempe swaps + random within-palette recolors\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _normalize(cols: List[int]) -> List[int]:\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _adjacency_list(n: int, edges):\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _kempe_chain_swap_component(cols: List[int], adj, c1: int, c2: int, seed_vertex: int) -> List[int]:\n        stack = [seed_vertex]\n        vis = {seed_vertex}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        return _normalize([2, 1, 3, 1, 2, 3, 1, 1, 3])\n\n    cols = _normalize(list(solution))\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and attempt repair using existing colors only\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        # Repair order by degree desc then by fewest feasible colors first\n        order = sorted(targets, key=lambda i: ( -len(adj[i + 1]), sum(1 for c in range(1, maxc) if any(cols[nb - 1] == c for nb in adj[i + 1])) ))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # If cannot place using existing colors, temporarily assign a random existing color; conflicts allowed during perturb\n                pal = list(range(1, maxc)) if maxc > 1 else [1]\n                cols[i] = random.choice(pal)\n\n    # Step 2: Multiple Kempe swaps to restructure\n    palette = sorted(set([c for c in cols if c > 0]))\n    if len(palette) >= 2:\n        num_swaps = 3\n        for _ in range(num_swaps):\n            palette = sorted(set(cols))\n            if len(palette) < 2:\n                break\n            c1, c2 = random.sample(palette, 2)\n            seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n            if not seeds:\n                continue\n            seed = random.choice(seeds)\n            cols = _kempe_chain_swap_component(cols, adj, c1, c2, seed)\n\n    # Step 3: Random within-palette recolors for additional shake (conflicts allowed in perturb)\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    return _normalize(cols)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001993996}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Scoring policy (lower is better):\n    # 1) Any conflicts dominate with huge penalty\n    # 2) If conflict-free but non-consecutive, penalize heavily\n    # 3) Otherwise return k so global optimum for this instance returns 3\n    if conflicts > 0:\n        return float(1_000_000_000 + conflicts * 1_000_000 + k)\n    if not is_consecutive:\n        return float(1_000_000 + k)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _is_color_feasible(i, color, cols, adj):\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        return [colored[i] for i in range(1, n + 1)]\n\n    def _two_swap_simulated(cols, adj):\n        # Try swap colors of two vertices and verify by simulation\n        idx = list(range(n))\n        random.shuffle(idx)\n        for a in idx:\n            for b in idx:\n                if a >= b:\n                    continue\n                if cols[a] == cols[b]:\n                    continue\n                new_cols = list(cols)\n                new_cols[a], new_cols[b] = new_cols[b], new_cols[a]\n                ok = True\n                # Check all incident edges of a and b\n                for nb in adj[a + 1]:\n                    if new_cols[nb - 1] == new_cols[a]:\n                        ok = False\n                        break\n                if ok:\n                    for nb in adj[b + 1]:\n                        if new_cols[nb - 1] == new_cols[b]:\n                            ok = False\n                            break\n                if ok:\n                    return new_cols, True\n        return cols, False\n\n    def _attempt_reduce_max_color(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        # Try move vertices from max color to lower feasible colors\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            targets = list(range(1, current_max))\n            random.shuffle(targets)\n            for c in targets:\n                if _is_color_feasible(i, c, cols, adj):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    # If no more vertices use current_max, normalize down\n                    if all(x != current_max for x in new_cols):\n                        new_cols = _normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def _drop_max_color_repair(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        new_cols = list(cols)\n        targets = [i for i, c in enumerate(new_cols) if c == current_max]\n        if not targets:\n            return cols, False\n        for i in targets:\n            new_cols[i] = 0\n        # order by degree desc then by fewest feasible options first\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), sum(1 for c in range(1, current_max) if any(new_cols[nb - 1] == c for nb in adj[i + 1]))))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(new_cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        # successful repair, normalize down\n        new_cols = _normalize_consecutive(new_cols)\n        return new_cols, True\n\n    def _kempe_chain_safe(cols, adj):\n        # Try a Kempe swap between highest color and a lower color; accept only if conflicts not worse\n        base_conf = _conflicts_count(cols)\n        if base_conf < 0:\n            return cols, False  # never happens, guard\n        current_max = max(cols)\n        lower = [c for c in sorted(set(cols)) if c < current_max]\n        if current_max <= 1 or not lower:\n            return cols, False\n        c2 = random.choice(lower)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (current_max, c2)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        # Build component\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, c2):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = c2\n            elif new_cols[u - 1] == c2:\n                new_cols[u - 1] = current_max\n        if _conflicts_count(new_cols) <= base_conf:\n            # normalize only if color class current_max becomes empty\n            if all(x != current_max for x in new_cols):\n                new_cols = _normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = _adjacency_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = _dsatur_construct(adj)\n        init_cols = _normalize_consecutive(init_cols)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = list(solution)\n\n    # Phase 1: if conflicts exist, repair them greedily (min-conflicts for a high-degree vertex)\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # choose a conflicted vertex preferring higher degree\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        # try existing colors first\n        palette = sorted(set(cols))\n        random.shuffle(palette)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in palette:\n            if c == cols[i]:\n                # evaluate current color too\n                pass\n            # count conflicts if assign c\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c and nb - 1 != i:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_cols = list(cols)\n        new_cols[i] = best_c\n        return new_cols, \"Repair-MinConflicts\"\n\n    # Phase 2: feasible; attempt to reduce palette size\n    op_order = [\n        \"reduce_move\", \"drop_repair\", \"kempe\", \"two_swap\"\n    ]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            new_cols, ok = _attempt_reduce_max_color(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-RecolorMaxClass\"\n        elif op == \"drop_repair\":\n            new_cols, ok = _drop_max_color_repair(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-DropColorRepair\"\n        elif op == \"kempe\":\n            new_cols, ok = _kempe_chain_safe(cols, adj)\n            if ok:\n                return new_cols, \"Kempe-Chain\"\n        elif op == \"two_swap\":\n            new_cols, ok = _two_swap_simulated(cols, adj)\n            if ok:\n                return new_cols, \"Two-Swap\"\n\n    # Fallback: recolor a random vertex with a random existing color if feasible\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    random.shuffle(palette)\n    for c in palette:\n        if _is_color_feasible(i, c, cols, adj):\n            new_cols = list(cols)\n            new_cols[i] = c\n            return new_cols, \"Fallback-Recolor\"\n\n    return list(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # deterministic valid seed 3-coloring\n        return [2,1,3,1,2,3,1,1,3]\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and try greedy repair within existing colors\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow conflicts during perturbation: assign random existing color\n                pal = list(range(1, max(1, maxc)))\n                cols[i] = random.choice(pal) if pal else 1\n\n    # Step 2: Multiple Kempe-chain swaps across random color pairs (diversification)\n    def _kempe_swap_component(cols, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    palette = sorted(set(cols))\n    for _ in range(3):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = _kempe_swap_component(cols, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette to shake\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    # Step 4: Light repair pass to avoid too many conflicts\n    for i in range(n):\n        # try to reduce conflicts at i by picking a different color if possible\n        best_c = cols[i]\n        best_inc = 0\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == cols[i]:\n                best_inc += 1\n        if best_inc == 0:\n            continue\n        for c in range(1, max(2, pal_max + 1)):\n            if c == cols[i]:\n                continue\n            inc = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    inc += 1\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    # Normalize at the end to keep consecutive color indices\n    cols = _normalize_consecutive(cols)\n    return cols\n","Resultados":[[1,3,2,1,3,2,3,1,2],3.0,[2,1,3,1,2,3,1,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002881098}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Scoring policy (lower is better):\n    # 1) Any conflicts dominate with huge penalty\n    # 2) If conflict-free but non-consecutive, penalize heavily\n    # 3) Otherwise return k so global optimum for this instance returns 3\n    if conflicts > 0:\n        return float(1_000_000_000 + conflicts * 1_000_000 + k)\n    if not is_consecutive:\n        return float(1_000_000 + k)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _is_color_feasible(i, color, cols, adj):\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        return [colored[i] for i in range(1, n + 1)]\n\n    def _two_swap_simulated(cols, adj):\n        # Try swap colors of two vertices and verify by simulation\n        idx = list(range(n))\n        random.shuffle(idx)\n        for a in idx:\n            for b in idx:\n                if a >= b:\n                    continue\n                if cols[a] == cols[b]:\n                    continue\n                new_cols = list(cols)\n                new_cols[a], new_cols[b] = new_cols[b], new_cols[a]\n                ok = True\n                # Check all incident edges of a and b\n                for nb in adj[a + 1]:\n                    if new_cols[nb - 1] == new_cols[a]:\n                        ok = False\n                        break\n                if ok:\n                    for nb in adj[b + 1]:\n                        if new_cols[nb - 1] == new_cols[b]:\n                            ok = False\n                            break\n                if ok:\n                    return new_cols, True\n        return cols, False\n\n    def _attempt_reduce_max_color(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        # Try move vertices from max color to lower feasible colors\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            targets = list(range(1, current_max))\n            random.shuffle(targets)\n            for c in targets:\n                if _is_color_feasible(i, c, cols, adj):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    # If no more vertices use current_max, normalize down\n                    if all(x != current_max for x in new_cols):\n                        new_cols = _normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def _drop_max_color_repair(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        new_cols = list(cols)\n        targets = [i for i, c in enumerate(new_cols) if c == current_max]\n        if not targets:\n            return cols, False\n        for i in targets:\n            new_cols[i] = 0\n        # order by degree desc then by fewest feasible options first\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), sum(1 for c in range(1, current_max) if any(new_cols[nb - 1] == c for nb in adj[i + 1]))))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(new_cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        # successful repair, normalize down\n        new_cols = _normalize_consecutive(new_cols)\n        return new_cols, True\n\n    def _kempe_chain_safe(cols, adj):\n        # Try a Kempe swap between highest color and a lower color; accept only if conflicts not worse\n        base_conf = _conflicts_count(cols)\n        if base_conf < 0:\n            return cols, False  # never happens, guard\n        current_max = max(cols)\n        lower = [c for c in sorted(set(cols)) if c < current_max]\n        if current_max <= 1 or not lower:\n            return cols, False\n        c2 = random.choice(lower)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (current_max, c2)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        # Build component\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, c2):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = c2\n            elif new_cols[u - 1] == c2:\n                new_cols[u - 1] = current_max\n        if _conflicts_count(new_cols) <= base_conf:\n            # normalize only if color class current_max becomes empty\n            if all(x != current_max for x in new_cols):\n                new_cols = _normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = _adjacency_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = _dsatur_construct(adj)\n        init_cols = _normalize_consecutive(init_cols)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = list(solution)\n\n    # Phase 1: if conflicts exist, repair them greedily (min-conflicts for a high-degree vertex)\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # choose a conflicted vertex preferring higher degree\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        # try existing colors first\n        palette = sorted(set(cols))\n        random.shuffle(palette)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in palette:\n            if c == cols[i]:\n                # evaluate current color too\n                pass\n            # count conflicts if assign c\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c and nb - 1 != i:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_cols = list(cols)\n        new_cols[i] = best_c\n        return new_cols, \"Repair-MinConflicts\"\n\n    # Phase 2: feasible; attempt to reduce palette size\n    op_order = [\n        \"reduce_move\", \"drop_repair\", \"kempe\", \"two_swap\"\n    ]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            new_cols, ok = _attempt_reduce_max_color(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-RecolorMaxClass\"\n        elif op == \"drop_repair\":\n            new_cols, ok = _drop_max_color_repair(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-DropColorRepair\"\n        elif op == \"kempe\":\n            new_cols, ok = _kempe_chain_safe(cols, adj)\n            if ok:\n                return new_cols, \"Kempe-Chain\"\n        elif op == \"two_swap\":\n            new_cols, ok = _two_swap_simulated(cols, adj)\n            if ok:\n                return new_cols, \"Two-Swap\"\n\n    # Fallback: recolor a random vertex with a random existing color if feasible\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    random.shuffle(palette)\n    for c in palette:\n        if _is_color_feasible(i, c, cols, adj):\n            new_cols = list(cols)\n            new_cols[i] = c\n            return new_cols, \"Fallback-Recolor\"\n\n    return list(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # deterministic valid seed 3-coloring\n        return [2,1,3,1,2,3,1,1,3]\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and try greedy repair within existing colors\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow conflicts during perturbation: assign random existing color\n                pal = list(range(1, max(1, maxc)))\n                cols[i] = random.choice(pal) if pal else 1\n\n    # Step 2: Multiple Kempe-chain swaps across random color pairs (diversification)\n    def _kempe_swap_component(cols, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    palette = sorted(set(cols))\n    for _ in range(3):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = _kempe_swap_component(cols, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette to shake\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    # Step 4: Light repair pass to avoid too many conflicts\n    for i in range(n):\n        # try to reduce conflicts at i by picking a different color if possible\n        best_c = cols[i]\n        best_inc = 0\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == cols[i]:\n                best_inc += 1\n        if best_inc == 0:\n            continue\n        for c in range(1, max(2, pal_max + 1)):\n            if c == cols[i]:\n                continue\n            inc = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    inc += 1\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    # Normalize at the end to keep consecutive color indices\n    cols = _normalize_consecutive(cols)\n    return cols\n","Resultados":[[1,1,1,1,1,1,1,1,1],3.0,[2,1,3,1,2,3,1,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003393805}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e12\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n\n    cols = solution\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette size and consecutiveness\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n    is_consecutive = palette_sorted == list(range(1, k+1))\n\n    # Scoring policy (lower is better):\n    # 1) Any conflicts dominate with huge penalty\n    # 2) If conflict-free but non-consecutive, penalize heavily\n    # 3) Otherwise return k so global optimum for this instance returns 3\n    if conflicts > 0:\n        return float(1_000_000_000 + conflicts * 1_000_000 + k)\n    if not is_consecutive:\n        return float(1_000_000 + k)\n    return float(k)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def _conflicted_vertices(cols):\n        conflicted = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def _is_color_feasible(i, color, cols, adj):\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == color:\n                return False\n        return True\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        return [colored[i] for i in range(1, n + 1)]\n\n    def _two_swap_simulated(cols, adj):\n        # Try swap colors of two vertices and verify by simulation\n        idx = list(range(n))\n        random.shuffle(idx)\n        for a in idx:\n            for b in idx:\n                if a >= b:\n                    continue\n                if cols[a] == cols[b]:\n                    continue\n                new_cols = list(cols)\n                new_cols[a], new_cols[b] = new_cols[b], new_cols[a]\n                ok = True\n                # Check all incident edges of a and b\n                for nb in adj[a + 1]:\n                    if new_cols[nb - 1] == new_cols[a]:\n                        ok = False\n                        break\n                if ok:\n                    for nb in adj[b + 1]:\n                        if new_cols[nb - 1] == new_cols[b]:\n                            ok = False\n                            break\n                if ok:\n                    return new_cols, True\n        return cols, False\n\n    def _attempt_reduce_max_color(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        # Try move vertices from max color to lower feasible colors\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            targets = list(range(1, current_max))\n            random.shuffle(targets)\n            for c in targets:\n                if _is_color_feasible(i, c, cols, adj):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    # If no more vertices use current_max, normalize down\n                    if all(x != current_max for x in new_cols):\n                        new_cols = _normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def _drop_max_color_repair(cols, adj):\n        current_max = max(cols)\n        if current_max <= 1:\n            return cols, False\n        new_cols = list(cols)\n        targets = [i for i, c in enumerate(new_cols) if c == current_max]\n        if not targets:\n            return cols, False\n        for i in targets:\n            new_cols[i] = 0\n        # order by degree desc then by fewest feasible options first\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), sum(1 for c in range(1, current_max) if any(new_cols[nb - 1] == c for nb in adj[i + 1]))))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(new_cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        # successful repair, normalize down\n        new_cols = _normalize_consecutive(new_cols)\n        return new_cols, True\n\n    def _kempe_chain_safe(cols, adj):\n        # Try a Kempe swap between highest color and a lower color; accept only if conflicts not worse\n        base_conf = _conflicts_count(cols)\n        if base_conf < 0:\n            return cols, False  # never happens, guard\n        current_max = max(cols)\n        lower = [c for c in sorted(set(cols)) if c < current_max]\n        if current_max <= 1 or not lower:\n            return cols, False\n        c2 = random.choice(lower)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (current_max, c2)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        # Build component\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, c2):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = c2\n            elif new_cols[u - 1] == c2:\n                new_cols[u - 1] = current_max\n        if _conflicts_count(new_cols) <= base_conf:\n            # normalize only if color class current_max becomes empty\n            if all(x != current_max for x in new_cols):\n                new_cols = _normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = _adjacency_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = _dsatur_construct(adj)\n        init_cols = _normalize_consecutive(init_cols)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = list(solution)\n\n    # Phase 1: if conflicts exist, repair them greedily (min-conflicts for a high-degree vertex)\n    conflicted = _conflicted_vertices(cols)\n    if conflicted:\n        # choose a conflicted vertex preferring higher degree\n        cand = sorted(list(conflicted), key=lambda i: (-len(adj[i + 1]), i))\n        i = random.choice(cand[:max(1, min(3, len(cand)))])\n        # try existing colors first\n        palette = sorted(set(cols))\n        random.shuffle(palette)\n        best_c = cols[i]\n        best_conf = math.inf\n        for c in palette:\n            if c == cols[i]:\n                # evaluate current color too\n                pass\n            # count conflicts if assign c\n            conf = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c and nb - 1 != i:\n                    conf += 1\n                    if conf >= best_conf:\n                        break\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_cols = list(cols)\n        new_cols[i] = best_c\n        return new_cols, \"Repair-MinConflicts\"\n\n    # Phase 2: feasible; attempt to reduce palette size\n    op_order = [\n        \"reduce_move\", \"drop_repair\", \"kempe\", \"two_swap\"\n    ]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            new_cols, ok = _attempt_reduce_max_color(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-RecolorMaxClass\"\n        elif op == \"drop_repair\":\n            new_cols, ok = _drop_max_color_repair(cols, adj)\n            if ok:\n                return new_cols, \"ReduceK-DropColorRepair\"\n        elif op == \"kempe\":\n            new_cols, ok = _kempe_chain_safe(cols, adj)\n            if ok:\n                return new_cols, \"Kempe-Chain\"\n        elif op == \"two_swap\":\n            new_cols, ok = _two_swap_simulated(cols, adj)\n            if ok:\n                return new_cols, \"Two-Swap\"\n\n    # Fallback: recolor a random vertex with a random existing color if feasible\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    random.shuffle(palette)\n    for c in palette:\n        if _is_color_feasible(i, c, cols, adj):\n            new_cols = list(cols)\n            new_cols[i] = c\n            return new_cols, \"Fallback-Recolor\"\n\n    return list(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def _adjacency_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def _normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def _conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        # deterministic valid seed 3-coloring\n        return [2,1,3,1,2,3,1,1,3]\n\n    cols = list(solution)\n    adj = _adjacency_list(n, edges)\n\n    # Step 1: Drop highest color class and try greedy repair within existing colors\n    maxc = max(cols)\n    targets = [i for i, c in enumerate(cols) if c == maxc]\n    if targets:\n        for i in targets:\n            cols[i] = 0\n        order = sorted(targets, key=lambda i: (-len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, maxc):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    cols[i] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow conflicts during perturbation: assign random existing color\n                pal = list(range(1, max(1, maxc)))\n                cols[i] = random.choice(pal) if pal else 1\n\n    # Step 2: Multiple Kempe-chain swaps across random color pairs (diversification)\n    def _kempe_swap_component(cols, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    palette = sorted(set(cols))\n    for _ in range(3):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = _kempe_swap_component(cols, c1, c2, seed)\n\n    # Step 3: Random recolors within current palette to shake\n    pal_max = max(cols)\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.randint(1, max(1, pal_max))\n\n    # Step 4: Light repair pass to avoid too many conflicts\n    for i in range(n):\n        # try to reduce conflicts at i by picking a different color if possible\n        best_c = cols[i]\n        best_inc = 0\n        for nb in adj[i + 1]:\n            if cols[nb - 1] == cols[i]:\n                best_inc += 1\n        if best_inc == 0:\n            continue\n        for c in range(1, max(2, pal_max + 1)):\n            if c == cols[i]:\n                continue\n            inc = 0\n            for nb in adj[i + 1]:\n                if cols[nb - 1] == c:\n                    inc += 1\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    # Normalize at the end to keep consecutive color indices\n    cols = _normalize_consecutive(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002125618}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette metrics\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n\n    # Tiebreakers to encourage reducible palettes\n    # - max color class size\n    # - sum of degrees inside max color class\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Lexicographic scalarization: conflicts >> k >> structure\n    score = conflicts * 1_000_000 + k * 1_000 + max_color_size * 10 + sum_deg_max\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return conf\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        # try moving a vertex from max color to lowest feasible lower color\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    new_cols = normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        # order by fewest feasible colors then higher degree\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1])))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        temp = normalize_consecutive(temp)\n        return temp, True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if not lower_colors:\n            return cols, False\n        # pick target color that maximizes adjacency between max color and target color\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        # seed from a vertex in max color with highest degree into target\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        # build (current_max, target) component of seed\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            new_cols = normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    # If conflicts exist: repair with min-conflicts; allow temporary new color to break deadlocks\n    conf = conflicts_count(cols)\n    if conf > 0:\n        conf_set = list(conflicted_vertices(cols))\n        # select vertex with fewest feasible colors, then higher degree\n        palette = sorted(set(cols))\n        conf_set.sort(key=lambda i: (len(feasible_colors(i, cols, palette, adj)), -len(adj[i + 1]), i))\n        i = conf_set[0]\n        feas = feasible_colors(i, cols, palette, adj)\n        new_cols = list(cols)\n        if feas:\n            # choose lowest feasible color to aid normalization\n            new_cols[i] = min(feas)\n            return normalize_consecutive(new_cols), \"Repair-MinConflicts\"\n        else:\n            # introduce a new color temporarily\n            new_cols[i] = max(palette) + 1\n            return normalize_consecutive(new_cols), \"Repair-IntroduceColor\"\n\n    # Feasible: attempt palette reduction moves\n    op_order = [\"reduce_move\", \"drop_repair\", \"kempe\"]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            nxt, ok = attempt_reduce_move(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-RecolorFromMax\"\n        elif op == \"drop_repair\":\n            nxt, ok = drop_color_repair(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-DropRepair\"\n        elif op == \"kempe\":\n            nxt, ok = kempe_targeted(cols, adj)\n            if ok:\n                return nxt, \"Kempe-Targeted\"\n\n    # Fallback: recolor random vertex to lowest feasible existing color (keeps feasibility)\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    # If no feasible change, return as is\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # 1) Eject a portion of max color class and try to reinsert within current palette\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        # remove about half of max class (at least 1)\n        random.shuffle(max_idxs)\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        for i in removed:\n            cols[i] = 0\n        for i in removed:\n            # greedy insert to smallest feasible color < maxc if possible, else random in [1, maxc]\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform a few Kempe-chain swaps across random color pairs\n    for _ in range(2):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Randomly recolor a few vertices within current palette to diversify\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Light local repair: for vertices in conflict, choose a color minimizing local conflicts\n    for i in range(n):\n        # count current conflicts at i\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in sorted(set(cols)):\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    cols = normalize_consecutive(cols)\n    return cols\n","Resultados":[[2,1,3,1,2,3,1,1,3],3053.0,[2,1,3,1,2,3,1,1,3],3043.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.003416826}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette metrics\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n\n    # Tiebreakers to encourage reducible palettes\n    # - max color class size\n    # - sum of degrees inside max color class\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Lexicographic scalarization: conflicts >> k >> structure\n    score = conflicts * 1_000_000 + k * 1_000 + max_color_size * 10 + sum_deg_max\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return conf\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        # try moving a vertex from max color to lowest feasible lower color\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    new_cols = normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        # order by fewest feasible colors then higher degree\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1])))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        temp = normalize_consecutive(temp)\n        return temp, True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if not lower_colors:\n            return cols, False\n        # pick target color that maximizes adjacency between max color and target color\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        # seed from a vertex in max color with highest degree into target\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        # build (current_max, target) component of seed\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            new_cols = normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    # If conflicts exist: repair with min-conflicts; allow temporary new color to break deadlocks\n    conf = conflicts_count(cols)\n    if conf > 0:\n        conf_set = list(conflicted_vertices(cols))\n        # select vertex with fewest feasible colors, then higher degree\n        palette = sorted(set(cols))\n        conf_set.sort(key=lambda i: (len(feasible_colors(i, cols, palette, adj)), -len(adj[i + 1]), i))\n        i = conf_set[0]\n        feas = feasible_colors(i, cols, palette, adj)\n        new_cols = list(cols)\n        if feas:\n            # choose lowest feasible color to aid normalization\n            new_cols[i] = min(feas)\n            return normalize_consecutive(new_cols), \"Repair-MinConflicts\"\n        else:\n            # introduce a new color temporarily\n            new_cols[i] = max(palette) + 1\n            return normalize_consecutive(new_cols), \"Repair-IntroduceColor\"\n\n    # Feasible: attempt palette reduction moves\n    op_order = [\"reduce_move\", \"drop_repair\", \"kempe\"]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            nxt, ok = attempt_reduce_move(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-RecolorFromMax\"\n        elif op == \"drop_repair\":\n            nxt, ok = drop_color_repair(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-DropRepair\"\n        elif op == \"kempe\":\n            nxt, ok = kempe_targeted(cols, adj)\n            if ok:\n                return nxt, \"Kempe-Targeted\"\n\n    # Fallback: recolor random vertex to lowest feasible existing color (keeps feasibility)\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    # If no feasible change, return as is\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # 1) Eject a portion of max color class and try to reinsert within current palette\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        # remove about half of max class (at least 1)\n        random.shuffle(max_idxs)\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        for i in removed:\n            cols[i] = 0\n        for i in removed:\n            # greedy insert to smallest feasible color < maxc if possible, else random in [1, maxc]\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform a few Kempe-chain swaps across random color pairs\n    for _ in range(2):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Randomly recolor a few vertices within current palette to diversify\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Light local repair: for vertices in conflict, choose a color minimizing local conflicts\n    for i in range(n):\n        # count current conflicts at i\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in sorted(set(cols)):\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    cols = normalize_consecutive(cols)\n    return cols\n","Resultados":[[1,3,4,3,2,1,3,3,2],3053.0,[1,3,2,1,3,2,3,1,2],3041.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00455362}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_CONSEC_COLORS_1_TO_k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    # Palette metrics\n    palette_sorted = sorted(set(cols))\n    k = len(palette_sorted)\n\n    # Tiebreakers to encourage reducible palettes\n    # - max color class size\n    # - sum of degrees inside max color class\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Lexicographic scalarization: conflicts >> k >> structure\n    score = conflicts * 1_000_000 + k * 1_000 + max_color_size * 10 + sum_deg_max\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return conf\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        # try moving a vertex from max color to lowest feasible lower color\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    new_cols = normalize_consecutive(new_cols)\n                    return new_cols, True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        # order by fewest feasible colors then higher degree\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1])))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        temp = normalize_consecutive(temp)\n        return temp, True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        lower_colors = [c for c in sorted(set(cols)) if c < current_max]\n        if not lower_colors:\n            return cols, False\n        # pick target color that maximizes adjacency between max color and target color\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        # seed from a vertex in max color with highest degree into target\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        # build (current_max, target) component of seed\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            new_cols = normalize_consecutive(new_cols)\n            return new_cols, True\n        return cols, False\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    # If conflicts exist: repair with min-conflicts; allow temporary new color to break deadlocks\n    conf = conflicts_count(cols)\n    if conf > 0:\n        conf_set = list(conflicted_vertices(cols))\n        # select vertex with fewest feasible colors, then higher degree\n        palette = sorted(set(cols))\n        conf_set.sort(key=lambda i: (len(feasible_colors(i, cols, palette, adj)), -len(adj[i + 1]), i))\n        i = conf_set[0]\n        feas = feasible_colors(i, cols, palette, adj)\n        new_cols = list(cols)\n        if feas:\n            # choose lowest feasible color to aid normalization\n            new_cols[i] = min(feas)\n            return normalize_consecutive(new_cols), \"Repair-MinConflicts\"\n        else:\n            # introduce a new color temporarily\n            new_cols[i] = max(palette) + 1\n            return normalize_consecutive(new_cols), \"Repair-IntroduceColor\"\n\n    # Feasible: attempt palette reduction moves\n    op_order = [\"reduce_move\", \"drop_repair\", \"kempe\"]\n    random.shuffle(op_order)\n    for op in op_order:\n        if op == \"reduce_move\":\n            nxt, ok = attempt_reduce_move(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-RecolorFromMax\"\n        elif op == \"drop_repair\":\n            nxt, ok = drop_color_repair(cols, adj)\n            if ok:\n                return nxt, \"ReduceK-DropRepair\"\n        elif op == \"kempe\":\n            nxt, ok = kempe_targeted(cols, adj)\n            if ok:\n                return nxt, \"Kempe-Targeted\"\n\n    # Fallback: recolor random vertex to lowest feasible existing color (keeps feasibility)\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    # If no feasible change, return as is\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # 1) Eject a portion of max color class and try to reinsert within current palette\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        # remove about half of max class (at least 1)\n        random.shuffle(max_idxs)\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        for i in removed:\n            cols[i] = 0\n        for i in removed:\n            # greedy insert to smallest feasible color < maxc if possible, else random in [1, maxc]\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform a few Kempe-chain swaps across random color pairs\n    for _ in range(2):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Randomly recolor a few vertices within current palette to diversify\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Light local repair: for vertices in conflict, choose a color minimizing local conflicts\n    for i in range(n):\n        # count current conflicts at i\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in sorted(set(cols)):\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    cols = normalize_consecutive(cols)\n    return cols\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00226762}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List of 9 positive integers representing colors assigned to vertices 1..9. Colors must be consecutive from 1..k, where k is the number of distinct colors used. Example: [2,1,3,1,2,3,1,1,3].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    # Normalize to consecutive palette 1..k for evaluation consistency\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Hard-penalize any infeasible coloring; keep conflicts as tie-breaker\n        return float(1e9 + conflicts)\n\n    # Feasible: primary objective is minimizing k; add tiny tie-breakers\n    k = len(set(cols))\n\n    # Tie-breakers: encourage reducing the max color class burden\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Piecewise scalarization: exact k first, then tiny eps tie-breakers\n    score = (\n        float(k)\n        + 1e-6 * float(max_color_size)\n        + 1e-9 * float(sum_deg_max)\n    )\n    return score\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return list(conf)\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        return normalize_consecutive(temp), True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        palette = sorted(set(cols))\n        lower_colors = [c for c in palette if c < current_max]\n        if not lower_colors:\n            return cols, False\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def two_color_component_swap(cols, adj):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            return cols, False\n        a, b = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (a, b)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (a, b):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            new_cols[u - 1] = a if new_cols[u - 1] == b else (b if new_cols[u - 1] == a else new_cols[u - 1])\n        return normalize_consecutive(new_cols), True\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    conf = conflicts_count(cols)\n    if conf > 0:\n        # Randomized min-conflicts repair with bounded palette growth\n        conf_set = conflicted_vertices(cols)\n        palette = sorted(set(cols))\n        random.shuffle(conf_set)\n        # pick best among a few candidates\n        candidates = conf_set[:max(1, min(3, len(conf_set)))]\n        best = None\n        best_inc = math.inf\n        best_choice = None\n        for i in candidates:\n            feas = feasible_colors(i, cols, palette, adj)\n            choices = feas if feas else [max(palette) + 1]\n            for c in choices:\n                trial = cols[i]\n                inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n                if inc < best_inc:\n                    best_inc = inc\n                    best = i\n                    best_choice = c\n                    if inc == 0:\n                        break\n        new_cols = list(cols)\n        new_cols[best] = best_choice\n        return normalize_consecutive(new_cols), (\"Repair-MinConflicts\" if best_choice in palette else \"Repair-IntroduceColor\")\n\n    # Feasible region: attempt palette reduction\n    # 1) Direct recolor from max color to lower color\n    nxt, ok = attempt_reduce_move(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-RecolorFromMax\"\n\n    # 2) Try dropping max color with greedy reinsertion\n    nxt, ok = drop_color_repair(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-DropRepair\"\n\n    # 3) Targeted Kempe move focusing on max color interactions\n    nxt, ok = kempe_targeted(cols, adj)\n    if ok:\n        return nxt, \"Kempe-Targeted\"\n\n    # 4) Two-color component swap to unlock structure\n    nxt, ok = two_color_component_swap(cols, adj)\n    if ok:\n        return nxt, \"Swap-2ColorComponent\"\n\n    # 5) Fallback: recolor random vertex to lowest feasible existing color\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # Degree array for bias\n    deg = {i: len(adj[i]) for i in range(1, n + 1)}\n\n    # 1) Degree-biased ejection from max color class and DSATUR-like reinsertion\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        max_idxs.sort(key=lambda i: -deg[i + 1])\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        snapshot = list(cols)\n        for i in removed:\n            cols[i] = 0\n        # Reinsertion: order by higher degree first, then fewer feasible colors\n        order = sorted(removed, key=lambda i: (-deg[i + 1], i))\n        for i in order:\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform several Kempe-chain swaps across random color pairs to diversify\n    rounds = 3\n    for _ in range(rounds):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Random recolor a few vertices within current palette\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Local repair for conflicts: move to color minimizing local conflicts\n    for i in range(n):\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in palette:\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    return normalize_consecutive(cols)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00000369}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List of 9 positive integers representing colors assigned to vertices 1..9. Colors must be consecutive from 1..k, where k is the number of distinct colors used. Example: [2,1,3,1,2,3,1,1,3].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    # Normalize to consecutive palette 1..k for evaluation consistency\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Hard-penalize any infeasible coloring; keep conflicts as tie-breaker\n        return float(1e9 + conflicts)\n\n    # Feasible: primary objective is minimizing k; add tiny tie-breakers\n    k = len(set(cols))\n\n    # Tie-breakers: encourage reducing the max color class burden\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Piecewise scalarization: exact k first, then tiny eps tie-breakers\n    score = (\n        float(k)\n        + 1e-6 * float(max_color_size)\n        + 1e-9 * float(sum_deg_max)\n    )\n    return score\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return list(conf)\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        return normalize_consecutive(temp), True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        palette = sorted(set(cols))\n        lower_colors = [c for c in palette if c < current_max]\n        if not lower_colors:\n            return cols, False\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def two_color_component_swap(cols, adj):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            return cols, False\n        a, b = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (a, b)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (a, b):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            new_cols[u - 1] = a if new_cols[u - 1] == b else (b if new_cols[u - 1] == a else new_cols[u - 1])\n        return normalize_consecutive(new_cols), True\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    conf = conflicts_count(cols)\n    if conf > 0:\n        # Randomized min-conflicts repair with bounded palette growth\n        conf_set = conflicted_vertices(cols)\n        palette = sorted(set(cols))\n        random.shuffle(conf_set)\n        # pick best among a few candidates\n        candidates = conf_set[:max(1, min(3, len(conf_set)))]\n        best = None\n        best_inc = math.inf\n        best_choice = None\n        for i in candidates:\n            feas = feasible_colors(i, cols, palette, adj)\n            choices = feas if feas else [max(palette) + 1]\n            for c in choices:\n                trial = cols[i]\n                inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n                if inc < best_inc:\n                    best_inc = inc\n                    best = i\n                    best_choice = c\n                    if inc == 0:\n                        break\n        new_cols = list(cols)\n        new_cols[best] = best_choice\n        return normalize_consecutive(new_cols), (\"Repair-MinConflicts\" if best_choice in palette else \"Repair-IntroduceColor\")\n\n    # Feasible region: attempt palette reduction\n    # 1) Direct recolor from max color to lower color\n    nxt, ok = attempt_reduce_move(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-RecolorFromMax\"\n\n    # 2) Try dropping max color with greedy reinsertion\n    nxt, ok = drop_color_repair(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-DropRepair\"\n\n    # 3) Targeted Kempe move focusing on max color interactions\n    nxt, ok = kempe_targeted(cols, adj)\n    if ok:\n        return nxt, \"Kempe-Targeted\"\n\n    # 4) Two-color component swap to unlock structure\n    nxt, ok = two_color_component_swap(cols, adj)\n    if ok:\n        return nxt, \"Swap-2ColorComponent\"\n\n    # 5) Fallback: recolor random vertex to lowest feasible existing color\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # Degree array for bias\n    deg = {i: len(adj[i]) for i in range(1, n + 1)}\n\n    # 1) Degree-biased ejection from max color class and DSATUR-like reinsertion\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        max_idxs.sort(key=lambda i: -deg[i + 1])\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        snapshot = list(cols)\n        for i in removed:\n            cols[i] = 0\n        # Reinsertion: order by higher degree first, then fewer feasible colors\n        order = sorted(removed, key=lambda i: (-deg[i + 1], i))\n        for i in order:\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform several Kempe-chain swaps across random color pairs to diversify\n    rounds = 3\n    for _ in range(rounds):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Random recolor a few vertices within current palette\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Local repair for conflicts: move to color minimizing local conflicts\n    for i in range(n):\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in palette:\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    return normalize_consecutive(cols)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.0000017}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List of 9 positive integers representing colors assigned to vertices 1..9. Colors must be consecutive from 1..k, where k is the number of distinct colors used. Example: [2,1,3,1,2,3,1,1,3].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(1e12)\n\n    # Normalize to consecutive palette 1..k for evaluation consistency\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    cols = normalize_consecutive(list(solution))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # Hard-penalize any infeasible coloring; keep conflicts as tie-breaker\n        return float(1e9 + conflicts)\n\n    # Feasible: primary objective is minimizing k; add tiny tie-breakers\n    k = len(set(cols))\n\n    # Tie-breakers: encourage reducing the max color class burden\n    degrees = [0] * (n + 1)\n    for (u, v) in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    max_color = max(cols)\n    max_class_indices = [i+1 for i, c in enumerate(cols) if c == max_color]\n    max_color_size = len(max_class_indices)\n    sum_deg_max = sum(degrees[i] for i in max_class_indices)\n\n    # Piecewise scalarization: exact k first, then tiny eps tie-breakers\n    score = (\n        float(k)\n        + 1e-6 * float(max_color_size)\n        + 1e-9 * float(sum_deg_max)\n    )\n    return score\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def conflicts_count(cols):\n        c = 0\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def conflicted_vertices(cols):\n        conf = set()\n        for (u, v) in edges:\n            if cols[u-1] == cols[v-1]:\n                conf.add(u-1)\n                conf.add(v-1)\n        return list(conf)\n\n    def feasible_colors(i, cols, palette, adj):\n        used = {cols[nb - 1] for nb in adj[i + 1]}\n        return [c for c in palette if c not in used]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def attempt_reduce_move(cols, adj):\n        current_max = max(cols)\n        indices = [i for i, c in enumerate(cols) if c == current_max]\n        random.shuffle(indices)\n        for i in indices:\n            for c in range(1, current_max):\n                if all(cols[nb - 1] != c for nb in adj[i + 1]):\n                    new_cols = list(cols)\n                    new_cols[i] = c\n                    return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def drop_color_repair(cols, adj):\n        current_max = max(cols)\n        idxs = [i for i, c in enumerate(cols) if c == current_max]\n        if not idxs:\n            return cols, False\n        temp = list(cols)\n        for i in idxs:\n            temp[i] = 0\n        order = sorted(idxs, key=lambda i: (len(feasible_colors(i, temp, list(range(1, current_max)), adj)), -len(adj[i + 1]), i))\n        for i in order:\n            placed = False\n            for c in range(1, current_max):\n                if all(temp[nb - 1] != c for nb in adj[i + 1]):\n                    temp[i] = c\n                    placed = True\n                    break\n            if not placed:\n                return cols, False\n        return normalize_consecutive(temp), True\n\n    def kempe_targeted(cols, adj):\n        base = conflicts_count(cols)\n        current_max = max(cols)\n        palette = sorted(set(cols))\n        lower_colors = [c for c in palette if c < current_max]\n        if not lower_colors:\n            return cols, False\n        def cut_size(target):\n            cut = 0\n            for (u, v) in edges:\n                cu, cv = cols[u-1], cols[v-1]\n                if {cu, cv} == {current_max, target}:\n                    cut += 1\n            return cut\n        lower_colors.sort(key=lambda c: -cut_size(c))\n        target = lower_colors[0]\n        candidates = [i+1 for i, c in enumerate(cols) if c == current_max]\n        candidates.sort(key=lambda u: (-sum(1 for w in adj[u] if cols[w-1] == target), -len(adj[u]), u))\n        if not candidates:\n            return cols, False\n        seed = candidates[0]\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (current_max, target):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            if new_cols[u - 1] == current_max:\n                new_cols[u - 1] = target\n            elif new_cols[u - 1] == target:\n                new_cols[u - 1] = current_max\n        if conflicts_count(new_cols) <= base:\n            return normalize_consecutive(new_cols), True\n        return cols, False\n\n    def two_color_component_swap(cols, adj):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            return cols, False\n        a, b = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (a, b)]\n        if not seeds:\n            return cols, False\n        seed = random.choice(seeds)\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (a, b):\n                    vis.add(w)\n                    stack.append(w)\n        new_cols = list(cols)\n        for u in vis:\n            new_cols[u - 1] = a if new_cols[u - 1] == b else (b if new_cols[u - 1] == a else new_cols[u - 1])\n        return normalize_consecutive(new_cols), True\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        init_cols = dsatur_construct(adj)\n        return init_cols, \"Init-DSATUR\"\n\n    cols = normalize_consecutive(list(solution))\n\n    conf = conflicts_count(cols)\n    if conf > 0:\n        # Randomized min-conflicts repair with bounded palette growth\n        conf_set = conflicted_vertices(cols)\n        palette = sorted(set(cols))\n        random.shuffle(conf_set)\n        # pick best among a few candidates\n        candidates = conf_set[:max(1, min(3, len(conf_set)))]\n        best = None\n        best_inc = math.inf\n        best_choice = None\n        for i in candidates:\n            feas = feasible_colors(i, cols, palette, adj)\n            choices = feas if feas else [max(palette) + 1]\n            for c in choices:\n                trial = cols[i]\n                inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n                if inc < best_inc:\n                    best_inc = inc\n                    best = i\n                    best_choice = c\n                    if inc == 0:\n                        break\n        new_cols = list(cols)\n        new_cols[best] = best_choice\n        return normalize_consecutive(new_cols), (\"Repair-MinConflicts\" if best_choice in palette else \"Repair-IntroduceColor\")\n\n    # Feasible region: attempt palette reduction\n    # 1) Direct recolor from max color to lower color\n    nxt, ok = attempt_reduce_move(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-RecolorFromMax\"\n\n    # 2) Try dropping max color with greedy reinsertion\n    nxt, ok = drop_color_repair(cols, adj)\n    if ok:\n        return nxt, \"ReduceK-DropRepair\"\n\n    # 3) Targeted Kempe move focusing on max color interactions\n    nxt, ok = kempe_targeted(cols, adj)\n    if ok:\n        return nxt, \"Kempe-Targeted\"\n\n    # 4) Two-color component swap to unlock structure\n    nxt, ok = two_color_component_swap(cols, adj)\n    if ok:\n        return nxt, \"Swap-2ColorComponent\"\n\n    # 5) Fallback: recolor random vertex to lowest feasible existing color\n    i = random.randrange(n)\n    palette = sorted(set(cols))\n    feas = feasible_colors(i, cols, palette, adj)\n    if feas:\n        new_cols = list(cols)\n        new_cols[i] = min(feas)\n        return normalize_consecutive(new_cols), \"Fallback-1Opt\"\n\n    return normalize_consecutive(cols), \"No-Op\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n_local, edges_local):\n        adj = {i: set() for i in range(1, n_local + 1)}\n        for (u, v) in edges_local:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_consecutive(cols):\n        palette = sorted(set(cols))\n        mapping = {c: (i + 1) for i, c in enumerate(palette)}\n        return [mapping[c] for c in cols]\n\n    def dsatur_construct(adj):\n        uncolored = set(range(1, n + 1))\n        colored = {}\n        sat_deg = {u: set() for u in range(1, n + 1)}\n        degrees = {u: len(adj[u]) for u in range(1, n + 1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat_deg[x]), degrees[x], x))\n            forbidden = {colored[v] for v in adj[u] if v in colored}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colored[u] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat_deg[v].add(c)\n        cols = [colored[i] for i in range(1, n + 1)]\n        return normalize_consecutive(cols)\n\n    def kempe_swap_component(cols, adj, c1, c2, seed):\n        stack = [seed]\n        vis = {seed}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in vis and cols[w - 1] in (c1, c2):\n                    vis.add(w)\n                    stack.append(w)\n        for u in vis:\n            if cols[u - 1] == c1:\n                cols[u - 1] = c2\n            elif cols[u - 1] == c2:\n                cols[u - 1] = c1\n        return cols\n\n    adj = adj_list(n, edges)\n\n    valid = isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not valid:\n        cols = dsatur_construct(adj)\n    else:\n        cols = normalize_consecutive(list(solution))\n\n    # Degree array for bias\n    deg = {i: len(adj[i]) for i in range(1, n + 1)}\n\n    # 1) Degree-biased ejection from max color class and DSATUR-like reinsertion\n    maxc = max(cols)\n    max_idxs = [i for i, c in enumerate(cols) if c == maxc]\n    if max_idxs:\n        max_idxs.sort(key=lambda i: -deg[i + 1])\n        m = max(1, len(max_idxs) \/\/ 2)\n        removed = max_idxs[:m]\n        snapshot = list(cols)\n        for i in removed:\n            cols[i] = 0\n        # Reinsertion: order by higher degree first, then fewer feasible colors\n        order = sorted(removed, key=lambda i: (-deg[i + 1], i))\n        for i in order:\n            feas = [c for c in range(1, maxc) if all(cols[nb - 1] != c for nb in adj[i + 1])]\n            if feas:\n                cols[i] = random.choice(feas)\n            else:\n                cols[i] = random.randint(1, maxc)\n\n    # 2) Perform several Kempe-chain swaps across random color pairs to diversify\n    rounds = 3\n    for _ in range(rounds):\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            break\n        c1, c2 = random.sample(palette, 2)\n        seeds = [i + 1 for i, c in enumerate(cols) if c in (c1, c2)]\n        if not seeds:\n            continue\n        seed = random.choice(seeds)\n        cols = kempe_swap_component(cols, adj, c1, c2, seed)\n\n    # 3) Random recolor a few vertices within current palette\n    palette = sorted(set(cols))\n    steps = 3\n    for _ in range(steps):\n        i = random.randrange(n)\n        cols[i] = random.choice(palette)\n\n    # 4) Local repair for conflicts: move to color minimizing local conflicts\n    for i in range(n):\n        cur_inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == cols[i])\n        if cur_inc == 0:\n            continue\n        best_c = cols[i]\n        best_inc = cur_inc\n        for c in palette:\n            if c == cols[i]:\n                continue\n            inc = sum(1 for nb in adj[i + 1] if cols[nb - 1] == c)\n            if inc < best_inc:\n                best_inc = inc\n                best_c = c\n                if inc == 0:\n                    break\n        cols[i] = best_c\n\n    return normalize_consecutive(cols)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00000109}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Fitness combines objective (colors used) with penalties for constraint violations\n    # Lower is better.\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Base penalties\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n    # Validate type and length\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Validate entries\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n    # Compute conflicts\n    conflicts = 0\n    cols = solution\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # Range\/consecutiveness check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if unique_colors:\n        if unique_colors != list(range(1, k+1)):\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            if not unique_colors or unique_colors[0] != 1:\n                range_violations += 1\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to be consecutive 1..k while preserving equality pattern\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: one of {\"Recolor\",\"Swap\"}\n    if not isinstance(solution, list):\n        return solution, \"Invalid\", \"NoOp\"\n    n = len(solution)\n    if n != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move type probabilistically\n    move = \"Recolor\" if random.random() < 0.7 else \"Swap\"\n    if move == \"Recolor\":\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        # Allow choosing among 1..current_k+1 to escape local minima\n        new_color = sol[idx]\n        if current_k <= 1:\n            candidate_colors = [1, 2]\n        else:\n            candidate_colors = list(range(1, current_k + 2))\n        candidate_colors = [c for c in candidate_colors if c != new_color]\n        if not candidate_colors:\n            return sol, \"Local\", \"Recolor\"\n        sol[idx] = random.choice(candidate_colors)\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Recolor\"\n    else:  # Swap\n        if n < 2:\n            return sol, \"Local\", \"Swap\"\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Swap\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef _normalize_colors_pert(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: perform multiple recolors and a shuffle block\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        candidate_colors = list(range(1, max(3, current_k + 1)))\n        if sol[idx] in candidate_colors and len(candidate_colors) > 1:\n            candidate_colors.remove(sol[idx])\n        sol[idx] = random.choice(candidate_colors)\n    # Random block shuffle\n    i, j = sorted(random.sample(range(n), 2))\n    block = sol[i:j+1]\n    random.shuffle(block)\n    sol[i:j+1] = block\n    sol = _normalize_colors_pert(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00000476}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Fitness combines objective (colors used) with penalties for constraint violations\n    # Lower is better.\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Base penalties\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n    # Validate type and length\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Validate entries\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n    # Compute conflicts\n    conflicts = 0\n    cols = solution\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # Range\/consecutiveness check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if unique_colors:\n        if unique_colors != list(range(1, k+1)):\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            if not unique_colors or unique_colors[0] != 1:\n                range_violations += 1\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to be consecutive 1..k while preserving equality pattern\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: one of {\"Recolor\",\"Swap\"}\n    if not isinstance(solution, list):\n        return solution, \"Invalid\", \"NoOp\"\n    n = len(solution)\n    if n != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move type probabilistically\n    move = \"Recolor\" if random.random() < 0.7 else \"Swap\"\n    if move == \"Recolor\":\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        # Allow choosing among 1..current_k+1 to escape local minima\n        new_color = sol[idx]\n        if current_k <= 1:\n            candidate_colors = [1, 2]\n        else:\n            candidate_colors = list(range(1, current_k + 2))\n        candidate_colors = [c for c in candidate_colors if c != new_color]\n        if not candidate_colors:\n            return sol, \"Local\", \"Recolor\"\n        sol[idx] = random.choice(candidate_colors)\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Recolor\"\n    else:  # Swap\n        if n < 2:\n            return sol, \"Local\", \"Swap\"\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Swap\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef _normalize_colors_pert(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: perform multiple recolors and a shuffle block\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        candidate_colors = list(range(1, max(3, current_k + 1)))\n        if sol[idx] in candidate_colors and len(candidate_colors) > 1:\n            candidate_colors.remove(sol[idx])\n        sol[idx] = random.choice(candidate_colors)\n    # Random block shuffle\n    i, j = sorted(random.sample(range(n), 2))\n    block = sol[i:j+1]\n    random.shuffle(block)\n    sol[i:j+1] = block\n    sol = _normalize_colors_pert(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00000165}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Fitness combines objective (colors used) with penalties for constraint violations\n    # Lower is better.\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Base penalties\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 1000.0\n    PEN_RANGE = 10.0\n    # Validate type and length\n    if not isinstance(solution, list):\n        return PEN_INVALID\n    if len(solution) != n:\n        return PEN_INVALID\n    # Validate entries\n    for x in solution:\n        if not isinstance(x, int):\n            return PEN_INVALID\n        if x < 1:\n            return PEN_INVALID\n    # Compute conflicts\n    conflicts = 0\n    cols = solution\n    for (u,v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # Range\/consecutiveness check\n    unique_colors = sorted(set(cols))\n    k = len(unique_colors)\n    range_violations = 0\n    if unique_colors:\n        if unique_colors != list(range(1, k+1)):\n            expected = set(range(1, k+1))\n            missing = expected.difference(unique_colors)\n            range_violations = len(missing)\n            if not unique_colors or unique_colors[0] != 1:\n                range_violations += 1\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * conflicts + PEN_RANGE * range_violations\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to be consecutive 1..k while preserving equality pattern\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type: one of {\"Recolor\",\"Swap\"}\n    if not isinstance(solution, list):\n        return solution, \"Invalid\", \"NoOp\"\n    n = len(solution)\n    if n != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move type probabilistically\n    move = \"Recolor\" if random.random() < 0.7 else \"Swap\"\n    if move == \"Recolor\":\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        # Allow choosing among 1..current_k+1 to escape local minima\n        new_color = sol[idx]\n        if current_k <= 1:\n            candidate_colors = [1, 2]\n        else:\n            candidate_colors = list(range(1, current_k + 2))\n        candidate_colors = [c for c in candidate_colors if c != new_color]\n        if not candidate_colors:\n            return sol, \"Local\", \"Recolor\"\n        sol[idx] = random.choice(candidate_colors)\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Recolor\"\n    else:  # Swap\n        if n < 2:\n            return sol, \"Local\", \"Swap\"\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        sol = _normalize_colors(sol)\n        return sol, \"Local\", \"Swap\"\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef _normalize_colors_pert(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_color\n            next_color += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: perform multiple recolors and a shuffle block\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_k = len(set(sol))\n        candidate_colors = list(range(1, max(3, current_k + 1)))\n        if sol[idx] in candidate_colors and len(candidate_colors) > 1:\n            candidate_colors.remove(sol[idx])\n        sol[idx] = random.choice(candidate_colors)\n    # Random block shuffle\n    i, j = sorted(random.sample(range(n), 2))\n    block = sol[i:j+1]\n    random.shuffle(block)\n    sol[i:j+1] = block\n    sol = _normalize_colors_pert(sol)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00000114}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS; solution is a JSON array of 9 positive integers where colors are consecutively labeled from 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 100.0\n    PEN_RANGE = 5.0\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = solution\n    # conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # consecutiveness penalty: count missing labels in 1..max_color\n    unique_colors = set(cols)\n    max_color = max(unique_colors) if unique_colors else 0\n    missing = 0\n    if max_color > 0:\n        present = unique_colors\n        missing = sum(1 for c in range(1, max_color+1) if c not in present)\n    k = len(unique_colors)\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * float(conflicts) + PEN_RANGE * float(missing)\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\"}\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _recolor_move(sol: List[int]) -> List[int]:\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose high-degree vertex to explore color reduction\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            candidates = [i for i,d in enumerate(degs) if d == max_deg]\n        v = random.choice(candidates)\n        # evaluate best color in 1..current_k+1\n        best_color = sol[v]\n        best_cost = 1e9\n        palette = list(range(1, current_k+2))\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cost = 0\n            for u in adj[v]:\n                cost += 1 if sol[u] == c else 0\n            # slight bias to lower color ids to promote compact palette\n            cost_tie = (c*1e-3)\n            score = cost + cost_tie\n            if score < best_cost:\n                best_cost = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        current_k = len(set(sol))\n        if current_k < 2:\n            return sol\n        # Pick a seed vertex biased to conflicts\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a second color different from seed color\n        c1 = sol[seed]\n        other_colors = [c for c in range(1, current_k+1) if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        # BFS over subgraph induced by colors {c1,c2}\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol: List[int]) -> List[int]:\n        # swap labels of two random colors (can help escape encoding biases)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move adaptively\n    conflict_count = len(_conflict_vertices(sol))\n    r = random.random()\n    if conflict_count > 0:\n        # prioritize fixing conflicts\n        move_type = \"Recolor\" if r < 0.7 else \"KempeSwap\"\n    else:\n        # diversify\n        move_type = \"KempeSwap\" if r < 0.6 else \"Recolor\"\n        if r > 0.9:\n            move_type = \"PaletteSwap\"\n    if move_type == \"Recolor\":\n        new_sol = _recolor_move(sol)\n    elif move_type == \"KempeSwap\":\n        new_sol = _kempe_swap(sol)\n    else:\n        new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move_type\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation combining multiple targeted recolors and a Kempe swap\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # pick random color pair and random seed among vertices with one of these colors\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # number of recolors scaled with size\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # choose high degree vertices when no conflicts\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            vs = [i for i,d in enumerate(degs) if d == max_deg]\n            v = random.choice(vs)\n        palette = list(range(1, max(3, k + 1)))\n        if sol[v] in palette and len(palette) > 1:\n            palette.remove(sol[v])\n        sol[v] = random.choice(palette)\n    # apply multiple Kempe swaps to strongly shake structure\n    for _ in range(2):\n        sol = _kempe_swap(sol)\n    # random palette relabel to change encoding\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001255784}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS; solution is a JSON array of 9 positive integers where colors are consecutively labeled from 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 100.0\n    PEN_RANGE = 5.0\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = solution\n    # conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # consecutiveness penalty: count missing labels in 1..max_color\n    unique_colors = set(cols)\n    max_color = max(unique_colors) if unique_colors else 0\n    missing = 0\n    if max_color > 0:\n        present = unique_colors\n        missing = sum(1 for c in range(1, max_color+1) if c not in present)\n    k = len(unique_colors)\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * float(conflicts) + PEN_RANGE * float(missing)\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\"}\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _recolor_move(sol: List[int]) -> List[int]:\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose high-degree vertex to explore color reduction\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            candidates = [i for i,d in enumerate(degs) if d == max_deg]\n        v = random.choice(candidates)\n        # evaluate best color in 1..current_k+1\n        best_color = sol[v]\n        best_cost = 1e9\n        palette = list(range(1, current_k+2))\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cost = 0\n            for u in adj[v]:\n                cost += 1 if sol[u] == c else 0\n            # slight bias to lower color ids to promote compact palette\n            cost_tie = (c*1e-3)\n            score = cost + cost_tie\n            if score < best_cost:\n                best_cost = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        current_k = len(set(sol))\n        if current_k < 2:\n            return sol\n        # Pick a seed vertex biased to conflicts\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a second color different from seed color\n        c1 = sol[seed]\n        other_colors = [c for c in range(1, current_k+1) if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        # BFS over subgraph induced by colors {c1,c2}\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol: List[int]) -> List[int]:\n        # swap labels of two random colors (can help escape encoding biases)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move adaptively\n    conflict_count = len(_conflict_vertices(sol))\n    r = random.random()\n    if conflict_count > 0:\n        # prioritize fixing conflicts\n        move_type = \"Recolor\" if r < 0.7 else \"KempeSwap\"\n    else:\n        # diversify\n        move_type = \"KempeSwap\" if r < 0.6 else \"Recolor\"\n        if r > 0.9:\n            move_type = \"PaletteSwap\"\n    if move_type == \"Recolor\":\n        new_sol = _recolor_move(sol)\n    elif move_type == \"KempeSwap\":\n        new_sol = _kempe_swap(sol)\n    else:\n        new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move_type\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation combining multiple targeted recolors and a Kempe swap\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # pick random color pair and random seed among vertices with one of these colors\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # number of recolors scaled with size\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # choose high degree vertices when no conflicts\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            vs = [i for i,d in enumerate(degs) if d == max_deg]\n            v = random.choice(vs)\n        palette = list(range(1, max(3, k + 1)))\n        if sol[v] in palette and len(palette) > 1:\n            palette.remove(sol[v])\n        sol[v] = random.choice(palette)\n    # apply multiple Kempe swaps to strongly shake structure\n    for _ in range(2):\n        sol = _kempe_swap(sol)\n    # random palette relabel to change encoding\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001537348}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS; solution is a JSON array of 9 positive integers where colors are consecutively labeled from 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Lower is better\n    # Graph edges (1-indexed nodes):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    PEN_INVALID = 1e8\n    PEN_CONFLICT = 100.0\n    PEN_RANGE = 5.0\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = solution\n    # conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    # consecutiveness penalty: count missing labels in 1..max_color\n    unique_colors = set(cols)\n    max_color = max(unique_colors) if unique_colors else 0\n    missing = 0\n    if max_color > 0:\n        present = unique_colors\n        missing = sum(1 for c in range(1, max_color+1) if c not in present)\n    k = len(unique_colors)\n    obj = float(k)\n    fitness = obj + PEN_CONFLICT * float(conflicts) + PEN_RANGE * float(missing)\n    return float(fitness)\n","Vecindad":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # NB_Type: \"Local\"; Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\"}\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _recolor_move(sol: List[int]) -> List[int]:\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose high-degree vertex to explore color reduction\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            candidates = [i for i,d in enumerate(degs) if d == max_deg]\n        v = random.choice(candidates)\n        # evaluate best color in 1..current_k+1\n        best_color = sol[v]\n        best_cost = 1e9\n        palette = list(range(1, current_k+2))\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cost = 0\n            for u in adj[v]:\n                cost += 1 if sol[u] == c else 0\n            # slight bias to lower color ids to promote compact palette\n            cost_tie = (c*1e-3)\n            score = cost + cost_tie\n            if score < best_cost:\n                best_cost = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        current_k = len(set(sol))\n        if current_k < 2:\n            return sol\n        # Pick a seed vertex biased to conflicts\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a second color different from seed color\n        c1 = sol[seed]\n        other_colors = [c for c in range(1, current_k+1) if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        # BFS over subgraph induced by colors {c1,c2}\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol: List[int]) -> List[int]:\n        # swap labels of two random colors (can help escape encoding biases)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = copy.deepcopy(solution)\n    # Choose move adaptively\n    conflict_count = len(_conflict_vertices(sol))\n    r = random.random()\n    if conflict_count > 0:\n        # prioritize fixing conflicts\n        move_type = \"Recolor\" if r < 0.7 else \"KempeSwap\"\n    else:\n        # diversify\n        move_type = \"KempeSwap\" if r < 0.6 else \"Recolor\"\n        if r > 0.9:\n            move_type = \"PaletteSwap\"\n    if move_type == \"Recolor\":\n        new_sol = _recolor_move(sol)\n    elif move_type == \"KempeSwap\":\n        new_sol = _kempe_swap(sol)\n    else:\n        new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move_type\n","Perturbacion":"import random\nimport copy\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation combining multiple targeted recolors and a Kempe swap\n    def _normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def _conflict_vertices(sol: List[int]) -> List[int]:\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # pick random color pair and random seed among vertices with one of these colors\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = copy.deepcopy(solution)\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # number of recolors scaled with size\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # choose high degree vertices when no conflicts\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            vs = [i for i,d in enumerate(degs) if d == max_deg]\n            v = random.choice(vs)\n        palette = list(range(1, max(3, k + 1)))\n        if sol[v] in palette and len(palette) > 1:\n            palette.remove(sol[v])\n        sol[v] = random.choice(palette)\n    # apply multiple Kempe swaps to strongly shake structure\n    for _ in range(2):\n        sol = _kempe_swap(sol)\n    # random palette relabel to change encoding\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001539428}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1e6\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    # conflicts\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = float(PEN_CONFLICT * conflicts + k)\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, \"Local\", Movement_Type) where Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\",\"EliminateColor\"}\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        # Try colors from 1..current_k (+ optionally current_k+1 only if conflict exists)\n        palette = list(range(1, current_k + (1 if _conflict_vertices(sol) else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            # prefer lower color ids slightly and avoid introducing new color\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            # choose c2 from neighbor colors to address conflict\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            # try to reduce usage of highest color\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            # pick any vertex of color c1 as seed\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to greedily recolor vertices of the highest color into lower colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        # choose random seed among vertices with color a or b\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # Targeted random recolors\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # bias to highest color and high-degree vertices\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    # Multiple Kempe swaps\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    # Random palette relabel\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001657329}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1e6\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    # conflicts\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = float(PEN_CONFLICT * conflicts + k)\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, \"Local\", Movement_Type) where Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\",\"EliminateColor\"}\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        # Try colors from 1..current_k (+ optionally current_k+1 only if conflict exists)\n        palette = list(range(1, current_k + (1 if _conflict_vertices(sol) else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            # prefer lower color ids slightly and avoid introducing new color\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            # choose c2 from neighbor colors to address conflict\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            # try to reduce usage of highest color\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            # pick any vertex of color c1 as seed\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to greedily recolor vertices of the highest color into lower colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        # choose random seed among vertices with color a or b\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # Targeted random recolors\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # bias to highest color and high-degree vertices\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    # Multiple Kempe swaps\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    # Random palette relabel\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001783912}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1e6\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    # conflicts\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = float(PEN_CONFLICT * conflicts + k)\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, \"Local\", Movement_Type) where Movement_Type in {\"Recolor\",\"KempeSwap\",\"PaletteSwap\",\"EliminateColor\"}\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        candidates = _conflict_vertices(sol)\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        # Try colors from 1..current_k (+ optionally current_k+1 only if conflict exists)\n        palette = list(range(1, current_k + (1 if _conflict_vertices(sol) else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            # prefer lower color ids slightly and avoid introducing new color\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            # choose c2 from neighbor colors to address conflict\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            # try to reduce usage of highest color\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            # pick any vertex of color c1 as seed\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to greedily recolor vertices of the highest color into lower colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, \"Local\", move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        # choose random seed among vertices with color a or b\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    # Targeted random recolors\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            # bias to highest color and high-degree vertices\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    # Multiple Kempe swaps\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    # Random palette relabel\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002167585}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type)\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        candidates = conflicted[:]\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        conflict_exists = len(conflicted) > 0\n        palette = list(range(1, current_k + (1 if conflict_exists else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e18\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]  \n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002111915}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type)\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        candidates = conflicted[:]\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        conflict_exists = len(conflicted) > 0\n        palette = list(range(1, current_k + (1 if conflict_exists else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e18\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]  \n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":[[1,2,1,2,2,3,1,1,1],3.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004505155}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Conflicts dominate; then minimize number of colors k.\n    # Graph edges (1-indexed nodes):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, move_type)\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _recolor_move(sol):\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        candidates = conflicted[:]\n        if not candidates:\n            # choose a high-degree vertex, prefer highest color class\n            degs = [len(adj[i]) for i in range(n)]\n            max_deg = max(degs)\n            highest_color = max(sol)\n            cand = [i for i,d in enumerate(degs) if d == max_deg]\n            hc = [i for i in cand if sol[i] == highest_color]\n            candidates = hc if hc else cand\n        v = random.choice(candidates)\n        conflict_exists = len(conflicted) > 0\n        palette = list(range(1, current_k + (1 if conflict_exists else 0) + 1))\n        best_color = sol[v]\n        best_score = 1e18\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conflicts += 1\n            introduce_new = 1 if c > current_k else 0\n            score = conflicts + 0.001*c + 10*introduce_new\n            if score < best_score:\n                best_score = score\n                best_color = c\n        out = sol[:]\n        out[v] = best_color\n        return _normalize_colors(out)\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            seed = random.choice(conflicted)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            c2_choices = list(nbr_colors) if nbr_colors else [c for c in colors if c != c1]\n            c2 = random.choice(c2_choices)\n        else:\n            c1 = max(colors)\n            other = [c for c in colors if c != c1]\n            c2 = random.choice(other)\n            idxs = [i for i,x in enumerate(sol) if x == c1]\n            seed = random.choice(idxs)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _palette_swap(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        mapping = {a:b, b:a}\n        out = [(mapping.get(c, c)) for c in sol]\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol\n        target = max(colors)\n        if target == 1:\n            return sol\n        adj = _adj_list()\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            for c in range(1, target):\n                if c not in forbidden:\n                    out[v] = c\n                    break\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    sol = solution[:]\n    conflict_count = len(_conflict_vertices(sol))\n    n = len(sol)\n    p_recolor = min(0.9, 0.2 + 0.7 * (conflict_count \/ max(1, n)))\n    r = random.random()\n    if conflict_count > 0:\n        if r < p_recolor:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n    else:\n        r2 = random.random()\n        if r2 < 0.5:\n            move = \"EliminateColor\"\n            new_sol = _eliminate_highest_color(sol)\n        elif r2 < 0.85:\n            move = \"KempeSwap\"\n            new_sol = _kempe_swap(sol)\n        elif r2 < 0.97:\n            move = \"Recolor\"\n            new_sol = _recolor_move(sol)\n        else:\n            move = \"PaletteSwap\"\n            new_sol = _palette_swap(sol)\n    return new_sol, move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors + Kempe swaps + palette shuffle\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _kempe_swap(sol):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        a, b = random.sample(colors, 2)\n        candidates = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return sol\n        seed = random.choice(candidates)\n        from collections import deque\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]  \n    n = len(sol)\n    adj = _adj_list()\n    k = len(set(sol))\n    steps = max(4, n \/\/ 2)\n    for _ in range(steps):\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            if high_vertices:\n                v = random.choice(high_vertices)\n            else:\n                degs = [len(adj[i]) for i in range(n)]\n                max_deg = max(degs)\n                vs = [i for i,d in enumerate(degs) if d == max_deg]\n                v = random.choice(vs)\n        palette = list(range(1, max(3, k)))\n        if sol[v] in palette and len(palette) > 1:\n            try:\n                palette.remove(sol[v])\n            except ValueError:\n                pass\n        if not palette:\n            palette = [1]\n        sol[v] = random.choice(palette)\n    for _ in range(3):\n        sol = _kempe_swap(sol)\n    colors = sorted(set(sol))\n    relabel = colors[:]\n    random.shuffle(relabel)\n    mapping = {c: r for c, r in zip(colors, relabel)}\n    sol = [mapping[c] for c in sol]\n    sol = _normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002367739}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # give up for this vertex (keep target); will be normalized\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00166663}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # give up for this vertex (keep target); will be normalized\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001990274}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # give up for this vertex (keep target); will be normalized\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002229048}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00161046}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002488091}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate (large penalty), then minimize k. Lower is better.\n    # Assumes solution is a list of 9 positive ints; normalizes to consecutive colors starting at 1.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 1_000_000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains consecutive-colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        # Returns a permutation of vertices [0..n-1] by decreasing saturation then degree\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _recolor_move(sol):\n        # DSATUR-guided recolor without introducing new colors unless conflicts exist\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            # pick conflicting vertex with highest saturation\n            order = _dsatur_order(sol)\n            candidates = [v for v in order if v in set(conflicted)]\n            v = candidates[0] if candidates else random.choice(conflicted)\n            allow_new = True\n        else:\n            # pick vertex in highest color class to reduce k\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        palette = list(range(1, current_k + (1 if allow_new and conflicted else 0) + 1))\n        best_c = sol[v]\n        best_score = (10**9)\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts = sum(1 for u in adj[v] if sol[u] == c)\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate the highest color via greedy DSATUR repair\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {out[u] for u in adj[v]}\n            assigned = None\n            for c in range(1, target):\n                if c not in forbidden:\n                    assigned = c\n                    break\n            if assigned is None:\n                # fallback: try a Kempe swap involving one of the forbidden colors\n                forb_list = list(forbidden) if forbidden else [1]\n                pair = (target, random.choice(forb_list)) if forb_list else (target, 1)\n                out = _kempe_swap(out, seed=v, pair=pair)\n                # retry assignment\n                forbidden2 = {out[u] for u in adj[v]}\n                for c in range(1, max(out)):\n                    if c not in forbidden2:\n                        assigned = c\n                        break\n                if assigned is None:\n                    assigned = target\n                out[v] = assigned\n            else:\n                out[v] = assigned\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        # bias to vertices in max color\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NoOp\"\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution, \"NoOp\"\n    sol = _normalize_colors(solution)\n\n    # Move policy: conflict-driven; otherwise elimination-focused\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return _recolor_move(sol), \"Recolor\"\n        else:\n            return _conflict_directed_kempe(sol), \"KempeSwap\"\n    else:\n        r = random.random()\n        if r < 0.5:\n            return _eliminate_highest_color(sol), \"EliminateColor\"\n        elif r < 0.85:\n            return _kempe_swap(sol), \"KempeSwap\"\n        else:\n            return _recolor_move(sol), \"Recolor\"\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n    n = len(sol)\n    adj = _adj_list()\n\n    # Choose a color class to remove: prefer highest color or a random non-empty class\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    # Unassign these vertices and reinsert via DSATUR greedy\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify while preserving feasibility mostly\n    iters = 3\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002662043}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate, then minimize k. Lower is better.\n    # Input: list of 9 positive integers (colors). Colors may be any positive ints; we normalize to consecutive 1..k.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains 1..k consecutive colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _recolor_move(sol):\n        # DSATUR-guided recolor. If conflicts exist, allow k+1; otherwise keep feasibility (no new conflicts).\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            order = _dsatur_order(sol)\n            cset = set(conflicted)\n            cand = [v for v in order if v in cset]\n            v = cand[0] if cand else random.choice(conflicted)\n            allow_new = True\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        # Palette up to k (+1 only if allowed)\n        palette = list(range(1, current_k + (1 if allow_new else 0) + 1))\n        best_c = sol[v]\n        best_score = 10**9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts_here = 1 if c in forbidden else 0\n            if not conflicted and conflicts_here > 0:\n                # preserve feasibility when already conflict-free\n                continue\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts_here + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate highest color class without introducing conflicts.\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        # Multiple passes with greedy recolor and occasional Kempe swaps\n        for _ in range(3):\n            random.shuffle(verts)\n            changed = False\n            for v in list(verts):\n                if out[v] != target:\n                    continue\n                forbidden = {out[u] for u in adj[v]}\n                assigned = None\n                for c in range(1, target):\n                    if c not in forbidden:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # try Kempe swap with a random forbidden color to free a slot\n                    if forbidden:\n                        f = random.choice(list(forbidden))\n                        out2 = _kempe_swap(out, seed=v, pair=(target, f))\n                        forb2 = {out2[u] for u in adj[v]}\n                        for c in range(1, max(out2)):\n                            if c not in forb2:\n                                out = out2\n                                assigned = c\n                                break\n                if assigned is not None:\n                    out[v] = assigned\n                    changed = True\n            out = _normalize_colors(out)\n            if not changed:\n                break\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"NoOp\")\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"NoOp\")\n    sol = _normalize_colors(solution)\n\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return (_recolor_move(sol), \"Recolor\")\n        else:\n            return (_conflict_directed_kempe(sol), \"KempeSwap\")\n    else:\n        r = random.random()\n        if r < 0.55:\n            return (_eliminate_highest_color(sol), \"EliminateColor\")\n        elif r < 0.85:\n            return (_kempe_swap(sol), \"KempeSwap\")\n        else:\n            return (_recolor_move(sol), \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Prefer removing highest color class\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify\n    iters = 4\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001666651}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate, then minimize k. Lower is better.\n    # Input: list of 9 positive integers (colors). Colors may be any positive ints; we normalize to consecutive 1..k.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains 1..k consecutive colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _recolor_move(sol):\n        # DSATUR-guided recolor. If conflicts exist, allow k+1; otherwise keep feasibility (no new conflicts).\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            order = _dsatur_order(sol)\n            cset = set(conflicted)\n            cand = [v for v in order if v in cset]\n            v = cand[0] if cand else random.choice(conflicted)\n            allow_new = True\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        # Palette up to k (+1 only if allowed)\n        palette = list(range(1, current_k + (1 if allow_new else 0) + 1))\n        best_c = sol[v]\n        best_score = 10**9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts_here = 1 if c in forbidden else 0\n            if not conflicted and conflicts_here > 0:\n                # preserve feasibility when already conflict-free\n                continue\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts_here + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate highest color class without introducing conflicts.\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        # Multiple passes with greedy recolor and occasional Kempe swaps\n        for _ in range(3):\n            random.shuffle(verts)\n            changed = False\n            for v in list(verts):\n                if out[v] != target:\n                    continue\n                forbidden = {out[u] for u in adj[v]}\n                assigned = None\n                for c in range(1, target):\n                    if c not in forbidden:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # try Kempe swap with a random forbidden color to free a slot\n                    if forbidden:\n                        f = random.choice(list(forbidden))\n                        out2 = _kempe_swap(out, seed=v, pair=(target, f))\n                        forb2 = {out2[u] for u in adj[v]}\n                        for c in range(1, max(out2)):\n                            if c not in forb2:\n                                out = out2\n                                assigned = c\n                                break\n                if assigned is not None:\n                    out[v] = assigned\n                    changed = True\n            out = _normalize_colors(out)\n            if not changed:\n                break\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"NoOp\")\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"NoOp\")\n    sol = _normalize_colors(solution)\n\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return (_recolor_move(sol), \"Recolor\")\n        else:\n            return (_conflict_directed_kempe(sol), \"KempeSwap\")\n    else:\n        r = random.random()\n        if r < 0.55:\n            return (_eliminate_highest_color(sol), \"EliminateColor\")\n        elif r < 0.85:\n            return (_kempe_swap(sol), \"KempeSwap\")\n        else:\n            return (_recolor_move(sol), \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Prefer removing highest color class\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify\n    iters = 4\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002009375}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Feasibility-first fitness: conflicts dominate, then minimize k. Lower is better.\n    # Input: list of 9 positive integers (colors). Colors may be any positive ints; we normalize to consecutive 1..k.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PEN_INVALID)\n    cols = _normalize_colors(solution)\n    conflicts = 0\n    for (u, v) in _edges():\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n    k = len(set(cols))\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Maintains 1..k consecutive colors invariant.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _conflict_vertices(sol):\n        e = _edges()\n        n = len(sol)\n        conflict = [False]*n\n        for (u,v) in e:\n            if sol[u-1] == sol[v-1]:\n                conflict[u-1] = True\n                conflict[v-1] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def _dsatur_order(sol):\n        n = len(sol)\n        adj = _adj_list()\n        deg = [len(adj[i]) for i in range(n)]\n        used_colors = [set() for _ in range(n)]\n        for v in range(n):\n            for u in adj[v]:\n                used_colors[v].add(sol[u])\n        sat = [len(used_colors[v]) for v in range(n)]\n        order = list(range(n))\n        order.sort(key=lambda v:(-sat[v], -deg[v], random.random()))\n        return order\n    def _kempe_swap(sol, seed=None, pair=None):\n        n = len(sol)\n        if n == 0:\n            return sol\n        adj = _adj_list()\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if pair is None:\n            if seed is None:\n                seed = random.randrange(n)\n            c1 = sol[seed]\n            nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n            if nbr_colors:\n                c2 = random.choice(list(nbr_colors))\n            else:\n                c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c1, c2 = pair\n            if seed is None:\n                ix = [i for i,c in enumerate(sol) if c == c1 or c == c2]\n                if not ix:\n                    return sol\n                seed = random.choice(ix)\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == c1 or sol[u] == c2):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize_colors(out)\n    def _recolor_move(sol):\n        # DSATUR-guided recolor. If conflicts exist, allow k+1; otherwise keep feasibility (no new conflicts).\n        n = len(sol)\n        adj = _adj_list()\n        current_k = len(set(sol))\n        conflicted = _conflict_vertices(sol)\n        if conflicted:\n            order = _dsatur_order(sol)\n            cset = set(conflicted)\n            cand = [v for v in order if v in cset]\n            v = cand[0] if cand else random.choice(conflicted)\n            allow_new = True\n        else:\n            highest = max(sol)\n            high_vertices = [i for i,c in enumerate(sol) if c == highest]\n            order = _dsatur_order(sol)\n            hv_ordered = [v for v in order if v in set(high_vertices)]\n            v = hv_ordered[0] if hv_ordered else random.randrange(n)\n            allow_new = False\n        forbidden = {sol[u] for u in adj[v]}\n        # Palette up to k (+1 only if allowed)\n        palette = list(range(1, current_k + (1 if allow_new else 0) + 1))\n        best_c = sol[v]\n        best_score = 10**9\n        for c in palette:\n            if c == sol[v]:\n                continue\n            conflicts_here = 1 if c in forbidden else 0\n            if not conflicted and conflicts_here > 0:\n                # preserve feasibility when already conflict-free\n                continue\n            introduce_new = 1 if c > current_k else 0\n            score = 100*conflicts_here + 20*introduce_new + c*0.001\n            if score < best_score:\n                best_score = score\n                best_c = c\n        out = sol[:]\n        out[v] = best_c\n        return _normalize_colors(out)\n    def _eliminate_highest_color(sol):\n        # Attempt to eliminate highest color class without introducing conflicts.\n        adj = _adj_list()\n        k = len(set(sol))\n        if k <= 1:\n            return sol\n        target = max(sol)\n        out = sol[:]\n        verts = [i for i,c in enumerate(out) if c == target]\n        if not verts:\n            return out\n        # Multiple passes with greedy recolor and occasional Kempe swaps\n        for _ in range(3):\n            random.shuffle(verts)\n            changed = False\n            for v in list(verts):\n                if out[v] != target:\n                    continue\n                forbidden = {out[u] for u in adj[v]}\n                assigned = None\n                for c in range(1, target):\n                    if c not in forbidden:\n                        assigned = c\n                        break\n                if assigned is None:\n                    # try Kempe swap with a random forbidden color to free a slot\n                    if forbidden:\n                        f = random.choice(list(forbidden))\n                        out2 = _kempe_swap(out, seed=v, pair=(target, f))\n                        forb2 = {out2[u] for u in adj[v]}\n                        for c in range(1, max(out2)):\n                            if c not in forb2:\n                                out = out2\n                                assigned = c\n                                break\n                if assigned is not None:\n                    out[v] = assigned\n                    changed = True\n            out = _normalize_colors(out)\n            if not changed:\n                break\n        return _normalize_colors(out)\n    def _conflict_directed_kempe(sol):\n        conflicts = _conflict_vertices(sol)\n        if not conflicts:\n            return sol\n        maxc = max(sol)\n        cand = [v for v in conflicts if sol[v] == maxc]\n        seed = random.choice(cand if cand else conflicts)\n        return _kempe_swap(sol, seed=seed, pair=None)\n\n    # Input validation and normalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"NoOp\")\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"NoOp\")\n    sol = _normalize_colors(solution)\n\n    conflicts = _conflict_vertices(sol)\n    if conflicts:\n        r = random.random()\n        if r < 0.6:\n            return (_recolor_move(sol), \"Recolor\")\n        else:\n            return (_conflict_directed_kempe(sol), \"KempeSwap\")\n    else:\n        r = random.random()\n        if r < 0.55:\n            return (_eliminate_highest_color(sol), \"EliminateColor\")\n        elif r < 0.85:\n            return (_kempe_swap(sol), \"KempeSwap\")\n        else:\n            return (_recolor_move(sol), \"Recolor\")\n","Perturbacion":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Large-neighborhood perturbation: remove a color class, reinsert by DSATUR greedy, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n    def _normalize_colors(sol):\n        mapping = {}\n        next_color = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_color\n                next_color += 1\n            out.append(mapping[c])\n        return out\n    def _kempe_component_swap(sol, seed, a, b):\n        n = len(sol)\n        adj = _adj_list()\n        visited = [False]*n\n        q = deque([seed])\n        visited[seed] = True\n        component = []\n        while q:\n            v = q.popleft()\n            if sol[v] == a or sol[v] == b:\n                component.append(v)\n                for u in adj[v]:\n                    if not visited[u] and (sol[u] == a or sol[u] == b):\n                        visited[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in component:\n            out[v] = b if sol[v] == a else a\n        return _normalize_colors(out)\n    def _repair_dsatur(sol, unassigned):\n        # Greedy DSATUR reinsertion of vertices in 'unassigned' set\n        adj = _adj_list()\n        n = len(sol)\n        colored = [c if i not in unassigned else 0 for i,c in enumerate(sol)]\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize_colors(colored)\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize_colors(solution)\n\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Prefer removing highest color class\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    remove_set = [i for i,c in enumerate(sol) if c == target]\n    if not remove_set:\n        return sol\n    unassigned = set(remove_set)\n    for v in remove_set:\n        sol[v] = 0\n    sol = _repair_dsatur(sol, unassigned)\n\n    # Apply several Kempe shakes to diversify\n    iters = 4\n    for _ in range(iters):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        sol = _kempe_component_swap(sol, seed, a, b)\n\n    return _normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002243658}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Feasibility-first: lower is better. Penalize any invalid\/non-consecutive encoding.\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    # Enforce consecutive color indexing 1..k\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a single neighbor solution (list of ints) maintaining 1..k consecutive colors.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _is_consecutive(sol):\n        s = set(sol)\n        k = len(s)\n        return s == set(range(1, k+1))\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _score(sol, edges):\n        # Mirror evaluation without invalid penalties; assumes consecutive\n        return 10000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _recolor_best_of(sol, adj, edges, allow_new_color):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            # try to eliminate highest color\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        tried = 0\n        for v in cand_vertices:\n            forbidden = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            random.shuffle(palette)\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                if not allow_new_color and c in forbidden:\n                    continue\n                # do not introduce immediate conflict when already conflict-free\n                if not conflicted and c in forbidden:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                tried += 1\n                if tried >= 20:\n                    return best if best is not None else sol\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # Seed from conflicted vertex if any\n        edges = _edges()\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            # pick any different color\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        from collections import deque as _dq\n        vis = [False]*n\n        q = _dq([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Input validation and normalization to maintain representation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Decide move based on conflicts\n    if _conflicts_count(sol, edges) > 0:\n        # Try recolor without increasing colors first; if no improvement, allow k+1 rarely\n        out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n        if _score(out, edges) <= _score(sol, edges):\n            return out\n        if random.random() < 0.2:\n            return _recolor_best_of(sol, adj, edges, allow_new_color=True)\n        return _kempe_swap(sol, adj)\n    else:\n        # Conflict-free: try eliminate highest color or gentle Kempe\n        if random.random() < 0.7:\n            out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n            # Prefer solutions with fewer colors or equal colors and not worse\n            if (len(set(out)) < len(set(sol))) or (_score(out, edges) <= _score(sol, edges)):\n                return out\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: drop one color class and reinsert by DSATUR, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored has 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove a color class (prefer highest)\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if not verts:\n        return sol\n    colored = sol[:]\n    for v in verts:\n        colored[v] = 0\n    unassigned = set(verts)\n    sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply several Kempe shakes\n    shakes = 4\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001223085}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Feasibility-first: lower is better. Penalize any invalid\/non-consecutive encoding.\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    # Enforce consecutive color indexing 1..k\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a single neighbor solution (list of ints) maintaining 1..k consecutive colors.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _is_consecutive(sol):\n        s = set(sol)\n        k = len(s)\n        return s == set(range(1, k+1))\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _score(sol, edges):\n        # Mirror evaluation without invalid penalties; assumes consecutive\n        return 10000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _recolor_best_of(sol, adj, edges, allow_new_color):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            # try to eliminate highest color\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        tried = 0\n        for v in cand_vertices:\n            forbidden = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            random.shuffle(palette)\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                if not allow_new_color and c in forbidden:\n                    continue\n                # do not introduce immediate conflict when already conflict-free\n                if not conflicted and c in forbidden:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                tried += 1\n                if tried >= 20:\n                    return best if best is not None else sol\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # Seed from conflicted vertex if any\n        edges = _edges()\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            # pick any different color\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        from collections import deque as _dq\n        vis = [False]*n\n        q = _dq([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Input validation and normalization to maintain representation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Decide move based on conflicts\n    if _conflicts_count(sol, edges) > 0:\n        # Try recolor without increasing colors first; if no improvement, allow k+1 rarely\n        out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n        if _score(out, edges) <= _score(sol, edges):\n            return out\n        if random.random() < 0.2:\n            return _recolor_best_of(sol, adj, edges, allow_new_color=True)\n        return _kempe_swap(sol, adj)\n    else:\n        # Conflict-free: try eliminate highest color or gentle Kempe\n        if random.random() < 0.7:\n            out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n            # Prefer solutions with fewer colors or equal colors and not worse\n            if (len(set(out)) < len(set(sol))) or (_score(out, edges) <= _score(sol, edges)):\n                return out\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: drop one color class and reinsert by DSATUR, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored has 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove a color class (prefer highest)\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if not verts:\n        return sol\n    colored = sol[:]\n    for v in verts:\n        colored[v] = 0\n    unassigned = set(verts)\n    sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply several Kempe shakes\n    shakes = 4\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001616991}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Feasibility-first: lower is better. Penalize any invalid\/non-consecutive encoding.\n    PEN_INVALID = 1e12\n    PEN_CONFLICT = 10000.0\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    # Enforce consecutive color indexing 1..k\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a single neighbor solution (list of ints) maintaining 1..k consecutive colors.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _is_consecutive(sol):\n        s = set(sol)\n        k = len(s)\n        return s == set(range(1, k+1))\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _score(sol, edges):\n        # Mirror evaluation without invalid penalties; assumes consecutive\n        return 10000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _recolor_best_of(sol, adj, edges, allow_new_color):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            # try to eliminate highest color\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        tried = 0\n        for v in cand_vertices:\n            forbidden = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            random.shuffle(palette)\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                if not allow_new_color and c in forbidden:\n                    continue\n                # do not introduce immediate conflict when already conflict-free\n                if not conflicted and c in forbidden:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                tried += 1\n                if tried >= 20:\n                    return best if best is not None else sol\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        # Seed from conflicted vertex if any\n        edges = _edges()\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            # pick any different color\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        from collections import deque as _dq\n        vis = [False]*n\n        q = _dq([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Input validation and normalization to maintain representation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Decide move based on conflicts\n    if _conflicts_count(sol, edges) > 0:\n        # Try recolor without increasing colors first; if no improvement, allow k+1 rarely\n        out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n        if _score(out, edges) <= _score(sol, edges):\n            return out\n        if random.random() < 0.2:\n            return _recolor_best_of(sol, adj, edges, allow_new_color=True)\n        return _kempe_swap(sol, adj)\n    else:\n        # Conflict-free: try eliminate highest color or gentle Kempe\n        if random.random() < 0.7:\n            out = _recolor_best_of(sol, adj, edges, allow_new_color=False)\n            # Prefer solutions with fewer colors or equal colors and not worse\n            if (len(set(out)) < len(set(sol))) or (_score(out, edges) <= _score(sol, edges)):\n                return out\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: drop one color class and reinsert by DSATUR, then multiple Kempe shakes.\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored has 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            c2 = random.choice([c for c in colors if c != c1])\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove a color class (prefer highest)\n    target = max(colors) if random.random() < 0.7 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if not verts:\n        return sol\n    colored = sol[:]\n    for v in verts:\n        colored[v] = 0\n    unassigned = set(verts)\n    sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply several Kempe shakes\n    shakes = 4\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00161085}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Strongly penalize any infeasibility or invalid encoding.\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e9\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    # Enforce consecutive color indexing 1..k\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strong feasibility-first: any conflict dominates k\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n# Neighbor generator for graph coloring on fixed 9-vertex graph.\n# Returns (neighbor_solution_list, move_type_str)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _score(sol, edges):\n        return 1_000_000_000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        # Candidate vertices: conflicted first; otherwise try max color class\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        # Order by (degree, random tie-break), prefer higher degree\n        cand_vertices.sort(key=lambda v:(-len(adj[v]), random.random()))\n        best = None\n        best_move = None\n        best_score = float('inf')\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            # Try colors ordered to prefer lower indices to help k reduction\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                # If currently conflict-free, do not introduce conflicts\n                if not conflicted and c in forb:\n                    continue\n                # If conflicted, prefer colors not in forb; skip those that worsen conflicts\n                if c in forb:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                    best_move = \"recolor\"\n        return (best if best is not None else sol, (best_move if best_move is not None else \"recolor\"))\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol, \"kempe\"\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol, \"kempe\"\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out), \"kempe\"\n    def _color_elim(sol, adj, edges):\n        # Attempt to eliminate the highest color by greedy recoloring its vertices\n        k = max(sol)\n        target = k\n        verts = [i for i,c in enumerate(sol) if c == target]\n        if not verts:\n            return sol, \"color_elim\"\n        out = sol[:]\n        for v in verts:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, target):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, \"color_elim\"  # fail, return original\n        out = [c if c < target else c-1 for c in out]  # remove empty top color if any\n        return _normalize(out), \"color_elim\"\n    # Validate input and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"invalid\")\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Strategy: if conflicts>0, recolor best-improving; else try color elimination, else Kempe\n    if _conflicts_count(sol, edges) > 0:\n        neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return (neigh, mv)\n        # fallback Kempe\n        neigh, mv = _kempe_swap(sol, adj)\n        return (neigh, mv)\n    else:\n        # Conflict-free: prioritize reducing k\n        if random.random() < 0.7:\n            elim, mv = _color_elim(sol, adj, edges)\n            if elim != sol and max(elim) < max(sol):\n                return (elim, mv)\n        # gentle recolor to explore\n        if random.random() < 0.5:\n            neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return (neigh, mv)\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\n# Strong perturbation to escape local minima while preserving consecutive color encoding.\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored: list with 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove one color class (prefer the highest) and repair with DSATUR\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply multiple Kempe shakes to diversify\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001462178}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Strongly penalize any infeasibility or invalid encoding.\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e9\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    # Enforce consecutive color indexing 1..k\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strong feasibility-first: any conflict dominates k\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n# Neighbor generator for graph coloring on fixed 9-vertex graph.\n# Returns (neighbor_solution_list, move_type_str)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _score(sol, edges):\n        return 1_000_000_000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        # Candidate vertices: conflicted first; otherwise try max color class\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        # Order by (degree, random tie-break), prefer higher degree\n        cand_vertices.sort(key=lambda v:(-len(adj[v]), random.random()))\n        best = None\n        best_move = None\n        best_score = float('inf')\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            # Try colors ordered to prefer lower indices to help k reduction\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                # If currently conflict-free, do not introduce conflicts\n                if not conflicted and c in forb:\n                    continue\n                # If conflicted, prefer colors not in forb; skip those that worsen conflicts\n                if c in forb:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                    best_move = \"recolor\"\n        return (best if best is not None else sol, (best_move if best_move is not None else \"recolor\"))\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol, \"kempe\"\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol, \"kempe\"\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out), \"kempe\"\n    def _color_elim(sol, adj, edges):\n        # Attempt to eliminate the highest color by greedy recoloring its vertices\n        k = max(sol)\n        target = k\n        verts = [i for i,c in enumerate(sol) if c == target]\n        if not verts:\n            return sol, \"color_elim\"\n        out = sol[:]\n        for v in verts:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, target):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, \"color_elim\"  # fail, return original\n        out = [c if c < target else c-1 for c in out]  # remove empty top color if any\n        return _normalize(out), \"color_elim\"\n    # Validate input and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"invalid\")\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Strategy: if conflicts>0, recolor best-improving; else try color elimination, else Kempe\n    if _conflicts_count(sol, edges) > 0:\n        neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return (neigh, mv)\n        # fallback Kempe\n        neigh, mv = _kempe_swap(sol, adj)\n        return (neigh, mv)\n    else:\n        # Conflict-free: prioritize reducing k\n        if random.random() < 0.7:\n            elim, mv = _color_elim(sol, adj, edges)\n            if elim != sol and max(elim) < max(sol):\n                return (elim, mv)\n        # gentle recolor to explore\n        if random.random() < 0.5:\n            neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return (neigh, mv)\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\n# Strong perturbation to escape local minima while preserving consecutive color encoding.\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored: list with 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove one color class (prefer the highest) and repair with DSATUR\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply multiple Kempe shakes to diversify\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001759192}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Strongly penalize any infeasibility or invalid encoding.\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e9\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    # Enforce consecutive color indexing 1..k\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strong feasibility-first: any conflict dominates k\n    fitness = PEN_CONFLICT * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n# Neighbor generator for graph coloring on fixed 9-vertex graph.\n# Returns (neighbor_solution_list, move_type_str)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _score(sol, edges):\n        return 1_000_000_000.0 * _conflicts_count(sol, edges) + len(set(sol))\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        # Candidate vertices: conflicted first; otherwise try max color class\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc]\n            if not cand_vertices:\n                cand_vertices = list(range(n))\n        # Order by (degree, random tie-break), prefer higher degree\n        cand_vertices.sort(key=lambda v:(-len(adj[v]), random.random()))\n        best = None\n        best_move = None\n        best_score = float('inf')\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            # Try colors ordered to prefer lower indices to help k reduction\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                # If currently conflict-free, do not introduce conflicts\n                if not conflicted and c in forb:\n                    continue\n                # If conflicted, prefer colors not in forb; skip those that worsen conflicts\n                if c in forb:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                sc = _score(tmp, edges)\n                if sc < best_score:\n                    best = tmp\n                    best_score = sc\n                    best_move = \"recolor\"\n        return (best if best is not None else sol, (best_move if best_move is not None else \"recolor\"))\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol, \"kempe\"\n        conflicts = _conflict_vertices(sol, adj)\n        if conflicts:\n            seed = random.choice(conflicts)\n        else:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol, \"kempe\"\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out), \"kempe\"\n    def _color_elim(sol, adj, edges):\n        # Attempt to eliminate the highest color by greedy recoloring its vertices\n        k = max(sol)\n        target = k\n        verts = [i for i,c in enumerate(sol) if c == target]\n        if not verts:\n            return sol, \"color_elim\"\n        out = sol[:]\n        for v in verts:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, target):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, \"color_elim\"  # fail, return original\n        out = [c if c < target else c-1 for c in out]  # remove empty top color if any\n        return _normalize(out), \"color_elim\"\n    # Validate input and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (solution, \"invalid\")\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    # Strategy: if conflicts>0, recolor best-improving; else try color elimination, else Kempe\n    if _conflicts_count(sol, edges) > 0:\n        neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return (neigh, mv)\n        # fallback Kempe\n        neigh, mv = _kempe_swap(sol, adj)\n        return (neigh, mv)\n    else:\n        # Conflict-free: prioritize reducing k\n        if random.random() < 0.7:\n            elim, mv = _color_elim(sol, adj, edges)\n            if elim != sol and max(elim) < max(sol):\n                return (elim, mv)\n        # gentle recolor to explore\n        if random.random() < 0.5:\n            neigh, mv = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return (neigh, mv)\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\n# Strong perturbation to escape local minima while preserving consecutive color encoding.\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        # colored: list with 0 for unassigned vertices\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        if not nbr_colors:\n            other = [c for c in colors if c != c1]\n            if not other:\n                return sol\n            c2 = random.choice(other)\n        else:\n            c2 = random.choice(list(nbr_colors))\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    # Remove one color class (prefer the highest) and repair with DSATUR\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    # Apply multiple Kempe shakes to diversify\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001730502}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e6\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return float(PEN_CONFLICT * conflicts + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc] or list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        base_conf = _conflicts_count(sol, edges)\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                conf = _conflicts_count(tmp, edges)\n                # allow non-worsening conflicts; prefer fewer colors implicitly via normalize\n                if conf <= base_conf:\n                    sc = conf * 1_000_000 + len(set(tmp))\n                    if sc < best_score:\n                        best = tmp\n                        best_score = sc\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicts = _conflict_vertices(sol, adj)\n        seed = random.choice(conflicts) if conflicts else random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other_colors = [c for c in colors if c != c1]\n        if not nbr_colors and not other_colors:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other_colors)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    def _color_elim(sol, adj):\n        k = max(sol)\n        verts = [i for i,c in enumerate(sol) if c == k]\n        if not verts:\n            return sol\n        out = sol[:]\n        # DSATUR-like ordering for vertices in the target color\n        def sat_deg(v):\n            return len({out[u] for u in adj[v]})\n        order = sorted(verts, key=lambda v:(-sat_deg(v), -len(adj[v])))\n        for v in order:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, k):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol\n        out = [c if c < k else c-1 for c in out]\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    if _conflicts_count(sol, edges) > 0:\n        neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return neigh\n        return _kempe_swap(sol, adj)\n    else:\n        if random.random() < 0.8:\n            elim = _color_elim(sol, adj)\n            if max(elim) < max(sol):\n                return elim\n        # gentle exploration\n        if random.random() < 0.5:\n            neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return neigh\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other = [c for c in colors if c != c1]\n        if not nbr_colors and not other:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001351197}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e6\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return float(PEN_CONFLICT * conflicts + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc] or list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        base_conf = _conflicts_count(sol, edges)\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                conf = _conflicts_count(tmp, edges)\n                # allow non-worsening conflicts; prefer fewer colors implicitly via normalize\n                if conf <= base_conf:\n                    sc = conf * 1_000_000 + len(set(tmp))\n                    if sc < best_score:\n                        best = tmp\n                        best_score = sc\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicts = _conflict_vertices(sol, adj)\n        seed = random.choice(conflicts) if conflicts else random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other_colors = [c for c in colors if c != c1]\n        if not nbr_colors and not other_colors:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other_colors)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    def _color_elim(sol, adj):\n        k = max(sol)\n        verts = [i for i,c in enumerate(sol) if c == k]\n        if not verts:\n            return sol\n        out = sol[:]\n        # DSATUR-like ordering for vertices in the target color\n        def sat_deg(v):\n            return len({out[u] for u in adj[v]})\n        order = sorted(verts, key=lambda v:(-sat_deg(v), -len(adj[v])))\n        for v in order:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, k):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol\n        out = [c if c < k else c-1 for c in out]\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    if _conflicts_count(sol, edges) > 0:\n        neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return neigh\n        return _kempe_swap(sol, adj)\n    else:\n        if random.random() < 0.8:\n            elim = _color_elim(sol, adj)\n            if max(elim) < max(sol):\n                return elim\n        # gentle exploration\n        if random.random() < 0.5:\n            neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return neigh\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other = [c for c in colors if c != c1]\n        if not nbr_colors and not other:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001768752}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_9_CONSEC_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PEN_INVALID = 1e15\n    PEN_CONFLICT = 1e6\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    n = 9\n    if not isinstance(solution, list):\n        return float(PEN_INVALID)\n    if len(solution) != n:\n        return float(PEN_INVALID)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return float(PEN_INVALID)\n    colors = set(solution)\n    k = len(colors)\n    if colors != set(range(1, k+1)):\n        return float(PEN_INVALID)\n    conflicts = 0\n    for (u,v) in _edges():\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return float(PEN_CONFLICT * conflicts + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _conflicts_count(sol, edges):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def _conflict_vertices(sol, adj):\n        n = len(sol)\n        mark = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    mark[u] = True\n                    mark[v] = True\n        return [i for i,fl in enumerate(mark) if fl]\n    def _best_recolor_vertex(sol, adj, edges, allow_new_color=False):\n        n = len(sol)\n        k = len(set(sol))\n        conflicted = set(_conflict_vertices(sol, adj))\n        if conflicted:\n            cand_vertices = list(conflicted)\n        else:\n            maxc = max(sol)\n            cand_vertices = [i for i,c in enumerate(sol) if c == maxc] or list(range(n))\n        random.shuffle(cand_vertices)\n        best = None\n        best_score = float('inf')\n        base_conf = _conflicts_count(sol, edges)\n        for v in cand_vertices:\n            forb = {sol[u] for u in adj[v]}\n            palette = list(range(1, k + (1 if allow_new_color else 0) + 1))\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                tmp = sol[:]\n                tmp[v] = c\n                tmp = _normalize(tmp)\n                conf = _conflicts_count(tmp, edges)\n                # allow non-worsening conflicts; prefer fewer colors implicitly via normalize\n                if conf <= base_conf:\n                    sc = conf * 1_000_000 + len(set(tmp))\n                    if sc < best_score:\n                        best = tmp\n                        best_score = sc\n        return best if best is not None else sol\n    def _kempe_swap(sol, adj):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        conflicts = _conflict_vertices(sol, adj)\n        seed = random.choice(conflicts) if conflicts else random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other_colors = [c for c in colors if c != c1]\n        if not nbr_colors and not other_colors:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other_colors)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    def _color_elim(sol, adj):\n        k = max(sol)\n        verts = [i for i,c in enumerate(sol) if c == k]\n        if not verts:\n            return sol\n        out = sol[:]\n        # DSATUR-like ordering for vertices in the target color\n        def sat_deg(v):\n            return len({out[u] for u in adj[v]})\n        order = sorted(verts, key=lambda v:(-sat_deg(v), -len(adj[v])))\n        for v in order:\n            forb = {out[u] for u in adj[v]}\n            placed = False\n            for c in range(1, k):\n                if c not in forb:\n                    out[v] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol\n        out = [c if c < k else c-1 for c in out]\n        return _normalize(out)\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    edges = _edges()\n    if _conflicts_count(sol, edges) > 0:\n        neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n        if neigh != sol:\n            return neigh\n        return _kempe_swap(sol, adj)\n    else:\n        if random.random() < 0.8:\n            elim = _color_elim(sol, adj)\n            if max(elim) < max(sol):\n                return elim\n        # gentle exploration\n        if random.random() < 0.5:\n            neigh = _best_recolor_vertex(sol, adj, edges, allow_new_color=False)\n            if neigh != sol:\n                return neigh\n        return _kempe_swap(sol, adj)\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n    def _adj_list():\n        e = _edges()\n        n = 9\n        adj = [[] for _ in range(n)]\n        for (u,v) in e:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    def _dsatur_repair(colored, unassigned, adj):\n        def saturation(v):\n            return len({colored[u] for u in adj[v] if colored[u] != 0})\n        while unassigned:\n            v = max(unassigned, key=lambda x:(saturation(x), len(adj[x]), random.random()))\n            forb = {colored[u] for u in adj[v] if colored[u] != 0}\n            k = max(colored) if colored else 0\n            chosen = None\n            for c in range(1, k+1):\n                if c not in forb:\n                    chosen = c\n                    break\n            if chosen is None:\n                chosen = k+1\n            colored[v] = chosen\n            unassigned.remove(v)\n        return _normalize(colored)\n    def _kempe_swap(sol, adj, seed=None):\n        n = len(sol)\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol\n        if seed is None:\n            seed = random.randrange(n)\n        c1 = sol[seed]\n        nbr_colors = {sol[u] for u in adj[seed] if sol[u] != c1}\n        other = [c for c in colors if c != c1]\n        if not nbr_colors and not other:\n            return sol\n        c2 = random.choice(list(nbr_colors) or other)\n        vis = [False]*n\n        q = deque([seed])\n        vis[seed] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if sol[v] == c1 or sol[v] == c2:\n                comp.append(v)\n                for u in adj[v]:\n                    if not vis[u] and (sol[u] == c1 or sol[u] == c2):\n                        vis[u] = True\n                        q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = c2 if sol[v] == c1 else c1\n        return _normalize(out)\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return solution\n    sol = _normalize(solution)\n    adj = _adj_list()\n    colors = sorted(set(sol))\n    if not colors:\n        return sol\n    target = max(colors) if random.random() < 0.8 else random.choice(colors)\n    verts = [i for i,c in enumerate(sol) if c == target]\n    if verts:\n        colored = sol[:]\n        for v in verts:\n            colored[v] = 0\n        unassigned = set(verts)\n        sol = _dsatur_repair(colored, unassigned, adj)\n    shakes = 5\n    for _ in range(shakes):\n        seed = random.randrange(9)\n        sol = _kempe_swap(sol, adj, seed=seed)\n    return _normalize(sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002015696}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels must be contiguous 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: minimize k with penalties for violations and non-contiguous labels.\n    # Lower is better.\n    HARD_PEN = 10**9\n    GAP_PEN = 10**5\n    EDGE_PEN = 10**4\n    # Validate type\/length\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Validate values\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Graph edges embedded locally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Base objective: k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: colors must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += GAP_PEN\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += GAP_PEN\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += EDGE_PEN * conflicts\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator.\n    Returns a tuple (NB_Type, Movement_Type) as required.\n    Side-effect: mutates the provided solution list to a neighbouring solution.\n    Movement types implemented:\n      - (\"Recolor\", \"SingleVertex\"): change color of one vertex to an existing or new color\n      - (\"SwapColors\", \"Global\"): swap two color labels globally to encourage contiguity exploration\n    \"\"\"\n    # Validate basic structure defensively; if invalid, do nothing and declare a no-op recolor\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        try:\n            if int(x) != x or x < 1:\n                return (\"Recolor\", \"SingleVertex\")\n        except Exception:\n            return (\"Recolor\", \"SingleVertex\")\n    # Choose movement\n    move_roll = random.random()\n    if move_roll < 0.7:\n        # Single-vertex recolor\n        idx = random.randrange(9)\n        current_k = 0\n        for x in solution:\n            if x > current_k:\n                current_k = x\n        # candidate colors: 1..current_k (+ maybe current_k+1 to allow new color introduction)\n        allow_new = True\n        candidates = list(range(1, current_k + 1 + (1 if allow_new else 0)))\n        if solution[idx] in candidates:\n            candidates.remove(solution[idx])\n        if not candidates:\n            return (\"Recolor\", \"SingleVertex\")\n        new_color = random.choice(candidates)\n        solution[idx] = new_color\n        return (\"Recolor\", \"SingleVertex\")\n    else:\n        # Global swap of two colors\n        colors = sorted(set(int(x) for x in solution))\n        if len(colors) < 2:\n            return (\"SwapColors\", \"Global\")\n        a, b = random.sample(colors, 2)\n        if a == b:\n            return (\"SwapColors\", \"Global\")\n        for i in range(len(solution)):\n            if solution[i] == a:\n                solution[i] = b\n            elif solution[i] == b:\n                solution[i] = a\n        return (\"SwapColors\", \"Global\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed copy of the given solution by applying multiple random recolors\n    and occasional global color swaps. Does not modify the input list.\n    \"\"\"\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-length vector if malformed\n        sol = [1 + (i % 3) for i in range(9)]\n    else:\n        sol = [int(x) if int(x) == x and x >= 1 else 1 for x in solution]\n    res = sol[:]\n    # Determine number of perturbation steps\n    steps = 5 + random.randrange(6)  # 5..10\n    for _ in range(steps):\n        roll = random.random()\n        if roll < 0.75:\n            # recolor one vertex\n            idx = random.randrange(9)\n            k = 0\n            for x in res:\n                if x > k:\n                    k = x\n            candidates = list(range(1, k + 2))  # allow introducing k+1\n            if res[idx] in candidates:\n                candidates.remove(res[idx])\n            if candidates:\n                res[idx] = random.choice(candidates)\n        else:\n            # swap two colors globally\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(9):\n                    if res[i] == a:\n                        res[i] = b\n                    elif res[i] == b:\n                        res[i] = a\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000004361}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels must be contiguous 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: minimize k with penalties for violations and non-contiguous labels.\n    # Lower is better.\n    HARD_PEN = 10**9\n    GAP_PEN = 10**5\n    EDGE_PEN = 10**4\n    # Validate type\/length\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Validate values\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Graph edges embedded locally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Base objective: k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: colors must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += GAP_PEN\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += GAP_PEN\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += EDGE_PEN * conflicts\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator.\n    Returns a tuple (NB_Type, Movement_Type) as required.\n    Side-effect: mutates the provided solution list to a neighbouring solution.\n    Movement types implemented:\n      - (\"Recolor\", \"SingleVertex\"): change color of one vertex to an existing or new color\n      - (\"SwapColors\", \"Global\"): swap two color labels globally to encourage contiguity exploration\n    \"\"\"\n    # Validate basic structure defensively; if invalid, do nothing and declare a no-op recolor\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        try:\n            if int(x) != x or x < 1:\n                return (\"Recolor\", \"SingleVertex\")\n        except Exception:\n            return (\"Recolor\", \"SingleVertex\")\n    # Choose movement\n    move_roll = random.random()\n    if move_roll < 0.7:\n        # Single-vertex recolor\n        idx = random.randrange(9)\n        current_k = 0\n        for x in solution:\n            if x > current_k:\n                current_k = x\n        # candidate colors: 1..current_k (+ maybe current_k+1 to allow new color introduction)\n        allow_new = True\n        candidates = list(range(1, current_k + 1 + (1 if allow_new else 0)))\n        if solution[idx] in candidates:\n            candidates.remove(solution[idx])\n        if not candidates:\n            return (\"Recolor\", \"SingleVertex\")\n        new_color = random.choice(candidates)\n        solution[idx] = new_color\n        return (\"Recolor\", \"SingleVertex\")\n    else:\n        # Global swap of two colors\n        colors = sorted(set(int(x) for x in solution))\n        if len(colors) < 2:\n            return (\"SwapColors\", \"Global\")\n        a, b = random.sample(colors, 2)\n        if a == b:\n            return (\"SwapColors\", \"Global\")\n        for i in range(len(solution)):\n            if solution[i] == a:\n                solution[i] = b\n            elif solution[i] == b:\n                solution[i] = a\n        return (\"SwapColors\", \"Global\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed copy of the given solution by applying multiple random recolors\n    and occasional global color swaps. Does not modify the input list.\n    \"\"\"\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-length vector if malformed\n        sol = [1 + (i % 3) for i in range(9)]\n    else:\n        sol = [int(x) if int(x) == x and x >= 1 else 1 for x in solution]\n    res = sol[:]\n    # Determine number of perturbation steps\n    steps = 5 + random.randrange(6)  # 5..10\n    for _ in range(steps):\n        roll = random.random()\n        if roll < 0.75:\n            # recolor one vertex\n            idx = random.randrange(9)\n            k = 0\n            for x in res:\n                if x > k:\n                    k = x\n            candidates = list(range(1, k + 2))  # allow introducing k+1\n            if res[idx] in candidates:\n                candidates.remove(res[idx])\n            if candidates:\n                res[idx] = random.choice(candidates)\n        else:\n            # swap two colors globally\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(9):\n                    if res[i] == a:\n                        res[i] = b\n                    elif res[i] == b:\n                        res[i] = a\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00000179}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels must be contiguous 1..k","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Fitness: minimize k with penalties for violations and non-contiguous labels.\n    # Lower is better.\n    HARD_PEN = 10**9\n    GAP_PEN = 10**5\n    EDGE_PEN = 10**4\n    # Validate type\/length\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Validate values\n    try:\n        for x in solution:\n            if int(x) != x:\n                return float(HARD_PEN)\n            if x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n    # Graph edges embedded locally\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Base objective: k = max color used\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: colors must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += GAP_PEN\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += GAP_PEN\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += EDGE_PEN * conflicts\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator.\n    Returns a tuple (NB_Type, Movement_Type) as required.\n    Side-effect: mutates the provided solution list to a neighbouring solution.\n    Movement types implemented:\n      - (\"Recolor\", \"SingleVertex\"): change color of one vertex to an existing or new color\n      - (\"SwapColors\", \"Global\"): swap two color labels globally to encourage contiguity exploration\n    \"\"\"\n    # Validate basic structure defensively; if invalid, do nothing and declare a no-op recolor\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        try:\n            if int(x) != x or x < 1:\n                return (\"Recolor\", \"SingleVertex\")\n        except Exception:\n            return (\"Recolor\", \"SingleVertex\")\n    # Choose movement\n    move_roll = random.random()\n    if move_roll < 0.7:\n        # Single-vertex recolor\n        idx = random.randrange(9)\n        current_k = 0\n        for x in solution:\n            if x > current_k:\n                current_k = x\n        # candidate colors: 1..current_k (+ maybe current_k+1 to allow new color introduction)\n        allow_new = True\n        candidates = list(range(1, current_k + 1 + (1 if allow_new else 0)))\n        if solution[idx] in candidates:\n            candidates.remove(solution[idx])\n        if not candidates:\n            return (\"Recolor\", \"SingleVertex\")\n        new_color = random.choice(candidates)\n        solution[idx] = new_color\n        return (\"Recolor\", \"SingleVertex\")\n    else:\n        # Global swap of two colors\n        colors = sorted(set(int(x) for x in solution))\n        if len(colors) < 2:\n            return (\"SwapColors\", \"Global\")\n        a, b = random.sample(colors, 2)\n        if a == b:\n            return (\"SwapColors\", \"Global\")\n        for i in range(len(solution)):\n            if solution[i] == a:\n                solution[i] = b\n            elif solution[i] == b:\n                solution[i] = a\n        return (\"SwapColors\", \"Global\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed copy of the given solution by applying multiple random recolors\n    and occasional global color swaps. Does not modify the input list.\n    \"\"\"\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize a random feasible-length vector if malformed\n        sol = [1 + (i % 3) for i in range(9)]\n    else:\n        sol = [int(x) if int(x) == x and x >= 1 else 1 for x in solution]\n    res = sol[:]\n    # Determine number of perturbation steps\n    steps = 5 + random.randrange(6)  # 5..10\n    for _ in range(steps):\n        roll = random.random()\n        if roll < 0.75:\n            # recolor one vertex\n            idx = random.randrange(9)\n            k = 0\n            for x in res:\n                if x > k:\n                    k = x\n            candidates = list(range(1, k + 2))  # allow introducing k+1\n            if res[idx] in candidates:\n                candidates.remove(res[idx])\n            if candidates:\n                res[idx] = random.choice(candidates)\n        else:\n            # swap two colors globally\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for i in range(9):\n                    if res[i] == a:\n                        res[i] = b\n                    elif res[i] == b:\n                        res[i] = a\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00000105}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels are maintained contiguous 1..k via canonical relabeling after each move.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return float(HARD_PEN)\n        if x < 1:\n            return float(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in first-occurrence order\n    def canonical_relabel(sol):\n        mapping = {}\n        next_c = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            res.append(mapping[c])\n        return res\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color\n    Always applies canonical relabeling after a successful move to keep labels contiguous.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # BFS on subgraph induced by colors {c1,c2}\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        # swap colors on visited set\n        changed = False\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n                changed = True\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n                changed = True\n        return changed\n    # Build conflict set\n    conflicted = []\n    for v in range(1,10):\n        if conflicts_of_vertex(solution, v) > 0:\n            conflicted.append(v)\n    k = max(solution)\n    move_roll = random.random()\n    # Try RemoveColor occasionally when no conflicts (intensification)\n    if not conflicted and move_roll < 0.3 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # attempt greedy reassignment\n        feasible = True\n        for v in sorted(verts, key=lambda x: -len(adj[x])):\n            colors = list(range(1, target))\n            new_c, add = least_conflict_color(solution, v, colors)\n            if new_c is None or any(solution[nb-1] == new_c for nb in adj[v]):\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            canonical_relabel_inplace(solution)\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # if failed, revert by relabeling to maintain contiguity (no destructive tracking needed)\n        canonical_relabel_inplace(solution)\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        v = random.choice(conflicted)\n        colors = list(range(1, k+1))\n        new_c, add = least_conflict_color(solution, v, colors)\n        # with small probability, allow introducing k+1 if it strictly reduces conflicts at v\n        introduce_new = False\n        if (new_c is None or add > 0) and random.random() < 0.1:\n            introduce_new = True\n        if introduce_new:\n            solution[v-1] = k+1\n        elif new_c is not None:\n            solution[v-1] = new_c\n        # else leave as is\n        canonical_relabel_inplace(solution)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain move for diversification or when conflict-free but stuck on higher k\n    # Choose a vertex and a different color\n    v = random.randrange(1,10)\n    # pick a candidate color among existing colors different from current\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            kempe_chain_swap(solution, v, c2)\n            canonical_relabel_inplace(solution)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to a random existing color\n    idx = random.randrange(9)\n    choices = [c for c in range(1, k+1) if c != solution[idx]]\n    if choices:\n        solution[idx] = random.choice(choices)\n    canonical_relabel_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple conflict-guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        # build conflict list\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            # recolor a conflicted vertex with least-conflict color; occasionally allow new color\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, add = least_conflict_color(res, v, colors)\n            if (new_c is None or add > 0) and random.random() < 0.15:\n                res[v-1] = k+1\n            elif new_c is not None:\n                res[v-1] = new_c\n        else:\n            # Kempe chain diversification\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n        # keep labels contiguous\n        canonical_relabel_inplace(res)\n    return res\n","Resultados":[[1,2,3,2,1,3,2,2,3],3.0,[1,2,3,2,1,3,2,2,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002590903}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels are maintained contiguous 1..k via canonical relabeling after each move.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return float(HARD_PEN)\n        if x < 1:\n            return float(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in first-occurrence order\n    def canonical_relabel(sol):\n        mapping = {}\n        next_c = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            res.append(mapping[c])\n        return res\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color\n    Always applies canonical relabeling after a successful move to keep labels contiguous.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # BFS on subgraph induced by colors {c1,c2}\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        # swap colors on visited set\n        changed = False\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n                changed = True\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n                changed = True\n        return changed\n    # Build conflict set\n    conflicted = []\n    for v in range(1,10):\n        if conflicts_of_vertex(solution, v) > 0:\n            conflicted.append(v)\n    k = max(solution)\n    move_roll = random.random()\n    # Try RemoveColor occasionally when no conflicts (intensification)\n    if not conflicted and move_roll < 0.3 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # attempt greedy reassignment\n        feasible = True\n        for v in sorted(verts, key=lambda x: -len(adj[x])):\n            colors = list(range(1, target))\n            new_c, add = least_conflict_color(solution, v, colors)\n            if new_c is None or any(solution[nb-1] == new_c for nb in adj[v]):\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            canonical_relabel_inplace(solution)\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # if failed, revert by relabeling to maintain contiguity (no destructive tracking needed)\n        canonical_relabel_inplace(solution)\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        v = random.choice(conflicted)\n        colors = list(range(1, k+1))\n        new_c, add = least_conflict_color(solution, v, colors)\n        # with small probability, allow introducing k+1 if it strictly reduces conflicts at v\n        introduce_new = False\n        if (new_c is None or add > 0) and random.random() < 0.1:\n            introduce_new = True\n        if introduce_new:\n            solution[v-1] = k+1\n        elif new_c is not None:\n            solution[v-1] = new_c\n        # else leave as is\n        canonical_relabel_inplace(solution)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain move for diversification or when conflict-free but stuck on higher k\n    # Choose a vertex and a different color\n    v = random.randrange(1,10)\n    # pick a candidate color among existing colors different from current\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            kempe_chain_swap(solution, v, c2)\n            canonical_relabel_inplace(solution)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to a random existing color\n    idx = random.randrange(9)\n    choices = [c for c in range(1, k+1) if c != solution[idx]]\n    if choices:\n        solution[idx] = random.choice(choices)\n    canonical_relabel_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple conflict-guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        # build conflict list\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            # recolor a conflicted vertex with least-conflict color; occasionally allow new color\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, add = least_conflict_color(res, v, colors)\n            if (new_c is None or add > 0) and random.random() < 0.15:\n                res[v-1] = k+1\n            elif new_c is not None:\n                res[v-1] = new_c\n        else:\n            # Kempe chain diversification\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n        # keep labels contiguous\n        canonical_relabel_inplace(res)\n    return res\n","Resultados":["Kempe",1000000000000.0,[1,2,3,1,2,3,2,1,3],3.0],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004492406}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS; solution[i-1] is color in {1..k} for vertex i; labels are maintained contiguous 1..k via canonical relabeling after each move.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return float(HARD_PEN)\n        if x < 1:\n            return float(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in first-occurrence order\n    def canonical_relabel(sol):\n        mapping = {}\n        next_c = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            res.append(mapping[c])\n        return res\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return float(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color\n    Always applies canonical relabeling after a successful move to keep labels contiguous.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # BFS on subgraph induced by colors {c1,c2}\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        # swap colors on visited set\n        changed = False\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n                changed = True\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n                changed = True\n        return changed\n    # Build conflict set\n    conflicted = []\n    for v in range(1,10):\n        if conflicts_of_vertex(solution, v) > 0:\n            conflicted.append(v)\n    k = max(solution)\n    move_roll = random.random()\n    # Try RemoveColor occasionally when no conflicts (intensification)\n    if not conflicted and move_roll < 0.3 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # attempt greedy reassignment\n        feasible = True\n        for v in sorted(verts, key=lambda x: -len(adj[x])):\n            colors = list(range(1, target))\n            new_c, add = least_conflict_color(solution, v, colors)\n            if new_c is None or any(solution[nb-1] == new_c for nb in adj[v]):\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            canonical_relabel_inplace(solution)\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # if failed, revert by relabeling to maintain contiguity (no destructive tracking needed)\n        canonical_relabel_inplace(solution)\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        v = random.choice(conflicted)\n        colors = list(range(1, k+1))\n        new_c, add = least_conflict_color(solution, v, colors)\n        # with small probability, allow introducing k+1 if it strictly reduces conflicts at v\n        introduce_new = False\n        if (new_c is None or add > 0) and random.random() < 0.1:\n            introduce_new = True\n        if introduce_new:\n            solution[v-1] = k+1\n        elif new_c is not None:\n            solution[v-1] = new_c\n        # else leave as is\n        canonical_relabel_inplace(solution)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain move for diversification or when conflict-free but stuck on higher k\n    # Choose a vertex and a different color\n    v = random.randrange(1,10)\n    # pick a candidate color among existing colors different from current\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            kempe_chain_swap(solution, v, c2)\n            canonical_relabel_inplace(solution)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to a random existing color\n    idx = random.randrange(9)\n    choices = [c for c in range(1, k+1) if c != solution[idx]]\n    if choices:\n        solution[idx] = random.choice(choices)\n    canonical_relabel_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple conflict-guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonical_relabel_inplace(sol):\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, colors):\n        best_c = None\n        best_val = 10**9\n        cur = sol[v-1]\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_c = c\n        return best_c, best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        # build conflict list\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            # recolor a conflicted vertex with least-conflict color; occasionally allow new color\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, add = least_conflict_color(res, v, colors)\n            if (new_c is None or add > 0) and random.random() < 0.15:\n                res[v-1] = k+1\n            elif new_c is not None:\n                res[v-1] = new_c\n        else:\n            # Kempe chain diversification\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n        # keep labels contiguous\n        canonical_relabel_inplace(res)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00151392}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS: solution[i-1] in {1..k} for vertex i; contiguous labels enforced by evaluation canonical relabeling.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors if non-worsening on edge conflicts\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with rollback on failure\n    Canonical relabeling is NOT applied here to preserve move semantics; evaluation will canonicalize.\n    Colors are capped to Kmax to prevent unbounded growth.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonworsen(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # component in subgraph induced by colors {c1,c2}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = total_conflicts(sol)\n        # apply swap on a copy to test\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = total_conflicts(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    Kmax = max(4, k)  # hard cap; we avoid introducing new colors in neighbour\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # order by degree descending (DSATUR-like on subproblem)\n        order = sorted(verts, key=lambda x: -len(adj[x]))\n        original = solution[:]\n        feasible = True\n        for v in order:\n            # try colors 1..target-1 by least-conflict with randomized ties, but ensure feasibility\n            new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n            # ensure no conflict after assignment\n            ok = True\n            for nb in adj[v]:\n                if solution[nb-1] == new_c:\n                    ok = False\n                    break\n            if not ok:\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # rollback on failure\n        for i in range(9):\n            solution[i] = original[i]\n        # fall through to other moves\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.7:\n        # pick a vertex among the top-conflict ones (stochastic greedy)\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c >= max_cf - 1]  # top band\n        v = random.choice(top)\n        colors = list(range(1, min(Kmax, k) + 1))  # restrict within existing colors\n        new_c, _ = least_conflict_color(solution, v, colors)\n        solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonworsen(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":[[3,2,1,3,2,1,2,3,1],3,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001935955}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS: solution[i-1] in {1..k} for vertex i; contiguous labels enforced by evaluation canonical relabeling.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors if non-worsening on edge conflicts\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with rollback on failure\n    Canonical relabeling is NOT applied here to preserve move semantics; evaluation will canonicalize.\n    Colors are capped to Kmax to prevent unbounded growth.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonworsen(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # component in subgraph induced by colors {c1,c2}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = total_conflicts(sol)\n        # apply swap on a copy to test\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = total_conflicts(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    Kmax = max(4, k)  # hard cap; we avoid introducing new colors in neighbour\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # order by degree descending (DSATUR-like on subproblem)\n        order = sorted(verts, key=lambda x: -len(adj[x]))\n        original = solution[:]\n        feasible = True\n        for v in order:\n            # try colors 1..target-1 by least-conflict with randomized ties, but ensure feasibility\n            new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n            # ensure no conflict after assignment\n            ok = True\n            for nb in adj[v]:\n                if solution[nb-1] == new_c:\n                    ok = False\n                    break\n            if not ok:\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # rollback on failure\n        for i in range(9):\n            solution[i] = original[i]\n        # fall through to other moves\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.7:\n        # pick a vertex among the top-conflict ones (stochastic greedy)\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c >= max_cf - 1]  # top band\n        v = random.choice(top)\n        colors = list(range(1, min(Kmax, k) + 1))  # restrict within existing colors\n        new_c, _ = least_conflict_color(solution, v, colors)\n        solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonworsen(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":["Kempe",1000000000000,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004460207}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS: solution[i-1] in {1..k} for vertex i; contiguous labels enforced by evaluation canonical relabeling.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange between two colors if non-worsening on edge conflicts\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with rollback on failure\n    Canonical relabeling is NOT applied here to preserve move semantics; evaluation will canonicalize.\n    Colors are capped to Kmax to prevent unbounded growth.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op recolor meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonworsen(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        # component in subgraph induced by colors {c1,c2}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = total_conflicts(sol)\n        # apply swap on a copy to test\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = total_conflicts(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    Kmax = max(4, k)  # hard cap; we avoid introducing new colors in neighbour\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        # order by degree descending (DSATUR-like on subproblem)\n        order = sorted(verts, key=lambda x: -len(adj[x]))\n        original = solution[:]\n        feasible = True\n        for v in order:\n            # try colors 1..target-1 by least-conflict with randomized ties, but ensure feasibility\n            new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n            # ensure no conflict after assignment\n            ok = True\n            for nb in adj[v]:\n                if solution[nb-1] == new_c:\n                    ok = False\n                    break\n            if not ok:\n                feasible = False\n                break\n            solution[v-1] = new_c\n        if feasible:\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # rollback on failure\n        for i in range(9):\n            solution[i] = original[i]\n        # fall through to other moves\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.7:\n        # pick a vertex among the top-conflict ones (stochastic greedy)\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c >= max_cf - 1]  # top band\n        v = random.choice(top)\n        colors = list(range(1, min(Kmax, k) + 1))  # restrict within existing colors\n        new_c, _ = least_conflict_color(solution, v, colors)\n        solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonworsen(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 4 + random.randrange(4)  # 4..7\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001607}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_CANON_BY_EVAL: solution is a list of 9 positive integers; vertex i uses solution[i-1]. Evaluation canonically relabels colors to 1..k to enforce contiguity.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange accepted if non-worsening on (conflicts*W + k)\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with guarded repair; rollback on failure\n    Canonical relabeling is NOT applied here; evaluation will canonicalize. Operators avoid introducing new colors.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def fitness_pair(sol):\n        # proxy for evaluate: conflicts*W + k, W large\n        W = 10**6\n        return total_conflicts(sol) * W + max(sol)\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonnw(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = fitness_pair(sol)\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = fitness_pair(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = max(solution)\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if len(verts) > 0:\n            order = sorted(verts, key=lambda x: (-len(adj[x]), x))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                # try colors 1..target-1 by least-conflict with randomized ties, ensure feasibility locally\n                new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n                ok = True\n                for nb in adj[v]:\n                    if solution[nb-1] == new_c:\n                        ok = False\n                        break\n                if not ok:\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback on failure or no k decrease\n            for i in range(9):\n                solution[i] = original[i]\n        # fall through\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c == max_cf]\n        v = random.choice(top)\n        colors = list(range(1, k+1))\n        new_c, new_cost = least_conflict_color(solution, v, colors)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonnw(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 5 + random.randrange(4)  # 5..8\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":[[1,3,2,3,1,2,3,3,2],3,[1,3,2,3,1,2,3,3,2],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002058506}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_CANON_BY_EVAL: solution is a list of 9 positive integers; vertex i uses solution[i-1]. Evaluation canonically relabels colors to 1..k to enforce contiguity.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange accepted if non-worsening on (conflicts*W + k)\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with guarded repair; rollback on failure\n    Canonical relabeling is NOT applied here; evaluation will canonicalize. Operators avoid introducing new colors.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def fitness_pair(sol):\n        # proxy for evaluate: conflicts*W + k, W large\n        W = 10**6\n        return total_conflicts(sol) * W + max(sol)\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonnw(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = fitness_pair(sol)\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = fitness_pair(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = max(solution)\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if len(verts) > 0:\n            order = sorted(verts, key=lambda x: (-len(adj[x]), x))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                # try colors 1..target-1 by least-conflict with randomized ties, ensure feasibility locally\n                new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n                ok = True\n                for nb in adj[v]:\n                    if solution[nb-1] == new_c:\n                        ok = False\n                        break\n                if not ok:\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback on failure or no k decrease\n            for i in range(9):\n                solution[i] = original[i]\n        # fall through\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c == max_cf]\n        v = random.choice(top)\n        colors = list(range(1, k+1))\n        new_c, new_cost = least_conflict_color(solution, v, colors)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonnw(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 5 + random.randrange(4)  # 5..8\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":["Kempe",1000000000000,[2,3,1,3,2,1,3,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004325485}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_CANON_BY_EVAL: solution is a list of 9 positive integers; vertex i uses solution[i-1]. Evaluation canonically relabels colors to 1..k to enforce contiguity.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns integer fitness (lower is better): fitness = conflicts*W + k, with W large.\n    Enforces: solution is a list of 9 positive ints; labels are canonically relabeled to 1..k.\n    Graph is embedded locally.\n    \"\"\"\n    HARD_PEN = 10**12\n    W = 10**6  # weight for conflicts\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n    # Value checks: strictly integers >=1\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Canonical relabel to 1..k in increasing color order for stability\n    def canonical_relabel(sol):\n        colors = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(colors)}\n        return [mapping[c] for c in sol]\n    sol = canonical_relabel(solution)\n    # Compute conflicts and k\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbour generator. Mutates 'solution' list and returns a tuple describing the move.\n    Movement types:\n      - (\"Recolor\", \"SingleVertex\"): conflict-guided least-conflict recolor with randomized tie-breaking\n      - (\"Kempe\", \"ChainSwap\"): Kempe chain interchange accepted if non-worsening on (conflicts*W + k)\n      - (\"RemoveColor\", \"GreedyRepair\"): try to eliminate the maximum color with guarded repair; rollback on failure\n    Canonical relabeling is NOT applied here; evaluation will canonicalize. Operators avoid introducing new colors.\n    \"\"\"\n    # Defensive: ensure proper structure; otherwise, no-op meta\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Local graph structures\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def fitness_pair(sol):\n        # proxy for evaluate: conflicts*W + k, W large\n        W = 10**6\n        return total_conflicts(sol) * W + max(sol)\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap_if_nonnw(sol, v, c2):\n        # returns True if applied, False otherwise\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        before = fitness_pair(sol)\n        tmp = sol[:]\n        for u in visited:\n            tmp[u-1] = c2 if tmp[u-1] == c1 else (c1 if tmp[u-1] == c2 else tmp[u-1])\n        after = fitness_pair(tmp)\n        if after <= before:\n            for u in visited:\n                sol[u-1] = c2 if sol[u-1] == c1 else (c1 if sol[u-1] == c2 else sol[u-1])\n            return True\n        return False\n    # Build conflict set and current k\n    conflicted = [v for v in range(1,10) if conflicts_of_vertex(solution, v) > 0]\n    k = max(solution)\n    move_roll = random.random()\n    # Attempt RemoveColor when conflict-free and k>1 with small probability\n    if not conflicted and k > 1 and move_roll < 0.25:\n        target = max(solution)\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if len(verts) > 0:\n            order = sorted(verts, key=lambda x: (-len(adj[x]), x))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                # try colors 1..target-1 by least-conflict with randomized ties, ensure feasibility locally\n                new_c, _ = least_conflict_color(solution, v, list(range(1, target)))\n                ok = True\n                for nb in adj[v]:\n                    if solution[nb-1] == new_c:\n                        ok = False\n                        break\n                if not ok:\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback on failure or no k decrease\n            for i in range(9):\n                solution[i] = original[i]\n        # fall through\n    # Conflict-guided recolor (primary move)\n    if conflicted and move_roll < 0.75:\n        cf_counts = [(v, conflicts_of_vertex(solution, v)) for v in conflicted]\n        max_cf = max(c for _, c in cf_counts)\n        top = [v for v,c in cf_counts if c == max_cf]\n        v = random.choice(top)\n        colors = list(range(1, k+1))\n        new_c, new_cost = least_conflict_color(solution, v, colors)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification or non-worsening move\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        current_c = solution[v-1]\n        other_choices = [c for c in colors if c != current_c]\n        if other_choices:\n            c2 = random.choice(other_choices)\n            applied = kempe_chain_swap_if_nonnw(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: trivial recolor to an existing different color\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if choices:\n        solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY of the given solution by applying multiple guided moves\n    (recolors and Kempe chains). Input is not modified.\n    \"\"\"\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Local graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_of_vertex(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, colors):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in colors:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 5 + random.randrange(4)  # 5..8\n    for _ in range(steps):\n        conflicted = [v for v in range(1,10) if conflicts_of_vertex(res, v) > 0]\n        k = max(res)\n        roll = random.random()\n        if conflicted and roll < 0.6:\n            v = random.choice(conflicted)\n            colors = list(range(1, k+1))\n            new_c, _ = least_conflict_color(res, v, colors)\n            res[v-1] = new_c\n        else:\n            v = random.randrange(1,10)\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_chain_swap(res, v, c2)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00159163}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): least-conflict recolor; may introduce k+1 if stuck.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free.\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return True\n    # Build state\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # Attempt deterministic RemoveColor if conflict-free\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            order = sorted(verts, key=lambda v: (-len(set(solution[nb-1] for nb in adj[v])), -len(adj[v]), v))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                new_c, _ = least_conflict_color(solution, v, palette)\n                if any(solution[nb-1] == new_c for nb in adj[v]):\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through if failed\n    # Conflict-guided recolor primary\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # choose vertex by highest conflict then degree\n        cf = [(v, vertex_conflicts(solution, v), len(adj[v])) for v in conflicted]\n        best_cf = max(cf, key=lambda t: (t[1], t[2]))[1]\n        cand = [v for v,c,deg in cf if c == best_cf]\n        v = random.choice(cand)\n        palette = list(range(1, k+1))\n        # allow introducing new color if k==1 or no improvement possible\n        if k == 1 or all(solution[nb-1] != c for c in palette for nb in adj[v]):\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            applied = kempe_chain_swap(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor within current palette\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if not choices:\n        choices = [1]\n    solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Input is not modified.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        conflicted = [v for v in range(1,10) if vertex_conflicts(res, v) > 0]\n        roll = random.random()\n        if roll < 0.55:\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                # focus on max color to promote k reduction\n                maxc = max(res)\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            palette = list(range(1, k+1))\n            if k == 1 and conflicted:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = new_c\n        else:\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":[[3,1,2,1,3,2,1,1,2],3,[3,1,2,1,3,2,1,1,2],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002087277}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): least-conflict recolor; may introduce k+1 if stuck.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free.\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return True\n    # Build state\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # Attempt deterministic RemoveColor if conflict-free\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            order = sorted(verts, key=lambda v: (-len(set(solution[nb-1] for nb in adj[v])), -len(adj[v]), v))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                new_c, _ = least_conflict_color(solution, v, palette)\n                if any(solution[nb-1] == new_c for nb in adj[v]):\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through if failed\n    # Conflict-guided recolor primary\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # choose vertex by highest conflict then degree\n        cf = [(v, vertex_conflicts(solution, v), len(adj[v])) for v in conflicted]\n        best_cf = max(cf, key=lambda t: (t[1], t[2]))[1]\n        cand = [v for v,c,deg in cf if c == best_cf]\n        v = random.choice(cand)\n        palette = list(range(1, k+1))\n        # allow introducing new color if k==1 or no improvement possible\n        if k == 1 or all(solution[nb-1] != c for c in palette for nb in adj[v]):\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            applied = kempe_chain_swap(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor within current palette\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if not choices:\n        choices = [1]\n    solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Input is not modified.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        conflicted = [v for v in range(1,10) if vertex_conflicts(res, v) > 0]\n        roll = random.random()\n        if roll < 0.55:\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                # focus on max color to promote k reduction\n                maxc = max(res)\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            palette = list(range(1, k+1))\n            if k == 1 and conflicted:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = new_c\n        else:\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":["Kempe",1000000000001,[2,3,1,3,2,1,3,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.005092735}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): least-conflict recolor; may introduce k+1 if stuck.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free.\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (\"Recolor\", \"SingleVertex\")\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return False\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return True\n    # Build state\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # Attempt deterministic RemoveColor if conflict-free\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            order = sorted(verts, key=lambda v: (-len(set(solution[nb-1] for nb in adj[v])), -len(adj[v]), v))\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                new_c, _ = least_conflict_color(solution, v, palette)\n                if any(solution[nb-1] == new_c for nb in adj[v]):\n                    feasible = False\n                    break\n                solution[v-1] = new_c\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through if failed\n    # Conflict-guided recolor primary\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # choose vertex by highest conflict then degree\n        cf = [(v, vertex_conflicts(solution, v), len(adj[v])) for v in conflicted]\n        best_cf = max(cf, key=lambda t: (t[1], t[2]))[1]\n        cand = [v for v,c,deg in cf if c == best_cf]\n        v = random.choice(cand)\n        palette = list(range(1, k+1))\n        # allow introducing new color if k==1 or no improvement possible\n        if k == 1 or all(solution[nb-1] != c for c in palette for nb in adj[v]):\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        if new_c != solution[v-1]:\n            solution[v-1] = new_c\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            applied = kempe_chain_swap(solution, v, c2)\n            if applied:\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor within current palette\n    idx = random.randrange(9)\n    cur = solution[idx]\n    choices = [c for c in range(1, k+1) if c != cur]\n    if not choices:\n        choices = [1]\n    solution[idx] = random.choice(choices)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Input is not modified.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def total_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        return random.choice(best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        conflicted = [v for v in range(1,10) if vertex_conflicts(res, v) > 0]\n        roll = random.random()\n        if roll < 0.55:\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                # focus on max color to promote k reduction\n                maxc = max(res)\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            palette = list(range(1, k+1))\n            if k == 1 and conflicted:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = new_c\n        else:\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001669901}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; introduces k+1 iff no conflict-free color exists.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with local repair.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free via safe reassignment with rollback.\n    Assumes 'solution' is a mutable list of length 9 with ints >=1; clamps outputs to >=1.\n    \"\"\"\n    # Validate minimal shape; if invalid, nothing done but metadata returned\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # Bias toward smaller colors to promote k reduction\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair(sol, touched):\n        # Greedy fix for any new conflicts on touched vertices\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            palette = list(range(1, kcur+1))\n            allowed = [c for c in palette if c not in neighbour_colors(sol, v)]\n            if not allowed:\n                palette.append(kcur+1)\n                cnew, _ = least_conflict_color(sol, v, palette)\n                sol[v-1] = max(1, cnew)\n            else:\n                sol[v-1] = min(allowed)\n    # State\n    k = max(solution)\n    # If conflict-free, attempt to remove max color deterministically\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # Order by DSATUR proxy: unique neighbor colors count, then degree desc\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                allowed = [c for c in palette if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through\n    # Main path: DSATUR-guided recolor with correct k+1 introduction\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # DSATUR-like selection: prioritize higher saturation, then more conflicts, then degree\n        sat = []\n        for v in conflicted:\n            sat.append((v, len({solution[nb-1] for nb in adj[v]}), vertex_conflicts(solution, v), len(adj[v])))\n        best_sat = max(sat, key=lambda t: (t[1], t[2], t[3]))[1:]\n        cand = [v for (v,s,cfg,deg) in sat if (s,cfg,deg) == best_sat]\n        v = random.choice(cand)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain for diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            if touched:\n                local_repair(solution, touched)\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: simple recolor within current palette, prefer smallest non-conflicting color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # allow new color if absolutely necessary\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        # With probability, try to recolor conflicted or max-color vertices\n        if random.random() < 0.6:\n            # target a conflicted vertex if any; else one with max color\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                maxc = k\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification between two existing colors\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":[[3,1,2,3,1,2,1,3,2],3,[3,1,2,3,1,2,1,3,2],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002295429}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; introduces k+1 iff no conflict-free color exists.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with local repair.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free via safe reassignment with rollback.\n    Assumes 'solution' is a mutable list of length 9 with ints >=1; clamps outputs to >=1.\n    \"\"\"\n    # Validate minimal shape; if invalid, nothing done but metadata returned\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # Bias toward smaller colors to promote k reduction\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair(sol, touched):\n        # Greedy fix for any new conflicts on touched vertices\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            palette = list(range(1, kcur+1))\n            allowed = [c for c in palette if c not in neighbour_colors(sol, v)]\n            if not allowed:\n                palette.append(kcur+1)\n                cnew, _ = least_conflict_color(sol, v, palette)\n                sol[v-1] = max(1, cnew)\n            else:\n                sol[v-1] = min(allowed)\n    # State\n    k = max(solution)\n    # If conflict-free, attempt to remove max color deterministically\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # Order by DSATUR proxy: unique neighbor colors count, then degree desc\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                allowed = [c for c in palette if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through\n    # Main path: DSATUR-guided recolor with correct k+1 introduction\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # DSATUR-like selection: prioritize higher saturation, then more conflicts, then degree\n        sat = []\n        for v in conflicted:\n            sat.append((v, len({solution[nb-1] for nb in adj[v]}), vertex_conflicts(solution, v), len(adj[v])))\n        best_sat = max(sat, key=lambda t: (t[1], t[2], t[3]))[1:]\n        cand = [v for (v,s,cfg,deg) in sat if (s,cfg,deg) == best_sat]\n        v = random.choice(cand)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain for diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            if touched:\n                local_repair(solution, touched)\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: simple recolor within current palette, prefer smallest non-conflicting color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # allow new color if absolutely necessary\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        # With probability, try to recolor conflicted or max-color vertices\n        if random.random() < 0.6:\n            # target a conflicted vertex if any; else one with max color\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                maxc = k\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification between two existing colors\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":["Kempe",1000000000001,[2,1,3,1,2,3,1,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.005119686}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS_CONTIGUOUS_ENFORCED_BY_EVAL","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; introduces k+1 iff no conflict-free color exists.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with local repair.\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color when conflict-free via safe reassignment with rollback.\n    Assumes 'solution' is a mutable list of length 9 with ints >=1; clamps outputs to >=1.\n    \"\"\"\n    # Validate minimal shape; if invalid, nothing done but metadata returned\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # Bias toward smaller colors to promote k reduction\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair(sol, touched):\n        # Greedy fix for any new conflicts on touched vertices\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            palette = list(range(1, kcur+1))\n            allowed = [c for c in palette if c not in neighbour_colors(sol, v)]\n            if not allowed:\n                palette.append(kcur+1)\n                cnew, _ = least_conflict_color(sol, v, palette)\n                sol[v-1] = max(1, cnew)\n            else:\n                sol[v-1] = min(allowed)\n    # State\n    k = max(solution)\n    # If conflict-free, attempt to remove max color deterministically\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # Order by DSATUR proxy: unique neighbor colors count, then degree desc\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            original = solution[:]\n            feasible = True\n            for v in order:\n                palette = list(range(1, target))\n                allowed = [c for c in palette if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback\n            for i in range(9):\n                solution[i] = original[i]\n        # fall-through\n    # Main path: DSATUR-guided recolor with correct k+1 introduction\n    roll = random.random()\n    if conflicted and roll < 0.7:\n        # DSATUR-like selection: prioritize higher saturation, then more conflicts, then degree\n        sat = []\n        for v in conflicted:\n            sat.append((v, len({solution[nb-1] for nb in adj[v]}), vertex_conflicts(solution, v), len(adj[v])))\n        best_sat = max(sat, key=lambda t: (t[1], t[2], t[3]))[1:]\n        cand = [v for (v,s,cfg,deg) in sat if (s,cfg,deg) == best_sat]\n        v = random.choice(cand)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Kempe chain for diversification\n    colors = sorted(set(solution))\n    if len(colors) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            if touched:\n                local_repair(solution, touched)\n                return (\"Kempe\", \"ChainSwap\")\n    # Fallback: simple recolor within current palette, prefer smallest non-conflicting color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # allow new color if absolutely necessary\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    res = base[:]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 7 + random.randrange(5)  # 7..11\n    for _ in range(steps):\n        k = max(res)\n        # With probability, try to recolor conflicted or max-color vertices\n        if random.random() < 0.6:\n            # target a conflicted vertex if any; else one with max color\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                maxc = k\n                cand = [i for i,c in enumerate(res, start=1) if c == maxc]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification between two existing colors\n            colors = sorted(set(res))\n            if len(colors) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001787902}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. Each index i in [0..8] corresponds to vertex i+1. Colors are positive integers; evaluation canonically relabels to contiguous {1..k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; allows k+1 only if no color fits.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with bounded local repair (no k increase).\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color with rollback.\n    Mutates 'solution' list in place as per required signature returning metadata only.\n    Safeguards: validates and canonicalizes solution to contiguous labels 1..k at entry.\n    \"\"\"\n    # Minimal validation and canonicalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonical relabel to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair_no_inflate(sol, touched):\n        # Attempt to resolve conflicts on touched set without increasing k\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            # Try smallest non-neighbor color within 1..kcur\n            allowed = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, v)]\n            if allowed:\n                sol[v-1] = min(allowed)\n            else:\n                # As last resort try recoloring one conflicting neighbor to any non-neighbor color <= kcur\n                for nb in adj[v]:\n                    if sol[nb-1] == sol[v-1]:\n                        alt = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, nb)]\n                        if alt:\n                            sol[nb-1] = min(alt)\n                            break\n        # leave unresolved if impossible without k inflation; evaluation will penalize\n    # State\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If conflict-free, try to remove highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # DSATUR-like order\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            backup = solution[:]\n            feasible = True\n            for v in order:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            if verts:\n                seed = random.choice(verts)\n                # Try swapping max color with a smaller color\n                smaller = [c for c in range(1, target)]\n                if smaller:\n                    c2 = random.choice(smaller)\n                    touched = kempe_chain_swap(solution, seed, c2)\n                    local_repair_no_inflate(solution, touched)\n                    return (\"Kempe\", \"ChainSwap\")\n    # Conflict-driven recolor majority branch\n    if conflicted and random.random() < 0.75:\n        # Pick vertex by (saturation, conflicts, degree, -id)\n        sat_data = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            sat_data.append((sat, cfg, deg, -v, v))\n        _,_,_,_,v = max(sat_data)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Diversification: Kempe chain between two existing colors\n    colors_now = sorted(set(solution))\n    if len(colors_now) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors_now if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            local_repair_no_inflate(solution, touched)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 8 + random.randrange(5)  # 8..12\n    for _ in range(steps):\n        k = max(res)\n        if random.random() < 0.6:\n            # target conflicted else vertex in max color class\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                cand = [i for i,c in enumerate(res, start=1) if c == k]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification within existing colors if possible\n            colors_now = sorted(set(res))\n            if len(colors_now) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors_now if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":[[3,1,2,3,1,2,1,3,2],3,[3,1,2,3,1,2,1,3,2],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002396611}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. Each index i in [0..8] corresponds to vertex i+1. Colors are positive integers; evaluation canonically relabels to contiguous {1..k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; allows k+1 only if no color fits.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with bounded local repair (no k increase).\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color with rollback.\n    Mutates 'solution' list in place as per required signature returning metadata only.\n    Safeguards: validates and canonicalizes solution to contiguous labels 1..k at entry.\n    \"\"\"\n    # Minimal validation and canonicalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonical relabel to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair_no_inflate(sol, touched):\n        # Attempt to resolve conflicts on touched set without increasing k\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            # Try smallest non-neighbor color within 1..kcur\n            allowed = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, v)]\n            if allowed:\n                sol[v-1] = min(allowed)\n            else:\n                # As last resort try recoloring one conflicting neighbor to any non-neighbor color <= kcur\n                for nb in adj[v]:\n                    if sol[nb-1] == sol[v-1]:\n                        alt = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, nb)]\n                        if alt:\n                            sol[nb-1] = min(alt)\n                            break\n        # leave unresolved if impossible without k inflation; evaluation will penalize\n    # State\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If conflict-free, try to remove highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # DSATUR-like order\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            backup = solution[:]\n            feasible = True\n            for v in order:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            if verts:\n                seed = random.choice(verts)\n                # Try swapping max color with a smaller color\n                smaller = [c for c in range(1, target)]\n                if smaller:\n                    c2 = random.choice(smaller)\n                    touched = kempe_chain_swap(solution, seed, c2)\n                    local_repair_no_inflate(solution, touched)\n                    return (\"Kempe\", \"ChainSwap\")\n    # Conflict-driven recolor majority branch\n    if conflicted and random.random() < 0.75:\n        # Pick vertex by (saturation, conflicts, degree, -id)\n        sat_data = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            sat_data.append((sat, cfg, deg, -v, v))\n        _,_,_,_,v = max(sat_data)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Diversification: Kempe chain between two existing colors\n    colors_now = sorted(set(solution))\n    if len(colors_now) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors_now if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            local_repair_no_inflate(solution, touched)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 8 + random.randrange(5)  # 8..12\n    for _ in range(steps):\n        k = max(res)\n        if random.random() < 0.6:\n            # target conflicted else vertex in max color class\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                cand = [i for i,c in enumerate(res, start=1) if c == k]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification within existing colors if possible\n            colors_now = sorted(set(res))\n            if len(colors_now) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors_now if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":["Kempe",1000000000001,[2,1,3,2,1,3,1,2,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.005179967}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS. Each index i in [0..8] corresponds to vertex i+1. Colors are positive integers; evaluation canonically relabels to contiguous {1..k}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor. Returns (Operator, MovementType):\n      - (\"Recolor\",\"SingleVertex\"): DSATUR-guided recolor; allows k+1 only if no color fits.\n      - (\"Kempe\",\"ChainSwap\"): Kempe chain swap between two colors with bounded local repair (no k increase).\n      - (\"RemoveColor\",\"GreedyRepair\"): try to eliminate max color with rollback.\n    Mutates 'solution' list in place as per required signature returning metadata only.\n    Safeguards: validates and canonicalizes solution to contiguous labels 1..k at entry.\n    \"\"\"\n    # Minimal validation and canonicalization\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonical relabel to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        c = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == c)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def local_repair_no_inflate(sol, touched):\n        # Attempt to resolve conflicts on touched set without increasing k\n        kcur = max(sol)\n        for v in list(touched):\n            if vertex_conflicts(sol, v) == 0:\n                continue\n            # Try smallest non-neighbor color within 1..kcur\n            allowed = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, v)]\n            if allowed:\n                sol[v-1] = min(allowed)\n            else:\n                # As last resort try recoloring one conflicting neighbor to any non-neighbor color <= kcur\n                for nb in adj[v]:\n                    if sol[nb-1] == sol[v-1]:\n                        alt = [c for c in range(1, kcur+1) if c not in neighbour_colors(sol, nb)]\n                        if alt:\n                            sol[nb-1] = min(alt)\n                            break\n        # leave unresolved if impossible without k inflation; evaluation will penalize\n    # State\n    k = max(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If conflict-free, try to remove highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            # DSATUR-like order\n            def satdeg(v):\n                return (len({solution[nb-1] for nb in adj[v]}), len(adj[v]), -v)\n            order = sorted(verts, key=satdeg, reverse=True)\n            backup = solution[:]\n            feasible = True\n            for v in order:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    feasible = False\n                    break\n            if feasible and max(solution) < target:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            if verts:\n                seed = random.choice(verts)\n                # Try swapping max color with a smaller color\n                smaller = [c for c in range(1, target)]\n                if smaller:\n                    c2 = random.choice(smaller)\n                    touched = kempe_chain_swap(solution, seed, c2)\n                    local_repair_no_inflate(solution, touched)\n                    return (\"Kempe\", \"ChainSwap\")\n    # Conflict-driven recolor majority branch\n    if conflicted and random.random() < 0.75:\n        # Pick vertex by (saturation, conflicts, degree, -id)\n        sat_data = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            sat_data.append((sat, cfg, deg, -v, v))\n        _,_,_,_,v = max(sat_data)\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        if not allowed:\n            palette.append(k+1)\n        new_c, _ = least_conflict_color(solution, v, palette)\n        solution[v-1] = max(1, new_c)\n        return (\"Recolor\", \"SingleVertex\")\n    # Diversification: Kempe chain between two existing colors\n    colors_now = sorted(set(solution))\n    if len(colors_now) >= 2:\n        v = random.randrange(1,10)\n        cur = solution[v-1]\n        others = [c for c in colors_now if c != cur]\n        if others:\n            c2 = random.choice(others)\n            touched = kempe_chain_swap(solution, v, c2)\n            local_repair_no_inflate(solution, touched)\n            return (\"Kempe\", \"ChainSwap\")\n    # Fallback simple recolor\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, k+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        solution[idx] = max(1, k+1 if k >= 1 else 1)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    steps = 8 + random.randrange(5)  # 8..12\n    for _ in range(steps):\n        k = max(res)\n        if random.random() < 0.6:\n            # target conflicted else vertex in max color class\n            conflicted = []\n            for v in range(1,10):\n                c = res[v-1]\n                if any(res[nb-1] == c for nb in adj[v]):\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(conflicted)\n            else:\n                cand = [i for i,c in enumerate(res, start=1) if c == k]\n                v = random.choice(cand) if cand else random.randrange(1,10)\n            neigh_cols = neighbour_colors(res, v)\n            palette = list(range(1, k+1))\n            allowed = [c for c in palette if c not in neigh_cols]\n            if not allowed and k >= 1:\n                palette.append(k+1)\n            new_c, _ = least_conflict_color(res, v, palette)\n            res[v-1] = max(1, new_c)\n        else:\n            # Kempe diversification within existing colors if possible\n            colors_now = sorted(set(res))\n            if len(colors_now) >= 2:\n                v = random.randrange(1,10)\n                cur = res[v-1]\n                others = [c for c in colors_now if c != cur]\n                if others:\n                    c2 = random.choice(others)\n                    kempe_swap(res, v, c2)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001994195}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator. Returns metadata (Operator, MovementType).\n    Safeguards:\n      - Validates and canonicalizes to contiguous 1..k at entry.\n      - Avoids null moves; rolls back if a tentative move increases k without reducing conflicts.\n      - Prefers conflict reduction; when conflict-free attempts color elimination (k reduction) with rollback.\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonicalize to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # tie-break randomly among minimal colors, with preference for smaller index\n        m = min(best_list)\n        candidates = [c for c in best_list if c == m]\n        return random.choice(candidates if candidates else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_order(vertices):\n        data = []\n        for v in vertices:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            deg = len(adj[v])\n            data.append((sat, deg, random.random(), v))\n        data.sort(reverse=True)\n        return [v for *_rest, v in data]\n    def canonicalize(sol):\n        cols = sorted(set(sol))\n        mp = {c:i+1 for i,c in enumerate(cols)}\n        for i in range(9):\n            sol[i] = mp[sol[i]]\n    # Current state\n    k = max(solution)\n    base_conf = conflicts_count(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If no conflicts, try to eliminate the highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            backup = solution[:]\n            success = True\n            for v in dsatur_order(verts):\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    success = False\n                    break\n            canonicalize(solution)\n            if success and max(solution) < target and conflicts_count(solution) == 0:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            seed = random.choice(verts)\n            smaller = [c for c in range(1, target)]\n            if smaller:\n                c2 = random.choice(smaller)\n                kempe_chain_swap(solution, seed, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # If conflicts present, attempt focused recolor with limited allowance for k+1 only if conflicts drop\n    if conflicted:\n        # Choose vertex by (saturation, conflicts, degree, random)\n        candidates = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            candidates.append((sat, cfg, deg, random.random(), v))\n        candidates.sort(reverse=True)\n        v = candidates[0][-1]\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        backup = solution[:]\n        # Try within 1..k first\n        if allowed:\n            new_c, _ = least_conflict_color(solution, v, allowed)\n            if new_c != solution[v-1]:\n                solution[v-1] = new_c\n                return (\"Recolor\", \"SingleVertex\")\n        # Consider k+1 only if it reduces conflicts at v\n        if True:\n            tentative = k + 1\n            if tentative not in neigh_cols:\n                pre_v = vertex_conflicts(backup, v)\n                solution[v-1] = tentative\n                post_v = vertex_conflicts(solution, v)\n                if post_v < pre_v:\n                    return (\"Recolor\", \"SingleVertex\")\n                # rollback if no gain\n                for i in range(9):\n                    solution[i] = backup[i]\n        # If recolor failed, use Kempe swap between two existing colors\n        colors_now = sorted(set(solution))\n        if len(colors_now) >= 2:\n            v = random.randrange(1,10)\n            cur = solution[v-1]\n            others = [c for c in colors_now if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_chain_swap(solution, v, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # Diversification: simple recolor towards smallest available color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, max(solution)+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # as last resort stay or introduce k+1 only if it doesn't create same-color neighbors at v\n        t = max(solution) + 1\n        if t not in neigh_cols:\n            solution[idx] = t\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    # Modes: kempe_burst, color_merge, shuffle_subset\n    steps = 6 + random.randrange(5)  # 6..10\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick random vertex and swap with another color\n            v = random.randrange(1,10)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.7 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            changed = False\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n                    changed = True\n            if changed:\n                # canonicalize after merge attempt\n                cols = sorted(set(res))\n                mp = {c:i+1 for i,c in enumerate(cols)}\n                res = [mp[c] for c in res]\n        else:\n            # shuffle_subset: recolor a random subset preferring minimal conflicts\n            subset = random.sample(range(1,10), k=min(3, 1 + random.randrange(3)))\n            for v in subset:\n                neigh_cols = neighbour_colors(res, v)\n                palette = list(range(1, k+1))\n                allowed = [c for c in palette if c not in neigh_cols]\n                if not allowed and k >= 1:\n                    palette.append(k+1)\n                new_c, _ = least_conflict_color(res, v, palette)\n                res[v-1] = max(1, new_c)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000004541}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator. Returns metadata (Operator, MovementType).\n    Safeguards:\n      - Validates and canonicalizes to contiguous 1..k at entry.\n      - Avoids null moves; rolls back if a tentative move increases k without reducing conflicts.\n      - Prefers conflict reduction; when conflict-free attempts color elimination (k reduction) with rollback.\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonicalize to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # tie-break randomly among minimal colors, with preference for smaller index\n        m = min(best_list)\n        candidates = [c for c in best_list if c == m]\n        return random.choice(candidates if candidates else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_order(vertices):\n        data = []\n        for v in vertices:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            deg = len(adj[v])\n            data.append((sat, deg, random.random(), v))\n        data.sort(reverse=True)\n        return [v for *_rest, v in data]\n    def canonicalize(sol):\n        cols = sorted(set(sol))\n        mp = {c:i+1 for i,c in enumerate(cols)}\n        for i in range(9):\n            sol[i] = mp[sol[i]]\n    # Current state\n    k = max(solution)\n    base_conf = conflicts_count(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If no conflicts, try to eliminate the highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            backup = solution[:]\n            success = True\n            for v in dsatur_order(verts):\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    success = False\n                    break\n            canonicalize(solution)\n            if success and max(solution) < target and conflicts_count(solution) == 0:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            seed = random.choice(verts)\n            smaller = [c for c in range(1, target)]\n            if smaller:\n                c2 = random.choice(smaller)\n                kempe_chain_swap(solution, seed, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # If conflicts present, attempt focused recolor with limited allowance for k+1 only if conflicts drop\n    if conflicted:\n        # Choose vertex by (saturation, conflicts, degree, random)\n        candidates = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            candidates.append((sat, cfg, deg, random.random(), v))\n        candidates.sort(reverse=True)\n        v = candidates[0][-1]\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        backup = solution[:]\n        # Try within 1..k first\n        if allowed:\n            new_c, _ = least_conflict_color(solution, v, allowed)\n            if new_c != solution[v-1]:\n                solution[v-1] = new_c\n                return (\"Recolor\", \"SingleVertex\")\n        # Consider k+1 only if it reduces conflicts at v\n        if True:\n            tentative = k + 1\n            if tentative not in neigh_cols:\n                pre_v = vertex_conflicts(backup, v)\n                solution[v-1] = tentative\n                post_v = vertex_conflicts(solution, v)\n                if post_v < pre_v:\n                    return (\"Recolor\", \"SingleVertex\")\n                # rollback if no gain\n                for i in range(9):\n                    solution[i] = backup[i]\n        # If recolor failed, use Kempe swap between two existing colors\n        colors_now = sorted(set(solution))\n        if len(colors_now) >= 2:\n            v = random.randrange(1,10)\n            cur = solution[v-1]\n            others = [c for c in colors_now if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_chain_swap(solution, v, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # Diversification: simple recolor towards smallest available color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, max(solution)+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # as last resort stay or introduce k+1 only if it doesn't create same-color neighbors at v\n        t = max(solution) + 1\n        if t not in neigh_cols:\n            solution[idx] = t\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    # Modes: kempe_burst, color_merge, shuffle_subset\n    steps = 6 + random.randrange(5)  # 6..10\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick random vertex and swap with another color\n            v = random.randrange(1,10)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.7 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            changed = False\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n                    changed = True\n            if changed:\n                # canonicalize after merge attempt\n                cols = sorted(set(res))\n                mp = {c:i+1 for i,c in enumerate(cols)}\n                res = [mp[c] for c in res]\n        else:\n            # shuffle_subset: recolor a random subset preferring minimal conflicts\n            subset = random.sample(range(1,10), k=min(3, 1 + random.randrange(3)))\n            for v in subset:\n                neigh_cols = neighbour_colors(res, v)\n                palette = list(range(1, k+1))\n                allowed = [c for c in palette if c not in neigh_cols]\n                if not allowed and k >= 1:\n                    palette.append(k+1)\n                new_c, _ = least_conflict_color(res, v, palette)\n                res[v-1] = max(1, new_c)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00000144}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    sol = [mapping[c] for c in solution]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator. Returns metadata (Operator, MovementType).\n    Safeguards:\n      - Validates and canonicalizes to contiguous 1..k at entry.\n      - Avoids null moves; rolls back if a tentative move increases k without reducing conflicts.\n      - Prefers conflict reduction; when conflict-free attempts color elimination (k reduction) with rollback.\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"Recolor\", \"SingleVertex\")\n    for i,x in enumerate(solution):\n        if not isinstance(x, int) or x < 1:\n            solution[i] = 1\n    # Canonicalize to 1..k in-place\n    colors = sorted(set(solution))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    for i in range(9):\n        solution[i] = mapping[solution[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        # tie-break randomly among minimal colors, with preference for smaller index\n        m = min(best_list)\n        candidates = [c for c in best_list if c == m]\n        return random.choice(candidates if candidates else best_list), best_val\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_order(vertices):\n        data = []\n        for v in vertices:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            deg = len(adj[v])\n            data.append((sat, deg, random.random(), v))\n        data.sort(reverse=True)\n        return [v for *_rest, v in data]\n    def canonicalize(sol):\n        cols = sorted(set(sol))\n        mp = {c:i+1 for i,c in enumerate(cols)}\n        for i in range(9):\n            sol[i] = mp[sol[i]]\n    # Current state\n    k = max(solution)\n    base_conf = conflicts_count(solution)\n    conflicted = [v for v in range(1,10) if vertex_conflicts(solution, v) > 0]\n    # If no conflicts, try to eliminate the highest color\n    if not conflicted and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(solution, start=1) if c == target]\n        if verts:\n            backup = solution[:]\n            success = True\n            for v in dsatur_order(verts):\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(solution, v)]\n                if allowed:\n                    solution[v-1] = min(allowed)\n                else:\n                    success = False\n                    break\n            canonicalize(solution)\n            if success and max(solution) < target and conflicts_count(solution) == 0:\n                return (\"RemoveColor\", \"GreedyRepair\")\n            # rollback and try Kempe-assisted elimination\n            for i in range(9):\n                solution[i] = backup[i]\n            seed = random.choice(verts)\n            smaller = [c for c in range(1, target)]\n            if smaller:\n                c2 = random.choice(smaller)\n                kempe_chain_swap(solution, seed, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # If conflicts present, attempt focused recolor with limited allowance for k+1 only if conflicts drop\n    if conflicted:\n        # Choose vertex by (saturation, conflicts, degree, random)\n        candidates = []\n        for v in conflicted:\n            sat = len({solution[nb-1] for nb in adj[v]})\n            cfg = vertex_conflicts(solution, v)\n            deg = len(adj[v])\n            candidates.append((sat, cfg, deg, random.random(), v))\n        candidates.sort(reverse=True)\n        v = candidates[0][-1]\n        neigh_cols = neighbour_colors(solution, v)\n        palette = list(range(1, k+1))\n        allowed = [c for c in palette if c not in neigh_cols]\n        backup = solution[:]\n        # Try within 1..k first\n        if allowed:\n            new_c, _ = least_conflict_color(solution, v, allowed)\n            if new_c != solution[v-1]:\n                solution[v-1] = new_c\n                return (\"Recolor\", \"SingleVertex\")\n        # Consider k+1 only if it reduces conflicts at v\n        if True:\n            tentative = k + 1\n            if tentative not in neigh_cols:\n                pre_v = vertex_conflicts(backup, v)\n                solution[v-1] = tentative\n                post_v = vertex_conflicts(solution, v)\n                if post_v < pre_v:\n                    return (\"Recolor\", \"SingleVertex\")\n                # rollback if no gain\n                for i in range(9):\n                    solution[i] = backup[i]\n        # If recolor failed, use Kempe swap between two existing colors\n        colors_now = sorted(set(solution))\n        if len(colors_now) >= 2:\n            v = random.randrange(1,10)\n            cur = solution[v-1]\n            others = [c for c in colors_now if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_chain_swap(solution, v, c2)\n                canonicalize(solution)\n                return (\"Kempe\", \"ChainSwap\")\n    # Diversification: simple recolor towards smallest available color\n    idx = random.randrange(9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(solution, v)\n    choices = [c for c in range(1, max(solution)+1) if c != solution[idx] and c not in neigh_cols]\n    if choices:\n        solution[idx] = min(choices)\n    else:\n        # as last resort stay or introduce k+1 only if it doesn't create same-color neighbors at v\n        t = max(solution) + 1\n        if t not in neigh_cols:\n            solution[idx] = t\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors and Kempe swaps.\n    Representation preserved (list of 9 positive ints). Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k\n    colors = sorted(set(base))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in base]\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def least_conflict_color(sol, v, palette):\n        cur = sol[v-1]\n        best_val = 10**9\n        best_list = []\n        for c in palette:\n            if c == cur:\n                continue\n            add = 0\n            for nb in adj[v]:\n                if sol[nb-1] == c:\n                    add += 1\n            if add < best_val:\n                best_val = add\n                best_list = [c]\n            elif add == best_val:\n                best_list.append(c)\n        if not best_list:\n            return cur, 10**9\n        m = min(best_list)\n        smalls = [c for c in best_list if c == m]\n        return random.choice(smalls if smalls else best_list), best_val\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    # Modes: kempe_burst, color_merge, shuffle_subset\n    steps = 6 + random.randrange(5)  # 6..10\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick random vertex and swap with another color\n            v = random.randrange(1,10)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.7 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            changed = False\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n                    changed = True\n            if changed:\n                # canonicalize after merge attempt\n                cols = sorted(set(res))\n                mp = {c:i+1 for i,c in enumerate(cols)}\n                res = [mp[c] for c in res]\n        else:\n            # shuffle_subset: recolor a random subset preferring minimal conflicts\n            subset = random.sample(range(1,10), k=min(3, 1 + random.randrange(3)))\n            for v in subset:\n                neigh_cols = neighbour_colors(res, v)\n                palette = list(range(1, k+1))\n                allowed = [c for c in palette if c not in neigh_cols]\n                if not allowed and k >= 1:\n                    palette.append(k+1)\n                new_c, _ = least_conflict_color(res, v, palette)\n                res[v-1] = max(1, new_c)\n    # Final canonicalization\n    colors = sorted(set(res))\n    mapping = {c:i+1 for i,c in enumerate(colors)}\n    res = [mapping[c] for c in res]\n    return res\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.00000113}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k using first-seen mapping\n    mapping = {}\n    nxt = 1\n    sol = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol.append(mapping[c])\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains canonical colors 1..k (first-seen remap) at entry and after move.\n    - Prefers fitness-improving moves; accepts non-worsening if no improvement found.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        # reset to a valid seed\n        for i in range(9):\n            if i < len(solution) if isinstance(solution, list) else False:\n                pass\n        tmp = [1,2,3,1,2,3,2,1,3]\n        solution[:] = tmp\n    else:\n        for i,x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize_inplace(sol):\n        mp = {}\n        nxt = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            sol[i] = mp[c]\n    canonicalize_inplace(solution)\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # compute fitness with canonical form enforced\n        # conflicts*W + k\n        conflicts = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_key(sol, v):\n        sat = len({sol[nb-1] for nb in adj[v]})\n        deg = len(adj[v])\n        return (sat, vertex_conflicts(sol, v), deg, -v)  # deterministic tie-break by -id\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by DSATUR (on trial which == base initially)\n        verts_sorted = sorted(verts, key=lambda v: dsatur_key(trial, v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        canonicalize_inplace(trial)\n        if feasible:\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"RemoveColor\", \"GreedyRepair\")\n        # Try Kempe-assisted elimination from one of target vertices\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            c2 = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, c2)\n            canonicalize_inplace(trial)\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: focused recolor for best delta\n    if base_conf > 0:\n        conflicted = [v for v in range(1,10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = sorted(conflicted, key=lambda x: dsatur_key(base, x), reverse=True)[0]\n            neigh_cols = neighbour_colors(base, v)\n            palette = list(range(1, k+1))\n            best_trial = None\n            best_fit = None\n            # Try within 1..k avoiding neighbor colors\n            for c in palette:\n                if c == base[v-1] or c in neigh_cols:\n                    continue\n                tr = base[:]\n                tr[v-1] = c\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            # Consider k+1 only if it improves global fitness\n            t = k + 1\n            if t not in neigh_cols:\n                tr = base[:]\n                tr[v-1] = t\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            if best_trial is not None and best_fit <= base_fit:\n                solution[:] = best_trial\n                return (\"Recolor\", \"SingleVertex\")\n    # 3) Kempe swap between two colors to escape plateaus\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        v = 1 + (sum(base) % 9)  # deterministic-ish pick without external state\n        c1 = base[v-1]\n        c2 = colors_now[0] if colors_now[0] != c1 else colors_now[1]\n        trial = base[:]\n        kempe_chain_swap(trial, v, c2)\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 4) Swap color classes (global relabel) if it helps\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [ (b if c==a else (a if c==b else c)) for c in base ]\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"SwapClasses\", \"Global\")\n    # 5) Fallback: minimal safe recolor to smallest available color (may be equal fitness)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        t = k + 1\n        if t not in neigh_cols:\n            trial[v-1] = t\n    canonicalize_inplace(trial)\n    if fitness(trial) <= base_fit:\n        solution[:] = trial\n        return (\"Recolor\", \"SingleVertex\")\n    # No acceptable move found; leave solution as-is\n    canonicalize_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize(sol):\n        mp = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            out.append(mp[c])\n        return out\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.75 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + (random.randrange(3))\n            subset = random.sample(range(1,10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002218488}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k using first-seen mapping\n    mapping = {}\n    nxt = 1\n    sol = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol.append(mapping[c])\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains canonical colors 1..k (first-seen remap) at entry and after move.\n    - Prefers fitness-improving moves; accepts non-worsening if no improvement found.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        # reset to a valid seed\n        for i in range(9):\n            if i < len(solution) if isinstance(solution, list) else False:\n                pass\n        tmp = [1,2,3,1,2,3,2,1,3]\n        solution[:] = tmp\n    else:\n        for i,x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize_inplace(sol):\n        mp = {}\n        nxt = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            sol[i] = mp[c]\n    canonicalize_inplace(solution)\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # compute fitness with canonical form enforced\n        # conflicts*W + k\n        conflicts = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_key(sol, v):\n        sat = len({sol[nb-1] for nb in adj[v]})\n        deg = len(adj[v])\n        return (sat, vertex_conflicts(sol, v), deg, -v)  # deterministic tie-break by -id\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by DSATUR (on trial which == base initially)\n        verts_sorted = sorted(verts, key=lambda v: dsatur_key(trial, v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        canonicalize_inplace(trial)\n        if feasible:\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"RemoveColor\", \"GreedyRepair\")\n        # Try Kempe-assisted elimination from one of target vertices\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            c2 = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, c2)\n            canonicalize_inplace(trial)\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: focused recolor for best delta\n    if base_conf > 0:\n        conflicted = [v for v in range(1,10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = sorted(conflicted, key=lambda x: dsatur_key(base, x), reverse=True)[0]\n            neigh_cols = neighbour_colors(base, v)\n            palette = list(range(1, k+1))\n            best_trial = None\n            best_fit = None\n            # Try within 1..k avoiding neighbor colors\n            for c in palette:\n                if c == base[v-1] or c in neigh_cols:\n                    continue\n                tr = base[:]\n                tr[v-1] = c\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            # Consider k+1 only if it improves global fitness\n            t = k + 1\n            if t not in neigh_cols:\n                tr = base[:]\n                tr[v-1] = t\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            if best_trial is not None and best_fit <= base_fit:\n                solution[:] = best_trial\n                return (\"Recolor\", \"SingleVertex\")\n    # 3) Kempe swap between two colors to escape plateaus\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        v = 1 + (sum(base) % 9)  # deterministic-ish pick without external state\n        c1 = base[v-1]\n        c2 = colors_now[0] if colors_now[0] != c1 else colors_now[1]\n        trial = base[:]\n        kempe_chain_swap(trial, v, c2)\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 4) Swap color classes (global relabel) if it helps\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [ (b if c==a else (a if c==b else c)) for c in base ]\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"SwapClasses\", \"Global\")\n    # 5) Fallback: minimal safe recolor to smallest available color (may be equal fitness)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        t = k + 1\n        if t not in neigh_cols:\n            trial[v-1] = t\n    canonicalize_inplace(trial)\n    if fitness(trial) <= base_fit:\n        solution[:] = trial\n        return (\"Recolor\", \"SingleVertex\")\n    # No acceptable move found; leave solution as-is\n    canonicalize_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize(sol):\n        mp = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            out.append(mp[c])\n        return out\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.75 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + (random.randrange(3))\n            subset = random.sample(range(1,10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":["Kempe",1000000000001,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004433297}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k.\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Canonical relabel to 1..k using first-seen mapping\n    mapping = {}\n    nxt = 1\n    sol = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol.append(mapping[c])\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains canonical colors 1..k (first-seen remap) at entry and after move.\n    - Prefers fitness-improving moves; accepts non-worsening if no improvement found.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        # reset to a valid seed\n        for i in range(9):\n            if i < len(solution) if isinstance(solution, list) else False:\n                pass\n        tmp = [1,2,3,1,2,3,2,1,3]\n        solution[:] = tmp\n    else:\n        for i,x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize_inplace(sol):\n        mp = {}\n        nxt = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            sol[i] = mp[c]\n    canonicalize_inplace(solution)\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # compute fitness with canonical form enforced\n        # conflicts*W + k\n        conflicts = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def dsatur_key(sol, v):\n        sat = len({sol[nb-1] for nb in adj[v]})\n        deg = len(adj[v])\n        return (sat, vertex_conflicts(sol, v), deg, -v)  # deterministic tie-break by -id\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i,c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by DSATUR (on trial which == base initially)\n        verts_sorted = sorted(verts, key=lambda v: dsatur_key(trial, v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        canonicalize_inplace(trial)\n        if feasible:\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"RemoveColor\", \"GreedyRepair\")\n        # Try Kempe-assisted elimination from one of target vertices\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            c2 = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, c2)\n            canonicalize_inplace(trial)\n            new_fit = fitness(trial)\n            if new_fit <= base_fit:\n                solution[:] = trial\n                return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: focused recolor for best delta\n    if base_conf > 0:\n        conflicted = [v for v in range(1,10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = sorted(conflicted, key=lambda x: dsatur_key(base, x), reverse=True)[0]\n            neigh_cols = neighbour_colors(base, v)\n            palette = list(range(1, k+1))\n            best_trial = None\n            best_fit = None\n            # Try within 1..k avoiding neighbor colors\n            for c in palette:\n                if c == base[v-1] or c in neigh_cols:\n                    continue\n                tr = base[:]\n                tr[v-1] = c\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            # Consider k+1 only if it improves global fitness\n            t = k + 1\n            if t not in neigh_cols:\n                tr = base[:]\n                tr[v-1] = t\n                canonicalize_inplace(tr)\n                f = fitness(tr)\n                if best_fit is None or f < best_fit:\n                    best_fit = f\n                    best_trial = tr\n            if best_trial is not None and best_fit <= base_fit:\n                solution[:] = best_trial\n                return (\"Recolor\", \"SingleVertex\")\n    # 3) Kempe swap between two colors to escape plateaus\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        v = 1 + (sum(base) % 9)  # deterministic-ish pick without external state\n        c1 = base[v-1]\n        c2 = colors_now[0] if colors_now[0] != c1 else colors_now[1]\n        trial = base[:]\n        kempe_chain_swap(trial, v, c2)\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 4) Swap color classes (global relabel) if it helps\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [ (b if c==a else (a if c==b else c)) for c in base ]\n        canonicalize_inplace(trial)\n        if fitness(trial) <= base_fit:\n            solution[:] = trial\n            return (\"SwapClasses\", \"Global\")\n    # 5) Fallback: minimal safe recolor to smallest available color (may be equal fitness)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        t = k + 1\n        if t not in neigh_cols:\n            trial[v-1] = t\n    canonicalize_inplace(trial)\n    if fitness(trial) <= base_fit:\n        solution[:] = trial\n        return (\"Recolor\", \"SingleVertex\")\n    # No acceptable move found; leave solution as-is\n    canonicalize_inplace(solution)\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1,2,3,1,2,3,2,1,3]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Canonicalize to 1..k using first-seen remap\n    def canonicalize(sol):\n        mp = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mp:\n                mp[c] = nxt\n                nxt += 1\n            out.append(mp[c])\n        return out\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1,10)}\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.4 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.75 and k > 1:\n            # color_merge: try to remap some vertices of color k to lower colors greedily\n            target = k\n            verts = [i for i,c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + (random.randrange(3))\n            subset = random.sample(range(1,10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001782733}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9, positive integers with contiguous labels {1..k} (vertex order 1..9).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k (stable by smallest-vertex order).\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Stable canonical relabel to 1..k: color classes ordered by smallest vertex id\n    def stable_canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])  # by first appearance (smallest vertex id)\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    sol = stable_canonicalize(solution)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains contiguous labels 1..k via stable canonicalization at commit.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        tmp = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n        # replace contents if possible\n        if isinstance(solution, list):\n            solution.clear()\n            solution.extend(tmp)\n        else:\n            # cannot modify in place; nothing else to do per contract\n            return (\"Init\", \"Reset\")\n    else:\n        for i, x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Stable canonicalize helper (applied only on commit)\n    def stable_canonicalize_inplace(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # conflicts*W + k\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def color_usage(sol):\n        k = max(sol)\n        cnt = [0]*(k+1)\n        for c in sol:\n            cnt[c] += 1\n        return cnt\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i, c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by (degree, vertex id) descending degree first\n        verts_sorted = sorted(verts, key=lambda v: (len(adj[v]), -v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        if feasible:\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # Kempe assist from a target vertex\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            partner = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, partner)\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: recolor a highest-conflict vertex to least-used feasible color\n    if base_conf > 0:\n        conflicted = [v for v in range(1, 10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = max(conflicted, key=lambda x: (vertex_conflicts(base, x), len(adj[x]), -x))\n            usage = color_usage(base)\n            neigh_cols = neighbour_colors(base, v)\n            palette = [c for c in range(1, k+1) if c not in neigh_cols and c != base[v-1]]\n            if palette:\n                # choose least used color\n                palette.sort(key=lambda c: (usage[c], c))\n                trial = base[:]\n                trial[v-1] = palette[0]\n                stable_canonicalize_inplace(trial)\n                solution[:] = trial\n                return (\"Recolor\", \"SingleVertex\")\n            else:\n                # attempt Kempe swap with a color creating largest cut\n                best_trial = None\n                best_score = None\n                for c2 in range(1, k+1):\n                    if c2 == base[v-1]:\n                        continue\n                    tr = base[:]\n                    kempe_chain_swap(tr, v, c2)\n                    sc = fitness(tr)\n                    if best_score is None or sc < best_score:\n                        best_score = sc\n                        best_trial = tr\n                if best_trial is not None:\n                    stable_canonicalize_inplace(best_trial)\n                    solution[:] = best_trial\n                    return (\"Kempe\", \"ChainSwap\")\n    # 3) Swap color classes extremes as a global relabel move\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [(b if c == a else (a if c == b else c)) for c in base]\n        stable_canonicalize_inplace(trial)\n        solution[:] = trial\n        return (\"SwapClasses\", \"Global\")\n    # 4) Fallback: minimal safe recolor to smallest available color (may keep conflicts)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        # introduce new color only as last resort\n        trial[v-1] = k + 1\n    stable_canonicalize_inplace(trial)\n    solution[:] = trial\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Stable canonicalize to 1..k using smallest-vertex order\n    def canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish upper bound\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.45 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7 + random.randrange(9)) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.8 and k > 1:\n            # color_merge: try to remap color k to lower colors greedily\n            target = k\n            verts = [i for i, c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + random.randrange(3)\n            subset = random.sample(range(1, 10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002208002}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9, positive integers with contiguous labels {1..k} (vertex order 1..9).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k (stable by smallest-vertex order).\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Stable canonical relabel to 1..k: color classes ordered by smallest vertex id\n    def stable_canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])  # by first appearance (smallest vertex id)\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    sol = stable_canonicalize(solution)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains contiguous labels 1..k via stable canonicalization at commit.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        tmp = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n        # replace contents if possible\n        if isinstance(solution, list):\n            solution.clear()\n            solution.extend(tmp)\n        else:\n            # cannot modify in place; nothing else to do per contract\n            return (\"Init\", \"Reset\")\n    else:\n        for i, x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Stable canonicalize helper (applied only on commit)\n    def stable_canonicalize_inplace(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # conflicts*W + k\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def color_usage(sol):\n        k = max(sol)\n        cnt = [0]*(k+1)\n        for c in sol:\n            cnt[c] += 1\n        return cnt\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i, c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by (degree, vertex id) descending degree first\n        verts_sorted = sorted(verts, key=lambda v: (len(adj[v]), -v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        if feasible:\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # Kempe assist from a target vertex\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            partner = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, partner)\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: recolor a highest-conflict vertex to least-used feasible color\n    if base_conf > 0:\n        conflicted = [v for v in range(1, 10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = max(conflicted, key=lambda x: (vertex_conflicts(base, x), len(adj[x]), -x))\n            usage = color_usage(base)\n            neigh_cols = neighbour_colors(base, v)\n            palette = [c for c in range(1, k+1) if c not in neigh_cols and c != base[v-1]]\n            if palette:\n                # choose least used color\n                palette.sort(key=lambda c: (usage[c], c))\n                trial = base[:]\n                trial[v-1] = palette[0]\n                stable_canonicalize_inplace(trial)\n                solution[:] = trial\n                return (\"Recolor\", \"SingleVertex\")\n            else:\n                # attempt Kempe swap with a color creating largest cut\n                best_trial = None\n                best_score = None\n                for c2 in range(1, k+1):\n                    if c2 == base[v-1]:\n                        continue\n                    tr = base[:]\n                    kempe_chain_swap(tr, v, c2)\n                    sc = fitness(tr)\n                    if best_score is None or sc < best_score:\n                        best_score = sc\n                        best_trial = tr\n                if best_trial is not None:\n                    stable_canonicalize_inplace(best_trial)\n                    solution[:] = best_trial\n                    return (\"Kempe\", \"ChainSwap\")\n    # 3) Swap color classes extremes as a global relabel move\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [(b if c == a else (a if c == b else c)) for c in base]\n        stable_canonicalize_inplace(trial)\n        solution[:] = trial\n        return (\"SwapClasses\", \"Global\")\n    # 4) Fallback: minimal safe recolor to smallest available color (may keep conflicts)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        # introduce new color only as last resort\n        trial[v-1] = k + 1\n    stable_canonicalize_inplace(trial)\n    solution[:] = trial\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Stable canonicalize to 1..k using smallest-vertex order\n    def canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish upper bound\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.45 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7 + random.randrange(9)) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.8 and k > 1:\n            # color_merge: try to remap color k to lower colors greedily\n            target = k\n            verts = [i for i, c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + random.randrange(3)\n            subset = random.sample(range(1, 10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":["Recolor",1000000000001,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004294031}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9, positive integers with contiguous labels {1..k} (vertex order 1..9).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: conflicts*(|E|+1) + k, lower is better.\n    Enforces: list of length 9, ints >=1; canonical relabeling to 1..k (stable by smallest-vertex order).\n    Hard penalties distinguish failure modes.\n    \"\"\"\n    HARD_NONLIST = 10**12 + 1\n    HARD_LEN = 10**12 + 2\n    HARD_TYPE = 10**12 + 3\n    HARD_VAL = 10**12 + 4\n    # Type checks\n    if not isinstance(solution, list):\n        return int(HARD_NONLIST)\n    if len(solution) != 9:\n        return int(HARD_LEN)\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_TYPE)\n        if x < 1:\n            return int(HARD_VAL)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    W = len(edges) + 1  # 18\n    # Stable canonical relabel to 1..k: color classes ordered by smallest vertex id\n    def stable_canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])  # by first appearance (smallest vertex id)\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    sol = stable_canonicalize(solution)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    fitness = conflicts * W + k\n    return int(fitness)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    In-place neighbor generator with rollback safety.\n    - Maintains contiguous labels 1..k via stable canonicalization at commit.\n    - Operators: Recolor (single vertex), Kempe (chain swap), RemoveColor (greedy repair), SwapClasses (color-class swap).\n    Returns metadata tuple (Operator, MovementType).\n    Postcondition: solution is a list of 9 positive ints with contiguous labels starting at 1.\n    \"\"\"\n    # Basic validation and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        tmp = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n        # replace contents if possible\n        if isinstance(solution, list):\n            solution.clear()\n            solution.extend(tmp)\n        else:\n            # cannot modify in place; nothing else to do per contract\n            return (\"Init\", \"Reset\")\n    else:\n        for i, x in enumerate(solution):\n            if not isinstance(x, int) or x < 1:\n                solution[i] = 1\n    # Stable canonicalize helper (applied only on commit)\n    def stable_canonicalize_inplace(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n    # Graph data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    W = len(edges) + 1\n    # Helpers\n    def fitness(sol):\n        # conflicts*W + k\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * W + max(sol)\n    def conflicts_count(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def vertex_conflicts(sol, v):\n        col = sol[v-1]\n        return sum(1 for nb in adj[v] if sol[nb-1] == col)\n    def kempe_chain_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return set()\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n        return visited\n    def color_usage(sol):\n        k = max(sol)\n        cnt = [0]*(k+1)\n        for c in sol:\n            cnt[c] += 1\n        return cnt\n    # Current state\n    base = solution[:]\n    base_fit = fitness(base)\n    base_conf = conflicts_count(base)\n    k = max(base)\n    # 1) If conflict-free, try to eliminate highest color greedily\n    if base_conf == 0 and k > 1:\n        target = k\n        verts = [i for i, c in enumerate(base, start=1) if c == target]\n        trial = base[:]\n        # order by (degree, vertex id) descending degree first\n        verts_sorted = sorted(verts, key=lambda v: (len(adj[v]), -v), reverse=True)\n        feasible = True\n        for v in verts_sorted:\n            neigh = neighbour_colors(trial, v)\n            allowed = [c for c in range(1, target) if c not in neigh]\n            if allowed:\n                trial[v-1] = min(allowed)\n            else:\n                feasible = False\n                break\n        if feasible:\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"RemoveColor\", \"GreedyRepair\")\n        # Kempe assist from a target vertex\n        if verts:\n            trial = base[:]\n            seed = verts[0]\n            partner = 1 if target != 1 else 2\n            kempe_chain_swap(trial, seed, partner)\n            stable_canonicalize_inplace(trial)\n            solution[:] = trial\n            return (\"Kempe\", \"ChainSwap\")\n    # 2) Conflicted phase: recolor a highest-conflict vertex to least-used feasible color\n    if base_conf > 0:\n        conflicted = [v for v in range(1, 10) if vertex_conflicts(base, v) > 0]\n        if conflicted:\n            v = max(conflicted, key=lambda x: (vertex_conflicts(base, x), len(adj[x]), -x))\n            usage = color_usage(base)\n            neigh_cols = neighbour_colors(base, v)\n            palette = [c for c in range(1, k+1) if c not in neigh_cols and c != base[v-1]]\n            if palette:\n                # choose least used color\n                palette.sort(key=lambda c: (usage[c], c))\n                trial = base[:]\n                trial[v-1] = palette[0]\n                stable_canonicalize_inplace(trial)\n                solution[:] = trial\n                return (\"Recolor\", \"SingleVertex\")\n            else:\n                # attempt Kempe swap with a color creating largest cut\n                best_trial = None\n                best_score = None\n                for c2 in range(1, k+1):\n                    if c2 == base[v-1]:\n                        continue\n                    tr = base[:]\n                    kempe_chain_swap(tr, v, c2)\n                    sc = fitness(tr)\n                    if best_score is None or sc < best_score:\n                        best_score = sc\n                        best_trial = tr\n                if best_trial is not None:\n                    stable_canonicalize_inplace(best_trial)\n                    solution[:] = best_trial\n                    return (\"Kempe\", \"ChainSwap\")\n    # 3) Swap color classes extremes as a global relabel move\n    colors_now = sorted(set(base))\n    if len(colors_now) >= 2:\n        a, b = colors_now[0], colors_now[-1]\n        trial = [(b if c == a else (a if c == b else c)) for c in base]\n        stable_canonicalize_inplace(trial)\n        solution[:] = trial\n        return (\"SwapClasses\", \"Global\")\n    # 4) Fallback: minimal safe recolor to smallest available color (may keep conflicts)\n    idx = (sum(base) % 9)\n    v = idx + 1\n    neigh_cols = neighbour_colors(base, v)\n    choice = None\n    for c in range(1, k+1):\n        if c != base[v-1] and c not in neigh_cols:\n            choice = c\n            break\n    trial = base[:]\n    if choice is not None:\n        trial[v-1] = choice\n    else:\n        # introduce new color only as last resort\n        trial[v-1] = k + 1\n    stable_canonicalize_inplace(trial)\n    solution[:] = trial\n    return (\"Recolor\", \"SingleVertex\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed COPY using a short random walk combining recolors, Kempe swaps,\n    and color-merge attempts. Representation preserved (list of 9 positive ints).\n    Does not modify input.\n    \"\"\"\n    # Seed-safe copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 2, 3, 2, 1, 2]\n    else:\n        base = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Stable canonicalize to 1..k using smallest-vertex order\n    def canonicalize(sol):\n        pos = {}\n        for i, c in enumerate(sol, start=1):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(order)}\n        return [mapping[c] for c in sol]\n    res = canonicalize(base)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def neighbour_colors(sol, v):\n        return {sol[nb-1] for nb in adj[v]}\n    def kempe_swap(sol, v, c2):\n        c1 = sol[v-1]\n        if c1 == c2:\n            return\n        visited = {v}\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2) and nb not in visited:\n                    visited.add(nb)\n                    stack.append(nb)\n        for u in visited:\n            if sol[u-1] == c1:\n                sol[u-1] = c2\n            elif sol[u-1] == c2:\n                sol[u-1] = c1\n    steps = 6 + (sum(res) % 5)  # 6..10 deterministic-ish upper bound\n    for _ in range(steps):\n        mode_r = random.random()\n        k = max(res)\n        if mode_r < 0.45 and len(set(res)) >= 2:\n            # kempe_burst: pick vertex by a simple hash and swap with another color\n            v = 1 + ((res[0] * 3 + res[1] * 5 + res[2] * 7 + random.randrange(9)) % 9)\n            cur = res[v-1]\n            others = [c for c in range(1, k+1) if c != cur]\n            if others:\n                c2 = random.choice(others)\n                kempe_swap(res, v, c2)\n        elif mode_r < 0.8 and k > 1:\n            # color_merge: try to remap color k to lower colors greedily\n            target = k\n            verts = [i for i, c in enumerate(res, start=1) if c == target]\n            random.shuffle(verts)\n            for v in verts:\n                allowed = [c for c in range(1, target) if c not in neighbour_colors(res, v)]\n                if allowed:\n                    res[v-1] = random.choice(allowed)\n            res = canonicalize(res)\n        else:\n            # shuffle_subset: recolor a random subset avoiding neighbor colors; may introduce k+1 sparsely\n            subset_size = 1 + random.randrange(3)\n            subset = random.sample(range(1, 10), k=min(3, subset_size))\n            for v in subset:\n                neigh = neighbour_colors(res, v)\n                palette = [c for c in range(1, k+1) if c not in neigh and c != res[v-1]]\n                if palette:\n                    res[v-1] = random.choice(palette)\n                else:\n                    if k < 5 and (k+1) not in neigh:\n                        res[v-1] = k+1\n            res = canonicalize(res)\n    res = canonicalize(res)\n    return res\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001823656}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1. Each solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-indexed vertices). Objective: minimize number of distinct colors while penalizing any edge with equal endpoint colors.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better\n    # Validate\n    BIG = 10_000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Heavy penalty per conflict ensures feasibility is prioritized\n    return groups_used + conflicts * 1000","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # One-vertex recolor to a potentially existing or new color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback safe neighbor\n        return ( [1]*n, \"1-vertex-recolor\", \"stochastic\" )\n    new_sol = solution.copy()\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    v = random.randrange(n)\n    # Determine conflicting colors at v\n    neighbors = [u if u!=v else w for (u,w) in edges if v in (u,w)]\n    bad_colors = set(new_sol[u] for u in neighbors)\n    max_col = max(new_sol) if new_sol else 1\n    # Candidate colors: prefer existing colors not in bad_colors; allow exploration via new color with small prob\n    candidates = [c for c in range(1, max_col+1) if c not in bad_colors]\n    if not candidates or random.random() < 0.15:\n        candidates.append(max_col+1)\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    return ( new_sol, \"1-vertex-recolor\", \"stochastic\" )","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Medium kick: recolor a random subset of vertices to random existing or new colors\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = solution.copy()\n    max_col = max(new_sol)\n    k = random.randint(2, max(3, n\/\/3))\n    idxs = random.sample(range(n), k)\n    for v in idxs:\n        # 50% choose existing color, 50% allow possibly new color\n        if random.random() < 0.5:\n            new_sol[v] = random.randint(1, max_col)\n        else:\n            new_sol[v] = random.randint(1, max_col+1)\n    return new_sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000523438}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1. Each solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-indexed vertices). Objective: minimize number of distinct colors while penalizing any edge with equal endpoint colors.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better\n    # Validate\n    BIG = 10_000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Heavy penalty per conflict ensures feasibility is prioritized\n    return groups_used + conflicts * 1000","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # One-vertex recolor to a potentially existing or new color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback safe neighbor\n        return ( [1]*n, \"1-vertex-recolor\", \"stochastic\" )\n    new_sol = solution.copy()\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    v = random.randrange(n)\n    # Determine conflicting colors at v\n    neighbors = [u if u!=v else w for (u,w) in edges if v in (u,w)]\n    bad_colors = set(new_sol[u] for u in neighbors)\n    max_col = max(new_sol) if new_sol else 1\n    # Candidate colors: prefer existing colors not in bad_colors; allow exploration via new color with small prob\n    candidates = [c for c in range(1, max_col+1) if c not in bad_colors]\n    if not candidates or random.random() < 0.15:\n        candidates.append(max_col+1)\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    return ( new_sol, \"1-vertex-recolor\", \"stochastic\" )","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Medium kick: recolor a random subset of vertices to random existing or new colors\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = solution.copy()\n    max_col = max(new_sol)\n    k = random.randint(2, max(3, n\/\/3))\n    idxs = random.sample(range(n), k)\n    for v in idxs:\n        # 50% choose existing color, 50% allow possibly new color\n        if random.random() < 0.5:\n            new_sol[v] = random.randint(1, max_col)\n        else:\n            new_sol[v] = random.randint(1, max_col+1)\n    return new_sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000505557}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1. Each solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-indexed vertices). Objective: minimize number of distinct colors while penalizing any edge with equal endpoint colors.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better\n    # Validate\n    BIG = 10_000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Heavy penalty per conflict ensures feasibility is prioritized\n    return groups_used + conflicts * 1000","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # One-vertex recolor to a potentially existing or new color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback safe neighbor\n        return ( [1]*n, \"1-vertex-recolor\", \"stochastic\" )\n    new_sol = solution.copy()\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    v = random.randrange(n)\n    # Determine conflicting colors at v\n    neighbors = [u if u!=v else w for (u,w) in edges if v in (u,w)]\n    bad_colors = set(new_sol[u] for u in neighbors)\n    max_col = max(new_sol) if new_sol else 1\n    # Candidate colors: prefer existing colors not in bad_colors; allow exploration via new color with small prob\n    candidates = [c for c in range(1, max_col+1) if c not in bad_colors]\n    if not candidates or random.random() < 0.15:\n        candidates.append(max_col+1)\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    return ( new_sol, \"1-vertex-recolor\", \"stochastic\" )","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Medium kick: recolor a random subset of vertices to random existing or new colors\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = solution.copy()\n    max_col = max(new_sol)\n    k = random.randint(2, max(3, n\/\/3))\n    idxs = random.sample(range(n), k)\n    for v in idxs:\n        # 50% choose existing color, 50% allow possibly new color\n        if random.random() < 0.5:\n            new_sol[v] = random.randint(1, max_col)\n        else:\n            new_sol[v] = random.randint(1, max_col+1)\n    return new_sol","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000457706}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility without numeric blow-up\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\", \"fallback\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicts and conflict vertices\n    conflicts = 0\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    m = len(edges)\n    # Adaptive probability of introducing a new color\n    p_new_color = 0.0 if conflicts == 0 else min(0.15, conflicts \/ float(m))\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type\n    if random.random() < 0.55:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color if conflicts exist\n        if random.random() < p_new_color:\n            candidates = candidates + [max_col+1]\n        new_color = random.choice(candidates) if candidates else (max_col if max_col != new_sol[v] else max_col+1)\n        new_sol[v] = new_color\n        return (new_sol, \"1-vertex-recolor\", \"stochastic-greedy\")\n    else:\n        # Kempe chain swap between two colors starting at a (possibly conflicting) vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        color_a = new_sol[start]\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Degenerate, fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if random.random() < p_new_color:\n                candidates = candidates + [max_col+1]\n            new_sol[v] = random.choice(candidates) if candidates else max_col+1\n            return (new_sol, \"1-vertex-recolor\", \"fallback\")\n        # Pick a different color b\n        color_b = random.choice([c for c in colors_present if c != color_a])\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\", \"stochastic\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        # Swap colors a<->b in the Kempe component containing start\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(max(2, n\/\/3), max(3, n\/\/2))\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.7 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                # Fallback recolor\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000860582}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility without numeric blow-up\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\", \"fallback\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicts and conflict vertices\n    conflicts = 0\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    m = len(edges)\n    # Adaptive probability of introducing a new color\n    p_new_color = 0.0 if conflicts == 0 else min(0.15, conflicts \/ float(m))\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type\n    if random.random() < 0.55:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color if conflicts exist\n        if random.random() < p_new_color:\n            candidates = candidates + [max_col+1]\n        new_color = random.choice(candidates) if candidates else (max_col if max_col != new_sol[v] else max_col+1)\n        new_sol[v] = new_color\n        return (new_sol, \"1-vertex-recolor\", \"stochastic-greedy\")\n    else:\n        # Kempe chain swap between two colors starting at a (possibly conflicting) vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        color_a = new_sol[start]\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Degenerate, fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if random.random() < p_new_color:\n                candidates = candidates + [max_col+1]\n            new_sol[v] = random.choice(candidates) if candidates else max_col+1\n            return (new_sol, \"1-vertex-recolor\", \"fallback\")\n        # Pick a different color b\n        color_b = random.choice([c for c in colors_present if c != color_a])\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\", \"stochastic\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        # Swap colors a<->b in the Kempe component containing start\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(max(2, n\/\/3), max(3, n\/\/2))\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.7 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                # Fallback recolor\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001031435}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility without numeric blow-up\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\", \"fallback\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicts and conflict vertices\n    conflicts = 0\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    m = len(edges)\n    # Adaptive probability of introducing a new color\n    p_new_color = 0.0 if conflicts == 0 else min(0.15, conflicts \/ float(m))\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type\n    if random.random() < 0.55:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color if conflicts exist\n        if random.random() < p_new_color:\n            candidates = candidates + [max_col+1]\n        new_color = random.choice(candidates) if candidates else (max_col if max_col != new_sol[v] else max_col+1)\n        new_sol[v] = new_color\n        return (new_sol, \"1-vertex-recolor\", \"stochastic-greedy\")\n    else:\n        # Kempe chain swap between two colors starting at a (possibly conflicting) vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        color_a = new_sol[start]\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Degenerate, fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if random.random() < p_new_color:\n                candidates = candidates + [max_col+1]\n            new_sol[v] = random.choice(candidates) if candidates else max_col+1\n            return (new_sol, \"1-vertex-recolor\", \"fallback\")\n        # Pick a different color b\n        color_b = random.choice([c for c in colors_present if c != color_a])\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\", \"stochastic\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        # Swap colors a<->b in the Kempe component containing start\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(max(2, n\/\/3), max(3, n\/\/2))\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.7 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                # Fallback recolor\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001003364}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type: recolor or Kempe swap\n    if random.random() < 0.6:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color only if conflicts exist\n        if conflict_vertices and random.random() < 0.1:\n            candidates = candidates + [max_col+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        else:\n            new_sol[v] = max_col if max_col != new_sol[v] else max_col+1\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors starting at a selected vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if conflict_vertices and random.random() < 0.1:\n                candidates = candidates + [max_col+1]\n            if candidates:\n                new_sol[v] = random.choice(candidates)\n            else:\n                new_sol[v] = max_col+1\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        others = [c for c in colors_present if c != color_a]\n        if not others:\n            return (new_sol, \"noop\")\n        color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or occasionally new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.8 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":[[3,2,1,3,2,1,4,3,1],4,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001202327}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type: recolor or Kempe swap\n    if random.random() < 0.6:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color only if conflicts exist\n        if conflict_vertices and random.random() < 0.1:\n            candidates = candidates + [max_col+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        else:\n            new_sol[v] = max_col if max_col != new_sol[v] else max_col+1\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors starting at a selected vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if conflict_vertices and random.random() < 0.1:\n                candidates = candidates + [max_col+1]\n            if candidates:\n                new_sol[v] = random.choice(candidates)\n            else:\n                new_sol[v] = max_col+1\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        others = [c for c in colors_present if c != color_a]\n        if not others:\n            return (new_sol, \"noop\")\n        color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or occasionally new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.8 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":[[1,3,4,3,1,1,3,4,1],39,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001806525}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 100000\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # m = 17, set penalty to m+1=18 to prioritize feasibility\n    return groups_used + conflicts * 18\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    def neighbors_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n\n    new_sol = cur[:]\n\n    # Choose move type: recolor or Kempe swap\n    if random.random() < 0.6:\n        # Guided single-vertex recolor\n        if conflict_vertices and random.random() < 0.8:\n            v = random.choice(list(conflict_vertices))\n        else:\n            v = random.randrange(n)\n        bad = neighbors_colors(v, new_sol)\n        max_col = max(new_sol) if new_sol else 1\n        # Prefer feasible existing colors\n        candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n        # Occasionally allow a new color only if conflicts exist\n        if conflict_vertices and random.random() < 0.1:\n            candidates = candidates + [max_col+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        else:\n            new_sol[v] = max_col if max_col != new_sol[v] else max_col+1\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors starting at a selected vertex\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # Fallback to recolor\n            v = start\n            bad = neighbors_colors(v, new_sol)\n            max_col = max(new_sol)\n            candidates = [c for c in range(1, max_col+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                candidates = [c for c in range(1, max_col+1) if c != new_sol[v]]\n            if conflict_vertices and random.random() < 0.1:\n                candidates = candidates + [max_col+1]\n            if candidates:\n                new_sol[v] = random.choice(candidates)\n            else:\n                new_sol[v] = max_col+1\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        others = [c for c in colors_present if c != color_a]\n        if not others:\n            return (new_sol, \"noop\")\n        color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        comp = []\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(max(1, x)) for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_swap_from(start, color_a, color_b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == color_a or arr[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == color_a or arr[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == color_a:\n                arr[v] = color_b\n            elif arr[v] == color_b:\n                arr[v] = color_a\n\n    # Perform a sequence of random kicks: mix of recolors and Kempe swaps\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # Random recolor to existing or occasionally new color\n            v = random.randrange(n)\n            max_col = max(sol)\n            if random.random() < 0.8 and max_col > 1:\n                sol[v] = random.randint(1, max_col)\n            else:\n                sol[v] = random.randint(1, max_col+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b = random.choice([c for c in colors_present if c != a])\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[random.randrange(n)] = max(1, sol[random.randrange(n)] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000998524}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":[[3,2,1,3,2,1,2,3,1],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001521271}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":[[3,3,2,1,1,2,2,3,3],2000003,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001981067}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN9_INT_GE1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001136206}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best if best else [kmax+1]\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":[[3,2,1,2,3,1,2,2,1],3,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00148939}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best if best else [kmax+1]\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":[[1,1,1,2,1,2,1,2,1],3,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001969177}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"repair\")\n    cur = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    if random.random() < 0.7:\n        # Recolor move (guided)\n        if conflict_vertices and random.random() < 0.85:\n            v = random.choice(list(conflict_vertices))\n        else:\n            # pick higher degree vertex to increase impact\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        bad = neighbor_colors(v, new_sol)\n        kmax = max(new_sol)\n        # Prefer existing feasible colors\n        candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n        if not candidates:\n            # If none feasible, pick least-conflicting existing color\n            min_conf = None\n            best = []\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if (min_conf is None) or (conf < min_conf):\n                    min_conf = conf\n                    best = [c]\n                elif conf == min_conf:\n                    best.append(c)\n            candidates = best if best else [kmax+1]\n        # Very small chance to introduce a new color, only if currently conflicting\n        if conflict_vertices and random.random() < 0.05:\n            candidates = candidates + [kmax+1]\n        if candidates:\n            new_sol[v] = random.choice(candidates)\n        return (new_sol, \"recolor\")\n    else:\n        # Kempe chain swap between two colors, biased by neighbor colors\n        if conflict_vertices and random.random() < 0.8:\n            start = random.choice(list(conflict_vertices))\n        else:\n            start = random.randrange(n)\n        colors_present = list(set(new_sol))\n        if len(colors_present) == 1:\n            # fallback to recolor to break symmetry\n            v = start\n            bad = neighbor_colors(v, new_sol)\n            kmax = max(new_sol)\n            candidates = [c for c in range(1, kmax+1) if c not in bad and c != new_sol[v]]\n            if not candidates:\n                others = [c for c in range(1, kmax+1) if c != new_sol[v]]\n                if others:\n                    candidates = others\n                else:\n                    candidates = [kmax+1]\n            new_sol[v] = random.choice(candidates)\n            return (new_sol, \"recolor-fallback\")\n        color_a = new_sol[start]\n        # Prefer color_b among neighbors' colors to increase effect\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        if neigh_cols:\n            color_b = random.choice(neigh_cols)\n        else:\n            others = [c for c in colors_present if c != color_a]\n            if not others:\n                return (new_sol, \"noop\")\n            color_b = random.choice(others)\n        # BFS over subgraph induced by colors {a,b}\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if new_sol[v] == color_a or new_sol[v] == color_b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (new_sol[w] == color_a or new_sol[w] == color_b):\n                        seen[w] = True\n                        stack.append(w)\n        # Swap colors within the component\n        for v in comp:\n            if new_sol[v] == color_a:\n                new_sol[v] = color_b\n            elif new_sol[v] == color_b:\n                new_sol[v] = color_a\n        return (new_sol, \"kempe-swap\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    sol = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.5:\n            # random recolor kick (mostly within existing colors)\n            v = random.randrange(n)\n            kmax = max(sol)\n            if random.random() < 0.85 and kmax > 1:\n                sol[v] = random.randint(1, kmax)\n            else:\n                sol[v] = random.randint(1, kmax+1)\n        else:\n            # Kempe swap kick\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                sol[start] = max(1, sol[start] + 1)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001117066}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}. Canonicalize after moves by relabeling colors to 1..m in order of first occurrence.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            # Choose the neighbor color with minimum frontier conflicts after swap estimate\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                # estimate: count edges crossing component boundary that would become conflicts\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                # Use Kempe chain between current color and best alternative\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list occasionally\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001687403}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}. Canonicalize after moves by relabeling colors to 1..m in order of first occurrence.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            # Choose the neighbor color with minimum frontier conflicts after swap estimate\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                # estimate: count edges crossing component boundary that would become conflicts\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                # Use Kempe chain between current color and best alternative\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list occasionally\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],2000003,[3,2,1,3,2,1,2,3,1],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002667337}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_OF_POSITIVE_INTS. Index i in [0..8] corresponds to vertex i+1. Value is color label in {1,2,...}. Canonicalize after moves by relabeling colors to 1..m in order of first occurrence.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            # Choose the neighbor color with minimum frontier conflicts after swap estimate\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                # estimate: count edges crossing component boundary that would become conflicts\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                # Use Kempe chain between current color and best alternative\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list occasionally\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0014704}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001708183}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,2,1,2,1,2,1,2],2000003,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002710557}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic objective: strictly prioritize feasibility\n    return conflicts * 1_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    if random.random() < 0.65:\n        # Guided recolor with delta conflicts evaluation\n        if conflict_vertices and random.random() < 0.9:\n            v = random.choice(list(conflict_vertices))\n        else:\n            degs = [len(adj[i]) for i in range(n)]\n            v = max(range(n), key=lambda i: (degs[i], random.random()))\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # If no alternative (all same), allow new color only if v is in conflict\n        candidates = best_colors[:]\n        if not candidates:\n            candidates = [kmax+1] if v in conflict_vertices else [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        if neigh_cols:\n            cand_bs = list(set(neigh_cols))\n        else:\n            cand_bs = [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            # fallback to recolor\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # pick b with minimal estimated conflicts on boundary after swap\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                seen = [False]*n\n                stack = [start]\n                seen[start] = True\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    if new_sol[v] == color_a or new_sol[v] == b:\n                        comp.append(v)\n                        for w in adj[v]:\n                            if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                                seen[w] = True\n                                stack.append(w)\n                # compute boundary conflicts if swapped\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                if best_score is None or boundary_conf < best_score:\n                    best_score = boundary_conf\n                    best_b = b\n            # perform swap with best_b\n            b = best_b\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            comp = []\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    conflicts = []\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicts.append((u,v))\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve\n            u,v = random.choice(conflicts)\n            # Try recolor u with least-conflicting color\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[u]:\n                    continue\n                conf = sum(1 for w in adj[u] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[u] = best_c\n            else:\n                if best_c is None:\n                    best_c = kmax if kmax > 1 else 1\n                kempe_swap_from(u, sol[u], best_c, sol)\n        else:\n            # Random Kempe or recolor to diversify\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.6:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                if random.random() < 0.85 and kmax > 1:\n                    sol[v] = random.randint(1, kmax)\n                else:\n                    sol[v] = random.randint(1, kmax+1)\n        # refresh conflicts list\n        conflicts = []\n        for a,b in edges:\n            if sol[a] == sol[b]:\n                conflicts.append((a,b))\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001413589}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Strict lexicographic objective: feasibility first, then color count\n    return conflicts * 1_000_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def dsatur_pick(arr, prefer_conflict=True):\n        # DSATUR-based vertex selection; prefer conflict vertices first\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.6:\n        # Guided recolor with delta conflicts evaluation and no color bloat unless necessary\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Disallow spawning new color unless vertex is in conflict and no zero-conflict option\n        candidates = best_colors[:]\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.9:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        cand_bs = list(set(neigh_cols)) if neigh_cols else [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score candidate b by boundary conflicts after swap\n            def kempe_component(start_v, a, b, arr):\n                seen = [False]*n\n                stack = [start_v]\n                seen[start_v] = True\n                comp = []\n                while stack:\n                    x = stack.pop()\n                    if arr[x] == a or arr[x] == b:\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not seen[y] and (arr[y] == a or arr[y] == b):\n                                seen[y] = True\n                                stack.append(y)\n                return comp\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                comp = kempe_component(start, color_a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # Bonus if swap may reduce color count (creates empty class)\n                after_counts = {}\n                for x in range(n):\n                    col = new_sol[x]\n                    if x in comp:\n                        col = b if new_sol[x] == color_a else (color_a if new_sol[x] == b else new_sol[x])\n                    after_counts[col] = after_counts.get(col, 0) + 1\n                bonus = 0\n                if after_counts.get(color_a, 0) == 0 or after_counts.get(b, 0) == 0:\n                    bonus = -0.5  # favor potential color elimination\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b\n            comp = []\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    else:\n        # Color-class merge attempt: pick two colors and try to recolor vertices of minority into majority greedily\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            a,b = random.sample(colors, 2)\n            # Make b the majority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            # Try recolor a-vertices into existing colors excluding a\n            order = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(order)\n            for v in order:\n                best_c = None\n                best_conf = None\n                for c in colors:\n                    if c == a:\n                        continue\n                    conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                if best_c is not None:\n                    new_sol[v] = best_c\n            move_tag = \"class-merge\"\n        else:\n            # Fallback: random recolor within current palette\n            v = random.randrange(n)\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"random-recolor\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    conflicts = collect_conflicts(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve via recolor or Kempe\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor within current palette\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                # Kempe storm around the conflict vertex\n                colors_present = list(set(sol))\n                if len(colors_present) >= 2:\n                    b_choices = [c for c in colors_present if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: multiple random Kempe swaps or palette shake\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                # Occasionally allow introducing a new color to escape deep traps\n                if random.random() < 0.2:\n                    sol[v] = random.randint(1, kmax+1)\n                else:\n                    sol[v] = random.randint(1, kmax)\n        conflicts = collect_conflicts(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002072409}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Strict lexicographic objective: feasibility first, then color count\n    return conflicts * 1_000_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def dsatur_pick(arr, prefer_conflict=True):\n        # DSATUR-based vertex selection; prefer conflict vertices first\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.6:\n        # Guided recolor with delta conflicts evaluation and no color bloat unless necessary\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Disallow spawning new color unless vertex is in conflict and no zero-conflict option\n        candidates = best_colors[:]\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.9:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        cand_bs = list(set(neigh_cols)) if neigh_cols else [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score candidate b by boundary conflicts after swap\n            def kempe_component(start_v, a, b, arr):\n                seen = [False]*n\n                stack = [start_v]\n                seen[start_v] = True\n                comp = []\n                while stack:\n                    x = stack.pop()\n                    if arr[x] == a or arr[x] == b:\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not seen[y] and (arr[y] == a or arr[y] == b):\n                                seen[y] = True\n                                stack.append(y)\n                return comp\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                comp = kempe_component(start, color_a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # Bonus if swap may reduce color count (creates empty class)\n                after_counts = {}\n                for x in range(n):\n                    col = new_sol[x]\n                    if x in comp:\n                        col = b if new_sol[x] == color_a else (color_a if new_sol[x] == b else new_sol[x])\n                    after_counts[col] = after_counts.get(col, 0) + 1\n                bonus = 0\n                if after_counts.get(color_a, 0) == 0 or after_counts.get(b, 0) == 0:\n                    bonus = -0.5  # favor potential color elimination\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b\n            comp = []\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    else:\n        # Color-class merge attempt: pick two colors and try to recolor vertices of minority into majority greedily\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            a,b = random.sample(colors, 2)\n            # Make b the majority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            # Try recolor a-vertices into existing colors excluding a\n            order = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(order)\n            for v in order:\n                best_c = None\n                best_conf = None\n                for c in colors:\n                    if c == a:\n                        continue\n                    conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                if best_c is not None:\n                    new_sol[v] = best_c\n            move_tag = \"class-merge\"\n        else:\n            # Fallback: random recolor within current palette\n            v = random.randrange(n)\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"random-recolor\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    conflicts = collect_conflicts(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve via recolor or Kempe\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor within current palette\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                # Kempe storm around the conflict vertex\n                colors_present = list(set(sol))\n                if len(colors_present) >= 2:\n                    b_choices = [c for c in colors_present if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: multiple random Kempe swaps or palette shake\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                # Occasionally allow introducing a new color to escape deep traps\n                if random.random() < 0.2:\n                    sol[v] = random.randint(1, kmax+1)\n                else:\n                    sol[v] = random.randint(1, kmax)\n        conflicts = collect_conflicts(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,2,1,2,1,1,1,1],2000000003,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003279324}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_LEN_9_INT_COLORS_CANON. Index i in 0..8 maps to vertex i+1. Values are positive ints (color labels). After any move, relabel colors to 1..m by first occurrence order.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    # Validate\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Count edge conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Strict lexicographic objective: feasibility first, then color count\n    return conflicts * 1_000_000_000 + groups_used\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_tag)\n    n = 9\n    # Validate and sanitize strictly\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        cur = [1]*n\n    else:\n        cur = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: canonical relabel 1..m by first occurrence order\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    # Conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def dsatur_pick(arr, prefer_conflict=True):\n        # DSATUR-based vertex selection; prefer conflict vertices first\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.6:\n        # Guided recolor with delta conflicts evaluation and no color bloat unless necessary\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        bad = neighbor_colors(v, new_sol)\n        # Evaluate conflict delta for each candidate color among existing colors\n        best_colors = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Disallow spawning new color unless vertex is in conflict and no zero-conflict option\n        candidates = best_colors[:]\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not in neighbor set when tied\n        pref = [c for c in candidates if c not in bad]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.9:\n        # Kempe chain swap between two colors; prioritize conflict vertices\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        color_a = new_sol[start]\n        neigh_cols = [new_sol[w] for w in adj[start] if new_sol[w] != color_a]\n        colors_present = list(set(new_sol))\n        cand_bs = list(set(neigh_cols)) if neigh_cols else [c for c in colors_present if c != color_a]\n        if not cand_bs:\n            v = start\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = kmax+1 if v in conflict_vertices else new_sol[v]\n            new_sol[v] = best_c\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score candidate b by boundary conflicts after swap\n            def kempe_component(start_v, a, b, arr):\n                seen = [False]*n\n                stack = [start_v]\n                seen[start_v] = True\n                comp = []\n                while stack:\n                    x = stack.pop()\n                    if arr[x] == a or arr[x] == b:\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not seen[y] and (arr[y] == a or arr[y] == b):\n                                seen[y] = True\n                                stack.append(y)\n                return comp\n            best_b = None\n            best_score = None\n            for b in cand_bs:\n                comp = kempe_component(start, color_a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == color_a else color_a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # Bonus if swap may reduce color count (creates empty class)\n                after_counts = {}\n                for x in range(n):\n                    col = new_sol[x]\n                    if x in comp:\n                        col = b if new_sol[x] == color_a else (color_a if new_sol[x] == b else new_sol[x])\n                    after_counts[col] = after_counts.get(col, 0) + 1\n                bonus = 0\n                if after_counts.get(color_a, 0) == 0 or after_counts.get(b, 0) == 0:\n                    bonus = -0.5  # favor potential color elimination\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b\n            comp = []\n            seen = [False]*n\n            stack = [start]\n            seen[start] = True\n            while stack:\n                v = stack.pop()\n                if new_sol[v] == color_a or new_sol[v] == b:\n                    comp.append(v)\n                    for w in adj[v]:\n                        if not seen[w] and (new_sol[w] == color_a or new_sol[w] == b):\n                            seen[w] = True\n                            stack.append(w)\n            for v in comp:\n                if new_sol[v] == color_a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = color_a\n            move_tag = \"kempe-swap\"\n    else:\n        # Color-class merge attempt: pick two colors and try to recolor vertices of minority into majority greedily\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            a,b = random.sample(colors, 2)\n            # Make b the majority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            # Try recolor a-vertices into existing colors excluding a\n            order = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(order)\n            for v in order:\n                best_c = None\n                best_conf = None\n                for c in colors:\n                    if c == a:\n                        continue\n                    conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                if best_c is not None:\n                    new_sol[v] = best_c\n            move_tag = \"class-merge\"\n        else:\n            # Fallback: random recolor within current palette\n            v = random.randrange(n)\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"random-recolor\"\n    # Canonicalize labels to prevent color bloat and normalize representation\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1]*n\n    else:\n        sol = solution[:]\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        mapc = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in mapc:\n                mapc[x] = nxt\n                nxt += 1\n            out.append(mapc[x])\n        return out\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    # Identify conflict edges\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    conflicts = collect_conflicts(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        if conflicts and random.random() < 0.6:\n            # Focused kick: pick a conflict edge and try to resolve via recolor or Kempe\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor within current palette\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                # Kempe storm around the conflict vertex\n                colors_present = list(set(sol))\n                if len(colors_present) >= 2:\n                    b_choices = [c for c in colors_present if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: multiple random Kempe swaps or palette shake\n            start = random.randrange(n)\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors_present if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                v = start\n                kmax = max(sol)\n                # Occasionally allow introducing a new color to escape deep traps\n                if random.random() < 0.2:\n                    sol[v] = random.randint(1, kmax+1)\n                else:\n                    sol[v] = random.randint(1, kmax)\n        conflicts = collect_conflicts(sol)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001737594}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9 where index i in 0..8 corresponds to vertex i+1. Values are positive integers (color labels). Canonicalization: after any move, relabel colors to 1..m by sorting color classes by (class size ascending, then smallest vertex index ascending), and mapping to labels 1..m in that order.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 1_000_000  # > |E| (=17), ensures feasibility prioritized\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        # Stable canonicalization by (class size, smallest index)\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    cur = sanitize(solution)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v: int, arr: List[int]):\n        return set(arr[w] for w in adj[v])\n    def dsatur_pick(arr: List[int], prefer_conflict: bool=True) -> int:\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    def kempe_component(start_v: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.55:\n        # Guided recolor; avoid introducing new colors when possible\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        neigh = neighbor_colors(v, new_sol)\n        # Evaluate conflicts for each existing color\n        best_cols = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:]\n        # Only allow new color if v is in conflict and no zero-conflict option exists\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not present in neighborhood\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.85:\n        # Kempe chain swap\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if not b_choices:\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, max(1, kmax))\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score b by boundary conflicts after swap, with slight bonus for eliminating a color\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == a else a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # simulate counts for elimination bonus\n                counts = {}\n                for i,x in enumerate(new_sol):\n                    col = x\n                    if i in comp:\n                        col = b if x == a else (a if x == b else x)\n                    counts[col] = counts.get(col,0)+1\n                bonus = -0.5 if counts.get(a,0)==0 or counts.get(b,0)==0 else 0.0\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n    else:\n        # Feasibility-preserving class-merge attempt if feasible, else conflict-driven recolor\n        # Check feasibility (no conflicts)\n        feasible = True\n        for u,v in edges:\n            if new_sol[u] == new_sol[v]:\n                feasible = False\n                break\n        if feasible and len(set(new_sol)) >= 2:\n            colors = list(set(new_sol))\n            a,b = random.sample(colors, 2)\n            # make a the minority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            ok = True\n            a_vertices = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(a_vertices)\n            for v in a_vertices:\n                # pick lowest-index color not in neighborhood (excluding a)\n                neigh = neighbor_colors(v, new_sol)\n                candidates = sorted([c for c in set(new_sol) if c != a and c not in neigh])\n                if not candidates:\n                    ok = False\n                    break\n                new_sol[v] = candidates[0]\n            if ok:\n                move_tag = \"class-merge\"\n            else:\n                # rollback not kept; choose a small kempe to diversify\n                start = random.randrange(n)\n                a2 = new_sol[start]\n                colset = list(set(new_sol))\n                b_choices = [c for c in colset if c != a2]\n                if b_choices:\n                    b2 = random.choice(b_choices)\n                    comp = []\n                    comp = [start]  # minimal perturb\n                    for v in comp:\n                        if new_sol[v] == a2:\n                            new_sol[v] = b2\n                        elif new_sol[v] == b2:\n                            new_sol[v] = a2\n                move_tag = \"diversify\"\n        else:\n            # conflict-driven recolor\n            if conflict_vertices:\n                v = random.choice(list(conflict_vertices))\n            else:\n                v = random.randrange(n)\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = random.randint(1, kmax)\n            new_sol[v] = best_c\n            move_tag = \"recolor-conflict\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr: List[int]):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            # Focused kick on a conflict edge\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: random Kempe or palette shake\n            start = random.randrange(n)\n            colors = list(set(sol))\n            if len(colors) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                kmax = max(sol)\n                if random.random() < 0.2:\n                    sol[start] = random.randint(1, kmax+1)\n                else:\n                    sol[start] = random.randint(1, kmax)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001722424}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9 where index i in 0..8 corresponds to vertex i+1. Values are positive integers (color labels). Canonicalization: after any move, relabel colors to 1..m by sorting color classes by (class size ascending, then smallest vertex index ascending), and mapping to labels 1..m in that order.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 1_000_000  # > |E| (=17), ensures feasibility prioritized\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        # Stable canonicalization by (class size, smallest index)\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    cur = sanitize(solution)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v: int, arr: List[int]):\n        return set(arr[w] for w in adj[v])\n    def dsatur_pick(arr: List[int], prefer_conflict: bool=True) -> int:\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    def kempe_component(start_v: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.55:\n        # Guided recolor; avoid introducing new colors when possible\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        neigh = neighbor_colors(v, new_sol)\n        # Evaluate conflicts for each existing color\n        best_cols = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:]\n        # Only allow new color if v is in conflict and no zero-conflict option exists\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not present in neighborhood\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.85:\n        # Kempe chain swap\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if not b_choices:\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, max(1, kmax))\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score b by boundary conflicts after swap, with slight bonus for eliminating a color\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == a else a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # simulate counts for elimination bonus\n                counts = {}\n                for i,x in enumerate(new_sol):\n                    col = x\n                    if i in comp:\n                        col = b if x == a else (a if x == b else x)\n                    counts[col] = counts.get(col,0)+1\n                bonus = -0.5 if counts.get(a,0)==0 or counts.get(b,0)==0 else 0.0\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n    else:\n        # Feasibility-preserving class-merge attempt if feasible, else conflict-driven recolor\n        # Check feasibility (no conflicts)\n        feasible = True\n        for u,v in edges:\n            if new_sol[u] == new_sol[v]:\n                feasible = False\n                break\n        if feasible and len(set(new_sol)) >= 2:\n            colors = list(set(new_sol))\n            a,b = random.sample(colors, 2)\n            # make a the minority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            ok = True\n            a_vertices = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(a_vertices)\n            for v in a_vertices:\n                # pick lowest-index color not in neighborhood (excluding a)\n                neigh = neighbor_colors(v, new_sol)\n                candidates = sorted([c for c in set(new_sol) if c != a and c not in neigh])\n                if not candidates:\n                    ok = False\n                    break\n                new_sol[v] = candidates[0]\n            if ok:\n                move_tag = \"class-merge\"\n            else:\n                # rollback not kept; choose a small kempe to diversify\n                start = random.randrange(n)\n                a2 = new_sol[start]\n                colset = list(set(new_sol))\n                b_choices = [c for c in colset if c != a2]\n                if b_choices:\n                    b2 = random.choice(b_choices)\n                    comp = []\n                    comp = [start]  # minimal perturb\n                    for v in comp:\n                        if new_sol[v] == a2:\n                            new_sol[v] = b2\n                        elif new_sol[v] == b2:\n                            new_sol[v] = a2\n                move_tag = \"diversify\"\n        else:\n            # conflict-driven recolor\n            if conflict_vertices:\n                v = random.choice(list(conflict_vertices))\n            else:\n                v = random.randrange(n)\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = random.randint(1, kmax)\n            new_sol[v] = best_c\n            move_tag = \"recolor-conflict\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr: List[int]):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            # Focused kick on a conflict edge\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: random Kempe or palette shake\n            start = random.randrange(n)\n            colors = list(set(sol))\n            if len(colors) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                kmax = max(sol)\n                if random.random() < 0.2:\n                    sol[start] = random.randint(1, kmax+1)\n                else:\n                    sol[start] = random.randint(1, kmax)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002025317}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9 where index i in 0..8 corresponds to vertex i+1. Values are positive integers (color labels). Canonicalization: after any move, relabel colors to 1..m by sorting color classes by (class size ascending, then smallest vertex index ascending), and mapping to labels 1..m in that order.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 1_000_000  # > |E| (=17), ensures feasibility prioritized\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        # Stable canonicalization by (class size, smallest index)\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    cur = sanitize(solution)\n    # Compute conflict vertices\n    conflict_vertices = set()\n    for u,v in edges:\n        if cur[u] == cur[v]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    def neighbor_colors(v: int, arr: List[int]):\n        return set(arr[w] for w in adj[v])\n    def dsatur_pick(arr: List[int], prefer_conflict: bool=True) -> int:\n        cand = list(conflict_vertices) if (prefer_conflict and conflict_vertices) else list(range(n))\n        best = None\n        best_key = None\n        for v in cand:\n            sat = len(neighbor_colors(v, arr))\n            key = (sat, len(adj[v]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = v\n        return best if best is not None else random.randrange(n)\n    def kempe_component(start_v: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    new_sol = cur[:]\n    move_tag = \"recolor\"\n    r = random.random()\n    if r < 0.55:\n        # Guided recolor; avoid introducing new colors when possible\n        v = dsatur_pick(new_sol, prefer_conflict=True)\n        kmax = max(new_sol)\n        neigh = neighbor_colors(v, new_sol)\n        # Evaluate conflicts for each existing color\n        best_cols = []\n        best_conf = None\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:]\n        # Only allow new color if v is in conflict and no zero-conflict option exists\n        if not candidates:\n            if v in conflict_vertices and (best_conf is None or best_conf > 0):\n                candidates = [kmax+1]\n            else:\n                candidates = [new_sol[v]]\n        # Prefer colors not present in neighborhood\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    elif r < 0.85:\n        # Kempe chain swap\n        start = random.choice(list(conflict_vertices)) if conflict_vertices and random.random() < 0.85 else random.randrange(n)\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if not b_choices:\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, max(1, kmax))\n            move_tag = \"recolor-fallback\"\n        else:\n            # Score b by boundary conflicts after swap, with slight bonus for eliminating a color\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary_conf = 0\n                for v in comp:\n                    new_col = b if new_sol[v] == a else a\n                    for w in adj[v]:\n                        if w not in comp and new_sol[w] == new_col:\n                            boundary_conf += 1\n                # simulate counts for elimination bonus\n                counts = {}\n                for i,x in enumerate(new_sol):\n                    col = x\n                    if i in comp:\n                        col = b if x == a else (a if x == b else x)\n                    counts[col] = counts.get(col,0)+1\n                bonus = -0.5 if counts.get(a,0)==0 or counts.get(b,0)==0 else 0.0\n                score = boundary_conf + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n    else:\n        # Feasibility-preserving class-merge attempt if feasible, else conflict-driven recolor\n        # Check feasibility (no conflicts)\n        feasible = True\n        for u,v in edges:\n            if new_sol[u] == new_sol[v]:\n                feasible = False\n                break\n        if feasible and len(set(new_sol)) >= 2:\n            colors = list(set(new_sol))\n            a,b = random.sample(colors, 2)\n            # make a the minority\n            cnt_a = sum(1 for x in new_sol if x == a)\n            cnt_b = sum(1 for x in new_sol if x == b)\n            if cnt_a > cnt_b:\n                a,b = b,a\n            ok = True\n            a_vertices = [i for i,x in enumerate(new_sol) if x == a]\n            random.shuffle(a_vertices)\n            for v in a_vertices:\n                # pick lowest-index color not in neighborhood (excluding a)\n                neigh = neighbor_colors(v, new_sol)\n                candidates = sorted([c for c in set(new_sol) if c != a and c not in neigh])\n                if not candidates:\n                    ok = False\n                    break\n                new_sol[v] = candidates[0]\n            if ok:\n                move_tag = \"class-merge\"\n            else:\n                # rollback not kept; choose a small kempe to diversify\n                start = random.randrange(n)\n                a2 = new_sol[start]\n                colset = list(set(new_sol))\n                b_choices = [c for c in colset if c != a2]\n                if b_choices:\n                    b2 = random.choice(b_choices)\n                    comp = []\n                    comp = [start]  # minimal perturb\n                    for v in comp:\n                        if new_sol[v] == a2:\n                            new_sol[v] = b2\n                        elif new_sol[v] == b2:\n                            new_sol[v] = a2\n                move_tag = \"diversify\"\n        else:\n            # conflict-driven recolor\n            if conflict_vertices:\n                v = random.choice(list(conflict_vertices))\n            else:\n                v = random.randrange(n)\n            kmax = max(new_sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == new_sol[v]:\n                    continue\n                conf = sum(1 for w in adj[v] if new_sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is None:\n                best_c = random.randint(1, kmax)\n            new_sol[v] = best_c\n            move_tag = \"recolor-conflict\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    # Graph (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr: List[int]) -> List[int]:\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol: List[int]) -> List[int]:\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr: List[int]):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start: int, a: int, b: int, arr: List[int]):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            # Focused kick on a conflict edge\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            # Try least-conflict recolor\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = sum(1 for w in adj[pick] if sol[w] == c)\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Diversification: random Kempe or palette shake\n            start = random.randrange(n)\n            colors = list(set(sol))\n            if len(colors) >= 2 and random.random() < 0.7:\n                a = sol[start]\n                b_choices = [c for c in colors if c != a]\n                b = random.choice(b_choices)\n                kempe_swap_from(start, a, b, sol)\n            else:\n                kmax = max(sol)\n                if random.random() < 0.2:\n                    sol[start] = random.randint(1, kmax+1)\n                else:\n                    sol[start] = random.randint(1, kmax)\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001980616}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9. Index i in 0..8 corresponds to vertex i+1. Each entry is a positive integer color label. After any modification, relabel colors to 1..m by ordering color classes by (class size ascending, then smallest vertex index ascending).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 100  # > |E| (=17), prioritizes feasibility\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def conflict_vertices(arr):\n        s = set()\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                s.add(u); s.add(v)\n        return s\n    def kempe_component(start_v, a, b, arr):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    cur = sanitize(solution)\n    new_sol = cur[:]\n    confV = conflict_vertices(new_sol)\n    r = random.random()\n    move_tag = \"recolor\"\n    if r < 0.5:\n        # Zero\/low-conflict recolor preference on a conflict vertex if any\n        if confV:\n            v = random.choice(list(confV))\n        else:\n            # target vertex in smallest color class\n            counts = {}\n            for i,c in enumerate(new_sol):\n                counts[c] = counts.get(c,0)+1\n            smallest = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            cand = [i for i,x in enumerate(new_sol) if x==smallest]\n            v = random.choice(cand)\n        kmax = max(new_sol)\n        best_cols = []\n        best_conf = None\n        neigh = neighbor_colors(v, new_sol)\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:] if best_cols else [new_sol[v]]\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        # Disallow introducing a new color here\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap centered at a high-saturation vertex\n        if confV and random.random() < 0.8:\n            start = random.choice(list(confV))\n        else:\n            # pick vertex with max distinct neighbor colors\n            best_v = 0\n            best_key = (-1,-1,0)\n            for v in range(n):\n                sat = len(neighbor_colors(v, new_sol))\n                key = (sat, len(adj[v]), random.random())\n                if key > best_key:\n                    best_key = key\n                    best_v = v\n            start = best_v\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if b_choices:\n            # choose b minimizing boundary conflicts after swap\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary = 0\n                comp_set = set(comp)\n                for v in comp:\n                    newc = b if new_sol[v]==a else a\n                    for w in adj[v]:\n                        if w not in comp_set and new_sol[w]==newc:\n                            boundary += 1\n                # slight bonus for eliminating a color\n                cnt_a = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==a))\n                cnt_b = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==b))\n                bonus = -0.5 if cnt_a==0 or cnt_b==0 else 0.0\n                score = boundary + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n        else:\n            # fallback recolor\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"recolor-fallback\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = 0\n                for w in adj[pick]:\n                    if sol[w] == c:\n                        conf += 1\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Small color-drop attempt: target smallest class\n            counts = {}\n            for x in sol:\n                counts[x] = counts.get(x,0)+1\n            a = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            verts = [i for i,x in enumerate(sol) if x==a]\n            random.shuffle(verts)\n            ok = True\n            for vtx in verts[:max(1, len(verts)-1)]:\n                neigh = set(sol[w] for w in adj[vtx])\n                candidates = sorted([c for c in set(sol) if c != a and c not in neigh], key=lambda c: counts.get(c,0))\n                if candidates:\n                    sol[vtx] = candidates[0]\n                    counts[sol[vtx]] = counts.get(sol[vtx],0)+1\n                else:\n                    # targeted Kempe to free a color\n                    colors = list(set(sol))\n                    b_choices = [c for c in colors if c != a]\n                    if not b_choices:\n                        ok = False\n                        break\n                    b = random.choice(b_choices)\n                    kempe_swap_from(vtx, a, b, sol)\n            # continue regardless; perturbation is allowed to be disruptive\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00223142}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9. Index i in 0..8 corresponds to vertex i+1. Each entry is a positive integer color label. After any modification, relabel colors to 1..m by ordering color classes by (class size ascending, then smallest vertex index ascending).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 100  # > |E| (=17), prioritizes feasibility\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def conflict_vertices(arr):\n        s = set()\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                s.add(u); s.add(v)\n        return s\n    def kempe_component(start_v, a, b, arr):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    cur = sanitize(solution)\n    new_sol = cur[:]\n    confV = conflict_vertices(new_sol)\n    r = random.random()\n    move_tag = \"recolor\"\n    if r < 0.5:\n        # Zero\/low-conflict recolor preference on a conflict vertex if any\n        if confV:\n            v = random.choice(list(confV))\n        else:\n            # target vertex in smallest color class\n            counts = {}\n            for i,c in enumerate(new_sol):\n                counts[c] = counts.get(c,0)+1\n            smallest = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            cand = [i for i,x in enumerate(new_sol) if x==smallest]\n            v = random.choice(cand)\n        kmax = max(new_sol)\n        best_cols = []\n        best_conf = None\n        neigh = neighbor_colors(v, new_sol)\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:] if best_cols else [new_sol[v]]\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        # Disallow introducing a new color here\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap centered at a high-saturation vertex\n        if confV and random.random() < 0.8:\n            start = random.choice(list(confV))\n        else:\n            # pick vertex with max distinct neighbor colors\n            best_v = 0\n            best_key = (-1,-1,0)\n            for v in range(n):\n                sat = len(neighbor_colors(v, new_sol))\n                key = (sat, len(adj[v]), random.random())\n                if key > best_key:\n                    best_key = key\n                    best_v = v\n            start = best_v\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if b_choices:\n            # choose b minimizing boundary conflicts after swap\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary = 0\n                comp_set = set(comp)\n                for v in comp:\n                    newc = b if new_sol[v]==a else a\n                    for w in adj[v]:\n                        if w not in comp_set and new_sol[w]==newc:\n                            boundary += 1\n                # slight bonus for eliminating a color\n                cnt_a = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==a))\n                cnt_b = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==b))\n                bonus = -0.5 if cnt_a==0 or cnt_b==0 else 0.0\n                score = boundary + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n        else:\n            # fallback recolor\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"recolor-fallback\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = 0\n                for w in adj[pick]:\n                    if sol[w] == c:\n                        conf += 1\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Small color-drop attempt: target smallest class\n            counts = {}\n            for x in sol:\n                counts[x] = counts.get(x,0)+1\n            a = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            verts = [i for i,x in enumerate(sol) if x==a]\n            random.shuffle(verts)\n            ok = True\n            for vtx in verts[:max(1, len(verts)-1)]:\n                neigh = set(sol[w] for w in adj[vtx])\n                candidates = sorted([c for c in set(sol) if c != a and c not in neigh], key=lambda c: counts.get(c,0))\n                if candidates:\n                    sol[vtx] = candidates[0]\n                    counts[sol[vtx]] = counts.get(sol[vtx],0)+1\n                else:\n                    # targeted Kempe to free a color\n                    colors = list(set(sol))\n                    b_choices = [c for c in colors if c != a]\n                    if not b_choices:\n                        ok = False\n                        break\n                    b = random.choice(b_choices)\n                    kempe_swap_from(vtx, a, b, sol)\n            # continue regardless; perturbation is allowed to be disruptive\n    sol = canonicalize(sol)\n    return sol\n","Resultados":[[1,3,2,3,1,2,3,3,2],103,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004981736}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"List[int] of length 9. Index i in 0..8 corresponds to vertex i+1. Each entry is a positive integer color label. After any modification, relabel colors to 1..m by ordering color classes by (class size ascending, then smallest vertex index ascending).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    n = 9\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for u,v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    CONFLICT_WEIGHT = 100  # > |E| (=17), prioritizes feasibility\n    return conflicts * CONFLICT_WEIGHT + groups_used\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def neighbor_colors(v, arr):\n        s = set()\n        for w in adj[v]:\n            s.add(arr[w])\n        return s\n    def conflict_vertices(arr):\n        s = set()\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                s.add(u); s.add(v)\n        return s\n    def kempe_component(start_v, a, b, arr):\n        seen = [False]*n\n        stack = [start_v]\n        seen[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            if arr[x] == a or arr[x] == b:\n                comp.append(x)\n                for y in adj[x]:\n                    if not seen[y] and (arr[y] == a or arr[y] == b):\n                        seen[y] = True\n                        stack.append(y)\n        return comp\n    cur = sanitize(solution)\n    new_sol = cur[:]\n    confV = conflict_vertices(new_sol)\n    r = random.random()\n    move_tag = \"recolor\"\n    if r < 0.5:\n        # Zero\/low-conflict recolor preference on a conflict vertex if any\n        if confV:\n            v = random.choice(list(confV))\n        else:\n            # target vertex in smallest color class\n            counts = {}\n            for i,c in enumerate(new_sol):\n                counts[c] = counts.get(c,0)+1\n            smallest = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            cand = [i for i,x in enumerate(new_sol) if x==smallest]\n            v = random.choice(cand)\n        kmax = max(new_sol)\n        best_cols = []\n        best_conf = None\n        neigh = neighbor_colors(v, new_sol)\n        for c in range(1, kmax+1):\n            if c == new_sol[v]:\n                continue\n            conf = 0\n            for w in adj[v]:\n                if new_sol[w] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_cols = [c]\n            elif conf == best_conf:\n                best_cols.append(c)\n        candidates = best_cols[:] if best_cols else [new_sol[v]]\n        pref = [c for c in candidates if c not in neigh]\n        if pref:\n            candidates = pref\n        # Disallow introducing a new color here\n        new_sol[v] = random.choice(candidates)\n        move_tag = \"recolor\"\n    else:\n        # Kempe chain swap centered at a high-saturation vertex\n        if confV and random.random() < 0.8:\n            start = random.choice(list(confV))\n        else:\n            # pick vertex with max distinct neighbor colors\n            best_v = 0\n            best_key = (-1,-1,0)\n            for v in range(n):\n                sat = len(neighbor_colors(v, new_sol))\n                key = (sat, len(adj[v]), random.random())\n                if key > best_key:\n                    best_key = key\n                    best_v = v\n            start = best_v\n        a = new_sol[start]\n        colors_present = list(set(new_sol))\n        b_choices = [c for c in colors_present if c != a]\n        if b_choices:\n            # choose b minimizing boundary conflicts after swap\n            best_b = None\n            best_score = None\n            for b in b_choices:\n                comp = kempe_component(start, a, b, new_sol)\n                boundary = 0\n                comp_set = set(comp)\n                for v in comp:\n                    newc = b if new_sol[v]==a else a\n                    for w in adj[v]:\n                        if w not in comp_set and new_sol[w]==newc:\n                            boundary += 1\n                # slight bonus for eliminating a color\n                cnt_a = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==a))\n                cnt_b = sum(1 for i,x in enumerate(new_sol) if (i not in comp_set and x==b))\n                bonus = -0.5 if cnt_a==0 or cnt_b==0 else 0.0\n                score = boundary + bonus\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_b = b\n            b = best_b if best_b is not None else random.choice(b_choices)\n            comp = kempe_component(start, a, b, new_sol)\n            for v in comp:\n                if new_sol[v] == a:\n                    new_sol[v] = b\n                elif new_sol[v] == b:\n                    new_sol[v] = a\n            move_tag = \"kempe-swap\"\n        else:\n            # fallback recolor\n            v = start\n            kmax = max(new_sol)\n            new_sol[v] = random.randint(1, kmax)\n            move_tag = \"recolor-fallback\"\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_tag)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def canonicalize(arr):\n        classes = {}\n        for i,c in enumerate(arr):\n            if c not in classes:\n                classes[c] = {\"count\":0, \"min_idx\":i}\n            classes[c][\"count\"] += 1\n            if i < classes[c][\"min_idx\"]:\n                classes[c][\"min_idx\"] = i\n        order = sorted(classes.items(), key=lambda kv: (kv[1][\"count\"], kv[1][\"min_idx\"]))\n        remap = {old:(i+1) for i,(old,_) in enumerate(order)}\n        return [remap[c] for c in arr]\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n or any((not isinstance(x,int) or x<1) for x in sol):\n            return [1]*n\n        return sol[:]\n    def collect_conflicts(arr):\n        conf = []\n        for u,v in edges:\n            if arr[u] == arr[v]:\n                conf.append((u,v))\n        return conf\n    def kempe_swap_from(start, a, b, arr):\n        seen = [False]*n\n        stack = [start]\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            if arr[v] == a or arr[v] == b:\n                comp.append(v)\n                for w in adj[v]:\n                    if not seen[w] and (arr[w] == a or arr[w] == b):\n                        seen[w] = True\n                        stack.append(w)\n        for v in comp:\n            if arr[v] == a:\n                arr[v] = b\n            elif arr[v] == b:\n                arr[v] = a\n    sol = sanitize(solution)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        conflicts = collect_conflicts(sol)\n        if conflicts and random.random() < 0.6:\n            u,v = random.choice(conflicts)\n            pick = u if random.random() < 0.5 else v\n            kmax = max(sol)\n            best_c = None\n            best_conf = None\n            for c in range(1, kmax+1):\n                if c == sol[pick]:\n                    continue\n                conf = 0\n                for w in adj[pick]:\n                    if sol[w] == c:\n                        conf += 1\n                if best_conf is None or conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            if best_c is not None and best_conf == 0:\n                sol[pick] = best_c\n            else:\n                colors = list(set(sol))\n                if len(colors) >= 2:\n                    b_choices = [c for c in colors if c != sol[pick]]\n                    if b_choices:\n                        b = random.choice(b_choices)\n                        kempe_swap_from(pick, sol[pick], b, sol)\n        else:\n            # Small color-drop attempt: target smallest class\n            counts = {}\n            for x in sol:\n                counts[x] = counts.get(x,0)+1\n            a = min(counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            verts = [i for i,x in enumerate(sol) if x==a]\n            random.shuffle(verts)\n            ok = True\n            for vtx in verts[:max(1, len(verts)-1)]:\n                neigh = set(sol[w] for w in adj[vtx])\n                candidates = sorted([c for c in set(sol) if c != a and c not in neigh], key=lambda c: counts.get(c,0))\n                if candidates:\n                    sol[vtx] = candidates[0]\n                    counts[sol[vtx]] = counts.get(sol[vtx],0)+1\n                else:\n                    # targeted Kempe to free a color\n                    colors = list(set(sol))\n                    b_choices = [c for c in colors if c != a]\n                    if not b_choices:\n                        ok = False\n                        break\n                    b = random.choice(b_choices)\n                    kempe_swap_from(vtx, a, b, sol)\n            # continue regardless; perturbation is allowed to be disruptive\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.003022661}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Heavy penalties for conflicts and invalid inputs.\n    # Graph edges (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return groups_used + conflicts * 1000.0\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution, \"Recolor\", \"SingleIndex\"\n    n = len(solution)\n    new_sol = solution.copy()\n    idx = random.randrange(n)\n    current_colors = set(new_sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Allow exploration: pick from existing colors, with small chance to add a new color\n    if random.random() < 0.15:\n        new_color = max_color + 1\n    else:\n        new_color = random.choice(list(current_colors))\n    # Ensure change\n    if new_color == new_sol[idx]:\n        # pick a different color deterministically if possible\n        choices = list(current_colors)\n        if new_sol[idx] in choices and len(choices) > 1:\n            choices.remove(new_sol[idx])\n            new_color = random.choice(choices)\n        else:\n            new_color = new_sol[idx] + 1\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", \"SingleVertexRecolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    new_sol = solution.copy()\n    steps = random.randint(2, max(3, n \/\/ 2))\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_colors = set(new_sol)\n        max_color = max(current_colors) if current_colors else 1\n        if random.random() < 0.2:\n            new_color = max_color + 1\n        else:\n            new_color = random.choice(list(current_colors))\n        if new_color == new_sol[idx]:\n            # force a different color\n            alt = list(current_colors)\n            if new_sol[idx] in alt and len(alt) > 1:\n                alt.remove(new_sol[idx])\n                new_color = random.choice(alt)\n            else:\n                new_color = new_sol[idx] + 1\n        new_sol[idx] = new_color\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00000419}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Heavy penalties for conflicts and invalid inputs.\n    # Graph edges (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return groups_used + conflicts * 1000.0\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution, \"Recolor\", \"SingleIndex\"\n    n = len(solution)\n    new_sol = solution.copy()\n    idx = random.randrange(n)\n    current_colors = set(new_sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Allow exploration: pick from existing colors, with small chance to add a new color\n    if random.random() < 0.15:\n        new_color = max_color + 1\n    else:\n        new_color = random.choice(list(current_colors))\n    # Ensure change\n    if new_color == new_sol[idx]:\n        # pick a different color deterministically if possible\n        choices = list(current_colors)\n        if new_sol[idx] in choices and len(choices) > 1:\n            choices.remove(new_sol[idx])\n            new_color = random.choice(choices)\n        else:\n            new_color = new_sol[idx] + 1\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", \"SingleVertexRecolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    new_sol = solution.copy()\n    steps = random.randint(2, max(3, n \/\/ 2))\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_colors = set(new_sol)\n        max_color = max(current_colors) if current_colors else 1\n        if random.random() < 0.2:\n            new_color = max_color + 1\n        else:\n            new_color = random.choice(list(current_colors))\n        if new_color == new_sol[idx]:\n            # force a different color\n            alt = list(current_colors)\n            if new_sol[idx] in alt and len(alt) > 1:\n                alt.remove(new_sol[idx])\n                new_color = random.choice(alt)\n            else:\n                new_color = new_sol[idx] + 1\n        new_sol[idx] = new_color\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.00000141}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Heavy penalties for conflicts and invalid inputs.\n    # Graph edges (0-indexed)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    return groups_used + conflicts * 1000.0\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution, \"Recolor\", \"SingleIndex\"\n    n = len(solution)\n    new_sol = solution.copy()\n    idx = random.randrange(n)\n    current_colors = set(new_sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Allow exploration: pick from existing colors, with small chance to add a new color\n    if random.random() < 0.15:\n        new_color = max_color + 1\n    else:\n        new_color = random.choice(list(current_colors))\n    # Ensure change\n    if new_color == new_sol[idx]:\n        # pick a different color deterministically if possible\n        choices = list(current_colors)\n        if new_sol[idx] in choices and len(choices) > 1:\n            choices.remove(new_sol[idx])\n            new_color = random.choice(choices)\n        else:\n            new_color = new_sol[idx] + 1\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", \"SingleVertexRecolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    n = len(solution)\n    new_sol = solution.copy()\n    steps = random.randint(2, max(3, n \/\/ 2))\n    for _ in range(steps):\n        idx = random.randrange(n)\n        current_colors = set(new_sol)\n        max_color = max(current_colors) if current_colors else 1\n        if random.random() < 0.2:\n            new_color = max_color + 1\n        else:\n            new_color = random.choice(list(current_colors))\n        if new_color == new_sol[idx]:\n            # force a different color\n            alt = list(current_colors)\n            if new_sol[idx] in alt and len(alt) > 1:\n                alt.remove(new_sol[idx])\n                new_color = random.choice(alt)\n            else:\n                new_color = new_sol[idx] + 1\n        new_sol[idx] = new_color\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.0000012}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Lexicographic objective via large penalty multiplier:\n    # primary: minimize edge conflicts; secondary: minimize number of colors.\n    # Returns BIG for invalid inputs.\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000_000_000.0\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1 or x > n:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic: conflicts dominate\n    return conflicts * 1_000_000.0 + float(groups_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Domain-aware neighbor: conflict-driven recolor if conflicts exist; otherwise color-reduction attempt.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution, \"Recolor\", \"NoOpInvalidInput\"\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        # Map colors to compact range 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a conflicting vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Try smallest feasible color within current max_color\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden]\n        if feasible:\n            chosen = feasible[0]\n        else:\n            # No feasible within current palette; pick a random existing color different from current\n            palette = [c for c in current_colors if c != new_sol[v]] or [new_sol[v]]\n            chosen = random.choice(palette)\n        new_sol[v] = chosen\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: attempt to reduce max color by recoloring a vertex of the highest color\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        # Indices of vertices with max_color\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[v] = feasible[0]\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak that prefers lower colors but keeps within current palette\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                # Prefer the smallest non-forbidden if available else random palette color\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_sol[v] = feasible[0]\n                else:\n                    new_sol[v] = random.choice(palette)\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex perturbation: recolor a subset of vertices, prioritizing those that would be in conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Identify conflict degrees\n    conflict_deg = [0]*n\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    # Select t vertices: prioritize highest conflict; if no conflicts, random vertices including some from max color class\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    # If no conflicts, bias towards max color class to encourage palette reduction\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(set(new_sol))\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices with random feasible colors within current palette when possible\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick any different color from palette\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n    new_sol = canonize_colors(new_sol)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000841652}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Lexicographic objective via large penalty multiplier:\n    # primary: minimize edge conflicts; secondary: minimize number of colors.\n    # Returns BIG for invalid inputs.\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000_000_000.0\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1 or x > n:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic: conflicts dominate\n    return conflicts * 1_000_000.0 + float(groups_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Domain-aware neighbor: conflict-driven recolor if conflicts exist; otherwise color-reduction attempt.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution, \"Recolor\", \"NoOpInvalidInput\"\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        # Map colors to compact range 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a conflicting vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Try smallest feasible color within current max_color\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden]\n        if feasible:\n            chosen = feasible[0]\n        else:\n            # No feasible within current palette; pick a random existing color different from current\n            palette = [c for c in current_colors if c != new_sol[v]] or [new_sol[v]]\n            chosen = random.choice(palette)\n        new_sol[v] = chosen\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: attempt to reduce max color by recoloring a vertex of the highest color\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        # Indices of vertices with max_color\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[v] = feasible[0]\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak that prefers lower colors but keeps within current palette\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                # Prefer the smallest non-forbidden if available else random palette color\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_sol[v] = feasible[0]\n                else:\n                    new_sol[v] = random.choice(palette)\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex perturbation: recolor a subset of vertices, prioritizing those that would be in conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Identify conflict degrees\n    conflict_deg = [0]*n\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    # Select t vertices: prioritize highest conflict; if no conflicts, random vertices including some from max color class\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    # If no conflicts, bias towards max color class to encourage palette reduction\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(set(new_sol))\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices with random feasible colors within current palette when possible\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick any different color from palette\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n    new_sol = canonize_colors(new_sol)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001046274}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INT_COLORS_START_AT_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Lower is better. Lexicographic objective via large penalty multiplier:\n    # primary: minimize edge conflicts; secondary: minimize number of colors.\n    # Returns BIG for invalid inputs.\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10_000_000_000.0\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1 or x > n:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    groups_used = len(set(solution))\n    # Lexicographic: conflicts dominate\n    return conflicts * 1_000_000.0 + float(groups_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Domain-aware neighbor: conflict-driven recolor if conflicts exist; otherwise color-reduction attempt.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution, \"Recolor\", \"NoOpInvalidInput\"\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        # Map colors to compact range 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a conflicting vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Try smallest feasible color within current max_color\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden]\n        if feasible:\n            chosen = feasible[0]\n        else:\n            # No feasible within current palette; pick a random existing color different from current\n            palette = [c for c in current_colors if c != new_sol[v]] or [new_sol[v]]\n            chosen = random.choice(palette)\n        new_sol[v] = chosen\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: attempt to reduce max color by recoloring a vertex of the highest color\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        # Indices of vertices with max_color\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[v] = feasible[0]\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak that prefers lower colors but keeps within current palette\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                # Prefer the smallest non-forbidden if available else random palette color\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_sol[v] = feasible[0]\n                else:\n                    new_sol[v] = random.choice(palette)\n        new_sol = canonize_colors(new_sol)\n        return new_sol, \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex perturbation: recolor a subset of vertices, prioritizing those that would be in conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution\n\n    def canonize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(solution)\n\n    # Identify conflict degrees\n    conflict_deg = [0]*n\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    # Select t vertices: prioritize highest conflict; if no conflicts, random vertices including some from max color class\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    # If no conflicts, bias towards max color class to encourage palette reduction\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(set(new_sol))\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices with random feasible colors within current palette when possible\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color+1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick any different color from palette\n            palette = [c for c in range(1, max_color+1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n    new_sol = canonize_colors(new_sol)\n    return new_sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001017583}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1","Evaluacion":"import sys\n\ndef evaluate_solution(solution):\n    # Accepts string encoding: space or comma separated integers of length 9\n    # Returns float fitness: lower is better. Lexicographic (conflicts, k=max color)\n    # Strictly self-contained: embeds problem data\n    BIG = float(sys.maxsize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(solution, list):\n            return list(solution)\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None:\n        return BIG\n    if len(arr) != n:\n        return BIG\n    for x in arr:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant objective\n        return float(conflicts) * (sys.maxsize \/\/ 32)\n    # Secondary: minimize number of colors; use k = max color to avoid sparse label bias\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, NB_Type, Movement_Type)\n    # Domain-aware: conflict-driven recolor else color-reduction attempt\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\", \"InvalidInput\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a vertex with maximum conflict degree (tie-break randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Attempt DSATUR-like recolor: choose color minimizing resulting conflicts; prefer smaller color id\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        # Candidate colors within current palette plus possibly a new color (max_color+1) as last resort\n        candidate_colors = list(range(1, max_color + 1))\n        if not candidate_colors:\n            candidate_colors = [1]\n        best_c = None\n        best_conf = 10**9\n        for c in candidate_colors:\n            conf = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and (best_c is None or c < best_c)):\n                best_conf = conf\n                best_c = c\n        # If all within-palette colors conflict equally and equal to degree, allow expanding palette by 1\n        if best_conf > 0 and (max_color + 1) not in candidate_colors:\n            # only if current color also conflicts, try new color\n            best_c = best_c if best_c is not None else (max_color + 1)\n        new_sol[v] = best_c if best_c is not None else new_sol[v]\n        return encode(new_sol), \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: try to reduce palette by moving from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                # Choose smallest feasible to encourage palette compaction\n                new_sol[v] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak to escape plateaus\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[v] = random.choice(feasible)\n            elif palette:\n                new_sol[v] = random.choice(palette)\n        return encode(new_sol), \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex perturbation: recolor a subset of vertices prioritizing conflicts or max color class\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # choose t vertices\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001005103}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1","Evaluacion":"import sys\n\ndef evaluate_solution(solution):\n    # Accepts string encoding: space or comma separated integers of length 9\n    # Returns float fitness: lower is better. Lexicographic (conflicts, k=max color)\n    # Strictly self-contained: embeds problem data\n    BIG = float(sys.maxsize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(solution, list):\n            return list(solution)\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None:\n        return BIG\n    if len(arr) != n:\n        return BIG\n    for x in arr:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant objective\n        return float(conflicts) * (sys.maxsize \/\/ 32)\n    # Secondary: minimize number of colors; use k = max color to avoid sparse label bias\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, NB_Type, Movement_Type)\n    # Domain-aware: conflict-driven recolor else color-reduction attempt\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\", \"InvalidInput\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a vertex with maximum conflict degree (tie-break randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Attempt DSATUR-like recolor: choose color minimizing resulting conflicts; prefer smaller color id\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        # Candidate colors within current palette plus possibly a new color (max_color+1) as last resort\n        candidate_colors = list(range(1, max_color + 1))\n        if not candidate_colors:\n            candidate_colors = [1]\n        best_c = None\n        best_conf = 10**9\n        for c in candidate_colors:\n            conf = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and (best_c is None or c < best_c)):\n                best_conf = conf\n                best_c = c\n        # If all within-palette colors conflict equally and equal to degree, allow expanding palette by 1\n        if best_conf > 0 and (max_color + 1) not in candidate_colors:\n            # only if current color also conflicts, try new color\n            best_c = best_c if best_c is not None else (max_color + 1)\n        new_sol[v] = best_c if best_c is not None else new_sol[v]\n        return encode(new_sol), \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: try to reduce palette by moving from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                # Choose smallest feasible to encourage palette compaction\n                new_sol[v] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak to escape plateaus\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[v] = random.choice(feasible)\n            elif palette:\n                new_sol[v] = random.choice(palette)\n        return encode(new_sol), \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex perturbation: recolor a subset of vertices prioritizing conflicts or max color class\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # choose t vertices\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001333598}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1","Evaluacion":"import sys\n\ndef evaluate_solution(solution):\n    # Accepts string encoding: space or comma separated integers of length 9\n    # Returns float fitness: lower is better. Lexicographic (conflicts, k=max color)\n    # Strictly self-contained: embeds problem data\n    BIG = float(sys.maxsize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(solution, list):\n            return list(solution)\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None:\n        return BIG\n    if len(arr) != n:\n        return BIG\n    for x in arr:\n        if not isinstance(x, int):\n            return BIG\n        if x < 1:\n            return BIG\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Dominant objective\n        return float(conflicts) * (sys.maxsize \/\/ 32)\n    # Secondary: minimize number of colors; use k = max color to avoid sparse label bias\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_str, NB_Type, Movement_Type)\n    # Domain-aware: conflict-driven recolor else color-reduction attempt\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\", \"InvalidInput\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Pick a vertex with maximum conflict degree (tie-break randomly)\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        v = random.choice(candidates)\n        # Attempt DSATUR-like recolor: choose color minimizing resulting conflicts; prefer smaller color id\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        forbidden = {new_sol[u] for u in adj[v]}\n        # Candidate colors within current palette plus possibly a new color (max_color+1) as last resort\n        candidate_colors = list(range(1, max_color + 1))\n        if not candidate_colors:\n            candidate_colors = [1]\n        best_c = None\n        best_conf = 10**9\n        for c in candidate_colors:\n            conf = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and (best_c is None or c < best_c)):\n                best_conf = conf\n                best_c = c\n        # If all within-palette colors conflict equally and equal to degree, allow expanding palette by 1\n        if best_conf > 0 and (max_color + 1) not in candidate_colors:\n            # only if current color also conflicts, try new color\n            best_c = best_c if best_c is not None else (max_color + 1)\n        new_sol[v] = best_c if best_c is not None else new_sol[v]\n        return encode(new_sol), \"Recolor\", \"ConflictDrivenSingleVertex\"\n    else:\n        # No conflicts: try to reduce palette by moving from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for v in max_class:\n            forbidden = {new_sol[u] for u in adj[v]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                # Choose smallest feasible to encourage palette compaction\n                new_sol[v] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Fallback: small tweak to escape plateaus\n            v = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[v]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[v] = random.choice(feasible)\n            elif palette:\n                new_sol[v] = random.choice(palette)\n        return encode(new_sol), \"Recolor\", \"ColorReductionSingleVertex\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex perturbation: recolor a subset of vertices prioritizing conflicts or max color class\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list):\n            return list(sol_str)\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # choose t vertices\n    t = max(2, n \/\/ 3)\n    vertices = list(range(n))\n    vertices.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = vertices[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    current_colors = sorted(set(new_sol))\n    max_color = current_colors[-1]\n\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001311987}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; Vertices are 1..9 mapped to indices 0..8 internally.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Self-contained evaluation for the specified 9-vertex graph coloring\n    # Returns float fitness: lower is better.\n    # Primary objective: minimize number of edge conflicts (dominant, large penalty per conflict)\n    # Secondary objective: minimize max color id (k)\n    BIG = 1_000_000_000.0  # Large penalty multiplier per conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return conflicts * BIG\n\n    # No conflicts: minimize max color id (k)\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, MoveLabel), where MoveLabel in {\"Recolor-ConflictDriven\",\"Recolor-ColorReduction\",\"NoOp\"}\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven single-vertex recolor aiming to reduce local conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        # Try colors within current palette first\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                # evaluate keeping same color only if needed for tie-break\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        # If all within-palette choices collide, consider expanding by one color\n        if best_conf > 0:\n            c = max_color + 1\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_color = c\n                best_conf = conf\n        new_sol[vtx] = best_color\n        return encode(new_sol), \"Recolor-ConflictDriven\"\n    else:\n        # No conflicts: try to reduce the maximum color id by moving vertices from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Feasible tweak within palette to create opportunities\n            vtx = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = random.choice(feasible)\n            elif palette:\n                new_sol[vtx] = random.choice(palette)\n        return encode(new_sol), \"Recolor-ColorReduction\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # Select t vertices biased to conflicts; if none, bias to max color class\n    t = max(2, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices to random feasible colors within current palette; if none, random within palette\n    max_color = max(new_sol)\n    for v in chosen[:t]:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001223366}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; Vertices are 1..9 mapped to indices 0..8 internally.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Self-contained evaluation for the specified 9-vertex graph coloring\n    # Returns float fitness: lower is better.\n    # Primary objective: minimize number of edge conflicts (dominant, large penalty per conflict)\n    # Secondary objective: minimize max color id (k)\n    BIG = 1_000_000_000.0  # Large penalty multiplier per conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return conflicts * BIG\n\n    # No conflicts: minimize max color id (k)\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, MoveLabel), where MoveLabel in {\"Recolor-ConflictDriven\",\"Recolor-ColorReduction\",\"NoOp\"}\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven single-vertex recolor aiming to reduce local conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        # Try colors within current palette first\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                # evaluate keeping same color only if needed for tie-break\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        # If all within-palette choices collide, consider expanding by one color\n        if best_conf > 0:\n            c = max_color + 1\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_color = c\n                best_conf = conf\n        new_sol[vtx] = best_color\n        return encode(new_sol), \"Recolor-ConflictDriven\"\n    else:\n        # No conflicts: try to reduce the maximum color id by moving vertices from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Feasible tweak within palette to create opportunities\n            vtx = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = random.choice(feasible)\n            elif palette:\n                new_sol[vtx] = random.choice(palette)\n        return encode(new_sol), \"Recolor-ColorReduction\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # Select t vertices biased to conflicts; if none, bias to max color class\n    t = max(2, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices to random feasible colors within current palette; if none, random within palette\n    max_color = max(new_sol)\n    for v in chosen[:t]:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001367968}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; Vertices are 1..9 mapped to indices 0..8 internally.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Self-contained evaluation for the specified 9-vertex graph coloring\n    # Returns float fitness: lower is better.\n    # Primary objective: minimize number of edge conflicts (dominant, large penalty per conflict)\n    # Secondary objective: minimize max color id (k)\n    BIG = 1_000_000_000.0  # Large penalty multiplier per conflict\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return conflicts * BIG\n\n    # No conflicts: minimize max color id (k)\n    k = max(arr) if arr else 0\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_str, MoveLabel), where MoveLabel in {\"Recolor-ConflictDriven\",\"Recolor-ColorReduction\",\"NoOp\"}\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflicts per vertex\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven single-vertex recolor aiming to reduce local conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        current_colors = sorted(set(new_sol))\n        max_color = max(current_colors) if current_colors else 1\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        # Try colors within current palette first\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                # evaluate keeping same color only if needed for tie-break\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        # If all within-palette choices collide, consider expanding by one color\n        if best_conf > 0:\n            c = max_color + 1\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_color = c\n                best_conf = conf\n        new_sol[vtx] = best_color\n        return encode(new_sol), \"Recolor-ConflictDriven\"\n    else:\n        # No conflicts: try to reduce the maximum color id by moving vertices from max color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = min(feasible)\n                moved = True\n                break\n        if not moved:\n            # Feasible tweak within palette to create opportunities\n            vtx = random.randrange(n)\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n            feasible = [c for c in palette if c not in forbidden]\n            if feasible:\n                new_sol[vtx] = random.choice(feasible)\n            elif palette:\n                new_sol[vtx] = random.choice(palette)\n        return encode(new_sol), \"Recolor-ColorReduction\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, list) or isinstance(sol_str, tuple):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    new_sol = list(arr)\n\n    # Select t vertices biased to conflicts; if none, bias to max color class\n    t = max(2, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    if all(cd == 0 for cd in conflict_deg):\n        max_color = max(new_sol)\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        for v in max_class:\n            if v not in chosen:\n                chosen.append(v)\n                if len(chosen) >= t:\n                    break\n\n    # Recolor chosen vertices to random feasible colors within current palette; if none, random within palette\n    max_color = max(new_sol)\n    for v in chosen[:t]:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c not in forbidden and c != new_sol[v]]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001332398}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; vertices 1..9 mapped to positions 1..9 in the list.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Evaluate coloring for the fixed 9-vertex graph; lower is better.\n    # Objective: lexicographic (conflicts, k). Mapped to float as conflicts + k\/1000 to ensure conflicts dominate.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors to 1..t by first occurrence order to reduce symmetry\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest conflict vertex, recolor to minimize incident conflicts, no palette expansion\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: try to reduce max color by moving vertices from the highest color class to feasible lower colors\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Try a benign recolor within palette that keeps conflict-free if possible\n            # Pick a random vertex not in singleton color class to diversify\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex feasible-biased shake without introducing new colors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose t vertices biased by conflicts; ensure at least 3 perturbed\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001102445}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; vertices 1..9 mapped to positions 1..9 in the list.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Evaluate coloring for the fixed 9-vertex graph; lower is better.\n    # Objective: lexicographic (conflicts, k). Mapped to float as conflicts + k\/1000 to ensure conflicts dominate.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors to 1..t by first occurrence order to reduce symmetry\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest conflict vertex, recolor to minimize incident conflicts, no palette expansion\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: try to reduce max color by moving vertices from the highest color class to feasible lower colors\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Try a benign recolor within palette that keeps conflict-free if possible\n            # Pick a random vertex not in singleton color class to diversify\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex feasible-biased shake without introducing new colors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose t vertices biased by conflicts; ensure at least 3 perturbed\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001315037}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9_COLORS>=1; vertices 1..9 mapped to positions 1..9 in the list.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Evaluate coloring for the fixed 9-vertex graph; lower is better.\n    # Objective: lexicographic (conflicts, k). Mapped to float as conflicts + k\/1000 to ensure conflicts dominate.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors to 1..t by first occurrence order to reduce symmetry\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest conflict vertex, recolor to minimize incident conflicts, no palette expansion\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                pass\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: try to reduce max color by moving vertices from the highest color class to feasible lower colors\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Try a benign recolor within palette that keeps conflict-free if possible\n            # Pick a random vertex not in singleton color class to diversify\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex feasible-biased shake without introducing new colors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose t vertices biased by conflicts; ensure at least 3 perturbed\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001241777}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest-conflict vertex; recolor within current palette minimizing new conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: attempt color reduction from highest color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Diversification: recolor a random vertex to a feasible alternative within palette\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-vertex shake biased by conflicts; keeps palette size\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose a subset biased by conflicts (at least 3 vertices)\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001181975}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest-conflict vertex; recolor within current palette minimizing new conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: attempt color reduction from highest color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Diversification: recolor a random vertex to a feasible alternative within palette\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-vertex shake biased by conflicts; keeps palette size\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose a subset biased by conflicts (at least 3 vertices)\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001329928}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_same_representation, MoveLabel)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = list(arr)\n\n    # Compute conflict degrees\n    conflict_deg = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if new_sol[u] == new_sol[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Conflict-driven recolor: pick highest-conflict vertex; recolor within current palette minimizing new conflicts\n        max_cd = max(conflict_deg)\n        candidates = [i for i, cd in enumerate(conflict_deg) if cd == max_cd and cd > 0]\n        vtx = random.choice(candidates)\n        max_color = max(new_sol)\n        best_color = new_sol[vtx]\n        best_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    conf += 1\n            if conf < best_conf or (conf == best_conf and c < best_color):\n                best_conf = conf\n                best_color = c\n        new_sol[vtx] = best_color\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-ConflictDriven(v={vtx+1},to={best_color})\"\n    else:\n        # No conflicts: attempt color reduction from highest color class\n        current_colors = sorted(set(new_sol))\n        max_color = current_colors[-1]\n        max_class = [i for i, c in enumerate(new_sol) if c == max_color]\n        random.shuffle(max_class)\n        moved = False\n        for vtx in max_class:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, max_color) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                moved = True\n                label = f\"Recolor-ColorReduction(v={vtx+1},{max_color}->\" + str(new_c) + \")\"\n                break\n        if not moved:\n            # Diversification: recolor a random vertex to a feasible alternative within palette\n            order = list(range(n))\n            random.shuffle(order)\n            for vtx in order:\n                forbidden = {new_sol[u] for u in adj[vtx]}\n                palette = [c for c in range(1, max_color + 1) if c != new_sol[vtx]]\n                feasible = [c for c in palette if c not in forbidden]\n                if feasible:\n                    new_c = random.choice(feasible)\n                    new_sol[vtx] = new_c\n                    label = f\"Recolor-Diversify(v={vtx+1},to={new_c})\"\n                    moved = True\n                    break\n        if not moved:\n            label = \"NoOp\"\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), label\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-vertex shake biased by conflicts; keeps palette size\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    conf_deg = [0]*n\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    max_color = max(arr)\n\n    # Choose a subset biased by conflicts (at least 3 vertices)\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        feasible = [c for c in range(1, max_color + 1) if c != new_sol[v] and c not in forbidden]\n        if feasible:\n            new_sol[v] = random.choice(feasible)\n        else:\n            palette = [c for c in range(1, max_color + 1) if c != new_sol[v]]\n            if palette:\n                new_sol[v] = random.choice(palette)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001650331}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring with conflict-driven recolor,\n    # DSATUR-based color reduction, Kempe-chain swaps, and diversification.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        # Flip the (a,b)-Kempe component containing start\n        target_color = arr[start]\n        if target_color not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            new_arr[v] = a_color if arr[v] == b_color else (b_color if arr[v] == a_color else arr[v])\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair with recolor or Kempe swap\n    if total_conf > 0:\n        # Pick vertex with highest (conflict_deg, dsatur, degree)\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Try recoloring within current palette (steepest descent)\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe-chain swap with each neighbor color to reduce conflicts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change to least-conflicting color (even if not improving)\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction from highest color class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        # DSATUR order to try recoloring into lower palette\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Try Kempe swaps with colors < top to move vertices out of top class\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                if max(trial) <= top:  # keep palette size; reduction may follow in next steps\n                    trial = canonicalize(trial)\n                    if trial != arr:\n                        return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: 1-1 color swap between random adjacent pair if valid\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        # accept if no new conflicts are introduced for u,v\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor within palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake: biased selection + Kempe flips + random recolors.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Choose t vertices: bias to high conflicts then high color index\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Apply a sequence of random Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random recolors within palette; allow temporary use of max_color to diversify\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = [c for c in range(1, max_color + 1)]\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[312132112,null,312132112,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001641992}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring with conflict-driven recolor,\n    # DSATUR-based color reduction, Kempe-chain swaps, and diversification.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        # Flip the (a,b)-Kempe component containing start\n        target_color = arr[start]\n        if target_color not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            new_arr[v] = a_color if arr[v] == b_color else (b_color if arr[v] == a_color else arr[v])\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair with recolor or Kempe swap\n    if total_conf > 0:\n        # Pick vertex with highest (conflict_deg, dsatur, degree)\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Try recoloring within current palette (steepest descent)\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe-chain swap with each neighbor color to reduce conflicts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change to least-conflicting color (even if not improving)\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction from highest color class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        # DSATUR order to try recoloring into lower palette\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Try Kempe swaps with colors < top to move vertices out of top class\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                if max(trial) <= top:  # keep palette size; reduction may follow in next steps\n                    trial = canonicalize(trial)\n                    if trial != arr:\n                        return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: 1-1 color swap between random adjacent pair if valid\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        # accept if no new conflicts are introduced for u,v\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor within palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake: biased selection + Kempe flips + random recolors.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Choose t vertices: bias to high conflicts then high color index\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Apply a sequence of random Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random recolors within palette; allow temporary use of max_color to diversify\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = [c for c in range(1, max_color + 1)]\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[312132112,null,312132112,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001958546}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph evaluation: objective = conflicts + k\/1000 (lower is better)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = max(arr) if arr else 0\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring with conflict-driven recolor,\n    # DSATUR-based color reduction, Kempe-chain swaps, and diversification.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Relabel colors by first occurrence to 1..t\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        # Flip the (a,b)-Kempe component containing start\n        target_color = arr[start]\n        if target_color not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            new_arr[v] = a_color if arr[v] == b_color else (b_color if arr[v] == a_color else arr[v])\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair with recolor or Kempe swap\n    if total_conf > 0:\n        # Pick vertex with highest (conflict_deg, dsatur, degree)\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Try recoloring within current palette (steepest descent)\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe-chain swap with each neighbor color to reduce conflicts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change to least-conflicting color (even if not improving)\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction from highest color class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        # DSATUR order to try recoloring into lower palette\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Try Kempe swaps with colors < top to move vertices out of top class\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                if max(trial) <= top:  # keep palette size; reduction may follow in next steps\n                    trial = canonicalize(trial)\n                    if trial != arr:\n                        return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: 1-1 color swap between random adjacent pair if valid\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        # accept if no new conflicts are introduced for u,v\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor within palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake: biased selection + Kempe flips + random recolors.\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = set([start])\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Choose t vertices: bias to high conflicts then high color index\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Apply a sequence of random Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random recolors within palette; allow temporary use of max_color to diversify\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = [c for c in range(1, max_color + 1)]\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002381991}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    # Objective: conflicts + (number_of_colors)\/1000 (minimize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Best recolor within current palette\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe swap\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: swap two vertices' colors if safe locally\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using Kempe flips and recolors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Random Kempe flips among chosen\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001822714}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    # Objective: conflicts + (number_of_colors)\/1000 (minimize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Best recolor within current palette\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe swap\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: swap two vertices' colors if safe locally\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using Kempe flips and recolors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Random Kempe flips among chosen\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":[123123213,null,123123213,null],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001895465}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    # Objective: conflicts + (number_of_colors)\/1000 (minimize)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Advanced neighbor for 9-vertex graph coloring\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution, \"NoOp\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) If conflicts exist: conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        # Best recolor within current palette\n        best_c = new_sol[vtx]\n        best_add_conf = 10**9\n        for c in range(1, max_color + 1):\n            if c == new_sol[vtx]:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        if best_add_conf < conf_deg[vtx]:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"Recolor-ConflictRepair(v={vtx+1},to={best_c})\"\n        # Try Kempe swap\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != new_sol[vtx]})\n        for c2 in neigh_colors:\n            trial = kempe_flip(new_sol, new_sol[vtx], c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KempeSwap(v={vtx+1},{new_sol[vtx]}<->{c2})\"\n        # Forced change\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"Recolor-Forced(v={vtx+1},to={best_c})\"\n\n    # 2) No conflicts: attempt color reduction\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                new_c = min(feasible)\n                new_sol[vtx] = new_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"ColorReduce-DSATUR(v={vtx+1},{top}->{new_c})\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KempeReduce(v={vtx+1},{top}<->{c2})\"\n\n    # 3) Diversification: swap two vertices' colors if safe locally\n    u, v = random.sample(range(n), 2)\n    if new_sol[u] != new_sol[v]:\n        cu, cv = new_sol[u], new_sol[v]\n        trial = list(new_sol)\n        trial[u], trial[v] = cv, cu\n        ok = True\n        for w in adj[u]:\n            if trial[w] == trial[u]:\n                ok = False\n                break\n        if ok:\n            for w in adj[v]:\n                if trial[w] == trial[v]:\n                    ok = False\n                    break\n        if ok:\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"Swap(u={u+1},v={v+1})\"\n\n    # 4) Fallback random feasible recolor\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                trial = list(new_sol)\n                trial[vtx] = c\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"Recolor-Diversify(v={vtx+1},to={c})\"\n\n    return encode(arr), \"NoOp\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using Kempe flips and recolors\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        return solution\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], arr[i], i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Random Kempe flips among chosen\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        if not neigh_colors:\n            continue\n        c2 = random.choice(neigh_colors)\n        trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n        if trial is not None:\n            new_sol = trial\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001849714}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":["1 2 3 1 2 3 2 1 3",0.003,"1 2 3 1 2 3 2 1 3",0.003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.004272916}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":["1 2 3 2 1 3 2 2 3",0.003,"1 2 3 1 2 3 2 1 3",0.003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.006389695}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002140068}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":["1 2 3 1 2 3 2 1 3",0.003,"1 2 3 1 2 3 2 1 3",0.003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.004677142}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":["1 2 3 1 2 3 2 1 3",0.003,"1 2 3 2 1 3 2 2 3",0.003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.006198982}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Fixed 9-vertex graph coloring evaluator\n    # Objective: minimize conflicts + (number_of_colors)\/1000\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n:\n        return float('inf')\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n\n    conflicts = 0\n    for u, v in edges:\n        if arr[u] == arr[v]:\n            conflicts += 1\n\n    k = len(set(arr))\n    return float(conflicts) + (float(k) \/ 1000.0)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour generator for 9-vertex graph coloring with repair, reduction, and diversification\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        # Stable relabel by order of first occurrence\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def dsatur_key(v, arr, adj):\n        sat = len({arr[u] for u in adj[v]})\n        deg = len(adj[v])\n        return (sat, deg, v)\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Return a valid canonical seed\n        seed = [1,2,3,1,2,3,2,1,3]\n        return encode(seed), \"Init|seed|-|-(valid)\"\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    new_sol = list(arr)\n\n    total_conf, conf_deg = conflicts_and_deg(new_sol)\n    max_color = max(new_sol)\n\n    # 1) Conflict-driven repair\n    if total_conf > 0:\n        candidates = [i for i in range(n) if conf_deg[i] > 0]\n        candidates.sort(key=lambda v: (conf_deg[v],) + dsatur_key(v, new_sol, adj), reverse=True)\n        vtx = candidates[0]\n        from_c = new_sol[vtx]\n        best_c = from_c\n        best_add_conf = 10**9\n        # Try recolors within current palette first\n        for c in range(1, max_color + 1):\n            if c == from_c:\n                continue\n            add_conf = 0\n            for u in adj[vtx]:\n                if new_sol[u] == c:\n                    add_conf += 1\n            if add_conf < best_add_conf or (add_conf == best_add_conf and c < best_c):\n                best_add_conf = add_conf\n                best_c = c\n        # Optionally allow temporary color increase to escape\n        allow_new = True\n        if allow_new:\n            add_conf_new = 0  # new color causes no immediate conflicts\n            if add_conf_new < best_add_conf:\n                best_add_conf = add_conf_new\n                best_c = max_color + 1\n        if best_c != from_c:\n            new_sol[vtx] = best_c\n            new_sol = canonicalize(new_sol)\n            return encode(new_sol), f\"RC|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n        # Kempe swap attempts\n        neigh_colors = sorted({new_sol[u] for u in adj[vtx] if new_sol[u] != from_c})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:3]:\n            trial = kempe_flip(new_sol, from_c, c2, vtx, adj)\n            if trial is None:\n                continue\n            trial = canonicalize(trial)\n            if trial != arr:\n                return encode(trial), f\"KS|{vtx+1}|{from_c}|{c2}\"\n        # Fallback: force recolor to least conflicting within palette\n        new_sol[vtx] = best_c\n        new_sol = canonicalize(new_sol)\n        return encode(new_sol), f\"RCF|{vtx+1}|{from_c}|{new_sol[vtx]}\"\n\n    # 2) No conflicts: attempt color reduction from highest class\n    current_colors = sorted(set(new_sol))\n    if len(current_colors) >= 2:\n        top = current_colors[-1]\n        class_vertices = [i for i, c in enumerate(new_sol) if c == top]\n        class_vertices.sort(key=lambda v: dsatur_key(v, new_sol, adj), reverse=True)\n        # Greedy reassignment to lower colors\n        for vtx in class_vertices:\n            forbidden = {new_sol[u] for u in adj[vtx]}\n            feasible = [c for c in range(1, top) if c not in forbidden]\n            if feasible:\n                from_c = new_sol[vtx]\n                to_c = min(feasible)\n                new_sol[vtx] = to_c\n                new_sol = canonicalize(new_sol)\n                return encode(new_sol), f\"CR|{vtx+1}|{from_c}|{to_c}\"\n        # Kempe attempts with colors < top\n        for vtx in class_vertices:\n            for c2 in range(1, top):\n                trial = kempe_flip(new_sol, top, c2, vtx, adj)\n                if trial is None:\n                    continue\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"KR|{vtx+1}|{top}|{c2}\"\n\n    # 3) Guided diversification: swap colors of two non-adjacent vertices if locally safe\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    for i in range(n):\n        for j in range(i+1, n):\n            u, v = vertices[i], vertices[j]\n            if u == v:\n                continue\n            if new_sol[u] == new_sol[v]:\n                continue\n            # Skip if adjacent\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            cu, cv = new_sol[u], new_sol[v]\n            trial = list(new_sol)\n            trial[u], trial[v] = cv, cu\n            ok = True\n            for w in adj[u]:\n                if trial[w] == trial[u]:\n                    ok = False\n                    break\n            if ok:\n                for w in adj[v]:\n                    if trial[w] == trial[v]:\n                        ok = False\n                        break\n            if ok:\n                trial = canonicalize(trial)\n                if trial != arr:\n                    return encode(trial), f\"SW|{u+1},{v+1}|{cu}|{cv}\"\n\n    # 4) Fallback: random feasible recolor within current palette\n    order = list(range(n))\n    random.shuffle(order)\n    for vtx in order:\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == new_sol[vtx]:\n                continue\n            if all(new_sol[u] != c for u in adj[vtx]):\n                from_c = new_sol[vtx]\n                new_sol[vtx] = c\n                new_sol = canonicalize(new_sol)\n                if new_sol != arr:\n                    return encode(new_sol), f\"RD|{vtx+1}|{from_c}|{c}\"\n\n    return encode(new_sol), \"NOOP|-|-|-\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-vertex Kempe-based shake and recolor\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n\n    def parse(sol_str):\n        if isinstance(sol_str, str):\n            s = sol_str.replace(',', ' ').split()\n            try:\n                arr = [int(x) for x in s]\n            except Exception:\n                return None\n            return arr\n        elif isinstance(sol_str, (list, tuple)):\n            try:\n                arr = [int(x) for x in sol_str]\n            except Exception:\n                return None\n            return arr\n        else:\n            return None\n\n    def encode(arr):\n        return ' '.join(str(x) for x in arr)\n\n    def canonicalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflicts_and_deg(arr):\n        conf_deg = [0]*n\n        total = 0\n        for u, v in edges:\n            if arr[u] == arr[v]:\n                conf_deg[u] += 1\n                conf_deg[v] += 1\n                total += 1\n        return total, conf_deg\n\n    def kempe_flip(arr, a_color, b_color, start, adj):\n        if arr[start] not in (a_color, b_color):\n            return None\n        stack = [start]\n        seen = {start}\n        component = []\n        while stack:\n            v = stack.pop()\n            component.append(v)\n            for u in adj[v]:\n                if u in seen:\n                    continue\n                if arr[u] in (a_color, b_color):\n                    seen.add(u)\n                    stack.append(u)\n        new_arr = list(arr)\n        for v in component:\n            if new_arr[v] == a_color:\n                new_arr[v] = b_color\n            elif new_arr[v] == b_color:\n                new_arr[v] = a_color\n        return new_arr\n\n    arr = parse(solution)\n    if arr is None or len(arr) != n or any((not isinstance(x, int) or x < 1) for x in arr):\n        # Provide a valid perturbation seed\n        return encode([1,2,3,1,2,3,2,1,3])\n\n    adj = build_adj()\n    arr = canonicalize(arr)\n    total_conf, conf_deg = conflicts_and_deg(arr)\n    max_color = max(arr)\n\n    # Select t vertices biased to high conflicts\/degree\n    t = max(3, n \/\/ 3)\n    order = list(range(n))\n    order.sort(key=lambda i: (conf_deg[i], len(adj[i]), -i), reverse=True)\n    chosen = order[:t]\n\n    new_sol = list(arr)\n\n    # Kempe flips among chosen vertices\n    for v in chosen:\n        neigh_colors = list({new_sol[u] for u in adj[v] if new_sol[u] != new_sol[v]})\n        random.shuffle(neigh_colors)\n        for c2 in neigh_colors[:2]:\n            trial = kempe_flip(new_sol, new_sol[v], c2, v, adj)\n            if trial is not None:\n                new_sol = trial\n                break\n\n    # Random feasible recolors within current palette\n    for v in chosen:\n        forbidden = {new_sol[u] for u in adj[v]}\n        palette = list(range(1, max_color + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != new_sol[v] and c not in forbidden:\n                new_sol[v] = c\n                break\n\n    # Optional class merge: try to eliminate highest color if exists\n    colors = sorted(set(new_sol))\n    if len(colors) > 1:\n        top = colors[-1]\n        verts = [i for i,c in enumerate(new_sol) if c == top]\n        random.shuffle(verts)\n        for v in verts:\n            forbidden = {new_sol[u] for u in adj[v]}\n            targets = [c for c in colors[:-1] if c not in forbidden]\n            if targets:\n                new_sol[v] = random.choice(targets)\n\n    new_sol = canonicalize(new_sol)\n    return encode(new_sol)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002187879}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE; solution = [x1,x2,...,x9] with xi>=1 integers representing group labels for students 1..9.","Evaluacion":"import random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Lower is better; heavy penalty ensures feasibility dominates\n    return num_groups + conflicts * 100000","Vecindad":"import random\nimport json\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns two strings: (NB_Type, Movement_Type)\n    # Movement_Type encodes the neighbor solution and move details as JSON string.\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        return (\"InvalidInput\", json.dumps({\"solution\": solution}))\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Helper to count conflicts for a given index with a tentative color\n    def conflicts_if(idx0: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if u-1 == idx0:\n                if color == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx0:\n                if color == arr[u-1]:\n                    cnt += 1\n        return cnt\n    n = 9\n    idx = random.randrange(n)\n    cur_color = solution[idx]\n    max_col = max(solution)\n    candidate_colors = list(range(1, max_col + 2))\n    if cur_color in candidate_colors:\n        candidate_colors.remove(cur_color)\n    # Choose color minimizing new local conflicts (break ties randomly)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        conf = conflicts_if(idx, c, solution)\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    new_color = random.choice(best_colors) if best_colors else cur_color\n    new_solution = solution[:]  # copy\n    new_solution[idx] = new_color\n    payload = {\n        \"solution\": new_solution,\n        \"move\": {\n            \"type\": \"SingleVertexRecolor\",\n            \"index\": idx+1,\n            \"from\": cur_color,\n            \"to\": new_color\n        }\n    }\n    return (\"SingleVertexRecolor\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return a simple default feasible-typed structure (fallback greedy attempt)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        base = default_solution()\n        return base\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    perturbed = solution[:]\n    max_col = max(perturbed)\n    # Number of vertices to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = perturbed[idx]\n        # Try colors 1..max_col+1 and pick one minimizing local conflicts; random tie-break\n        best_colors = []\n        best_conf = None\n        for c in range(1, max_col + 2):\n            if c == cur:\n                continue\n            conf = 0\n            for (u,v) in edges:\n                if u-1 == idx:\n                    if c == perturbed[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == perturbed[u-1]:\n                        conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if best_colors:\n            perturbed[idx] = random.choice(best_colors)\n    return perturbed","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.000575857}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE; solution = [x1,x2,...,x9] with xi>=1 integers representing group labels for students 1..9.","Evaluacion":"import random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Lower is better; heavy penalty ensures feasibility dominates\n    return num_groups + conflicts * 100000","Vecindad":"import random\nimport json\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns two strings: (NB_Type, Movement_Type)\n    # Movement_Type encodes the neighbor solution and move details as JSON string.\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        return (\"InvalidInput\", json.dumps({\"solution\": solution}))\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Helper to count conflicts for a given index with a tentative color\n    def conflicts_if(idx0: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if u-1 == idx0:\n                if color == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx0:\n                if color == arr[u-1]:\n                    cnt += 1\n        return cnt\n    n = 9\n    idx = random.randrange(n)\n    cur_color = solution[idx]\n    max_col = max(solution)\n    candidate_colors = list(range(1, max_col + 2))\n    if cur_color in candidate_colors:\n        candidate_colors.remove(cur_color)\n    # Choose color minimizing new local conflicts (break ties randomly)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        conf = conflicts_if(idx, c, solution)\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    new_color = random.choice(best_colors) if best_colors else cur_color\n    new_solution = solution[:]  # copy\n    new_solution[idx] = new_color\n    payload = {\n        \"solution\": new_solution,\n        \"move\": {\n            \"type\": \"SingleVertexRecolor\",\n            \"index\": idx+1,\n            \"from\": cur_color,\n            \"to\": new_color\n        }\n    }\n    return (\"SingleVertexRecolor\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return a simple default feasible-typed structure (fallback greedy attempt)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        base = default_solution()\n        return base\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    perturbed = solution[:]\n    max_col = max(perturbed)\n    # Number of vertices to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = perturbed[idx]\n        # Try colors 1..max_col+1 and pick one minimizing local conflicts; random tie-break\n        best_colors = []\n        best_conf = None\n        for c in range(1, max_col + 2):\n            if c == cur:\n                continue\n            conf = 0\n            for (u,v) in edges:\n                if u-1 == idx:\n                    if c == perturbed[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == perturbed[u-1]:\n                        conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if best_colors:\n            perturbed[idx] = random.choice(best_colors)\n    return perturbed","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.000760231}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE; solution = [x1,x2,...,x9] with xi>=1 integers representing group labels for students 1..9.","Evaluacion":"import random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Lower is better; heavy penalty ensures feasibility dominates\n    return num_groups + conflicts * 100000","Vecindad":"import random\nimport json\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns two strings: (NB_Type, Movement_Type)\n    # Movement_Type encodes the neighbor solution and move details as JSON string.\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        return (\"InvalidInput\", json.dumps({\"solution\": solution}))\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Helper to count conflicts for a given index with a tentative color\n    def conflicts_if(idx0: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if u-1 == idx0:\n                if color == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx0:\n                if color == arr[u-1]:\n                    cnt += 1\n        return cnt\n    n = 9\n    idx = random.randrange(n)\n    cur_color = solution[idx]\n    max_col = max(solution)\n    candidate_colors = list(range(1, max_col + 2))\n    if cur_color in candidate_colors:\n        candidate_colors.remove(cur_color)\n    # Choose color minimizing new local conflicts (break ties randomly)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        conf = conflicts_if(idx, c, solution)\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    new_color = random.choice(best_colors) if best_colors else cur_color\n    new_solution = solution[:]  # copy\n    new_solution[idx] = new_color\n    payload = {\n        \"solution\": new_solution,\n        \"move\": {\n            \"type\": \"SingleVertexRecolor\",\n            \"index\": idx+1,\n            \"from\": cur_color,\n            \"to\": new_color\n        }\n    }\n    return (\"SingleVertexRecolor\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return a simple default feasible-typed structure (fallback greedy attempt)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c,int) or c<=0) for c in solution):\n        base = default_solution()\n        return base\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    perturbed = solution[:]\n    max_col = max(perturbed)\n    # Number of vertices to perturb\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = perturbed[idx]\n        # Try colors 1..max_col+1 and pick one minimizing local conflicts; random tie-break\n        best_colors = []\n        best_conf = None\n        for c in range(1, max_col + 2):\n            if c == cur:\n                continue\n            conf = 0\n            for (u,v) in edges:\n                if u-1 == idx:\n                    if c == perturbed[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == perturbed[u-1]:\n                        conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if best_colors:\n            perturbed[idx] = random.choice(best_colors)\n    return perturbed","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.000682079}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; semantics depend only on equality\/inequality.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    max_label = max(solution)\n    # Lexicographic objective: minimize conflicts, then groups, then max label\n    # Scale to maintain strict priority\n    return conflicts * 1_000_000 + num_groups * 1_000 + max_label","Vecindad":"import random\nimport json\n\n# Neighbor operator: conflict-biased recolor with compaction-aware policy and optional Kempe 2-color flip on demand\n# Returns (NB_Type, Movement_Type) where Movement_Type is a compact JSON delta including newSolution for direct use.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: vertex conflicts count\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Compute total conflicts and per-vertex conflicts\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    max_col = max(solution)\n\n    # Candidate recolor set policy\n    def best_recolor_for(idx, arr, allow_new_color):\n        cur = arr[idx]\n        best_colors = []\n        best_score = None\n        max_allowed = max(arr) + (1 if allow_new_color else 0)\n        for c in range(1, max_allowed + 1):\n            if c == cur:\n                continue\n            # local conflicts if set idx to c\n            conf = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        conf += 1\n            # tie-break: prefer smaller color to aid compaction\n            score = (conf, c)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            return random.choice(best_colors)\n        return cur\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-biased selection: weight by (1 + conflicts)^2\n        weights = [(1 + vc[i])**2 for i in range(n)]\n        # Normalize and sample\n        r = random.random() * sum(weights)\n        acc = 0.0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                idx = i\n                break\n        # Allow introducing a new color only if it reduces immediate local conflicts strictly\n        cur = new_solution[idx]\n        # Evaluate best without new color\n        c_no_new = best_recolor_for(idx, new_solution, allow_new_color=False)\n        # Evaluate with potential new color\n        c_with_new = best_recolor_for(idx, new_solution, allow_new_color=True)\n        # Compute local conflicts for chosen candidates\n        def local_conf(idx, c, arr):\n            cnt = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        cnt += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        cnt += 1\n            return cnt\n        conf_no_new = local_conf(idx, c_no_new, new_solution)\n        conf_with_new = local_conf(idx, c_with_new, new_solution)\n        if conf_with_new < conf_no_new:\n            chosen = c_with_new\n        else:\n            chosen = c_no_new\n        new_solution[idx] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": chosen},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible: compaction-focused move. Try Kempe chain on two colors to enable class merge tendencies.\n        colors = list(sorted(set(new_solution)))\n        if len(colors) <= 1:\n            # trivial; just recolor different index to color 1\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            target = 1 if cur != 1 else (2 if 2 in colors else 1)\n            new_solution[idx] = target\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": target},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        # BFS over subgraph induced by colors {a,b}\n        comp = set()\n        stack = [start]\n        comp_colors = {i: new_solution[i] for i in cand_indices}\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        # Flip a<->b on the component\n        flipped = new_solution[:]\n        for i in comp:\n            flipped[i] = a if new_solution[i] == b else (b if new_solution[i] == a else new_solution[i])\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\n\n# Multi-vertex perturbation combining: (1) random recolors within existing palette, (2) color-class swap,\n# and (3) Kempe chain flip on random color pair. Designed to escape local minima while preserving structure.\n\ndef perturb_solution(solution):\n    # Fallback default if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    n = 9\n    pert = solution[:]\n    colors = sorted(set(pert))\n\n    # Op1: recolor m random vertices to random existing colors minimizing local conflicts (no new colors)\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: color-class swap between two random colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random pair to perturb structure without introducing new colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        comp.add(v)\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    return pert","Resultados":[[1,2,3,1,2,3,2,1,3],3003,[1,2,3,1,2,3,2,1,3],3003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002251999}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; semantics depend only on equality\/inequality.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    max_label = max(solution)\n    # Lexicographic objective: minimize conflicts, then groups, then max label\n    # Scale to maintain strict priority\n    return conflicts * 1_000_000 + num_groups * 1_000 + max_label","Vecindad":"import random\nimport json\n\n# Neighbor operator: conflict-biased recolor with compaction-aware policy and optional Kempe 2-color flip on demand\n# Returns (NB_Type, Movement_Type) where Movement_Type is a compact JSON delta including newSolution for direct use.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: vertex conflicts count\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Compute total conflicts and per-vertex conflicts\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    max_col = max(solution)\n\n    # Candidate recolor set policy\n    def best_recolor_for(idx, arr, allow_new_color):\n        cur = arr[idx]\n        best_colors = []\n        best_score = None\n        max_allowed = max(arr) + (1 if allow_new_color else 0)\n        for c in range(1, max_allowed + 1):\n            if c == cur:\n                continue\n            # local conflicts if set idx to c\n            conf = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        conf += 1\n            # tie-break: prefer smaller color to aid compaction\n            score = (conf, c)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            return random.choice(best_colors)\n        return cur\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-biased selection: weight by (1 + conflicts)^2\n        weights = [(1 + vc[i])**2 for i in range(n)]\n        # Normalize and sample\n        r = random.random() * sum(weights)\n        acc = 0.0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                idx = i\n                break\n        # Allow introducing a new color only if it reduces immediate local conflicts strictly\n        cur = new_solution[idx]\n        # Evaluate best without new color\n        c_no_new = best_recolor_for(idx, new_solution, allow_new_color=False)\n        # Evaluate with potential new color\n        c_with_new = best_recolor_for(idx, new_solution, allow_new_color=True)\n        # Compute local conflicts for chosen candidates\n        def local_conf(idx, c, arr):\n            cnt = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        cnt += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        cnt += 1\n            return cnt\n        conf_no_new = local_conf(idx, c_no_new, new_solution)\n        conf_with_new = local_conf(idx, c_with_new, new_solution)\n        if conf_with_new < conf_no_new:\n            chosen = c_with_new\n        else:\n            chosen = c_no_new\n        new_solution[idx] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": chosen},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible: compaction-focused move. Try Kempe chain on two colors to enable class merge tendencies.\n        colors = list(sorted(set(new_solution)))\n        if len(colors) <= 1:\n            # trivial; just recolor different index to color 1\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            target = 1 if cur != 1 else (2 if 2 in colors else 1)\n            new_solution[idx] = target\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": target},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        # BFS over subgraph induced by colors {a,b}\n        comp = set()\n        stack = [start]\n        comp_colors = {i: new_solution[i] for i in cand_indices}\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        # Flip a<->b on the component\n        flipped = new_solution[:]\n        for i in comp:\n            flipped[i] = a if new_solution[i] == b else (b if new_solution[i] == a else new_solution[i])\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\n\n# Multi-vertex perturbation combining: (1) random recolors within existing palette, (2) color-class swap,\n# and (3) Kempe chain flip on random color pair. Designed to escape local minima while preserving structure.\n\ndef perturb_solution(solution):\n    # Fallback default if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    n = 9\n    pert = solution[:]\n    colors = sorted(set(pert))\n\n    # Op1: recolor m random vertices to random existing colors minimizing local conflicts (no new colors)\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: color-class swap between two random colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random pair to perturb structure without introducing new colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        comp.add(v)\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    return pert","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3003],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002444122}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; semantics depend only on equality\/inequality.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    max_label = max(solution)\n    # Lexicographic objective: minimize conflicts, then groups, then max label\n    # Scale to maintain strict priority\n    return conflicts * 1_000_000 + num_groups * 1_000 + max_label","Vecindad":"import random\nimport json\n\n# Neighbor operator: conflict-biased recolor with compaction-aware policy and optional Kempe 2-color flip on demand\n# Returns (NB_Type, Movement_Type) where Movement_Type is a compact JSON delta including newSolution for direct use.\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: vertex conflicts count\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Compute total conflicts and per-vertex conflicts\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    max_col = max(solution)\n\n    # Candidate recolor set policy\n    def best_recolor_for(idx, arr, allow_new_color):\n        cur = arr[idx]\n        best_colors = []\n        best_score = None\n        max_allowed = max(arr) + (1 if allow_new_color else 0)\n        for c in range(1, max_allowed + 1):\n            if c == cur:\n                continue\n            # local conflicts if set idx to c\n            conf = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        conf += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        conf += 1\n            # tie-break: prefer smaller color to aid compaction\n            score = (conf, c)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            return random.choice(best_colors)\n        return cur\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-biased selection: weight by (1 + conflicts)^2\n        weights = [(1 + vc[i])**2 for i in range(n)]\n        # Normalize and sample\n        r = random.random() * sum(weights)\n        acc = 0.0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if acc >= r:\n                idx = i\n                break\n        # Allow introducing a new color only if it reduces immediate local conflicts strictly\n        cur = new_solution[idx]\n        # Evaluate best without new color\n        c_no_new = best_recolor_for(idx, new_solution, allow_new_color=False)\n        # Evaluate with potential new color\n        c_with_new = best_recolor_for(idx, new_solution, allow_new_color=True)\n        # Compute local conflicts for chosen candidates\n        def local_conf(idx, c, arr):\n            cnt = 0\n            for (u, v) in edges:\n                if u-1 == idx:\n                    if c == arr[v-1]:\n                        cnt += 1\n                elif v-1 == idx:\n                    if c == arr[u-1]:\n                        cnt += 1\n            return cnt\n        conf_no_new = local_conf(idx, c_no_new, new_solution)\n        conf_with_new = local_conf(idx, c_with_new, new_solution)\n        if conf_with_new < conf_no_new:\n            chosen = c_with_new\n        else:\n            chosen = c_no_new\n        new_solution[idx] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": chosen},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible: compaction-focused move. Try Kempe chain on two colors to enable class merge tendencies.\n        colors = list(sorted(set(new_solution)))\n        if len(colors) <= 1:\n            # trivial; just recolor different index to color 1\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            target = 1 if cur != 1 else (2 if 2 in colors else 1)\n            new_solution[idx] = target\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": target},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        # BFS over subgraph induced by colors {a,b}\n        comp = set()\n        stack = [start]\n        comp_colors = {i: new_solution[i] for i in cand_indices}\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        # Flip a<->b on the component\n        flipped = new_solution[:]\n        for i in comp:\n            flipped[i] = a if new_solution[i] == b else (b if new_solution[i] == a else new_solution[i])\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))","Perturbacion":"import random\n\n# Multi-vertex perturbation combining: (1) random recolors within existing palette, (2) color-class swap,\n# and (3) Kempe chain flip on random color pair. Designed to escape local minima while preserving structure.\n\ndef perturb_solution(solution):\n    # Fallback default if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    n = 9\n    pert = solution[:]\n    colors = sorted(set(pert))\n\n    # Op1: recolor m random vertices to random existing colors minimizing local conflicts (no new colors)\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: color-class swap between two random colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random pair to perturb structure without introducing new colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        comp.add(v)\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    return pert","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001338878}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; only equality matters. Labels may be non-contiguous; evaluation will canonicalize to 1..k.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Feasibility-first objective, then minimize k (groups)\n    # Scale to enforce strict priority\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: per-vertex conflicts with current color\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Helper: local conflicts if idx recolored to c\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict phase: operate on conflicted vertices only\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        # Weighted choice proportional to (1+vc)^2\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = sum(weights)\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Disallow introducing new colors in conflict reduction phase to avoid color drift\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        # Deltas\n        old_vc = vc[pick]\n        new_vc = local_conf(pick, chosen, new_solution)\n        d_conflicts = (new_vc - old_vc)  # each such edge counted once from this vertex perspective; total change is this difference\n        # Group delta\n        d_groups = 0\n        if chosen != cur:\n            if cur not in new_solution:\n                d_groups -= 1\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": cur, \"to\": chosen},\n            \"d_conflicts_hint\": d_conflicts,\n            \"d_groups_hint\": d_groups,\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt color-class elimination\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            # pick smallest color class to try eliminate\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            feasible = True\n            assignment = {}\n            for i in idxs:\n                # choose a color from other_colors that causes zero local conflicts if possible\n                zero_conf = [c for c in other_colors if local_conf(i, c, new_solution) == 0]\n                if zero_conf:\n                    # tie-break by color id to aid compaction\n                    assignment[i] = random.choice(zero_conf)\n                else:\n                    feasible = False\n                    break\n            if feasible:\n                # Apply reassignment\n                for i, c in assignment.items():\n                    new_solution[i] = c\n                # Remove target color label by canonical relabeling\n                # Canonicalize to 1..k\n                mapping = {}\n                next_c = 1\n                for idx in range(n):\n                    v = new_solution[idx]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[idx] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(assignment)},\n                    \"d_conflicts_hint\": 0,\n                    \"d_groups_hint\": -1,\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # If elimination fails or only one color, perform Kempe flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            # trivial recolor to color 1 if needed\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": tgt},\n                \"d_conflicts_hint\": 0,\n                \"d_groups_hint\": 0,\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"d_conflicts_hint\": 0,\n            \"d_groups_hint\": 0,\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random color pair\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k to keep palette compact post-perturb\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002921718}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; only equality matters. Labels may be non-contiguous; evaluation will canonicalize to 1..k.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Feasibility-first objective, then minimize k (groups)\n    # Scale to enforce strict priority\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: per-vertex conflicts with current color\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Helper: local conflicts if idx recolored to c\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict phase: operate on conflicted vertices only\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        # Weighted choice proportional to (1+vc)^2\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = sum(weights)\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Disallow introducing new colors in conflict reduction phase to avoid color drift\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        # Deltas\n        old_vc = vc[pick]\n        new_vc = local_conf(pick, chosen, new_solution)\n        d_conflicts = (new_vc - old_vc)  # each such edge counted once from this vertex perspective; total change is this difference\n        # Group delta\n        d_groups = 0\n        if chosen != cur:\n            if cur not in new_solution:\n                d_groups -= 1\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": cur, \"to\": chosen},\n            \"d_conflicts_hint\": d_conflicts,\n            \"d_groups_hint\": d_groups,\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt color-class elimination\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            # pick smallest color class to try eliminate\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            feasible = True\n            assignment = {}\n            for i in idxs:\n                # choose a color from other_colors that causes zero local conflicts if possible\n                zero_conf = [c for c in other_colors if local_conf(i, c, new_solution) == 0]\n                if zero_conf:\n                    # tie-break by color id to aid compaction\n                    assignment[i] = random.choice(zero_conf)\n                else:\n                    feasible = False\n                    break\n            if feasible:\n                # Apply reassignment\n                for i, c in assignment.items():\n                    new_solution[i] = c\n                # Remove target color label by canonical relabeling\n                # Canonicalize to 1..k\n                mapping = {}\n                next_c = 1\n                for idx in range(n):\n                    v = new_solution[idx]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[idx] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(assignment)},\n                    \"d_conflicts_hint\": 0,\n                    \"d_groups_hint\": -1,\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # If elimination fails or only one color, perform Kempe flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            # trivial recolor to color 1 if needed\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": tgt},\n                \"d_conflicts_hint\": 0,\n                \"d_groups_hint\": 0,\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"d_conflicts_hint\": 0,\n            \"d_groups_hint\": 0,\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random color pair\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k to keep palette compact post-perturb\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003327164}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE: solution = [x1,x2,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Colors are arbitrary positive labels; only equality matters. Labels may be non-contiguous; evaluation will canonicalize to 1..k.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Feasibility-first objective, then minimize k (groups)\n    # Scale to enforce strict priority\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Helper: per-vertex conflicts with current color\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx and arr[v-1] == color:\n                cnt += 1\n            elif v-1 == idx and arr[u-1] == color:\n                cnt += 1\n        return cnt\n\n    # Helper: local conflicts if idx recolored to c\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict phase: operate on conflicted vertices only\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        # Weighted choice proportional to (1+vc)^2\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = sum(weights)\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Disallow introducing new colors in conflict reduction phase to avoid color drift\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        # Deltas\n        old_vc = vc[pick]\n        new_vc = local_conf(pick, chosen, new_solution)\n        d_conflicts = (new_vc - old_vc)  # each such edge counted once from this vertex perspective; total change is this difference\n        # Group delta\n        d_groups = 0\n        if chosen != cur:\n            if cur not in new_solution:\n                d_groups -= 1\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": cur, \"to\": chosen},\n            \"d_conflicts_hint\": d_conflicts,\n            \"d_groups_hint\": d_groups,\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt color-class elimination\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            # pick smallest color class to try eliminate\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            feasible = True\n            assignment = {}\n            for i in idxs:\n                # choose a color from other_colors that causes zero local conflicts if possible\n                zero_conf = [c for c in other_colors if local_conf(i, c, new_solution) == 0]\n                if zero_conf:\n                    # tie-break by color id to aid compaction\n                    assignment[i] = random.choice(zero_conf)\n                else:\n                    feasible = False\n                    break\n            if feasible:\n                # Apply reassignment\n                for i, c in assignment.items():\n                    new_solution[i] = c\n                # Remove target color label by canonical relabeling\n                # Canonicalize to 1..k\n                mapping = {}\n                next_c = 1\n                for idx in range(n):\n                    v = new_solution[idx]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[idx] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(assignment)},\n                    \"d_conflicts_hint\": 0,\n                    \"d_groups_hint\": -1,\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # If elimination fails or only one color, perform Kempe flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            # trivial recolor to color 1 if needed\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": cur, \"to\": tgt},\n                \"d_conflicts_hint\": 0,\n                \"d_groups_hint\": 0,\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        # Build Kempe component from a random vertex with color a or b\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for (x, y) in edges:\n                v = None\n                if x-1 == u:\n                    v = y-1\n                elif y-1 == u:\n                    v = x-1\n                if v is not None and (new_solution[v] == a or new_solution[v] == b) and v not in comp:\n                    stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [a, b], \"size\": len(comp), \"seedIndex\": start+1},\n            \"d_conflicts_hint\": 0,\n            \"d_groups_hint\": 0,\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback if invalid input\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for (u, v) in edges:\n            if u-1 == idx:\n                if c == arr[v-1]:\n                    cnt += 1\n            elif v-1 == idx:\n                if c == arr[u-1]:\n                    cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on random color pair\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for (x, y) in edges:\n                    v = None\n                    if x-1 == u:\n                        v = y-1\n                    elif y-1 == u:\n                        v = x-1\n                    if v is not None and (pert[v] == a or pert[v] == b) and v not in comp:\n                        stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k to keep palette compact post-perturb\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002224609}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Labels arbitrary; only equality matters.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: recolor a conflicted vertex using existing palette\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = float(sum(weights))\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Choose color minimizing local conflicts; break ties by smaller color id, then random among equals\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": int(cur), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt to eliminate a color class sequentially (safe greedy)\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            # Process vertices in an order that prefers easier reassignments first\n            idxs.sort(key=lambda i: sum(1 for nb in adj[i] if new_solution[nb] in other_colors))\n            work = new_solution[:]\n            success = True\n            recolored = []\n            for i in idxs:\n                zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n                if zero_conf:\n                    # prefer smallest color id to compact\n                    choice = min(zero_conf)\n                    work[i] = choice\n                    recolored.append((i, choice))\n                else:\n                    success = False\n                    break\n            if success:\n                # Commit and canonicalize 1..k\n                new_solution = work\n                mapping = {}\n                next_c = 1\n                for i in range(n):\n                    v = new_solution[i]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[i] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Kempe chain flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": int(cur), \"to\": int(tgt)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for v in adj[u]:\n                if new_solution[v] == a or new_solution[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002588884}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Labels arbitrary; only equality matters.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: recolor a conflicted vertex using existing palette\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = float(sum(weights))\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Choose color minimizing local conflicts; break ties by smaller color id, then random among equals\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": int(cur), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt to eliminate a color class sequentially (safe greedy)\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            # Process vertices in an order that prefers easier reassignments first\n            idxs.sort(key=lambda i: sum(1 for nb in adj[i] if new_solution[nb] in other_colors))\n            work = new_solution[:]\n            success = True\n            recolored = []\n            for i in idxs:\n                zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n                if zero_conf:\n                    # prefer smallest color id to compact\n                    choice = min(zero_conf)\n                    work[i] = choice\n                    recolored.append((i, choice))\n                else:\n                    success = False\n                    break\n            if success:\n                # Commit and canonicalize 1..k\n                new_solution = work\n                mapping = {}\n                next_c = 1\n                for i in range(n):\n                    v = new_solution[i]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[i] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Kempe chain flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": int(cur), \"to\": int(tgt)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for v in adj[u]:\n                if new_solution[v] == a or new_solution[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002516772}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers for students 1..9 (1-indexed). Labels arbitrary; only equality matters.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"InvalidInput\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    vc = [v_conflicts(i, solution) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    new_solution = solution[:]\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: recolor a conflicted vertex using existing palette\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if not conflicted:\n            conflicted = list(range(n))\n        weights = [(1 + vc[i])**2 for i in conflicted]\n        s = float(sum(weights))\n        r = random.random() * s\n        acc = 0.0\n        pick = conflicted[0]\n        for i, w in zip(conflicted, weights):\n            acc += w\n            if acc >= r:\n                pick = i\n                break\n        cur = new_solution[pick]\n        palette = sorted(set(new_solution))\n        # Choose color minimizing local conflicts; break ties by smaller color id, then random among equals\n        best_colors = []\n        best_val = None\n        for c in palette:\n            if c == cur:\n                continue\n            conf = local_conf(pick, c, new_solution)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = cur\n        if best_colors:\n            chosen = random.choice(best_colors)\n        new_solution[pick] = chosen\n        payload = {\n            \"move\": {\"type\": \"Recolor\", \"index\": pick+1, \"from\": int(cur), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n    else:\n        # Feasible phase: attempt to eliminate a color class sequentially (safe greedy)\n        colors = sorted(set(new_solution))\n        if len(colors) >= 2:\n            counts = {c: 0 for c in colors}\n            for v in new_solution:\n                counts[v] += 1\n            target = min(colors, key=lambda c: (counts[c], c))\n            other_colors = [c for c in colors if c != target]\n            idxs = [i for i, c in enumerate(new_solution) if c == target]\n            # Process vertices in an order that prefers easier reassignments first\n            idxs.sort(key=lambda i: sum(1 for nb in adj[i] if new_solution[nb] in other_colors))\n            work = new_solution[:]\n            success = True\n            recolored = []\n            for i in idxs:\n                zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n                if zero_conf:\n                    # prefer smallest color id to compact\n                    choice = min(zero_conf)\n                    work[i] = choice\n                    recolored.append((i, choice))\n                else:\n                    success = False\n                    break\n            if success:\n                # Commit and canonicalize 1..k\n                new_solution = work\n                mapping = {}\n                next_c = 1\n                for i in range(n):\n                    v = new_solution[i]\n                    if v not in mapping:\n                        mapping[v] = next_c\n                        next_c += 1\n                    new_solution[i] = mapping[v]\n                payload = {\n                    \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                    \"newSolution\": new_solution,\n                }\n                return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Kempe chain flip between two random colors\n        colors = sorted(set(new_solution))\n        if len(colors) <= 1:\n            idx = random.randrange(n)\n            cur = new_solution[idx]\n            tgt = 1 if cur != 1 else cur\n            new_solution[idx] = tgt\n            payload = {\n                \"move\": {\"type\": \"Recolor\", \"index\": idx+1, \"from\": int(cur), \"to\": int(tgt)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(new_solution) if c == a or c == b]\n        start = random.choice(cand_indices)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            cu = new_solution[u]\n            for v in adj[u]:\n                if new_solution[v] == a or new_solution[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = new_solution[:]\n        for i in comp:\n            if flipped[i] == a:\n                flipped[i] = b\n            elif flipped[i] == b:\n                flipped[i] = a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": start+1},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    m = random.randint(2, 4)\n    m = min(m, n)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        cur = pert[idx]\n        best_colors = []\n        best_val = None\n        for c in colors:\n            if c == cur:\n                continue\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        if best_colors:\n            pert[idx] = random.choice(best_colors)\n\n    # Op2: random color-class swap\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                if pert[i] == a:\n                    pert[i] = b\n                elif pert[i] == b:\n                    pert[i] = a\n\n    # Canonicalize labels to 1..k\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        v = pert[i]\n        if v not in mapping:\n            mapping[v] = next_c\n            next_c += 1\n        pert[i] = mapping[v]\n\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001543611}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; canonicalization in evaluation removes label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Primary objective: conflicts -> weight 1e9, Secondary: number of groups\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with payload to avoid breaking callers\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    ncolors = sorted(set(cur))\n\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Always attempt a real change; three phases\n    # Phase A: If conflicts exist, do min-conflicts steepest descent recolor\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Pick the most conflicted vertex; tie-break by random among them\n        maxc = max(vc[i] for i in conflicted)\n        cand = [i for i in conflicted if vc[i] == maxc]\n        pick = random.choice(cand)\n        palette = sorted(set(cur))\n        # Try all existing colors and also allow introducing a new color only if no existing color reduces local conflicts\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(pick, c, cur)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = random.choice(best_colors)\n        if chosen == cur[pick]:\n            # Force change: if best is current color, pick another best among equals or introduce a new color id\n            alts = [c for c in best_colors if c != cur[pick]]\n            if alts:\n                chosen = random.choice(alts)\n            else:\n                chosen = max(palette) + 1\n        new_solution = cur[:]\n        new_solution[pick] = chosen\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(pick+1), \"from\": int(cur[pick]), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; try to eliminate a color using safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n        # Order by increasing saturation to ease reassignment\n        idxs.sort(key=lambda i: sum(1 for nb in adj[i] if cur[nb] in other_colors))\n        work = cur[:]\n        recolored = []\n        success = True\n        for i in idxs:\n            zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n            if zero_conf:\n                choice = min(zero_conf)\n                work[i] = choice\n                recolored.append((i, choice))\n            else:\n                success = False\n                break\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two colors to diversify without introducing conflicts\n    colors = sorted(set(cur))\n    if len(colors) < 2:\n        # Force an actual change: recolor a random vertex to a new color id 2\n        idx = random.randrange(n)\n        newc = 2 if cur[idx] != 2 else 1\n        new_solution = cur[:]\n        new_solution[idx] = newc\n        new_solution = canonicalize(new_solution)\n        payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    a, b = random.sample(colors, 2)\n    cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n    start = random.choice(cand_indices)\n    # Build Kempe component (alternating colors a\/b)\n    comp = set()\n    stack = [start]\n    while stack:\n        u = stack.pop()\n        if u in comp:\n            continue\n        comp.add(u)\n        for v in adj[u]:\n            if cur[v] == a or cur[v] == b:\n                if v not in comp:\n                    stack.append(v)\n    flipped = cur[:]\n    for i in comp:\n        flipped[i] = b if flipped[i] == a else a\n    flipped = canonicalize(flipped)\n    payload = {\n        \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n        \"newSolution\": flipped,\n    }\n    return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = min(4, n)\n    m = random.randint(2, m)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        elif choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        pert[idx] = choice\n\n    # Op2: random color-class swap (shuffle labels to diversify)\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002569416}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; canonicalization in evaluation removes label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Primary objective: conflicts -> weight 1e9, Secondary: number of groups\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with payload to avoid breaking callers\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    ncolors = sorted(set(cur))\n\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Always attempt a real change; three phases\n    # Phase A: If conflicts exist, do min-conflicts steepest descent recolor\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Pick the most conflicted vertex; tie-break by random among them\n        maxc = max(vc[i] for i in conflicted)\n        cand = [i for i in conflicted if vc[i] == maxc]\n        pick = random.choice(cand)\n        palette = sorted(set(cur))\n        # Try all existing colors and also allow introducing a new color only if no existing color reduces local conflicts\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(pick, c, cur)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = random.choice(best_colors)\n        if chosen == cur[pick]:\n            # Force change: if best is current color, pick another best among equals or introduce a new color id\n            alts = [c for c in best_colors if c != cur[pick]]\n            if alts:\n                chosen = random.choice(alts)\n            else:\n                chosen = max(palette) + 1\n        new_solution = cur[:]\n        new_solution[pick] = chosen\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(pick+1), \"from\": int(cur[pick]), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; try to eliminate a color using safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n        # Order by increasing saturation to ease reassignment\n        idxs.sort(key=lambda i: sum(1 for nb in adj[i] if cur[nb] in other_colors))\n        work = cur[:]\n        recolored = []\n        success = True\n        for i in idxs:\n            zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n            if zero_conf:\n                choice = min(zero_conf)\n                work[i] = choice\n                recolored.append((i, choice))\n            else:\n                success = False\n                break\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two colors to diversify without introducing conflicts\n    colors = sorted(set(cur))\n    if len(colors) < 2:\n        # Force an actual change: recolor a random vertex to a new color id 2\n        idx = random.randrange(n)\n        newc = 2 if cur[idx] != 2 else 1\n        new_solution = cur[:]\n        new_solution[idx] = newc\n        new_solution = canonicalize(new_solution)\n        payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    a, b = random.sample(colors, 2)\n    cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n    start = random.choice(cand_indices)\n    # Build Kempe component (alternating colors a\/b)\n    comp = set()\n    stack = [start]\n    while stack:\n        u = stack.pop()\n        if u in comp:\n            continue\n        comp.add(u)\n        for v in adj[u]:\n            if cur[v] == a or cur[v] == b:\n                if v not in comp:\n                    stack.append(v)\n    flipped = cur[:]\n    for i in comp:\n        flipped[i] = b if flipped[i] == a else a\n    flipped = canonicalize(flipped)\n    payload = {\n        \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n        \"newSolution\": flipped,\n    }\n    return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = min(4, n)\n    m = random.randint(2, m)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        elif choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        pert[idx] = choice\n\n    # Op2: random color-class swap (shuffle labels to diversify)\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002918231}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; canonicalization in evaluation removes label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n    sol = canonicalize(solution)\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n    # Primary objective: conflicts -> weight 1e9, Secondary: number of groups\n    return conflicts * 10**9 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with payload to avoid breaking callers\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    ncolors = sorted(set(cur))\n\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Always attempt a real change; three phases\n    # Phase A: If conflicts exist, do min-conflicts steepest descent recolor\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Pick the most conflicted vertex; tie-break by random among them\n        maxc = max(vc[i] for i in conflicted)\n        cand = [i for i in conflicted if vc[i] == maxc]\n        pick = random.choice(cand)\n        palette = sorted(set(cur))\n        # Try all existing colors and also allow introducing a new color only if no existing color reduces local conflicts\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(pick, c, cur)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        chosen = random.choice(best_colors)\n        if chosen == cur[pick]:\n            # Force change: if best is current color, pick another best among equals or introduce a new color id\n            alts = [c for c in best_colors if c != cur[pick]]\n            if alts:\n                chosen = random.choice(alts)\n            else:\n                chosen = max(palette) + 1\n        new_solution = cur[:]\n        new_solution[pick] = chosen\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(pick+1), \"from\": int(cur[pick]), \"to\": int(chosen)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; try to eliminate a color using safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n        # Order by increasing saturation to ease reassignment\n        idxs.sort(key=lambda i: sum(1 for nb in adj[i] if cur[nb] in other_colors))\n        work = cur[:]\n        recolored = []\n        success = True\n        for i in idxs:\n            zero_conf = [c for c in other_colors if local_conf(i, c, work) == 0]\n            if zero_conf:\n                choice = min(zero_conf)\n                work[i] = choice\n                recolored.append((i, choice))\n            else:\n                success = False\n                break\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two colors to diversify without introducing conflicts\n    colors = sorted(set(cur))\n    if len(colors) < 2:\n        # Force an actual change: recolor a random vertex to a new color id 2\n        idx = random.randrange(n)\n        newc = 2 if cur[idx] != 2 else 1\n        new_solution = cur[:]\n        new_solution[idx] = newc\n        new_solution = canonicalize(new_solution)\n        payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    a, b = random.sample(colors, 2)\n    cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n    start = random.choice(cand_indices)\n    # Build Kempe component (alternating colors a\/b)\n    comp = set()\n    stack = [start]\n    while stack:\n        u = stack.pop()\n        if u in comp:\n            continue\n        comp.add(u)\n        for v in adj[u]:\n            if cur[v] == a or cur[v] == b:\n                if v not in comp:\n                    stack.append(v)\n    flipped = cur[:]\n    for i in comp:\n        flipped[i] = b if flipped[i] == a else a\n    flipped = canonicalize(flipped)\n    payload = {\n        \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n        \"newSolution\": flipped,\n    }\n    return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = min(4, n)\n    m = random.randint(2, m)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        elif choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        pert[idx] = choice\n\n    # Op2: random color-class swap (shuffle labels to diversify)\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001867749}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; evaluation canonicalizes to 1..k to remove label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups. 1e6 keeps headroom and clear separation.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, do steepest-descent recolor within existing palette (no new colors)\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Rank by conflicts then degree (higher first), break ties randomly\n        best_improve = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            # Try all existing colors (no new color introduction here)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                score = (delta, -deg[i], c)\n                if (best_improve is None) or (score < best_improve):\n                    best_improve = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_improve:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            new_solution = canonicalize(new_solution)\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Fallback if no alternative found (shouldn't happen): random conflicted vertex recolor to any existing color\n        i = random.choice(conflicted)\n        alts = [c for c in colors if c != cur[i]]\n        c = random.choice(alts) if alts else cur[i]\n        new_solution = cur[:]\n        new_solution[i] = c\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorFallback\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by domain size (available zero-conf colors), then by degree descending\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n        success = True\n        # Limited backtracking depth-2: try up to two choices when domain size > 1\n        def try_reassign(pos, arr, rec):\n            if pos == len(idxs):\n                return True, arr, rec\n            i = idxs[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            # Try up to two options to avoid combinatorial blowup\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(0, work, [])\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip biased by rarest color; accept non-worsening conflicts (feasible stays feasible)\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        rare = min(colors, key=lambda c: (counts[c], c))\n        # pick partner color that interacts most with rare (rough heuristic)\n        freq = {c: 0 for c in colors}\n        for u in range(n):\n            if cur[u] == rare:\n                for v in adj[u]:\n                    freq[cur[v]] += 1\n        partners = [c for c in colors if c != rare]\n        if partners:\n            b = min(partners, key=lambda c: (-freq[c], c))\n        else:\n            b = random.choice(colors)\n        a = rare\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component (alternating colors a\/b)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        flipped = canonicalize(flipped)\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    new_solution = canonicalize(new_solution)\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # allow diversification if only one color exists\n        pert[idx] = choice\n\n    # Op2: random color-class relabeling (swap two labels) to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.00283764}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; evaluation canonicalizes to 1..k to remove label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups. 1e6 keeps headroom and clear separation.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, do steepest-descent recolor within existing palette (no new colors)\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Rank by conflicts then degree (higher first), break ties randomly\n        best_improve = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            # Try all existing colors (no new color introduction here)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                score = (delta, -deg[i], c)\n                if (best_improve is None) or (score < best_improve):\n                    best_improve = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_improve:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            new_solution = canonicalize(new_solution)\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Fallback if no alternative found (shouldn't happen): random conflicted vertex recolor to any existing color\n        i = random.choice(conflicted)\n        alts = [c for c in colors if c != cur[i]]\n        c = random.choice(alts) if alts else cur[i]\n        new_solution = cur[:]\n        new_solution[i] = c\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorFallback\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by domain size (available zero-conf colors), then by degree descending\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n        success = True\n        # Limited backtracking depth-2: try up to two choices when domain size > 1\n        def try_reassign(pos, arr, rec):\n            if pos == len(idxs):\n                return True, arr, rec\n            i = idxs[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            # Try up to two options to avoid combinatorial blowup\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(0, work, [])\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip biased by rarest color; accept non-worsening conflicts (feasible stays feasible)\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        rare = min(colors, key=lambda c: (counts[c], c))\n        # pick partner color that interacts most with rare (rough heuristic)\n        freq = {c: 0 for c in colors}\n        for u in range(n):\n            if cur[u] == rare:\n                for v in adj[u]:\n                    freq[cur[v]] += 1\n        partners = [c for c in colors if c != rare]\n        if partners:\n            b = min(partners, key=lambda c: (-freq[c], c))\n        else:\n            b = random.choice(colors)\n        a = rare\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component (alternating colors a\/b)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        flipped = canonicalize(flipped)\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    new_solution = canonicalize(new_solution)\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # allow diversification if only one color exists\n        pert[idx] = choice\n\n    # Op2: random color-class relabeling (swap two labels) to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003827432}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution = [x1,...,x9] with xi>=1 integers (1-indexed students). Labels are arbitrary; evaluation canonicalizes to 1..k to remove label bias.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups. 1e6 keeps headroom and clear separation.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = canonicalize(solution[:])\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, do steepest-descent recolor within existing palette (no new colors)\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        # Rank by conflicts then degree (higher first), break ties randomly\n        best_improve = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            # Try all existing colors (no new color introduction here)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                score = (delta, -deg[i], c)\n                if (best_improve is None) or (score < best_improve):\n                    best_improve = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_improve:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            new_solution = canonicalize(new_solution)\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": new_solution,\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n        # Fallback if no alternative found (shouldn't happen): random conflicted vertex recolor to any existing color\n        i = random.choice(conflicted)\n        alts = [c for c in colors if c != cur[i]]\n        c = random.choice(alts) if alts else cur[i]\n        new_solution = cur[:]\n        new_solution[i] = c\n        new_solution = canonicalize(new_solution)\n        payload = {\n            \"move\": {\"type\": \"RecolorFallback\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n            \"newSolution\": new_solution,\n        }\n        return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by domain size (available zero-conf colors), then by degree descending\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n        success = True\n        # Limited backtracking depth-2: try up to two choices when domain size > 1\n        def try_reassign(pos, arr, rec):\n            if pos == len(idxs):\n                return True, arr, rec\n            i = idxs[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            # Try up to two options to avoid combinatorial blowup\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(0, work, [])\n        if success:\n            work = canonicalize(work)\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": work,\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip biased by rarest color; accept non-worsening conflicts (feasible stays feasible)\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        rare = min(colors, key=lambda c: (counts[c], c))\n        # pick partner color that interacts most with rare (rough heuristic)\n        freq = {c: 0 for c in colors}\n        for u in range(n):\n            if cur[u] == rare:\n                for v in adj[u]:\n                    freq[cur[v]] += 1\n        partners = [c for c in colors if c != rare]\n        if partners:\n            b = min(partners, key=lambda c: (-freq[c], c))\n        else:\n            b = random.choice(colors)\n        a = rare\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component (alternating colors a\/b)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        flipped = canonicalize(flipped)\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": flipped,\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    new_solution = canonicalize(new_solution)\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": new_solution}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = canonicalize(solution[:])\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # allow diversification if only one color exists\n        pert[idx] = choice\n\n    # Op2: random color-class relabeling (swap two labels) to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002016242}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution=[x1,...,x9] with xi>=1 integers (1-indexed students). Labels arbitrary; evaluation canonicalizes to 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Keep internal labels as-is to reduce churn; only canonicalize outputs\n    cur = solution[:]\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, steepest-descent recolor within existing palette\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        best_score = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                # Tie-break toward rarer colors to aid palette compression\n                rarity = sum(1 for v in cur if v == c)\n                score = (delta, -deg[i], rarity, c)\n                if (best_score is None) or (score < best_score):\n                    best_score = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_score:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            # With small probability perform a random sideways step to avoid cycles\n            p_walk = 0.1\n            if random.random() < p_walk:\n                i = random.choice(conflicted)\n                alts = [c for c in colors if c != cur[i]] or [cur[i]]\n                c = random.choice(alts)\n                new_solution = cur[:]\n                new_solution[i] = c\n                payload = {\n                    \"move\": {\"type\": \"RandomWalkRecolor\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n                    \"newSolution\": canonicalize(new_solution),\n                }\n                return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n\n        # limited backtracking depth up to 4 or len(idxs)\n        max_depth = min(4, len(idxs))\n\n        def try_reassign(order, pos, arr, rec):\n            if pos == len(order):\n                return True, arr, rec\n            if pos >= max_depth and any(local_conf(i, target, arr) == 0 for i in order[pos:]):\n                # cutoff heuristic beyond depth\n                return False, arr, rec\n            i = order[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(order, pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(idxs, 0, work, [])\n        if success:\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip; choose pair by cut-size to bias improvement\n    if len(colors) >= 2:\n        # compute cut sizes between colors\n        cut = {a: {b: 0 for b in colors} for a in colors}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in colors for b in colors if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.003045294}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution=[x1,...,x9] with xi>=1 integers (1-indexed students). Labels arbitrary; evaluation canonicalizes to 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Keep internal labels as-is to reduce churn; only canonicalize outputs\n    cur = solution[:]\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, steepest-descent recolor within existing palette\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        best_score = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                # Tie-break toward rarer colors to aid palette compression\n                rarity = sum(1 for v in cur if v == c)\n                score = (delta, -deg[i], rarity, c)\n                if (best_score is None) or (score < best_score):\n                    best_score = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_score:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            # With small probability perform a random sideways step to avoid cycles\n            p_walk = 0.1\n            if random.random() < p_walk:\n                i = random.choice(conflicted)\n                alts = [c for c in colors if c != cur[i]] or [cur[i]]\n                c = random.choice(alts)\n                new_solution = cur[:]\n                new_solution[i] = c\n                payload = {\n                    \"move\": {\"type\": \"RandomWalkRecolor\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n                    \"newSolution\": canonicalize(new_solution),\n                }\n                return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n\n        # limited backtracking depth up to 4 or len(idxs)\n        max_depth = min(4, len(idxs))\n\n        def try_reassign(order, pos, arr, rec):\n            if pos == len(order):\n                return True, arr, rec\n            if pos >= max_depth and any(local_conf(i, target, arr) == 0 for i in order[pos:]):\n                # cutoff heuristic beyond depth\n                return False, arr, rec\n            i = order[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(order, pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(idxs, 0, work, [])\n        if success:\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip; choose pair by cut-size to bias improvement\n    if len(colors) >= 2:\n        # compute cut sizes between colors\n        cut = {a: {b: 0 for b in colors} for a in colors}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in colors for b in colors if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.004417581}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE. solution=[x1,...,x9] with xi>=1 integers (1-indexed students). Labels arbitrary; evaluation canonicalizes to 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Keep internal labels as-is to reduce churn; only canonicalize outputs\n    cur = solution[:]\n    colors = sorted(set(cur))\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: If conflicts exist, steepest-descent recolor within existing palette\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        best_score = None\n        best_moves = []\n        palette = sorted(set(cur))\n        for i in conflicted:\n            curc = cur[i]\n            cur_local = local_conf(i, curc, cur)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                delta = conf - cur_local  # want most negative\n                # Tie-break toward rarer colors to aid palette compression\n                rarity = sum(1 for v in cur if v == c)\n                score = (delta, -deg[i], rarity, c)\n                if (best_score is None) or (score < best_score):\n                    best_score = score\n                    best_moves = [(i, c, conf, cur_local)]\n                elif score == best_score:\n                    best_moves.append((i, c, conf, cur_local))\n        if best_moves:\n            # With small probability perform a random sideways step to avoid cycles\n            p_walk = 0.1\n            if random.random() < p_walk:\n                i = random.choice(conflicted)\n                alts = [c for c in colors if c != cur[i]] or [cur[i]]\n                c = random.choice(alts)\n                new_solution = cur[:]\n                new_solution[i] = c\n                payload = {\n                    \"move\": {\"type\": \"RandomWalkRecolor\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c)},\n                    \"newSolution\": canonicalize(new_solution),\n                }\n                return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n            i, c, conf_new, conf_old = random.choice(best_moves)\n            new_solution = cur[:]\n            new_solution[i] = c\n            payload = {\n                \"move\": {\"type\": \"RecolorMinConflicts\", \"index\": int(i+1), \"from\": int(cur[i]), \"to\": int(c), \"deltaLocal\": int(conf_new - conf_old)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Feasible; attempt to eliminate the smallest color class via safe reassignment\n    colors = sorted(set(cur))\n    if len(colors) >= 2:\n        counts = {c: 0 for c in colors}\n        for v in cur:\n            counts[v] += 1\n        target = min(colors, key=lambda c: (counts[c], c))\n        other_colors = [c for c in colors if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_size(i, arr):\n            return sum(1 for c in other_colors if local_conf(i, c, arr) == 0)\n        idxs.sort(key=lambda i: (domain_size(i, cur), -deg[i]))\n\n        work = cur[:]\n        recolored = []\n\n        # limited backtracking depth up to 4 or len(idxs)\n        max_depth = min(4, len(idxs))\n\n        def try_reassign(order, pos, arr, rec):\n            if pos == len(order):\n                return True, arr, rec\n            if pos >= max_depth and any(local_conf(i, target, arr) == 0 for i in order[pos:]):\n                # cutoff heuristic beyond depth\n                return False, arr, rec\n            i = order[pos]\n            zeros = [c for c in other_colors if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return False, arr, rec\n            cand = zeros[:2] if len(zeros) > 2 else zeros\n            random.shuffle(cand)\n            for c in cand:\n                arr2 = arr[:]\n                arr2[i] = c\n                ok, arr3, rec3 = try_reassign(order, pos+1, arr2, rec+[(i, c)])\n                if ok:\n                    return True, arr3, rec3\n            return False, arr, rec\n\n        success, work, recolored = try_reassign(idxs, 0, work, [])\n        if success:\n            payload = {\n                \"move\": {\"type\": \"EliminateColor\", \"removed\": int(target), \"recolored_count\": len(recolored)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip; choose pair by cut-size to bias improvement\n    if len(colors) >= 2:\n        # compute cut sizes between colors\n        cut = {a: {b: 0 for b in colors} for a in colors}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in colors for b in colors if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(colors, 2)\n        cand_indices = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand_indices) if cand_indices else random.randrange(n)\n        # Build Kempe component\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase D: Degenerate case with single color -> force recolor one vertex to create palette\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.002102284}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: Resolve conflicts via min-conflicts recolor within palette; allow occasional new color to escape\n    palette = sorted(set(cur))\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n            curc = cur[i]\n            best = []\n            best_val = None\n            # Try existing colors first\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                score = (conf, -deg[i], c)\n                if best_val is None or score < best_val:\n                    best_val = score\n                    best = [c]\n                elif score == best_val:\n                    best.append(c)\n            # With small probability, introduce a new color to break deadlocks\n            if random.random() < 0.1:\n                newc = max(palette) + 1\n                best.append(newc)\n            to_color = random.choice(best) if best else curc\n            new_solution = cur[:]\n            new_solution[i] = to_color\n            payload = {\n                \"move\": {\"type\": \"MinConflictsRecolor\", \"index\": int(i+1), \"from\": int(curc), \"to\": int(to_color)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Attempt to eliminate smallest color class via greedy safe reassignment\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        other = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_zero(i, arr):\n            return [c for c in other if local_conf(i, c, arr) == 0]\n\n        order = sorted(idxs, key=lambda i: (len(domain_zero(i, cur)), -deg[i]))\n        work = cur[:]\n        feasible = True\n        for i in order:\n            zeros = domain_zero(i, work)\n            if not zeros:\n                feasible = False\n                break\n            work[i] = random.choice(zeros)\n        if feasible:\n            payload = {\n                \"move\": {\"type\": \"EliminateColorGreedy\", \"removed\": int(target), \"recolored\": len(order)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two random colors biased by cut-size\n    if len(palette) >= 2:\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(palette, 2)\n        cand = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand) if cand else random.randrange(n)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Degenerate: single color, force recolor\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":[[1,2,3,1,2,3,2,1,3],3,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.002690961}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: Resolve conflicts via min-conflicts recolor within palette; allow occasional new color to escape\n    palette = sorted(set(cur))\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n            curc = cur[i]\n            best = []\n            best_val = None\n            # Try existing colors first\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                score = (conf, -deg[i], c)\n                if best_val is None or score < best_val:\n                    best_val = score\n                    best = [c]\n                elif score == best_val:\n                    best.append(c)\n            # With small probability, introduce a new color to break deadlocks\n            if random.random() < 0.1:\n                newc = max(palette) + 1\n                best.append(newc)\n            to_color = random.choice(best) if best else curc\n            new_solution = cur[:]\n            new_solution[i] = to_color\n            payload = {\n                \"move\": {\"type\": \"MinConflictsRecolor\", \"index\": int(i+1), \"from\": int(curc), \"to\": int(to_color)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Attempt to eliminate smallest color class via greedy safe reassignment\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        other = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_zero(i, arr):\n            return [c for c in other if local_conf(i, c, arr) == 0]\n\n        order = sorted(idxs, key=lambda i: (len(domain_zero(i, cur)), -deg[i]))\n        work = cur[:]\n        feasible = True\n        for i in order:\n            zeros = domain_zero(i, work)\n            if not zeros:\n                feasible = False\n                break\n            work[i] = random.choice(zeros)\n        if feasible:\n            payload = {\n                \"move\": {\"type\": \"EliminateColorGreedy\", \"removed\": int(target), \"recolored\": len(order)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two random colors biased by cut-size\n    if len(palette) >= 2:\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(palette, 2)\n        cand = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand) if cand else random.randrange(n)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Degenerate: single color, force recolor\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":["KempeFlip",1000000000000000000,[1,2,3,1,2,3,2,1,3],3],"Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.003124916}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution):\n    # Validate input; if invalid, return a NoOp with diagnostic payload\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        payload = {\"error\": \"InvalidInput\", \"solution\": solution}\n        return (\"NoOp\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def v_conflicts(idx, arr):\n        color = arr[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        cnt = 0\n        for nb in adj[idx]:\n            if arr[nb] == c:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    deg = [len(adj[i]) for i in range(n)]\n    vc = [v_conflicts(i, cur) for i in range(n)]\n    total_conflicts = sum(vc) \/\/ 2\n\n    # Phase A: Resolve conflicts via min-conflicts recolor within palette; allow occasional new color to escape\n    palette = sorted(set(cur))\n    if total_conflicts > 0:\n        conflicted = [i for i in range(n) if vc[i] > 0]\n        if conflicted:\n            i = random.choice(conflicted)\n            curc = cur[i]\n            best = []\n            best_val = None\n            # Try existing colors first\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                score = (conf, -deg[i], c)\n                if best_val is None or score < best_val:\n                    best_val = score\n                    best = [c]\n                elif score == best_val:\n                    best.append(c)\n            # With small probability, introduce a new color to break deadlocks\n            if random.random() < 0.1:\n                newc = max(palette) + 1\n                best.append(newc)\n            to_color = random.choice(best) if best else curc\n            new_solution = cur[:]\n            new_solution[i] = to_color\n            payload = {\n                \"move\": {\"type\": \"MinConflictsRecolor\", \"index\": int(i+1), \"from\": int(curc), \"to\": int(to_color)},\n                \"newSolution\": canonicalize(new_solution),\n            }\n            return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase B: Attempt to eliminate smallest color class via greedy safe reassignment\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        other = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        def domain_zero(i, arr):\n            return [c for c in other if local_conf(i, c, arr) == 0]\n\n        order = sorted(idxs, key=lambda i: (len(domain_zero(i, cur)), -deg[i]))\n        work = cur[:]\n        feasible = True\n        for i in order:\n            zeros = domain_zero(i, work)\n            if not zeros:\n                feasible = False\n                break\n            work[i] = random.choice(zeros)\n        if feasible:\n            payload = {\n                \"move\": {\"type\": \"EliminateColorGreedy\", \"removed\": int(target), \"recolored\": len(order)},\n                \"newSolution\": canonicalize(work),\n            }\n            return (\"EliminateColor\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Phase C: Kempe chain flip between two random colors biased by cut-size\n    if len(palette) >= 2:\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        if pairs:\n            a, b, _ = max(pairs, key=lambda t: (t[2], -t[0], -t[1]))\n        else:\n            a, b = random.sample(palette, 2)\n        cand = [i for i, c in enumerate(cur) if c == a or c == b]\n        start = random.choice(cand) if cand else random.randrange(n)\n        comp = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in comp:\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if cur[v] == a or cur[v] == b:\n                    if v not in comp:\n                        stack.append(v)\n        flipped = cur[:]\n        for i in comp:\n            flipped[i] = b if flipped[i] == a else a\n        payload = {\n            \"move\": {\"type\": \"KempeFlip\", \"colors\": [int(a), int(b)], \"size\": len(comp), \"seedIndex\": int(start+1)},\n            \"newSolution\": canonicalize(flipped),\n        }\n        return (\"KempeFlip\", json.dumps(payload, separators=(\",\", \":\")))\n\n    # Degenerate: single color, force recolor\n    idx = random.randrange(n)\n    newc = 2 if cur[idx] != 2 else 1\n    new_solution = cur[:]\n    new_solution[idx] = newc\n    payload = {\"move\": {\"type\": \"ForceRecolor\", \"index\": int(idx+1), \"from\": int(cur[idx]), \"to\": int(newc)}, \"newSolution\": canonicalize(new_solution)}\n    return (\"Recolor\", json.dumps(payload, separators=(\",\", \":\")))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n\n    # Op1: recolor m random vertices toward minimal local conflicts within existing palette\n    colors = sorted(set(pert))\n    if not colors:\n        return default_solution()\n    m = random.randint(2, min(4, n))\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        curc = pert[idx]\n        palette = sorted(set(pert))\n        best_colors = []\n        best_val = None\n        for c in palette:\n            conf = local_conf(idx, c, pert)\n            score = (conf, c)\n            if best_val is None or score < best_val:\n                best_val = score\n                best_colors = [c]\n            elif score == best_val:\n                best_colors.append(c)\n        choice = random.choice(best_colors)\n        if choice == curc and len(palette) > 1:\n            alts = [c for c in best_colors if c != curc]\n            if alts:\n                choice = random.choice(alts)\n        elif choice == curc and len(palette) == 1:\n            choice = max(palette) + 1  # diversify if only one color exists\n        pert[idx] = choice\n\n    # Op2: swap two color labels to escape label plateaus\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if pert[i] == a:\n                pert[i] = b\n            elif pert[i] == b:\n                pert[i] = a\n\n    # Op3: One Kempe chain flip on a random pair of colors\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Canonicalize labels to 1..k\n    pert = canonicalize(pert)\n    return pert\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001876641}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = solution[:]\n    cur = canonicalize(cur)\n\n    cur_conf = count_conflicts(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_colors = []\n            best_score = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                # tie-break: prefer colors that may reduce palette size by emptying current color class\n                will_empty = 1 if sum(1 for v in cur if v == curc) == 1 else 0\n                score = (conf, -will_empty, c)\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_colors = [c]\n                elif score == best_score:\n                    best_colors.append(c)\n            # If no alternative in palette (degenerate), allow introducing a new color only if it strictly reduces conflicts locally\n            if not best_colors:\n                newc = max(palette) + 1\n                if local_conf(i, newc, cur) < local_conf(i, curc, cur):\n                    best_colors = [newc]\n                else:\n                    # no improving move found; return same solution\n                    return cur\n            newc = random.choice(best_colors)\n            nxt = cur[:]\n            nxt[i] = newc\n            nxt = canonicalize(nxt)\n            return nxt\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # simple backtracking up to limited depth\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n        assign = {}\n\n        def dfs(k, arr):\n            if k == len(order):\n                return arr\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            random.shuffle(zeros)\n            for c in zeros:\n                arr2 = arr[:]\n                arr2[i] = c\n                res = dfs(k+1, arr2)\n                if res is not None:\n                    return res\n            return None\n\n        attempt = dfs(0, cur[:])\n        if attempt is not None:\n            attempt = canonicalize(attempt)\n            return attempt\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_score = (count_conflicts(cur), len(set(cur)))\n        for a, b, _ in pairs:\n            # build Kempe component from a random seed in (a,b)\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_score = (count_conflicts(flipped), len(set(flipped)))\n            if new_score <= base_score:\n                return flipped\n\n    # Fallback: slight random recolor within palette (keeps feasibility if no conflicts)\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    if len(palette) == 1:\n        cur[i] = 2 if cur[i] == 1 else 1\n    else:\n        alt = [c for c in palette if c != cur[i]]\n        cur[i] = random.choice(alt)\n    return canonicalize(cur)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n    pert = canonicalize(pert)\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001456387}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = solution[:]\n    cur = canonicalize(cur)\n\n    cur_conf = count_conflicts(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_colors = []\n            best_score = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                # tie-break: prefer colors that may reduce palette size by emptying current color class\n                will_empty = 1 if sum(1 for v in cur if v == curc) == 1 else 0\n                score = (conf, -will_empty, c)\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_colors = [c]\n                elif score == best_score:\n                    best_colors.append(c)\n            # If no alternative in palette (degenerate), allow introducing a new color only if it strictly reduces conflicts locally\n            if not best_colors:\n                newc = max(palette) + 1\n                if local_conf(i, newc, cur) < local_conf(i, curc, cur):\n                    best_colors = [newc]\n                else:\n                    # no improving move found; return same solution\n                    return cur\n            newc = random.choice(best_colors)\n            nxt = cur[:]\n            nxt[i] = newc\n            nxt = canonicalize(nxt)\n            return nxt\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # simple backtracking up to limited depth\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n        assign = {}\n\n        def dfs(k, arr):\n            if k == len(order):\n                return arr\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            random.shuffle(zeros)\n            for c in zeros:\n                arr2 = arr[:]\n                arr2[i] = c\n                res = dfs(k+1, arr2)\n                if res is not None:\n                    return res\n            return None\n\n        attempt = dfs(0, cur[:])\n        if attempt is not None:\n            attempt = canonicalize(attempt)\n            return attempt\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_score = (count_conflicts(cur), len(set(cur)))\n        for a, b, _ in pairs:\n            # build Kempe component from a random seed in (a,b)\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_score = (count_conflicts(flipped), len(set(flipped)))\n            if new_score <= base_score:\n                return flipped\n\n    # Fallback: slight random recolor within palette (keeps feasibility if no conflicts)\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    if len(palette) == 1:\n        cur[i] = 2 if cur[i] == 1 else 1\n    else:\n        alt = [c for c in palette if c != cur[i]]\n        cur[i] = random.choice(alt)\n    return canonicalize(cur)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n    pert = canonicalize(pert)\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.001810902}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = solution[:]\n    cur = canonicalize(cur)\n\n    cur_conf = count_conflicts(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_colors = []\n            best_score = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette:\n                if c == curc:\n                    continue\n                conf = local_conf(i, c, cur)\n                # tie-break: prefer colors that may reduce palette size by emptying current color class\n                will_empty = 1 if sum(1 for v in cur if v == curc) == 1 else 0\n                score = (conf, -will_empty, c)\n                if best_score is None or score < best_score:\n                    best_score = score\n                    best_colors = [c]\n                elif score == best_score:\n                    best_colors.append(c)\n            # If no alternative in palette (degenerate), allow introducing a new color only if it strictly reduces conflicts locally\n            if not best_colors:\n                newc = max(palette) + 1\n                if local_conf(i, newc, cur) < local_conf(i, curc, cur):\n                    best_colors = [newc]\n                else:\n                    # no improving move found; return same solution\n                    return cur\n            newc = random.choice(best_colors)\n            nxt = cur[:]\n            nxt[i] = newc\n            nxt = canonicalize(nxt)\n            return nxt\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # simple backtracking up to limited depth\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n        assign = {}\n\n        def dfs(k, arr):\n            if k == len(order):\n                return arr\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            random.shuffle(zeros)\n            for c in zeros:\n                arr2 = arr[:]\n                arr2[i] = c\n                res = dfs(k+1, arr2)\n                if res is not None:\n                    return res\n            return None\n\n        attempt = dfs(0, cur[:])\n        if attempt is not None:\n            attempt = canonicalize(attempt)\n            return attempt\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_score = (count_conflicts(cur), len(set(cur)))\n        for a, b, _ in pairs:\n            # build Kempe component from a random seed in (a,b)\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_score = (count_conflicts(flipped), len(set(flipped)))\n            if new_score <= base_score:\n                return flipped\n\n    # Fallback: slight random recolor within palette (keeps feasibility if no conflicts)\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    if len(palette) == 1:\n        cur[i] = 2 if cur[i] == 1 else 1\n    else:\n        alt = [c for c in palette if c != cur[i]]\n        cur[i] = random.choice(alt)\n    return canonicalize(cur)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    pert = solution[:]\n    pert = canonicalize(pert)\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001800851}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CANONICALIZED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def eval_scalar(arr):\n        # conflicts primary, groups secondary\n        return count_conflicts(arr) * 10**6 + len(set(arr))\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = canonicalize(solution[:])\n\n    cur_score = eval_scalar(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    cur_conf = count_conflicts(cur)\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_list = []\n            best_eval = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette + [max(palette)+1]:\n                if c == curc:\n                    continue\n                nxt = cur[:]\n                nxt[i] = c\n                nxt = canonicalize(nxt)\n                ev = eval_scalar(nxt)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_list = [nxt]\n                elif ev == best_eval:\n                    best_list.append(nxt)\n            if best_list:\n                return random.choice(best_list)\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by fewest conflict-free options, then higher degree\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n\n        best_found = None\n        best_eval = None\n        cutoff_nodes = min(len(order), 5)  # limit depth for speed\n\n        def dfs(k, arr):\n            nonlocal best_found, best_eval\n            if k == cutoff_nodes:\n                ev = eval_scalar(arr)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_found = arr[:]\n                return\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return\n            random.shuffle(zeros)\n            for c in zeros:\n                arr[i] = c\n                dfs(k+1, arr)\n                arr[i] = target\n\n        arr0 = cur[:]\n        dfs(0, arr0)\n        if best_found is not None and count_conflicts(best_found) == 0 and len(set(best_found)) <= len(set(cur)):\n            return canonicalize(best_found)\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening by eval_scalar\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_eval = eval_scalar(cur)\n        for a, b, _ in pairs:\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_eval = eval_scalar(flipped)\n            if new_eval <= base_eval:\n                return flipped\n\n    # Fallback: try random recolor but accept only if non-worsening\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    alt = [c for c in (palette + [max(palette)+1]) if c != cur[i]]\n    random.shuffle(alt)\n    for c in alt:\n        nxt = cur[:]\n        nxt[i] = c\n        nxt = canonicalize(nxt)\n        if eval_scalar(nxt) <= cur_score:\n            return nxt\n\n    return cur\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    def count_conflicts(arr):\n        return sum(1 for (u,v) in edges if arr[u-1] == arr[v-1])\n\n    pert = canonicalize(solution[:])\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Final light repair pass for any conflicts: greedy recolor conflicted vertices\n    if count_conflicts(pert) > 0:\n        colors = sorted(set(pert))\n        for i in range(n):\n            # if i is conflicted, try best color\n            if any(pert[i] == pert[j] for j in adj[i]):\n                best_c = pert[i]\n                best_conf = local_conf(i, best_c, pert)\n                for c in colors + [max(colors)+1]:\n                    if c == pert[i]:\n                        continue\n                    conf = local_conf(i, c, pert)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                pert[i] = best_c\n        pert = canonicalize(pert)\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"SA","Tiempo":0.001539489}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CANONICALIZED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def eval_scalar(arr):\n        # conflicts primary, groups secondary\n        return count_conflicts(arr) * 10**6 + len(set(arr))\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = canonicalize(solution[:])\n\n    cur_score = eval_scalar(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    cur_conf = count_conflicts(cur)\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_list = []\n            best_eval = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette + [max(palette)+1]:\n                if c == curc:\n                    continue\n                nxt = cur[:]\n                nxt[i] = c\n                nxt = canonicalize(nxt)\n                ev = eval_scalar(nxt)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_list = [nxt]\n                elif ev == best_eval:\n                    best_list.append(nxt)\n            if best_list:\n                return random.choice(best_list)\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by fewest conflict-free options, then higher degree\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n\n        best_found = None\n        best_eval = None\n        cutoff_nodes = min(len(order), 5)  # limit depth for speed\n\n        def dfs(k, arr):\n            nonlocal best_found, best_eval\n            if k == cutoff_nodes:\n                ev = eval_scalar(arr)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_found = arr[:]\n                return\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return\n            random.shuffle(zeros)\n            for c in zeros:\n                arr[i] = c\n                dfs(k+1, arr)\n                arr[i] = target\n\n        arr0 = cur[:]\n        dfs(0, arr0)\n        if best_found is not None and count_conflicts(best_found) == 0 and len(set(best_found)) <= len(set(cur)):\n            return canonicalize(best_found)\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening by eval_scalar\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_eval = eval_scalar(cur)\n        for a, b, _ in pairs:\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_eval = eval_scalar(flipped)\n            if new_eval <= base_eval:\n                return flipped\n\n    # Fallback: try random recolor but accept only if non-worsening\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    alt = [c for c in (palette + [max(palette)+1]) if c != cur[i]]\n    random.shuffle(alt)\n    for c in alt:\n        nxt = cur[:]\n        nxt[i] = c\n        nxt = canonicalize(nxt)\n        if eval_scalar(nxt) <= cur_score:\n            return nxt\n\n    return cur\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    def count_conflicts(arr):\n        return sum(1 for (u,v) in edges if arr[u-1] == arr[v-1])\n\n    pert = canonicalize(solution[:])\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Final light repair pass for any conflicts: greedy recolor conflicted vertices\n    if count_conflicts(pert) > 0:\n        colors = sorted(set(pert))\n        for i in range(n):\n            # if i is conflicted, try best color\n            if any(pert[i] == pert[j] for j in adj[i]):\n                best_c = pert[i]\n                best_conf = local_conf(i, best_c, pert)\n                for c in colors + [max(colors)+1]:\n                    if c == pert[i]:\n                        continue\n                    conf = local_conf(i, c, pert)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                pert[i] = best_c\n        pert = canonicalize(pert)\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"ILS","Tiempo":0.002050924}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CANONICALIZED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**18\n    # Validate representation\n    if (not isinstance(solution, list)) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if (not isinstance(c, int)) or c <= 0:\n            return LARGE\n\n    # Canonicalize labels to 1..k to remove label bias\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        canon = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            canon.append(mapping[v])\n        return canon\n\n    sol = canonicalize(solution)\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    num_groups = len(set(sol))\n\n    # Scalarization: primary conflicts, secondary groups.\n    return conflicts * 10**6 + num_groups\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    def eval_scalar(arr):\n        # conflicts primary, groups secondary\n        return count_conflicts(arr) * 10**6 + len(set(arr))\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    cur = canonicalize(solution[:])\n\n    cur_score = eval_scalar(cur)\n\n    # Phase A: If conflicts exist, perform min-conflicts recolor on a conflicted vertex\n    cur_conf = count_conflicts(cur)\n    if cur_conf > 0:\n        conflicted = [i for i in range(n) if any(cur[i] == cur[j] for j in adj[i])]\n        if conflicted:\n            # choose a most-conflicted vertex (break ties randomly)\n            maxc = -1\n            cand = []\n            for i in conflicted:\n                lc = local_conf(i, cur[i], cur)\n                if lc > maxc:\n                    maxc = lc\n                    cand = [i]\n                elif lc == maxc:\n                    cand.append(i)\n            i = random.choice(cand)\n            palette = sorted(set(cur))\n            best_list = []\n            best_eval = None\n            curc = cur[i]\n            # try recoloring to existing colors (excluding current)\n            for c in palette + [max(palette)+1]:\n                if c == curc:\n                    continue\n                nxt = cur[:]\n                nxt[i] = c\n                nxt = canonicalize(nxt)\n                ev = eval_scalar(nxt)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_list = [nxt]\n                elif ev == best_eval:\n                    best_list.append(nxt)\n            if best_list:\n                return random.choice(best_list)\n\n    # Phase B: Attempt to eliminate the smallest color class without creating conflicts\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        counts = {c: 0 for c in palette}\n        for v in cur:\n            counts[v] += 1\n        target = min(palette, key=lambda c: (counts[c], c))\n        others = [c for c in palette if c != target]\n        idxs = [i for i, c in enumerate(cur) if c == target]\n\n        # Order by fewest conflict-free options, then higher degree\n        order = sorted(idxs, key=lambda i: (sum(1 for c in others if local_conf(i, c, cur) == 0), -len(adj[i])))\n\n        best_found = None\n        best_eval = None\n        cutoff_nodes = min(len(order), 5)  # limit depth for speed\n\n        def dfs(k, arr):\n            nonlocal best_found, best_eval\n            if k == cutoff_nodes:\n                ev = eval_scalar(arr)\n                if (best_eval is None) or (ev < best_eval):\n                    best_eval = ev\n                    best_found = arr[:]\n                return\n            i = order[k]\n            zeros = [c for c in others if local_conf(i, c, arr) == 0]\n            if not zeros:\n                return\n            random.shuffle(zeros)\n            for c in zeros:\n                arr[i] = c\n                dfs(k+1, arr)\n                arr[i] = target\n\n        arr0 = cur[:]\n        dfs(0, arr0)\n        if best_found is not None and count_conflicts(best_found) == 0 and len(set(best_found)) <= len(set(cur)):\n            return canonicalize(best_found)\n\n    # Phase C: Kempe chain flip between two colors; accept only if non-worsening by eval_scalar\n    palette = sorted(set(cur))\n    if len(palette) >= 2:\n        # compute cut sizes\n        cut = {a: {b: 0 for b in palette} for a in palette}\n        for u, v in edges:\n            cu, cv = cur[u-1], cur[v-1]\n            if cu != cv:\n                cut[cu][cv] += 1\n                cut[cv][cu] += 1\n        pairs = [(a, b, cut[a][b]) for a in palette for b in palette if a < b]\n        pairs.sort(key=lambda t: (-t[2], t[0], t[1]))\n        base_eval = eval_scalar(cur)\n        for a, b, _ in pairs:\n            cand = [i for i, c in enumerate(cur) if c == a or c == b]\n            if not cand:\n                continue\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if cur[v] == a or cur[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            flipped = cur[:]\n            for i in comp:\n                flipped[i] = b if flipped[i] == a else a\n            flipped = canonicalize(flipped)\n            new_eval = eval_scalar(flipped)\n            if new_eval <= base_eval:\n                return flipped\n\n    # Fallback: try random recolor but accept only if non-worsening\n    i = random.randrange(n)\n    palette = sorted(set(cur))\n    alt = [c for c in (palette + [max(palette)+1]) if c != cur[i]]\n    random.shuffle(alt)\n    for c in alt:\n        nxt = cur[:]\n        nxt[i] = c\n        nxt = canonicalize(nxt)\n        if eval_scalar(nxt) <= cur_score:\n            return nxt\n\n    return cur\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Fallback default feasible seed (3-coloring)\n    def default_solution():\n        return [1,2,3,1,2,3,2,1,3]\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return default_solution()\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in mapping:\n                mapping[v] = next_c\n                next_c += 1\n            out.append(mapping[v])\n        return out\n\n    def local_conf(idx, c, arr):\n        return sum(1 for nb in adj[idx] if arr[nb] == c)\n\n    def count_conflicts(arr):\n        return sum(1 for (u,v) in edges if arr[u-1] == arr[v-1])\n\n    pert = canonicalize(solution[:])\n\n    # Op1: Merge two random colors (if >=2) by recoloring smaller class into best-fitting other colors, then repair greedily\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        counts = {c: sum(1 for v in pert if v == c) for c in colors}\n        a, b = sorted(random.sample(colors, 2), key=lambda c: counts[c])  # a is smaller\n        targets = [i for i, c in enumerate(pert) if c == a]\n        random.shuffle(targets)\n        for i in targets:\n            palette = [x for x in colors if x != a]\n            best = None\n            best_c = None\n            for c in palette:\n                conf = local_conf(i, c, pert)\n                sc = (conf, c)\n                if best is None or sc < best:\n                    best = sc\n                    best_c = c\n            if best_c is None:\n                best_c = b\n            pert[i] = best_c\n        # remove empty color by canonicalization\n        pert = canonicalize(pert)\n\n    # Op2: Random recolor k vertices towards minimal local conflict within current palette\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        palette = sorted(set(pert))\n        curc = pert[i]\n        best = None\n        best_cs = []\n        for c in palette:\n            conf = local_conf(i, c, pert)\n            sc = (conf, c)\n            if best is None or sc < best:\n                best = sc\n                best_cs = [c]\n            elif sc == best:\n                best_cs.append(c)\n        choice = random.choice(best_cs)\n        if choice == curc and len(palette) == 1:\n            choice = max(palette) + 1\n        pert[i] = choice\n\n    # Op3: One Kempe chain flip to diversify\n    colors = sorted(set(pert))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        cand = [i for i, c in enumerate(pert) if c == a or c == b]\n        if cand:\n            start = random.choice(cand)\n            comp = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in comp:\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if pert[v] == a or pert[v] == b:\n                        if v not in comp:\n                            stack.append(v)\n            for i in comp:\n                pert[i] = b if pert[i] == a else a\n\n    # Final light repair pass for any conflicts: greedy recolor conflicted vertices\n    if count_conflicts(pert) > 0:\n        colors = sorted(set(pert))\n        for i in range(n):\n            # if i is conflicted, try best color\n            if any(pert[i] == pert[j] for j in adj[i]):\n                best_c = pert[i]\n                best_conf = local_conf(i, best_c, pert)\n                for c in colors + [max(colors)+1]:\n                    if c == pert[i]:\n                        continue\n                    conf = local_conf(i, c, pert)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                pert[i] = best_c\n        pert = canonicalize(pert)\n\n    return canonicalize(pert)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,1,2,1,3,2,1,1,2],"Valor Optimo":3,"Metaheuristica":"TS","Tiempo":0.001972274}
