{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (0-indexed internally)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**7\n\n    # Domain validation (single penalty bucket)\n    domain_bad = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            domain_bad += 1\n\n    # Count edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else n\n\n    # Fitness: minimize; feasibility first, then k_used\n    if domain_bad == 0 and violations == 0:\n        return k_used\n\n    # Infeasible: heavy penalties; do not add k_used to avoid weakening penalty pressure\n    fitness = 0\n    fitness += domain_bad * 10**7\n    fitness += violations * 10**6\n    return fitness","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    # Basic recovery\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n, \"NB_Local\", \"Recover\"\n\n    sol = list(solution)\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(a):\n        # Canonical relabeling to 1..k in order of appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_count(a):\n        cnt = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                cnt += 1\n        return cnt\n\n    def is_feasible_color(a, idx, color):\n        for nb in adj[idx]:\n            if a[nb] == color:\n                return False\n        return True\n\n    def kempe_flip(a, start_idx, ca, cb):\n        # Flip colors ca<->cb on Kempe component containing start_idx within subgraph induced by {ca,cb}\n        if a[start_idx] not in (ca, cb):\n            return a\n        target_colors = (ca, cb)\n        q = deque([start_idx])\n        seen = set([start_idx])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for w in adj[u]:\n                if w in seen:\n                    continue\n                if a[w] in target_colors:\n                    seen.add(w)\n                    q.append(w)\n        b = a[:]\n        for u in comp:\n            b[u] = cb if a[u] == ca else ca\n        return b\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # Compute current conflicts\n    current_conflicts = conflicts_count(sol)\n\n    # Case 1: No conflicts -> try to reduce k by eliminating highest color\n    if current_conflicts == 0:\n        h = max_color\n        indices_h = [i for i, c in enumerate(sol) if c == h]\n        random.shuffle(indices_h)\n        for idx in indices_h:\n            # Try to move to the lowest feasible color in [1..h-1]\n            for c in range(1, h):\n                if is_feasible_color(sol, idx, c):\n                    sol[idx] = c\n                    # If we moved the last vertex off color h, normalize\n                    if all(cc != h for cc in sol):\n                        sol = normalize(sol)\n                    return sol, \"NB_Local\", \"ReduceColor\"\n        # If unable to move any, perform a Kempe flip between h and a random lower color\n        if h > 1 and indices_h:\n            other = random.randint(1, h-1)\n            v = random.choice(indices_h)\n            new_sol = kempe_flip(sol, v, h, other)\n            new_sol = normalize(new_sol)\n            return new_sol, \"NB_Global\", \"KempeFlip\"\n        return sol, \"NB_Local\", \"NoOp\"\n\n    # Case 2: Conflicts exist -> try greedy recolor of a conflicting vertex\n    conflicting_vertices = set()\n    for u, v in edges0:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        idx = random.choice(list(conflicting_vertices))\n    else:\n        idx = random.randrange(n)\n\n    # Best-improvement recolor among existing colors\n    best_color = sol[idx]\n    best_conf = math.inf\n    for c in range(1, max_color + 1):\n        if c == sol[idx]:\n            # Count conflicts if staying\n            conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        else:\n            conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        if conf < best_conf and is_feasible_color(sol, idx, c):\n            best_conf = conf\n            best_color = c\n    if best_color != sol[idx]:\n        sol[idx] = best_color\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"Recolor\"\n\n    # If recolor didn't find feasible lower-conflict color, try Kempe flip on a random neighbor color\n    neigh_colors = [sol[nb] for nb in adj[idx] if sol[nb] != sol[idx]]\n    if neigh_colors:\n        cb = random.choice(neigh_colors)\n        ca = sol[idx]\n        new_sol = kempe_flip(sol, idx, ca, cb)\n        new_sol = normalize(new_sol)\n        return new_sol, \"NB_Global\", \"KempeFlip\"\n\n    # Fallback: random recolor within current palette\n    sol[idx] = random.randint(1, max_color)\n    sol = normalize(sol)\n    return sol, \"NB_Local\", \"RandomRecolor\"","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Diversification: class swaps + random recolors biased to highest colors\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n\n    def normalize(a):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # 1) With some probability, swap two color classes entirely\n    if max_color >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # 2) Randomly recolor a subset, focusing on highest color class\n    h = max_color\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: (sol[i] != h, random.random()))  # prioritize highest color vertices\n    m = max(2, n \/\/ 3)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        pool = list(range(1, max(2, max_color)))  # prefer existing lower colors\n        # With small probability, allow introducing a new color for escape\n        if random.random() < 0.15:\n            pool.append(max_color + 1)\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    sol = normalize(sol)\n    return sol","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (0-indexed internally)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**7\n\n    # Domain validation\n    domain_bad = sum(1 for x in solution if not (isinstance(x, int) and x >= 1))\n\n    # Count edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else n\n\n    # Fitness: minimize; feasibility first via large weight on violations, while still guiding with k_used\n    if domain_bad == 0:\n        return violations * 1000 + k_used\n\n    # Infeasible domain: strong penalty\n    return 10**7 * domain_bad + violations * 1000 + k_used\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    # Basic recovery\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n, \"NB_Local\", \"Recover\"\n\n    sol = list(solution)\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(a):\n        # Canonical relabeling to 1..k in order of appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_count(a):\n        cnt = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                cnt += 1\n        return cnt\n\n    def kempe_flip(a, start_idx, ca, cb):\n        # Flip colors ca<->cb on Kempe component containing start_idx within subgraph induced by {ca,cb}\n        if a[start_idx] not in (ca, cb):\n            return a\n        target_colors = (ca, cb)\n        q = deque([start_idx])\n        seen = set([start_idx])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for w in adj[u]:\n                if w in seen:\n                    continue\n                if a[w] in target_colors:\n                    seen.add(w)\n                    q.append(w)\n        b = a[:]\n        for u in comp:\n            b[u] = cb if a[u] == ca else ca\n        return b\n\n    # Helper to evaluate tuple (violations, k)\n    def eval_tuple(a):\n        viol = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                viol += 1\n        k = len(set(a))\n        return (viol, k)\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n    current_conflicts = conflicts_count(sol)\n\n    # Phase A: If feasible, attempt to reduce number of colors\n    if current_conflicts == 0:\n        h = max_color\n        indices_h = [i for i, c in enumerate(sol) if c == h]\n        random.shuffle(indices_h)\n        # Try moving vertices off the highest color to lower feasible colors (first-improvement)\n        for idx in indices_h:\n            lower_colors = list(range(1, h))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if all(sol[nb] != c for nb in adj[idx]):\n                    sol[idx] = c\n                    # If color h eliminated, normalize to shrink palette\n                    if all(cc != h for cc in sol):\n                        sol = normalize(sol)\n                    return sol, \"NB_Local\", \"ReduceColor\"\n        # If stuck, try 2 candidate Kempe flips and accept best\n        if h > 1 and indices_h:\n            candidates = []\n            for _ in range(2):\n                other = random.randint(1, h-1)\n                v = random.choice(indices_h)\n                cand = normalize(kempe_flip(sol, v, h, other))\n                candidates.append(cand)\n            # choose best by (viol,k)\n            best = min(candidates + [sol], key=eval_tuple)\n            move = \"KempeFlip\" if best is not sol else \"NoOp\"\n            return best, (\"NB_Global\" if move==\"KempeFlip\" else \"NB_Local\"), move\n        return sol, \"NB_Local\", \"NoOp\"\n\n    # Phase B: Infeasible - reduce conflicts aggressively\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for u, v in edges0:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    idx = random.choice(list(conflicting_vertices)) if conflicting_vertices else random.randrange(n)\n\n    # Try first-improvement recolor minimizing conflicts at idx; allow introducing a new color with small probability\n    palette = list(range(1, max_color + 1))\n    if random.random() < 0.15:\n        palette.append(max_color + 1)\n    random.shuffle(palette)\n\n    best_c = sol[idx]\n    best_conf = sum(1 for nb in adj[idx] if sol[nb] == best_c)\n    improved = False\n    for c in palette:\n        conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n            improved = True\n            break  # first-improvement\n    if improved:\n        sol[idx] = best_c\n        # Normalize only if highest color class removed\n        max_c_after = max(sol)\n        if max_c_after < max_color:\n            sol = normalize(sol)\n        return sol, \"NB_Local\", \"RecolorMinConf\"\n\n    # If no recolor improvement, try 2 Kempe flips with neighbor colors and pick best\n    neigh_colors = [sol[nb] for nb in adj[idx] if sol[nb] != sol[idx]]\n    if neigh_colors:\n        candidates = []\n        for cb in random.sample(neigh_colors, k=min(2, len(neigh_colors))):\n            ca = sol[idx]\n            cand = normalize(kempe_flip(sol, idx, ca, cb))\n            candidates.append(cand)\n        best = min(candidates + [sol], key=eval_tuple)\n        move = \"KempeFlip\" if best is not sol else \"NoOp\"\n        return best, (\"NB_Global\" if move==\"KempeFlip\" else \"NB_Local\"), move\n\n    # Fallback: random recolor within current palette\n    sol[idx] = random.randint(1, max_color)\n    return sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Diversification: swap color classes and biased random recolors\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n\n    def normalize(a):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # 1) With probability 0.5, swap two color classes entirely\n    if max_color >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # 2) Randomly recolor about n\/3 vertices, prioritizing highest color class\n    h = max_color\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs.sort(key=lambda i: (sol[i] != h, random.random()))  # prioritize highest color vertices\n    m = max(2, n \/\/ 3)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        pool = list(range(1, max(2, max_color)))  # prefer existing lower colors\n        # Occasionally allow introducing a new color for escape\n        if random.random() < 0.2:\n            pool.append(max_color + 1)\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    sol = normalize(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (0-indexed internally)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**7\n\n    # Domain validation\n    domain_bad = sum(1 for x in solution if not (isinstance(x, int) and x >= 1))\n\n    # Count edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else n\n\n    # Fitness: minimize; feasibility first via large weight on violations, while still guiding with k_used\n    if domain_bad == 0:\n        return violations * 1000 + k_used\n\n    # Infeasible domain: strong penalty\n    return 10**7 * domain_bad + violations * 1000 + k_used\n","Vecindad":"import math\nimport random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n\n    # Cache static data and helpers on the function to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"initialized\"):\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        edges0 = [(u-1, v-1) for (u, v) in edges]\n        adj = [[] for _ in range(n)]\n        for u, v in edges0:\n            adj[u].append(v)\n            adj[v].append(u)\n        generate_neighbour.edges0 = edges0\n        generate_neighbour.adj = adj\n\n        def normalize(a):\n            mapping = {}\n            nextc = 1\n            out = []\n            for c in a:\n                if c not in mapping:\n                    mapping[c] = nextc\n                    nextc += 1\n                out.append(mapping[c])\n            return out\n\n        def conflicts_count(a):\n            cnt = 0\n            for u, v in edges0:\n                if a[u] == a[v]:\n                    cnt += 1\n            return cnt\n\n        def eval_tuple(a):\n            viol = 0\n            for u, v in edges0:\n                if a[u] == a[v]:\n                    viol += 1\n            k = len(set(a))\n            return (viol, k)\n\n        def kempe_flip(a, start_idx, ca, cb, adj, edges0):\n            if a[start_idx] not in (ca, cb):\n                return a\n            q = deque([start_idx])\n            seen = {start_idx}\n            comp = []\n            target_colors = (ca, cb)\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for w in adj[u]:\n                    if w in seen:\n                        continue\n                    if a[w] in target_colors:\n                        seen.add(w)\n                        q.append(w)\n            b = a[:]\n            for u in comp:\n                b[u] = cb if a[u] == ca else ca\n            return b\n\n        generate_neighbour.normalize = normalize\n        generate_neighbour.conflicts_count = conflicts_count\n        generate_neighbour.eval_tuple = eval_tuple\n        generate_neighbour.kempe_flip = kempe_flip\n        generate_neighbour.initialized = True\n\n    edges0 = generate_neighbour.edges0\n    adj = generate_neighbour.adj\n    normalize = generate_neighbour.normalize\n    conflicts_count = generate_neighbour.conflicts_count\n    eval_tuple = generate_neighbour.eval_tuple\n    kempe_flip = generate_neighbour.kempe_flip\n\n    # Recovery via DSATUR-like greedy if malformed\n    def dsatur_init():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # pick vertex with highest saturation (distinct neighbor colors), break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = set(colors[u] for u in adj[v] if colors[u] != 0)\n                key = (len(neigh_cols), degrees[v])\n                if best is None or key > best_key:\n                    best = v\n                    best_key = key\n            v = best\n            neigh_cols = set(colors[u] for u in adj[v] if colors[u] != 0)\n            c = 1\n            while c in neigh_cols:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n        return normalize(colors)\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return dsatur_init(), \"NB_Local\", \"Recover\"\n\n    sol = list(solution)\n\n    # Ensure domain\n    for i, x in enumerate(sol):\n        if not (isinstance(x, int) and x >= 1):\n            sol[i] = 1\n    sol = normalize(sol)\n\n    max_color = max(sol) if sol else 1\n    current_conflicts = conflicts_count(sol)\n\n    # Phase A: Feasible -> try to reduce k by moving off highest color\n    if current_conflicts == 0:\n        h = max_color\n        indices_h = [i for i, c in enumerate(sol) if c == h]\n        random.shuffle(indices_h)\n        improved_any = False\n        for idx in indices_h:\n            # best-improvement among lower colors\n            best_c = sol[idx]\n            best_key = (math.inf, h)  # (conflicts at idx, resulting max color)\n            for c in range(1, h):\n                if all(sol[nb] != c for nb in adj[idx]):\n                    # 0 local conflicts if feasible move\n                    max_after = max(h if any(cc == h and k != idx else 0 for k, cc in enumerate(sol)) else h-1, c)\n                    key = (0, max_after)\n                    if key < best_key:\n                        best_key = key\n                        best_c = c\n            if best_c != sol[idx]:\n                sol[idx] = best_c\n                improved_any = True\n        if improved_any:\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"ReduceColor\"\n        # Stronger Kempe flips: try multiple candidates and pick best by (viol,k)\n        candidates = [sol]\n        tries = min(8, len(indices_h)*2 if indices_h else 4)\n        for _ in range(tries):\n            if not indices_h or h <= 1:\n                break\n            v = random.choice(indices_h)\n            other = random.randint(1, h-1)\n            cand = normalize(kempe_flip(sol, v, h, other, adj, edges0))\n            candidates.append(cand)\n        best = min(candidates, key=eval_tuple)\n        move = \"KempeFlip\" if best is not sol else \"NoOp\"\n        return best, (\"NB_Global\" if move == \"KempeFlip\" else \"NB_Local\"), move\n\n    # Phase B: Infeasible -> reduce conflicts (best-improvement recolor)\n    conflicting_vertices = set()\n    for u, v in edges0:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    idx = random.choice(list(conflicting_vertices)) if conflicting_vertices else random.randrange(n)\n\n    # Evaluate best color in current palette for idx; tie-break by minimizing resulting k\n    palette = list(range(1, max_color + 1))\n    best_c = sol[idx]\n    best_key = (sum(1 for nb in adj[idx] if sol[nb] == best_c), max_color)\n    for c in palette:\n        conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        max_after = max_color\n        key = (conf, max_after)\n        if key < best_key:\n            best_key = key\n            best_c = c\n    if best_c != sol[idx]:\n        sol[idx] = best_c\n        # Normalize if a color class got emptied\n        present = set(sol)\n        if len(present) < max_color:\n            sol = normalize(sol)\n        return sol, \"NB_Local\", \"RecolorBest\"\n\n    # If recolor doesn't help, attempt several Kempe flips with neighbor colors and pick best\n    neigh_colors = [sol[nb] for nb in adj[idx] if sol[nb] != sol[idx]]\n    candidates = [sol]\n    if neigh_colors:\n        sample_colors = neigh_colors if len(neigh_colors) <= 6 else random.sample(neigh_colors, 6)\n        for cb in sample_colors:\n            ca = sol[idx]\n            cand = normalize(kempe_flip(sol, idx, ca, cb, adj, edges0))\n            candidates.append(cand)\n    best = min(candidates, key=eval_tuple)\n    move = \"KempeFlip\" if best is not sol else \"RandomRecolor\"\n    if best is sol:\n        # Fallback: random recolor within palette\n        sol[idx] = random.randint(1, max_color)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", move\n    return best, (\"NB_Global\" if move == \"KempeFlip\" else \"NB_Local\"), move\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Diversification: class swaps + biased multi-vertex recolors + optional Kempe-like shuffle\n    n = 9\n    # Basic recovery\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n\n    def normalize(a):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # 1) Swap two color classes entirely (if >=2 colors)\n    if max_color >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # 2) Recolor about n\/3 vertices, prioritizing highest color class\n    h = max_color\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs.sort(key=lambda i: (sol[i] != h, random.random()))\n    m = max(3, n \/\/ 3)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        # Prefer existing lower colors; rarely introduce a new color\n        pool = list(range(1, max(2, max_color)))\n        if pool and random.random() < 0.15:\n            pool.append(max_color + 1)\n        if not pool:\n            pool = [1]\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    # 3) Normalize to remove gaps\n    sol = normalize(sol)\n    return sol\n","Version":2}
